---
title: "Проверкой подлинности шифрования и подразделов наследования"
author: rick-anderson
description: 
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 34bb58a3-5a9a-41e5-b090-08f75b4bbefa
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 24ce71b417599bea22b7fae8b384db599f9e907c
ms.sourcegitcommit: 0b6c8e6d81d2b3c161cd375036eecbace46a9707
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2017
---
# <a name="subkey-derivation-and-authenticated-encryption"></a><span data-ttu-id="d8cb7-103">Проверкой подлинности шифрования и подразделов наследования</span><span class="sxs-lookup"><span data-stu-id="d8cb7-103">Subkey Derivation and Authenticated Encryption</span></span>

<a name=data-protection-implementation-subkey-derivation></a>

<span data-ttu-id="d8cb7-104">Большинство ключей в кольце ключ будет содержать определенные виды энтропии и будет иметь алгоритмическое сведения о том, «режим CBC шифрования + HMAC проверки» или «шифрование GCM + проверки».</span><span class="sxs-lookup"><span data-stu-id="d8cb7-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="d8cb7-105">В таких случаях мы называем внедренные энтропии материала основного (или км) для данного ключа и мы выполнения функции производного ключа для получения ключей, которые будут использоваться для фактических криптографических операций.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="d8cb7-106">Ключи являются абстрактными, а пользовательская реализация может вести себя как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="d8cb7-107">Если ключ обеспечивает собственную реализацию IAuthenticatedEncryptor, а не с помощью одного из встроенных фабрик, механизм, описанные в этом разделе, больше не применяется.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-107">If the key provides its own implementation of IAuthenticatedEncryptor rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name=data-protection-implementation-subkey-derivation-aad></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="d8cb7-108">Дополнительные данные, прошедшие проверку подлинности и подразделов наследования</span><span class="sxs-lookup"><span data-stu-id="d8cb7-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="d8cb7-109">Интерфейс IAuthenticatedEncryptor служит в качестве основной интерфейс для всех операций шифрования, прошедшего проверку подлинности.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-109">The IAuthenticatedEncryptor interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="d8cb7-110">Его метод Encrypt принимает два буфера: обычный текст и additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="d8cb7-110">Its Encrypt method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="d8cb7-111">Поток содержимого открытого текста без изменений вызов IDataProtector.Protect, но AAD создается системой и состоит из трех компонентов:</span><span class="sxs-lookup"><span data-stu-id="d8cb7-111">The plaintext contents flow unchanged the call to IDataProtector.Protect, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="d8cb7-112">32-разрядный magic заголовок 09 F0 C9 F0, определяющий этой версии системы защиты данных.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="d8cb7-113">128-разрядный идентификатор ключа.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="d8cb7-114">Строка переменной длины, сформированным из цепочки цель создания IDataProtector, который выполняет эту операцию.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-114">A variable-length string formed from the purpose chain that created the IDataProtector that is performing this operation.</span></span>

<span data-ttu-id="d8cb7-115">Так как AAD уникален для всех трех компонентов кортежа, мы можно использовать для формирования новых ключей из км вместо использования км сам во всех наших криптографических операций.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="d8cb7-116">При каждом вызове IAuthenticatedEncryptor.Encrypt выполняется следующий процесс производного ключа:</span><span class="sxs-lookup"><span data-stu-id="d8cb7-116">For every call to IAuthenticatedEncryptor.Encrypt, the following key derivation process takes place:</span></span>

<span data-ttu-id="d8cb7-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (contextHeader K_M AAD, || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="d8cb7-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="d8cb7-118">Здесь выполняется вызов Формирования NIST SP800-108 в режиме счетчика (см. [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), сек.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec.</span></span> <span data-ttu-id="d8cb7-119">5.1) со следующими параметрами:</span><span class="sxs-lookup"><span data-stu-id="d8cb7-119">5.1) with the following parameters:</span></span>

* <span data-ttu-id="d8cb7-120">Ключ производного ключа (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="d8cb7-120">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="d8cb7-121">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="d8cb7-121">PRF = HMACSHA512</span></span>

* <span data-ttu-id="d8cb7-122">Метка = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="d8cb7-122">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="d8cb7-123">контекст = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="d8cb7-123">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="d8cb7-124">Заголовок контекста имеет переменную длину и по сути служить отпечаток алгоритмов, для которых мы ваш класс порожден K_E и K_H.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-124">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="d8cb7-125">Модификатор ключей является строкой 128-разрядный формируется случайным образом при каждом вызове шифровать и позволяет добиться с перегрузке вероятность, что KE и KH уникальны для этой операции шифрования конкретных протоколов проверки подлинности, даже если другие входные данные для Формирования является константой.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-125">The key modifier is a 128-bit string randomly generated for each call to Encrypt and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="d8cb7-126">Шифрование в режиме CBC + операций проверки HMAC | K_E | Длина ключа симметричный блочный шифр, и | K_H | — Это размер хэш-кода HMAC подпрограммы.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-126">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="d8cb7-127">Для шифрования GCM + операций проверки | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-127">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="d8cb7-128">Шифрование в режиме CBC + HMAC проверки</span><span class="sxs-lookup"><span data-stu-id="d8cb7-128">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="d8cb7-129">После K_E создается посредством механизма выше, мы создать случайный вектор инициализации и запустить алгоритм симметричный блочный шифр, шифрование в виде обычного текста.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-129">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="d8cb7-130">Вектор инициализации и зашифрованного текста затем выполняются через подпрограмму HMAC, инициализируется с помощью ключа K_H для создания на компьютере MAC.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-130">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="d8cb7-131">Этот процесс и возвращаемого значения представлены графически ниже.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-131">This process and the return value is represented graphically below.</span></span>

![Режим CBC процесс и вернуться](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="d8cb7-133">*выходные данные: = keyModifier || IV || E_cbc (данные K_E iv) || HMAC (K_H, iv || E_cbc (данные K_E iv))*</span><span class="sxs-lookup"><span data-stu-id="d8cb7-133">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="d8cb7-134">Реализация IDataProtector.Protect будет [началу magic заголовка и идентификатора ключа](authenticated-encryption-details.md#data-protection-implementation-authenticated-encryption-details) вывод перед возвращением вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-134">The IDataProtector.Protect implementation will [prepend the magic header and key id](authenticated-encryption-details.md#data-protection-implementation-authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="d8cb7-135">Поскольку magic заголовка и идентификатора ключа неявно являются частью [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), и так как модификатор ключей передавались в качестве входных данных для Формирования, это означает проверку каждые однобайтовых последний возвращенный полезных данных по MAC.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-135">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="d8cb7-136">Режим Galois/счетчика шифрования + проверки</span><span class="sxs-lookup"><span data-stu-id="d8cb7-136">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="d8cb7-137">После K_E создается посредством механизма выше, мы формирования случайных nonce 96-разрядного и запустить алгоритм шифрования симметричных блок дешифруется открытого текста и создания тег аутентификации 128-разрядный.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-137">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Процесс GCM режима и вернуться](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="d8cb7-139">*выходные данные: = keyModifier || Nonce || E_gcm (K_E, nonce, данные) || authTag*</span><span class="sxs-lookup"><span data-stu-id="d8cb7-139">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="d8cb7-140">Несмотря на то, что GCM изначально поддерживает концепцию AAD, мы по-прежнему поступает AAD только для Формирования исходного, предусмотренной для его параметра AAD необходимо передать пустую строку в GCM.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-140">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="d8cb7-141">Причиной этого является двухступенчатой.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-141">The reason for this is two-fold.</span></span> <span data-ttu-id="d8cb7-142">Во-первых, [для поддержки гибкости](context-headers.md#data-protection-implementation-context-headers) мы никогда не будут K_M непосредственно как ключ шифрования.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-142">First, [to support agility](context-headers.md#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="d8cb7-143">Кроме того GCM налагает очень строгие уникальность ее входными данными.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-143">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="d8cb7-144">Задает вероятность того, что процедура шифрования GCM когда-либо вызванный для двух или более различных входных данных с тем же (ключ, nonce) пары не должен превышать 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-144">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="d8cb7-145">Если мы будем устранять K_E невозможно выполнить больше, чем 2 ^ 32 операции шифрования, прежде чем мы запуска от 2 ^ ограничить -32.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-145">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="d8cb7-146">Это может показаться очень большое количество операций, но изменяемым веб-сервера можно выполнить запросы 4 млрд простое дней, в пределах обычный время существования для этих ключей.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-146">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="d8cb7-147">Чтобы оставаться совместимым 2 ^ предел вероятность-32, мы продолжаем использовать 128-разрядный модификатор ключей и 96-разрядного nonce, которая расширяет число операций можно использовать для любого заданного K_M радикально.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-147">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="d8cb7-148">Для упрощения разработки мы Формирования кода путь к общей папке между операциями CBC и GCM, а поскольку AAD уже считается в Формирования нет необходимости переслать его подпрограмма GCM.</span><span class="sxs-lookup"><span data-stu-id="d8cb7-148">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there is no need to forward it to the GCM routine.</span></span>
