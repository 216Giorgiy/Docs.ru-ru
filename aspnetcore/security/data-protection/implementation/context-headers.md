---
title: "Заголовков контекста"
author: rick-anderson
description: "В этом документе перечислены сведения о реализации заголовков контекста защиты данных ASP.NET Core."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/implementation/context-headers
ms.openlocfilehash: b5ed2e48a55e23d73bccd01a731b35ea68f8944e
ms.sourcegitcommit: 3e303620a125325bb9abd4b2d315c106fb8c47fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2018
---
# <a name="context-headers"></a>Заголовков контекста

<a name="data-protection-implementation-context-headers"></a>

## <a name="background-and-theory"></a>Общие сведения и теории

В системе защиты данных «ключ» означает, что объект, способный предоставлять службы шифрования с проверкой подлинности. Каждый ключ определяется с помощью уникального идентификатора (GUID) и несет с собой сведения, алгоритма и entropic материал. Он предназначен каждый ключ содержат уникальные энтропии, но системе не удается обеспечить, и мы также должны быть учтены для разработчиков, которые могут изменить кольцо ключ вручную, изменив алгоритмической сведения существующего ключа в ключ обмена. Для достижения нашей требования безопасности, заданным в таких случаях системы защиты данных имеет смысл [криптографическая гибкость](https://www.microsoft.com/en-us/research/publication/cryptographic-agility-and-its-relation-to-circular-encryption/), что позволяет безопасно используют одно значение entropic через несколько алгоритмов шифрования.

Большинство систем, которые поддерживают криптографическая гибкость сделать, включая некоторые идентифицирующие сведения об алгоритме внутри полезных данных. Алгоритм OID обычно является хорошим кандидатом для этого. Одна из проблем возникла то, что существует несколько способов для указания того же алгоритма: «AES» (CNG) и управляемые Aes, AesManaged, AesCryptoServiceProvider, AesCng и (при наличии конкретные параметры) RijndaelManaged классы одинаковы все очередь и мы бы нужно хранить сопоставление всех их на правильный идентификатор Объекта. Если разработчик хотел предоставить пользовательский алгоритм (или даже другую реализацию AES), они бы сообщить нам его OID. Лишние регистрации в результате этого действия система конфигурации особенно велики.

Пошаговое выполнение обратно, мы решили, достигает проблему в обратную сторону. OID указывает, является алгоритм, но мы не интересует фактически это. Если требуется использовать значение single entropic безопасно в два разных алгоритма, не необходимые нам знать, что фактически, алгоритмы. Что мы волнует это поведение. Любой алгоритм довольно симметричный блочный шифр также является строгим псевдослучайное перестановки (политики репликации Паролей): исправьте входные данные (ключ, цепочки режим IV, открытым текстом) и выходной зашифрованного текста с перегрузке вероятности будут отделяться от симметричный блочный шифр алгоритм учетом же входных данных. Аналогичным образом любая функция довольно ключевого хэширования также является функцией строгого псевдослучайное (PRF), и на основе фиксированного набора входных свои выходные данные чрезвычайно будут distinct из любой другой функции хэширования с ключом.

Мы используем эту концепцию строгого PRPs и PRFs для создания заголовка контекста. Этот заголовок контекста по существу выступает в качестве стабильного отпечаток через алгоритмы используются для любой заданной операции и предоставляет криптографическая гибкость, системы защиты данных. Этот заголовок не возникнут и используется позже как часть [подраздел производного процесса](subkeyderivation.md#data-protection-implementation-subkey-derivation). Существует два разных способа для создания заголовка контекста, в зависимости от режима работы базовых алгоритмов.

## <a name="cbc-mode-encryption--hmac-authentication"></a>Шифрование в режиме CBC + HMAC проверки подлинности

<a name="data-protection-implementation-context-headers-cbc-components"></a>

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 00, что является маркером означает «шифрование CBC + HMAC проверки подлинности».

* [32 бита] Длина ключа (в байтах, с обратным порядком байтов) алгоритм шифрования симметричных блока.

* [32 бита] Размер блока (в байтах, с обратным порядком байтов) алгоритм шифрования симметричных блока.

* [32 бита] Длина ключа (в байтах, с обратным порядком байтов) алгоритм HMAC. (В настоящее время размер ключа всегда совпадает с размером хэш-кода.)

* [32 бита] Размер хэш-кода (в байтах, с обратным порядком байтов) алгоритма HMAC.

* EncCBC (K_E, IV, ""), который является результатом работы алгоритма симметричный блочный шифр, пустую строку входных данных и где IV — вектор нулевые. Конструирование K_E описан ниже.

* MAC (K_H, ""), который является результатом работы алгоритма HMAC, пустая строка входных данных. Конструирование K_H описан ниже.

В идеальном случае мы передаем нулевые векторов для K_E и K_H. Тем не менее мы хотим избежать ситуации, где основной алгоритм проверяет наличие слабых ключей перед выполнением любой операции (в частности DES и 3DES), которая исключает использование шаблона как вектор нулевые простое или repeatable.

Вместо этого мы используем Формирования NIST SP800-108 в режиме счетчика (см. [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), секунду 5.1) с ключом нулевой длины, метку и контекст и HMACSHA512 как базовый PRF. Мы производные | K_E | + | K_H | байт выходных данных, затем разложения результат K_E и K_H сами. Математически она представлена следующим образом.

(K_E || K_H) = SP800_108_CTR (prf = HMACSHA512, ключ = "», метки ="», контекст = "")

### <a name="example-aes-192-cbc--hmacsha256"></a>Пример: AES-192-CBC + HMACSHA256

Например рассмотрим случай, где блок симметричный алгоритм шифрования AES-192-CBC она алгоритм проверки HMACSHA256. Система создает заголовок контекста, выполнив следующие действия.

Во-первых, (K_E || K_H) = SP800_108_CTR (prf = HMACSHA512, ключ = "», метки ="», контекст = ""), где | K_E | = 192 бита и | K_H | = 256 бит в указанной алгоритмов. Это приводит к K_E = 5BB6... 21DD и K_H = A04A... 00A9 в следующем примере:

```
5B B6 C9 83 13 78 22 1D 8E 10 73 CA CF 65 8E B0
61 62 42 71 CB 83 21 DD A0 4A 05 00 5B AB C0 A2
49 6F A5 61 E3 E2 49 87 AA 63 55 CD 74 0A DA C4
B7 92 3D BF 59 90 00 A9
```

Далее вычислений Enc_CBC (K_E, IV, «») для AES-192-CBC заданный вектор Инициализации = 0 * и K_E, как описано выше.

result := F474B1872B3B53E4721DE19C0841DB6F

Далее вычислений MAC (K_H, "") для HMACSHA256, учитывая K_H, как описано выше.

result := D4791184B996092EE1202F36E8608FA8FBD98ABDFF5402F264B1D7211536220C

В результате получается полный заголовок ниже:

```
00 00 00 00 00 18 00 00 00 10 00 00 00 20 00 00
00 20 F4 74 B1 87 2B 3B 53 E4 72 1D E1 9C 08 41
DB 6F D4 79 11 84 B9 96 09 2E E1 20 2F 36 E8 60
8F A8 FB D9 8A BD FF 54 02 F2 64 B1 D7 21 15 36
22 0C
```

Этот заголовок контекста является отпечаток пары алгоритм шифрования, прошедшего проверку подлинности (шифрование AES-192-CBC + HMACSHA256 проверки). Компоненты, как описано [выше](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers-cbc-components) являются:

* маркер (00 00)

* Длина ключа для шифрования блока (00 00 00 18)

* размер блока блоков шифра (00 00 00 10)

* Длина ключа HMAC (00 00 00 20)

* размер хэш-кода HMAC (00 00 00 20)

* блочный шифр выходной политики репликации Паролей (F4 74 - DB 6F) и

* выходные данные HMAC PRF (D4 79 - end).

> [!NOTE]
> Шифрование в режиме CBC + HMAC заголовок проверки подлинности контекста создается так же, независимо от того, предоставляются ли реализации алгоритмы Windows CNG или управляемых типов SymmetricAlgorithm и KeyedHashAlgorithm. Это позволяет приложениям, выполняющимся в различных операционных системах, надежно создавать один и тот же заголовок контекста, несмотря на то, что реализации алгоритмов различаться в разных операционных систем. (На практике KeyedHashAlgorithm не должен быть правильный HMAC. Он может быть любой тип алгоритма хэширования с ключом.)

### <a name="example-3des-192-cbc--hmacsha1"></a>Например: 3DES-192-CBC + HMAC-SHA1

Во-первых, (K_E || K_H) = SP800_108_CTR (prf = HMACSHA512, ключ = "», метки ="», контекст = ""), где | K_E | = 192 бита и | K_H | = 160 бит в указанной алгоритмов. Это приводит к K_E = A219... E2BB и K_H = DC4A... B464 в следующем примере:

```
A2 19 60 2F 83 A9 13 EA B0 61 3A 39 B8 A6 7E 22
61 D9 F8 6C 10 51 E2 BB DC 4A 00 D7 03 A2 48 3E
D1 F7 5A 34 EB 28 3E D7 D4 67 B4 64
```

Далее вычислений Enc_CBC (K_E, IV, «») для 3DES-192-CBC заданный вектор Инициализации = 0 * и K_E, как описано выше.

результат: = ABB100F81E53E10E

Далее вычислений MAC (K_H, "") для HMAC-SHA1, учитывая K_H, как описано выше.

result := 76EB189B35CF03461DDF877CD9F4B1B4D63A7555

В результате получается полный заголовок, который является отпечаток прошедшего проверку подлинности пары алгоритм шифрования (шифрование 3DES-192-CBC + проверки HMAC-SHA1), показано ниже:

```
00 00 00 00 00 18 00 00 00 08 00 00 00 14 00 00
00 14 AB B1 00 F8 1E 53 E1 0E 76 EB 18 9B 35 CF
03 46 1D DF 87 7C D9 F4 B1 B4 D6 3A 75 55
```

Компоненты разбить следующим образом:

* маркер (00 00)

* Длина ключа для шифрования блока (00 00 00 18)

* размер блока блоков шифра (00 00 00 08)

* Длина ключа HMAC (00 00 00 14)

* размер хэш-кода HMAC (00 00 00 14)

* блочный шифр выходной политики репликации Паролей (B1 AB - E1 0E) и

* выходные данные HMAC PRF (76 EB - end).

## <a name="galoiscounter-mode-encryption--authentication"></a>Режим Galois/счетчика шифрования + проверки подлинности

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 01, которая является маркером означает «шифрование GCM + проверки подлинности».

* [32 бита] Длина ключа (в байтах, с обратным порядком байтов) алгоритм шифрования симметричных блока.

* [32 бита] Nonce размер (в байтах, с обратным порядком байтов), используемый во время операции шифрования с проверкой подлинности. (Для нашей системы, это имеет фиксированный размер nonce = 96 битов.)

* [32 бита] Размер блока (в байтах, с обратным порядком байтов) алгоритм шифрования симметричных блока. (Для GCM, это имеет фиксированный размер блока = 128 бит.)

* [32 бита] Проверка подлинности тег размер (в байтах, с обратным порядком байтов) созданном функцией шифрования прошедшего проверку подлинности. (Для нашей системы, это имеет фиксированный размер тег = 128 бит.)

* [128 бит] Тег Enc_GCM (K_E, nonce, «»), который является результатом работы алгоритма симметричный блочный шифр, пустую строку входных данных и размещения nonce нулевые 96-разрядного вектора.

K_E формируется с помощью того же механизма, как и шифрования CBC + HMAC сценарии проверки подлинности. Тем не менее, поскольку здесь не K_H, мы фактически имеют | K_H | = 0, и алгоритм сворачивает форму ниже.

K_E = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")

### <a name="example-aes-256-gcm"></a>Пример: AES-256-GCM

Сначала разрешить K_E = SP800_108_CTR (prf = HMACSHA512, ключ = "», метки ="», контекст = ""), где | K_E | = 256 бит.

K_E := 22BC6F1B171C08C4AE2F27444AF8FC8B3087A90006CAEA91FDCFB47C1B8733B8

Далее вычислений тега Enc_GCM проверки подлинности (K_E, nonce, «») для AES-256-GCM заданному nonce = 096 и K_E как описано выше.

result := E7DCCE66DF855A323A6BB7BD7A59BE45

В результате получается полный заголовок ниже:

```
00 01 00 00 00 20 00 00 00 0C 00 00 00 10 00 00
00 10 E7 DC CE 66 DF 85 5A 32 3A 6B B7 BD 7A 59
BE 45
```

Компоненты разбить следующим образом:

   * маркер (00 01)

   * Длина ключа для шифрования блока (00 00 00 20)

   * размер nonce (00 00 00 0 C)

   * размер блока блоков шифра (00 00 00 10)

   * размер тега (00 00 00 10) для проверки подлинности и

   * тег аутентификации из работающих блочного шифра (DC E7 — end).
