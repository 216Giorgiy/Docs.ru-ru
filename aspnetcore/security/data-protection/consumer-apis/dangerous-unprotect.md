---
title: "Снятие защиты полезных данных, ключи которых были отозваны"
author: rick-anderson
description: "В этом документе объясняется, как следует снять защиту данных, защищенные с помощью ключей, поскольку были отозваны, в приложении ASP.NET Core."
keywords: "Ключи, IPersistedDataProtector отозван ASP.NET Core, защиты данных"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 6c4e6591-45d2-4d25-855e-062ad352d648
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/dangerous-unprotect
ms.openlocfilehash: 5d431f0bbe7152525c9a360a6e90bccbd26be93d
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
# <a name="unprotecting-payloads-whose-keys-have-been-revoked"></a>Снятие защиты полезных данных, ключи которых были отозваны

<a name="data-protection-consumer-apis-dangerous-unprotect"></a>

В основном защиты данных ASP.NET Core API-интерфейсы не предназначены для неопределенного сохраняемости Конфиденциально полезных данных. Другие технологии, такие как [CNG Windows DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) и [Azure Rights Management](https://docs.microsoft.com/rights-management/) больше подходят для сценария хранилища не ограничена, и они обладают возможностями соответственно строгого управления ключами. С другой стороны, нет ничего запретить разработчик с помощью интерфейсов API защиты данных ASP.NET Core для долгосрочной защиты конфиденциальных данных. Ключи, никогда не удаляются из ключей, поэтому `IDataProtector.Unprotect` всегда можно восстановить существующий полезных данных, при условии, что ключи доступны и допустимым.

Однако проблема возникает при попытке снять защиту данных, защищенных отозванных ключом, как разработчик `IDataProtector.Unprotect` в этом случае будет вызвано исключение. Это может быть удобно при кратковременных или временных полезных данных (например, токены проверки подлинности), как эти виды полезных данных можно легко воссоздать в системе и в худшем случае посетитель узла возможно, потребуется снова войти в систему. Но для материализованных полезных данных, имеющих `Unprotect` throw может привести к потере недопустимых значений.

## <a name="ipersisteddataprotector"></a>IPersistedDataProtector

Для поддержки сценариев, что полезные данные, необходимо снять защиту даже в случае отозванных ключи система защиты данных содержит `IPersistedDataProtector` типа. Чтобы получить экземпляр `IPersistedDataProtector`, просто получить экземпляр `IDataProtector` в обычном и приведение try `IDataProtector` для `IPersistedDataProtector`.

> [!NOTE]
> Не все `IDataProtector` экземпляры могут быть приведены к `IPersistedDataProtector`. Разработчикам следует использовать в C# как оператор или аналогичные, чтобы избежать исключений среды выполнения причиной недопустимые приведения, они должны быть подготовлены к соответствующим образом обрабатывать случаи сбоя.

`IPersistedDataProtector`предоставляет поверхность следующие API:

```csharp
DangerousUnprotect(byte[] protectedData, bool ignoreRevocationErrors,
     out bool requiresMigration, out bool wasRevoked) : byte[]
```

Этот API принимает защищенных полезных данных (в виде массива байтов) и возвращает незащищенных полезных данных. Нет ни одна перегрузка на основе строк. Ниже приведены два выходных параметров.

* `requiresMigration`: установлено значение true, если ключ, используемый для защиты этого полезные данные больше не по умолчанию активного ключа, например, старый ключ, используемый для защиты этого полезные данные и ключ операции отката с момента откроется месте. Вызывающий объект можете рассмотреть возможность размещения полезных данных в зависимости от их бизнес-требованиям.

* `wasRevoked`: будет присвоено значение true, если ключ, используемый для защиты этого полезных данных был отозван.

>[!WARNING]
> Соблюдайте осторожность при передаче `ignoreRevocationErrors: true` для `DangerousUnprotect` метод. Если после вызова этого метода `wasRevoked` имеет значение true, то ключ, используемый для защиты этого полезных данных был отозван и подлинность полезных данных, которые должны рассматриваться как подозрительная. В этом случае только продолжают работать в незащищенном полезных данных при наличии некоторую уверенность в отдельном что его подлинность, например, что он поступающих от защищенную базу данных, а не отправки клиентом ненадежных веб.

[!code-csharp[Main](dangerous-unprotect/samples/dangerous-unprotect.cs)]
