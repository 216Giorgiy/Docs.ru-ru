---
title: "Назначение строками в ASP.NET Core"
author: rick-anderson
description: 
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 9d18c287-e0e6-4541-b09c-7fed45c902d9
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: dd87d8bcaf0056b322908e9a3ef75678f603e1e6
ms.sourcegitcommit: 0b6c8e6d81d2b3c161cd375036eecbace46a9707
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2017
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="69bd6-103">Цель иерархию и Многопользовательские приложения в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="69bd6-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="69bd6-104">Поскольку IDataProtector неявно IDataProtectionProvider, можно создать цепочку целей.</span><span class="sxs-lookup"><span data-stu-id="69bd6-104">Since an IDataProtector is also implicitly an IDataProtectionProvider, purposes can be chained together.</span></span> <span data-ttu-id="69bd6-105">В этом смысле поставщика. CreateProtector ([«purpose1», «purpose2»]) является эквивалентом поставщика. CreateProtector("purpose1"). CreateProtector("purpose2").</span><span class="sxs-lookup"><span data-stu-id="69bd6-105">In this sense provider.CreateProtector([ "purpose1", "purpose2" ]) is equivalent to provider.CreateProtector("purpose1").CreateProtector("purpose2").</span></span>

<span data-ttu-id="69bd6-106">Это обеспечивает некоторые интересные иерархические связи в системе защиты данных.</span><span class="sxs-lookup"><span data-stu-id="69bd6-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="69bd6-107">В предыдущем примере для [Contoso.Messaging.SecureMessage](purpose-strings.md#data-protection-contoso-purpose), SecureMessage компонента можно вызвать поставщик. CreateProtector("Contoso.Messaging.SecureMessage") после переднего плана и результат в поле закрытого _myProvider кэша.</span><span class="sxs-lookup"><span data-stu-id="69bd6-107">In the earlier example of [Contoso.Messaging.SecureMessage](purpose-strings.md#data-protection-contoso-purpose), the SecureMessage component can call provider.CreateProtector("Contoso.Messaging.SecureMessage") once upfront and cache the result into a private _myProvider field.</span></span> <span data-ttu-id="69bd6-108">Будущие предохранители можно создать путем вызова метода _myProvider.CreateProtector ("пользователь: имя пользователя»), и эти предохранители ключа, которые будут использоваться для защиты отдельных сообщений.</span><span class="sxs-lookup"><span data-stu-id="69bd6-108">Future protectors can then be created via calls to _myProvider.CreateProtector("User: username"), and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="69bd6-109">Это может также отражается.</span><span class="sxs-lookup"><span data-stu-id="69bd6-109">This can also be flipped.</span></span> <span data-ttu-id="69bd6-110">Рассмотрим один логический приложение какие узлы нескольких клиентов (CMS кажется разумным) и каждый клиент можно настроить свою собственную систему управления проверки подлинности и состояние.</span><span class="sxs-lookup"><span data-stu-id="69bd6-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="69bd6-111">Зонтик приложение имеет один основной поставщик, и вызывает поставщика. CreateProtector («клиента 1») и поставщика. CreateProtector («клиента (2)») для предоставления каждого клиента собственную изолированной срез системы защиты данных.</span><span class="sxs-lookup"><span data-stu-id="69bd6-111">The umbrella application has a single master provider, and it calls provider.CreateProtector("Tenant 1") and provider.CreateProtector("Tenant 2") to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="69bd6-112">Клиенты затем создать собственные отдельных предохранители, исходя из своих собственных потребностей, но независимо от того, насколько сильно они пытаются выполнить их не удается создать предохранителей, которые конфликтуют с любым другим клиентом в системе.</span><span class="sxs-lookup"><span data-stu-id="69bd6-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="69bd6-113">Графически она представлена ниже.</span><span class="sxs-lookup"><span data-stu-id="69bd6-113">Graphically this is represented as below.</span></span>

![Несколько целей аренды](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="69bd6-115">Это предполагает рамках элементов управления приложения, какие интерфейсы API доступны для отдельных клиентов и клиентов, которое не может выполнить произвольный код на сервере.</span><span class="sxs-lookup"><span data-stu-id="69bd6-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="69bd6-116">Если клиент может выполняться произвольный код, они могут выполнять отражение закрытых прервать гарантии изоляции или может только читать материала основного непосредственно и наследовать все подразделы, что пожелает.</span><span class="sxs-lookup"><span data-stu-id="69bd6-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="69bd6-117">Система защиты данных использует своего рода Многопользовательские приложения в конфигурации по умолчанию out of box.</span><span class="sxs-lookup"><span data-stu-id="69bd6-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="69bd6-118">По умолчанию материала основного хранится в папке профиля пользователя учетной записи процесса рабочего (или в реестре, для удостоверения пула приложений IIS).</span><span class="sxs-lookup"><span data-stu-id="69bd6-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="69bd6-119">Но фактически довольно часто, использование одной учетной записи для выполнения нескольких приложений и таким образом эти приложения появятся общий доступ к хозяину материала.</span><span class="sxs-lookup"><span data-stu-id="69bd6-119">But it is actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="69bd6-120">Чтобы устранить эту проблему, система защиты данных автоматически вставляет идентификатор уникальными на уровне приложений как первый элемент в цепочке общей цели.</span><span class="sxs-lookup"><span data-stu-id="69bd6-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="69bd6-121">Этой цели неявное служит для [изолировать отдельные приложения](../configuration/overview.md#data-protection-configuration-per-app-isolation) друг от друга, эффективно рассматривая каждое приложение как уникальный клиента в системе и процесс создания предохранителя выглядит идентична на рисунке выше.</span><span class="sxs-lookup"><span data-stu-id="69bd6-121">This implicit purpose serves to [isolate individual applications](../configuration/overview.md#data-protection-configuration-per-app-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
