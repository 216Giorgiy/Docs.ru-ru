---
title: "Предотвращение межсайтовых сценариев"
author: rick-anderson
description: "В этом документе представлены межсайтовых сценариев (XSS) и методы устранения этой уязвимости в приложении ASP.NET Core."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/cross-site-scripting
ms.openlocfilehash: af73a86aa6bcde084ecbe1a3fb5711c7da55871c
ms.sourcegitcommit: 3e303620a125325bb9abd4b2d315c106fb8c47fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2018
---
# <a name="preventing-cross-site-scripting"></a>Предотвращение межсайтовых сценариев

Автор: [Рик Андерсон](https://twitter.com/RickAndMSFT) (Rick Anderson)

Межсайтовых сценариев (XSS) является уязвимость системы безопасности, позволяющая злоумышленнику разместить клиентские скрипты (обычно JavaScript) в веб-страницы. При других пользователей загрузить измененные страницы будут выполняться скрипты злоумышленники, что позволит ему похищать файлы cookie и токены сеанса изменение содержимого веб-страницы по обработке модели DOM или перенаправить браузер на другую страницу. Уязвимости XSS обычно возникают в том случае, когда приложение входные данные пользователя и выводит его на странице без проверки, кодирования или его преобразование.

## <a name="protecting-your-application-against-xss"></a>Защита приложения от XSS

AT базовый уровень XSS работает путем tricking приложением для вставки `<script>` тег в готовом для просмотра страницы или путем вставки `On*` события в элемент. Разработчикам следует использовать следующие шаги для предотвращения во избежание внесения XSS в свои приложения.

1. Никогда не попадают непроверенных данных входные данные HTML, пока не будут выполнены остальные шаги. Непроверенных данных является любые данные, которые управляются злоумышленник, входных HTML, строк запросов, заголовки HTTP, даже данные из базы данных источника, как злоумышленник может иметь возможность нарушить базы данных, даже если они не может нарушить приложения.

2. Перед добавлением непроверенных данных внутри элемента HTML убедитесь, что он имеет кодировку HTML. HTML-кодирования принимает символы, такие как &lt; и изменяет их в безопасном форму как &amp;lt;

3. Перед переводом в HTML-атрибут непроверенных данных убедитесь, что он является атрибутом HTML в кодировке. Кодировка атрибута HTML является надмножеством HTML-кодирования и кодирует дополнительные символы, такие как "и".

4. Перед добавлением в код JavaScript непроверенных данных помещает данные в HTML-элемент, содержимое которых получить во время выполнения. Если это невозможно, то убедитесь, что данные кодируются JavaScript. Кодирование JavaScript принимает небезопасные символы для JavaScript и заменяет их символом их hex, например &lt; должен кодироваться как `\u003C`.

5. Перед переводом непроверенных данных в строку запроса URL-адреса убедитесь, что он является URL-кодированием.

## <a name="html-encoding-using-razor"></a>Кодировка HTML с помощью Razor

Подсистема Razor, автоматически используется в MVC кодирует все выходные данные источником переменные, если только вы много работать, чтобы он таким образом. Он использует правила кодирования при использовании атрибута HTML  *@*  директивы. Как HTML кодировка атрибута является надмножеством HTML-кодирования, это значит, что не нужно заниматься, следует ли использовать HTML-кодирования или кодировка атрибута HTML. Необходимо убедиться, что используются только в контексте HTML не при попытке вставить недоверенные входные данные непосредственно в JavaScript. Вспомогательных функций тегов также будут закодировать входные данные, используемые в параметрах тегов.

Использовать следующее представление Razor;

```none
@{
       var untrustedInput = "<\"123\">";
   }

   @untrustedInput
   ```

Это представление выводит содержимое *untrustedInput* переменной. Эта переменная содержит некоторые символы, которые используются в атак с XSS, а именно &lt;,» и &gt;. Проверка источника показаны выводимые данные кодируются как:

```html
&lt;&quot;123&quot;&gt;
   ```

>[!WARNING]
> Основные ASP.NET MVC предоставляет `HtmlString` класс, который не будет закодировано автоматически после выходных данных. Это никогда не можно использовать в сочетании с ненадежных входных данных, при этом будут представлены уязвимость XSS.

## <a name="javascript-encoding-using-razor"></a>Кодирование JavaScript с помощью Razor

Могут возникнуть ситуации, нужно вставить значение в JavaScript для обработки в представлении. Это можно сделать двумя способами. Это самый безопасный способ вставки простых значений — поместить значение в атрибуте данных тега и поиск его в JavaScript. Пример:

```none
@{
       var untrustedInput = "<\"123\">";
   }

   <div
       id="injectedData"
       data-untrustedinput="@untrustedInput" />

   <script>
     var injectedData = document.getElementById("injectedData");

     // All clients
     var clientSideUntrustedInputOldStyle =
         injectedData.getAttribute("data-untrustedinput");

     // HTML 5 clients only
     var clientSideUntrustedInputHtml5 =
         injectedData.dataset.untrustedinput;

     document.write(clientSideUntrustedInputOldStyle);
     document.write("<br />")
     document.write(clientSideUntrustedInputHtml5);
   </script>
   ```

В результате получится следующий код HTML

```html
<div
     id="injectedData"
     data-untrustedinput="&lt;&quot;123&quot;&gt;" />

   <script>
     var injectedData = document.getElementById("injectedData");

     var clientSideUntrustedInputOldStyle =
         injectedData.getAttribute("data-untrustedinput");

     var clientSideUntrustedInputHtml5 =
         injectedData.dataset.untrustedinput;

     document.write(clientSideUntrustedInputOldStyle);
     document.write("<br />")
     document.write(clientSideUntrustedInputHtml5);
   </script>
   ```

Если он выполняется, отображающего следующую процедуру.

```none
<"123">
   <"123">
   ```

Можно также вызвать кодировщик JavaScript напрямую,

```none
@using System.Text.Encodings.Web;
   @inject JavaScriptEncoder encoder;

   @{
       var untrustedInput = "<\"123\">";
   }

   <script>
       document.write("@encoder.Encode(untrustedInput)");
   </script>
   ```

Это сделает в браузере, следующим образом:

```html
<script>
       document.write("\u003C\u0022123\u0022\u003E");
   </script>
   ```

>[!WARNING]
> Не следует объединять недоверенные входные данные на языке JavaScript для создания элементов DOM. Следует использовать `createElement()` и назначить значения свойств, например соответствующим образом `node.TextContent=`, или используйте `element.SetAttribute()` / `element[attribute]=` в противном случае самостоятельно предоставлять на основе DOM XSS.

## <a name="accessing-encoders-in-code"></a>Доступ к кодировщики в коде

Кодировщики HTML, JavaScript и URL-адреса доступны для кода двумя способами, можно ввести их через [внедрения зависимостей](../fundamentals/dependency-injection.md#fundamentals-dependency-injection) или использовании кодировщики по умолчанию, содержащиеся в `System.Text.Encodings.Web` пространства имен. При использовании кодировщики по умолчанию любой применяются для диапазонов символов следует рассматривать как безопасные не вступят в силу — кодировщики по умолчанию используйте безопасный из возможных правила кодирования.

Для использования настраиваемых кодировщики через DI конструкторах займет *HtmlEncoder*, *JavaScriptEncoder* и *UrlEncoder* параметр соответствующим образом. Например,

```csharp
public class HomeController : Controller
   {
       HtmlEncoder _htmlEncoder;
       JavaScriptEncoder _javaScriptEncoder;
       UrlEncoder _urlEncoder;

       public HomeController(HtmlEncoder htmlEncoder,
                             JavaScriptEncoder javascriptEncoder,
                             UrlEncoder urlEncoder)
       {
           _htmlEncoder = htmlEncoder;
           _javaScriptEncoder = javascriptEncoder;
           _urlEncoder = urlEncoder;
       }
   }
   ```

## <a name="encoding-url-parameters"></a>Параметры кодировки URL-адреса

Если вы хотите создать строку запроса URL-адрес с ненадежных входных данных, как использование значение `UrlEncoder` для кодирования значения. Например, примененная к объекту директива

```csharp
var example = "\"Quoted Value with spaces and &\"";
   var encodedValue = _urlEncoder.Encode(example);
   ```

После кодирования encodedValue переменная будет содержать `%22Quoted%20Value%20with%20spaces%20and%20%26%22`. Пробелы, кавычки, знаки пунктуации и другие небезопасных символов кодироваться процента шестнадцатеричные значения, например символ пробела становится % 20.

>[!WARNING]
> Не используйте недоверенные входные данные как часть URL-пути. Всегда передает недоверенные входные данные как значение строки запроса.

<a name="security-cross-site-scripting-customization"></a>

## <a name="customizing-the-encoders"></a>Настройка кодировщики

По умолчанию кодировщики используйте безопасный список, ограниченный диапазон Юникода Basic Latin и кодирования всех символов вне этого диапазона как эквиваленты код символа. Это поведение также влияет на отрисовку вспомогательной функции тегов Razor и HtmlHelper как кодировщики будет использовать для сравнения строк в выходных данных.

Причины, обуславливающие это сделано для защиты от неизвестных или будущих браузера ошибок (предыдущих ошибок браузера задействуемый копирование основанные на обработку символов не на английском языке). Если веб-сайте усложняет использование Нелатинские символы, такие как китайский, кириллица или другим это, скорее всего, не желаемое поведение.

Вы можете настроить списки безопасном кодировщика для включения Юникода, допустимые диапазоны для приложения во время запуска, в `ConfigureServices()`.

Например, с помощью конфигурации по умолчанию, можно использовать Razor HtmlHelper следующим образом;

```html
<p>This link text is in Chinese: @Html.ActionLink("汉语/漢語", "Index")</p>
   ```

При просмотре исходного кода веб-страницы, то будет выведено его обработки следующим образом с кодированием; текст на китайском языке

```html
<p>This link text is in Chinese: <a href="/">&#x6C49;&#x8BED;/&#x6F22;&#x8A9E;</a></p>
   ```

Чтобы увеличить ширину символов, считаются безопасном кодировщиком необходимо вставить следующую строку в `ConfigureServices()` метод в `startup.cs`;

```csharp
services.AddSingleton<HtmlEncoder>(
     HtmlEncoder.Create(allowedRanges: new[] { UnicodeRanges.BasicLatin,
                                               UnicodeRanges.CjkUnifiedIdeographs }));
   ```

В этом примере расширяется список безопасных для включения CjkUnifiedIdeographs диапазон Юникода. Теперь стал бы выводимые данные

```html
<p>This link text is in Chinese: <a href="/">汉语/漢語</a></p>
   ```

Список надежных диапазоны задаются в виде кодировок Юникода, не языков. [Стандарт Юникод](http://unicode.org/) имеет список [кода диаграммы](http://www.unicode.org/charts/index.html) можно использовать для поиска диаграммы, содержащей вашей символов. Каждого кодировщика, Html, JavaScript и URL-адрес должен быть настроен отдельно.

> [!NOTE]
> Настройка надежных влияет только на источником через DI кодировщиков. Если прямой доступ к кодировщик через `System.Text.Encodings.Web.*Encoder.Default` затем по умолчанию, Basic Latin будет использоваться только списка надежных отправителей.

## <a name="where-should-encoding-take-place"></a>Где следует поместить кодирования take

Применяемый общий подход заключается в том кодирование выполняется во время вывода закодированные значения никогда не должны храниться в базе данных. Кодирование точке выходные данные можно изменить использование данных, например, из HTML-код, значение строки запроса. Также позволяет легко найти данных без необходимости кодирование значений перед поиском и позволяет воспользоваться преимуществами любые изменения или исправления, внесенные в кодировщиков.

## <a name="validation-as-an-xss-prevention-technique"></a>Проверка как способ защиты от XSS

Проверка может быть полезным инструментом ограничение атак с XSS. Например простой числовой строка, содержащая только символы 0 – 9 не будет вызывать XSS атаки. Проверка становится более сложным, следует нужно принимать HTML во вводимых - синтаксического анализа HTML-ввода является сложным, невозможно. Другие форматы текста и разметки будет более безопасный параметр для форматированного ввода. Никогда не следует полагаться на проверку сама по себе. Всегда кодировать недоверенные входные данные перед выводом, независимо от того, какая проверка выполнена.
