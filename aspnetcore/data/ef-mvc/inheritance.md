---
title: "Основные ASP.NET MVC с основными EF - наследования - 9, 10"
author: tdykstra
description: "Этот учебник будет показано, как реализовать наследование в модели данных с использованием Entity Framework Core в приложении ASP.NET Core."
manager: wpickett
ms.author: tdykstra
ms.date: 03/15/2017
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: get-started-article
uid: data/ef-mvc/inheritance
ms.openlocfilehash: 985cc38b10ef830b8274e40ad5f7050157fd4d86
ms.sourcegitcommit: a510f38930abc84c4b302029d019a34dfe76823b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2018
---
# <a name="inheritance---ef-core-with-aspnet-core-mvc-tutorial-9-of-10"></a>Наследование - Core EF учебнику ASP.NET Core MVC (9, 10)

По [Tom Dykstra](https://github.com/tdykstra) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Contoso университета примера веб-приложения показано, как создавать веб-приложения ASP.NET MVC ядра с помощью основного Entity Framework и Visual Studio. Сведения о учебника серии см [в первом учебнике ряда](intro.md).

В предыдущем учебнике обработки исключений параллелизма. Этот учебник будет показано, как реализовать наследование в модели данных.

В объектно ориентированного программирования, можно использовать наследование для упрощения повторного использования кода. В этом учебнике мы изменим `Instructor` и `Student` классов, чтобы они являются производными от `Person` базового класса, который содержит свойства, такие как `LastName` , которые являются общими для преподавателей и учащихся. Не добавить или изменить веб-страницы, но мы изменим некоторую часть кода, и эти изменения будут автоматически отражаться в базе данных.

## <a name="options-for-mapping-inheritance-to-database-tables"></a>Параметры для сопоставления наследования с таблицами базы данных

`Instructor` И `Student` классы в модели данных школе имеют несколько свойств, которые идентичны:

![Классы учащихся и инструкторов](inheritance/_static/no-inheritance.png)

Предположим, что нужно исключить избыточный код для свойств, которые являются общими для `Instructor` и `Student` сущности. Или вы хотите создать службу, имена форматов без интересуясь ли имя, откуда инструктор или студент. Можно создать `Person` базового класса, который содержит только те свойства общего, а затем сделать `Instructor` и `Student` классы наследуются от базового класса, как показано на следующем рисунке:

![Учащихся и инструкторов классы, производные от класса Person](inheritance/_static/inheritance.png)

Существует несколько способов эта структура наследования можно представить в базе данных. Можно создать таблицу Person, включая сведения о студентов и инструкторов в одной таблице. Некоторые столбцы могут применяются только к инструкторов (HireDate) к учащихся (EnrollmentDate), некоторые как параметр (Фамилия, имя). Как правило имеется столбец дискриминатора, чтобы указать, какой тип, каждая строка представляет. Например столбец дискриминатора установлена «Инструктора» для инструкторов и «Студентов» для учащихся.

![Пример таблица на иерархию](inheritance/_static/tph.png)

Этот шаблон создания структура наследования сущностей из одной таблицы базы данных называется таблица на иерархию наследования (TPH).

Альтернативой является база данных больше похожи на структуру наследования. Например можно только имя поля из таблицы Person и иметь отдельные таблицы с полями даты инструктора и студентов.

![Наследование типа «одна таблица на тип»](inheritance/_static/tpt.png)

Этот шаблон создания таблицы базы данных для каждого класса сущности, называется одна таблица на тип (TPT) наследования.

Еще другой вариант — Сопоставьте все типы неабстрактного для отдельных таблиц. Все свойства класса, включая унаследованные свойства сопоставляются со столбцами и соответствующая таблица. Этот шаблон вызывается наследования таблицы каждой конкретной реализацией класса (TPC). Если реализован TPC наследования для человека, учащихся и инструкторов классов, как показано выше, таблицами Student и инструктора выглядит не отличается после реализации наследования, чем раньше.

TPC и TPH схемы наследования обычно обеспечивают лучшую производительность, чем TPT схемы наследования, поскольку TPT шаблоны запросов сложного соединения может привести.

Этот учебник демонстрирует реализацию TPH наследования. TPH является только наследование, поддерживающий Entity Framework Core.  Вы выполните — создать `Person` класса, измените `Instructor` и `Student` классы являются производными от `Person`, добавьте новый класс `DbContext`и создание миграции.

> [!TIP] 
> Рекомендуется сохранить копию проекта перед вносит следующие изменения.  Затем Если возникли проблемы и нужно начать заново его будет проще запустить из сохраненного проекта вместо обращения действия выполняется для этого учебника, или будет в начало весь ряд.

## <a name="create-the-person-class"></a>Создание класса Person

В папке Models находится создайте Person.cs и замените код шаблона с помощью следующего кода:

[!code-csharp[Main](intro/samples/cu/Models/Person.cs)]

## <a name="make-student-and-instructor-classes-inherit-from-person"></a>Учащихся и инструкторов классы наследуют от пользователя сделать

В *Instructor.cs*, класс инструктора производный от класса Person и удалить ключа и имя поля. Код будет выглядеть как в следующем примере:

[!code-csharp[Main](intro/samples/cu/Models/Instructor.cs?name=snippet_AfterInheritance&highlight=8)]

Внесения изменений в *Student.cs*.

[!code-csharp[Main](intro/samples/cu/Models/Student.cs?name=snippet_AfterInheritance&highlight=8)]

## <a name="add-the-person-entity-type-to-the-data-model"></a>Добавить в модель данных сущности типа Person

Добавление типа сущности пользователя для *SchoolContext.cs*. Новые строки будут выделены.

[!code-csharp[Main](intro/samples/cu/Data/SchoolContext.cs?name=snippet_AfterInheritance&highlight=19,30)]

Это все, что платформа Entity Framework требуется для настройки таблица на иерархию наследования. Как вы увидите, при обновлении базы данных, он будет иметь таблицы Person вместо таблицами Student и инструктора.

## <a name="create-and-customize-migration-code"></a>Создание и настройка миграции кода

Сохраните изменения и выполните построение проекта. Затем откройте командную строку в папке проекта и введите следующую команду:

```console
dotnet ef migrations add Inheritance
```

Не запускайте `database update` еще команды. Этой команды приведет к потере данных, так как он будет удалить таблицу инструктора и переименовать таблицу студента лицу. Необходимо предоставить пользовательский код для сохранения данных.

Откройте *миграций /\<timestamp > _Inheritance.cs* и замените `Up` метод следующим кодом:

[!code-csharp[Main](intro/samples/cu/Migrations/20170216215525_Inheritance.cs?name=snippet_Up)]

Этот код отвечает за следующие задачи обновления базы данных:

* Удаление ограничения внешнего ключа и индексы, которые указывают на таблицу учащихся.

* Переименовывает таблицу в качестве лица инструктора и вносит изменения, необходимые для хранения данных студента:

* Добавляет EnrollmentDate допускает значения NULL для учащихся.

* Добавляет столбец дискриминатора для указания, является ли строка для учащихся или инструктор.

* Делает HireDate допускает значение NULL, поскольку студента строк не будет иметь дат приема на работу.

* Добавление временного поля, которое будет использоваться для обновления внешние ключи, указывающие на учащихся. Скопируйте студентов в таблице Person получат новые значения первичных ключей.

* Копирует данные из таблицы студента в таблицу Person. В этом случае учащихся получить назначения нового значения первичного ключа.

* Устраняет значения внешнего ключа, указывающие на учащихся.

* Повторно создает ограничения внешнего ключа и индексы, теперь указывает таблицы Person.

(Если вы использовали GUID вместо целое число в качестве первичного ключа типа, студента значения первичного ключа не пришлось изменять и удалось некоторые из них была пропущена.)

Запустите `database update` команды:

```console
dotnet ef database update
```

(В рабочей системе будет внести соответствующие изменения в `Down` метод в случае, когда-либо было необходимо использовать, чтобы вернуться к предыдущей версии базы данных. В этом учебнике вы не используете `Down` метод.)

> [!NOTE] 
> Можно получить другие ошибки при внесении изменений схемы в базу данных с существующие данные. Если возникли ошибки миграции, которые не удается устранить, можно изменить имя базы данных в строке соединения или удалить базу данных. Нет данных для переноса с новой базой данных, и команду update-database чаще завершиться без ошибок. Чтобы удалить базу данных, используйте SSOX или запустите `database drop` команду CLI.

## <a name="test-with-inheritance-implemented"></a>Тестирование с помощью наследования реализации

Запустите приложение и попробуйте различные страницы. Все, что работает так же, как раньше.

В **обозреватель объектов SQL Server**, разверните **данные соединения и SchoolContext** и затем **таблиц**, и вы увидите, что таблицами Student и инструктора были заменены Таблицы Person. Откройте в конструкторе таблиц Person и вы увидите, что все столбцы, которые используются в таблицах учащихся и инструкторов наличии.

![Таблица Person в SSOX](inheritance/_static/ssox-person-table.png)

Щелкните правой кнопкой мыши таблицу Person и нажмите кнопку **Показать таблицу данных** в столбце дискриминатора.

![Таблица Person в SSOX - таблицы данных](inheritance/_static/ssox-person-data.png)

## <a name="summary"></a>Сводка

Таблица на иерархию наследования для реализации `Person`, `Student`, и `Instructor` классы. Дополнительные сведения о наследовании в Entity Framework Core см. в разделе [наследования](https://docs.microsoft.com/ef/core/modeling/inheritance). В следующем уроке вы увидите, как обрабатывать разнообразные относительно сложных сценариев Entity Framework.

>[!div class="step-by-step"]
[Назад](concurrency.md)
[Вперед](advanced.md)  
