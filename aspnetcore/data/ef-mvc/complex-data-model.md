---
title: "Основные ASP.NET MVC с основными EF - модели данных — 5, 10"
author: tdykstra
description: "В этом учебнике добавляйте дополнительные сущности и связи и настроить модель данных, указав форматирование, проверки и правила сопоставления базы данных."
keywords: "Заметок к данным ASP.NET Core, Entity Framework Core,"
ms.author: tdykstra
manager: wpickett
ms.date: 03/15/2017
ms.topic: get-started-article
ms.assetid: 0dd63913-a041-48b6-96a4-3aeaedbdf5d0
ms.technology: aspnet
ms.prod: asp.net-core
uid: data/ef-mvc/complex-data-model
ms.openlocfilehash: dde50f766dc9842089cbb0561b8bd6e2d8e7c34f
ms.sourcegitcommit: 74a8ad9c1ba5c155d7c4303e67632a0922c38e86
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/20/2017
---
# <a name="creating-a-complex-data-model---ef-core-with-aspnet-core-mvc-tutorial-5-of-10"></a>Создание сложных данных модели - Core EF учебнику ASP.NET Core MVC (5, 10)

По [Tom Dykstra](https://github.com/tdykstra) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Contoso университета примера веб-приложения показано, как создавать веб-приложения ASP.NET MVC ядра с помощью основного Entity Framework и Visual Studio. Сведения о учебника серии см [в первом учебнике ряда](intro.md).

В предыдущих занятий вы работали с простая модель данных, созданный из трех сущностей. В этом учебнике вы добавите несколько сущностей и связей, путем указания форматирования, проверки и правила сопоставления базы данных будет настроить модель данных.

После завершения классы сущностей составляют модель данных, завершенные, показан на следующем рисунке:

![Схема Entity](complex-data-model/_static/diagram.png)

## <a name="customize-the-data-model-by-using-attributes"></a>Настройка модели данных с помощью атрибутов

В этом разделе вы увидите, как настроить модель данных с помощью атрибутов, укажите параметры форматирования, проверки и правила сопоставления базы данных. Затем в некоторых из следующих разделов, который вы создаете всю модель данных школе путем добавления атрибутов к классам вы уже создали и создание новых классов для остальных типов сущностей в модели.

### <a name="the-datatype-attribute"></a>Атрибут типа данных

Для дат регистрации студентов все веб-страниц в настоящее время отображения времени и даты, несмотря на то, что все, что важна для этого поля является датой. Используя атрибуты данных заметок, ее можно создать, позволяющим формат отображения в каждого представления, отображающего данные изменения кода. Пример этого процесса, что вы добавите атрибут `EnrollmentDate` свойства `Student` класса.

В *Models/Student.cs*, добавьте `using` инструкции для `System.ComponentModel.DataAnnotations` пространства имен и добавьте `DataType` и `DisplayFormat` атрибуты `EnrollmentDate` свойства, как показано в следующем примере:

[!code-csharp[Main](intro/samples/cu/Models/Student.cs?name=snippet_DataType&highlight=3,12-13)]

Атрибут `DataType` позволяет указать тип данных с более точным определением относительно встроенного типа базы данных. В этом случае нам нужен только для отслеживания даты, не даты и времени. `DataType` Перечисление предоставляет для многих типов данных, таких как дата, время, PhoneNumber, валюты, EmailAddress и многое другое. Атрибут `DataType` также обеспечивает автоматическое предоставление функций для определенных типов в приложении. Например, может быть создана ссылка `mailto:` для `DataType.EmailAddress`. Также в браузерах с поддержкой HTML5 может быть предоставлен селектор даты для `DataType.Date`. `DataType` Атрибут выдает HTML 5 `data-` (произносится данных тире) атрибутов, которые можно понять браузеров HTML 5. `DataType` Атрибуты не имеют каких-либо проверок.

`DataType.Date` не задает формат отображаемой даты. По умолчанию поле данных отображается в соответствии с форматы по умолчанию, в зависимости от сервера CultureInfo.

С помощью атрибута `DisplayFormat` можно явно указать формат даты:

```csharp
[DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]
```

Параметр `ApplyFormatInEditMode` указывает, что формат также должен применяться при отображении значения в текстовом поле для редактирования. (Может не потребоваться, для некоторых полей — например, для значений денежных сумм не можно обозначение денежной единицы в текстовом поле для изменения.)

Можно использовать `DisplayFormat` атрибут сам, но обычно имеет смысл использовать `DataType` также атрибут. `DataType` Атрибут передает семантику данных, а не как отображать его на экране и предоставляет следующие преимущества, которые вы не получаете с `DisplayFormat`:

* Браузер может включить функции HTML5 (например, для отображения элемента управления календаря, локализованными обозначение денежной единицы, отправка ссылок, некоторые клиентские ввода проверки и т. д.).

* По умолчанию формат отображения данных в браузере определяется в соответствии с установленным языковым стандартом.

Дополнительные сведения см. в разделе [ \<ввода > тег документации вспомогательный](../../mvc/views/working-with-forms.md#the-input-tag-helper).

Запустить приложение, перейдите на страницу индекса студентов и обратите внимание, раз больше не отображаются для дат регистрации. Также будет иметь значение true для любого представления, использующего модель студента.

![Отображение даты без времени страницы индекса студентов](complex-data-model/_static/dates-no-times.png)

### <a name="the-stringlength-attribute"></a>Атрибут StringLength

Также можно указать правила проверки данных и сообщений об ошибках проверки с помощью атрибутов. `StringLength` Атрибут задает максимальную длину в базе данных и предоставляет на стороне клиента и на стороне сервера проверки ASP.NET MVC. Можно также указать минимальной длины строки в этом атрибуте, но минимальное значение не оказывает влияния на схему базы данных.

Предположим, что вы хотите убедиться, что пользователь не ввел более 50 символов для имени. Чтобы добавить это ограничение, добавьте `StringLength` атрибуты `LastName` и `FirstMidName` свойства, как показано в следующем примере:

[!code-csharp[Main](intro/samples/cu/Models/Student.cs?name=snippet_StringLength&highlight=10,12)]

`StringLength` Атрибут не предотвратить ввода пробелы в имени пользователя. Можно использовать `RegularExpression` атрибутов для применения ограничений входных данных. Например следующий код требует первого символа в записываются прописными буквами и остальные символы преобразуются в алфавитном порядке:

```csharp
[RegularExpression(@"^[A-Z]+[a-zA-Z''-'\s]*$")]
```

`MaxLength` Атрибут предоставляет функциональность, аналогичную `StringLength` атрибута, но не предоставляет клиентской проверки.

Модель базы данных изменилось в результате которого требует изменения в схеме базы данных. Миграция будет использоваться для обновления схемы без потери данных, могут добавления в базу данных с помощью пользовательского интерфейса приложения.

Сохраните изменения и выполните построение проекта. Затем откройте командную строку в папке проекта и введите следующие команды:

```console
dotnet ef migrations add MaxLengthOnNames
```

```console
dotnet ef database update
```

`migrations add` Команда выдает предупреждение, может привести к потере данных, поскольку это изменение делает максимальную длину более короткие для двух столбцов.  Миграция создает файл с именем * \<timeStamp > _MaxLengthOnNames.cs*. Этот файл содержит код в `Up` метод, который будет обновлять базу данных в соответствии с текущей моделью данных. `database update` Этот код выполнялась команда.

Отметка времени, в качестве префикса к имени файла миграции используется платформой Entity Framework для упорядочения для миграции. Можно создать несколько миграции перед выполнением команды update-database, и затем все миграций применяются в порядке, в котором они были созданы.

Запустите приложение, выберите **учащихся** щелкните **создать новый**и введите имя длиной более 50 символов. При нажатии кнопки **создать**, клиентская проверка отобразится сообщение об ошибке.

![Студенты индексная страница, отображающий строку ошибки длины](complex-data-model/_static/string-length-errors.png)

### <a name="the-column-attribute"></a>Атрибут столбца

Атрибуты используются для управления как классы и свойства сопоставляются в базу данных. Предположим, что вы использовали имя `FirstMidName` -имя поля, так как поле также может содержать отчество. Но необходимо сделать столбец базы данных могут называться `FirstName`, так как в это имя привыкшим пользователей, которые будет записывать нерегламентированные запросы к базе данных. Чтобы это сопоставление, можно использовать `Column` атрибута.

`Column` Атрибут указывает, что при создании базы данных в столбце `Student` таблицу, которая сопоставляет `FirstMidName` свойство с именем `FirstName`. Другими словами, когда ваш код ссылается `Student.FirstMidName`, данные получаются из или обновлены в `FirstName` столбец `Student` таблицы. Если не указать имена столбцов, они являются присваивается то же имя, как и имя свойства.

В *Student.cs* файл, добавьте `using` инструкции для `System.ComponentModel.DataAnnotations.Schema` и добавьте атрибут имени столбца для `FirstMidName` свойства, как показано в следующий выделенный код:

[!code-csharp[Main](intro/samples/cu/Models/Student.cs?name=snippet_Column&highlight=4,14)]

Добавление `Column` атрибут изменяет модель `SchoolContext`, поэтому он не будет соответствовать базе данных.

Сохраните изменения и выполните построение проекта. Затем откройте командную строку в папке проекта и введите следующие команды, чтобы создать еще один процесс миграции:

```console
dotnet ef migrations add ColumnFirstName
```

```console
dotnet ef database update
```

В **обозреватель объектов SQL Server**, откройте в конструкторе таблиц учащихся, дважды щелкнув **студента** таблицы.

![Студенты таблицы в SSOX после миграции](complex-data-model/_static/ssox-after-migration.png)

Перед применением миграции первых двух столбцов имен были типа nvarchar(max). Они теперь nvarchar(50) и имя столбца был изменен с FirstMidName на «имя».

> [!Note]
> При попытке скомпилировать до завершения создания всех классов сущностей в следующих разделах, могут возникнуть ошибки компилятора.

## <a name="final-changes-to-the-student-entity"></a>Окончательных изменений в сущность Student

![Сущность Student](complex-data-model/_static/student-entity.png)

В *Models/Student.cs*, замените код, добавленный ранее следующий код. Изменения выделены.

[!code-csharp[Main](intro/samples/cu/Models/Student.cs?name=snippet_BeforeInheritance&highlight=11,13,15,18,22,24-31)]

### <a name="the-required-attribute"></a>Обязательный атрибут

`Required` Атрибут делает обязательные поля имя свойства. `Required` Атрибут не нужен для запретом типов, таких как типы значений (DateTime, int, дважды, число с плавающей запятой, и т. д.). Типы, которые не может быть неопределенным автоматически обрабатываются как обязательные поля.

Можно удалить `Required` атрибута и замените его минимальную длину параметра `StringLength` атрибута:

```csharp
[Display(Name = "Last Name")]
[StringLength(50, MinimumLength=1)]
public string LastName { get; set; }
```

### <a name="the-display-attribute"></a>Атрибут отображения

`Display` Атрибут указывает, должен быть заголовок для поля «Имя», «Фамилия», «Полное имя» и «Регистрации Date», а не имя свойства в каждом экземпляре (которая имеет место не разделение слов).

### <a name="the-fullname-calculated-property"></a>Свойство FullName вычисляется

`FullName`— Вычисляемое свойство, которое возвращает значение, которое создается путем объединения двух свойств. Поэтому он имеет только метод доступа get и нет `FullName` столбец создается в базе данных.

## <a name="create-the-instructor-entity"></a>Создать сущность инструктора

![Сущность инструктора](complex-data-model/_static/instructor-entity.png)

Создание *Models/Instructor.cs*, заменив шаблон код следующим кодом:

[!code-csharp[Main](intro/samples/cu/Models/Instructor.cs?name=snippet_BeforeInheritance)]

Обратите внимание, что некоторые свойства в сущности учащихся и инструкторов совпадают. В [реализации наследования](inheritance.md) учебника далее в этой серии будет оптимизацию данного кода, чтобы исключить избыточность.

Можно поместить несколько атрибутов в одной строке, поэтому можно также написать `HireDate` атрибуты следующим образом:

```csharp
[DataType(DataType.Date),Display(Name = "Hire Date"),DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]
```

### <a name="the-courseassignments-and-officeassignment-navigation-properties"></a>Свойства навигации CourseAssignments и OfficeAssignment

`CourseAssignments` И `OfficeAssignment` свойства — это свойства навигации.

Инструктор можно обучить любое количество курсов, поэтому `CourseAssignments` определен как коллекция.

```csharp
public ICollection<CourseAssignment> CourseAssignments { get; set; }
```

Если свойство навигации может содержать несколько сущностей, его тип должен быть список, в котором записи могут быть добавлены, удаленные и обновлены.  Можно указать `ICollection<T>` или тип, такой как `List<T>` или `HashSet<T>`. При указании `ICollection<T>`, создает EF `HashSet<T>` коллекции по умолчанию.

Причина, почему они являются `CourseAssignment` сущностями описывается ниже в разделе о связях многие ко многим.

Состояние университета Contoso бизнес-правила, инструктор только может иметь не более одного офиса, поэтому `OfficeAssignment` свойство содержит одну сущность OfficeAssignment (который может иметь значение null, если office не назначено).

```csharp
public OfficeAssignment OfficeAssignment { get; set; }
```

## <a name="create-the-officeassignment-entity"></a>Создать сущность OfficeAssignment

![OfficeAssignment сущности](complex-data-model/_static/officeassignment-entity.png)

Создание *Models/OfficeAssignment.cs* следующим кодом:

[!code-csharp[Main](intro/samples/cu/Models/OfficeAssignment.cs)]

### <a name="the-key-attribute"></a>Ключевой атрибут

Имеется один к нулю или одному связь между инструктора и OfficeAssignment сущностей. Office назначения существует только относительно инструктора, которую он назначен, и поэтому ее первичный ключ также является его внешний ключ к сущности инструктора. Однако платформа Entity Framework не удалось распознать автоматически InstructorID как первичный ключ сущности, так как его имя не соответствовать соглашению об именовании идентификатор или classnameID. Таким образом `Key` атрибут используется для идентификации в качестве ключа:

```csharp
[Key]
public int InstructorID { get; set; }
```

Можно также использовать `Key` атрибута, если сущность имеет собственный первичный ключ, но требуется свойство name что-то отличное от classnameID или идентификатор.

По умолчанию EF обрабатывает ключ как без формирования базы данных, так как столбец для идентифицирующего отношения.

### <a name="the-instructor-navigation-property"></a>Свойство навигации инструктора

Сущность инструктора имеет значение NULL `OfficeAssignment` свойство навигации (поскольку инструктор не может иметь назначение office), и имеет не допускающий сущность OfficeAssignment `Instructor` свойство навигации (так как не может присваиваться office существует без инструктор-- `InstructorID` не допускает значение NULL). Сущность инструктора имеет связанную сущность OfficeAssignment, каждая сущность получите ссылку на другую переменную в свойстве навигации.

Можно поместить `[Required]` атрибут для свойства навигации инструктора, чтобы указать, должен быть связанные инструктора, что не нужно делать, так как `InstructorID` внешний ключ (который также является ключом к этой таблице) допускают значение NULL.

## <a name="modify-the-course-entity"></a>Изменение сущности курса

![Сущности курса](complex-data-model/_static/course-entity.png)

В *Models/Course.cs*, замените код, добавленный ранее следующий код. Изменения выделены.

[!code-csharp[Main](intro/samples/cu/Models/Course.cs?name=snippet_Final&highlight=2,10,13,16,19,21,23)]

Сущность курс имеет свойство внешнего ключа `DepartmentID` указывающая связанной сущности отдела и он имеет `Department` свойства навигации.

Платформа Entity Framework не требуется добавлять свойство внешнего ключа в модель данных при наличии свойства навигации для связанной сущности.  EF автоматически создает внешние ключи в базе данных, где они необходимы и создает [затемнять свойства](https://docs.microsoft.com/ef/core/modeling/shadow-properties) для них. Однако наличие внешнего ключа в модели данных могут выполнять обновления проще и эффективнее. Например, при извлечения сущностью курса для редактирования сущности «отдел» имеет значение null, если он не загружается, таким образом при обновлении сущности курса, будет необходимо сначала извлечь сущности «отдел». Если свойство внешнего ключа `DepartmentID` включено в модель данных, не нужно извлечь сущности «отдел» перед обновлением.

### <a name="the-databasegenerated-attribute"></a>Атрибут DatabaseGenerated

`DatabaseGenerated` Атрибутом `None` параметр на `CourseID` свойство указывает, что значения первичного ключа предоставленного пользователем, а не созданное базой данных.

```csharp
[DatabaseGenerated(DatabaseGeneratedOption.None)]
[Display(Name = "Number")]
public int CourseID { get; set; }
```

По умолчанию Entity Framework предполагает генерировать значений первичного ключа в базе данных. Это требуется для большинства сценариев. Однако для набора сущностей, будет использовать курса определяемый пользователем номер серии 1000 для одного подразделения ряд 2000 для разных отделов и так далее.

`DatabaseGenerated` Атрибут также может использоваться для создания значения по умолчанию, как в случае столбцов базы данных, используемых для записи даты строки был создан или обновлен.  Дополнительные сведения см. в разделе [созданные свойства](https://docs.microsoft.com/ef/core/modeling/generated-properties).

### <a name="foreign-key-and-navigation-properties"></a>Свойства внешнего ключа и навигации

Свойства внешнего ключа и свойств навигации сущности курса отражают следующие связи:

Курс назначается одного подразделения, то есть `DepartmentID` внешнего ключа и `Department` свойства навигации по причинам, перечисленным выше.

```csharp
public int DepartmentID { get; set; }
public Department Department { get; set; }
```

Курс может иметь любое количество студентов, зарегистрированных в нем, так что `Enrollments` свойство навигации — это коллекция:

```csharp
public ICollection<Enrollment> Enrollments { get; set; }
```

Может обучения по нескольким инструкторов, поэтому `CourseAssignments` свойство навигации — это коллекция (тип `CourseAssignment` объясняется [позже](#many-to-many-relationships)):

```csharp
public ICollection<CourseAssignment> CourseAssignments { get; set; }
```

## <a name="create-the-department-entity"></a>Создание сущности «отдел»

![Сущность Department](complex-data-model/_static/department-entity.png)


Создание *Models/Department.cs* следующим кодом:

[!code-csharp[Main](intro/samples/cu/Models/Department.cs?name=snippet_Begin)]

### <a name="the-column-attribute"></a>Атрибут столбца

Ранее вы использовали `Column` атрибут, чтобы изменить сопоставление имени столбца. В коде для сущности «отдел» `Column` атрибут используется для изменения SQL сопоставления типов данных, чтобы столбец будет определен с помощью типа money SQL Server в базе данных:

```csharp
[Column(TypeName="money")]
public decimal Budget { get; set; }
```

Сопоставление столбцов обычно не является обязательным, поскольку Entity Framework выбирает соответствующий тип данных SQL Server, на основе типа CLR, определяемый для свойства. Среда CLR `decimal` сопоставляется SQL Server с типом `decimal` типа. Но в этом случае вы знать, что столбец будет удерживать денежные суммы больше подходит для, тип данных money.

### <a name="foreign-key-and-navigation-properties"></a>Свойства внешнего ключа и навигации

Свойства внешнего ключа и навигации отражают следующие связи:

Отдел может или не может быть администратор и администратор всегда инструктор. Поэтому `InstructorID` свойство включается в качестве внешнего ключа к сущности инструктора и знак вопроса добавляется после `int` введите обозначение, — отмечает свойство как допускающие значение NULL. Свойство навигации называется `Administrator` , но содержит сущности инструктора:

```csharp
public int? InstructorID { get; set; }
public Instructor Administrator { get; set; }
```

Отдел может иметь несколько курсов, то есть свойство навигации курсы:

```csharp
public ICollection<Course> Courses { get; set; }
```

> [!NOTE]
> По соглашению платформа Entity Framework позволяет каскадное удаление для внешних ключей, не допускающие значения NULL, а также для связи многие ко многим. Это может привести к циклической cascade delete правила, которые вызывает исключение при попытке добавить миграции. Например если свойство Department.InstructorID не определено как допускающие значение NULL, EF бы настроить правила cascade delete для удаления инструктора при удалении отдел, не нужны нужно иметь. При необходимости бизнес-правила `InstructorID` значение отличное от NULL, необходимо выполнить инструкцию fluent API для отключения каскадное удаление в отношении:
> ```csharp
> modelBuilder.Entity<Department>()
>    .HasOne(d => d.Administrator)
>    .WithMany()
>    .OnDelete(DeleteBehavior.Restrict)
> ```

## <a name="modify-the-enrollment-entity"></a>Изменение сущности регистрации

![Сущности регистрации](complex-data-model/_static/enrollment-entity.png)

В *Models/Enrollment.cs*, замените код, добавленный ранее следующий код:

[!code-csharp[Main](intro/samples/cu/Models/Enrollment.cs?name=snippet_Final&highlight=1-2,16)]

### <a name="foreign-key-and-navigation-properties"></a>Свойства внешнего ключа и навигации

Свойства внешнего ключа, а также свойства навигации отражают следующие связи:

Для одного курса, является запись регистрации, поэтому `CourseID` свойство внешнего ключа и `Course` свойство навигации:

```csharp
public int CourseID { get; set; }
public Course Course { get; set; }
```

Для одного студента, является запись регистрации, поэтому `StudentID` свойство внешнего ключа и `Student` свойство навигации:

```csharp
public int StudentID { get; set; }
public Student Student { get; set; }
```

## <a name="many-to-many-relationships"></a>Многие ко многим

Имеется отношение многие ко многим между сущностями студентов и курс и регистрации сущности функционирует как многие ко многим Соединяемая таблица *с полезными данными* в базе данных. «С полезными данными» означает, что в таблице регистрации содержит дополнительные данные помимо внешние ключи для соединяемых таблиц (в данном случае первичный ключ и свойство уровень).

Ниже показано, как будут выглядеть эти связи в схеме сущности. (Эта схема был создан с помощью средств управления питанием Entity Framework для EF 6.x; Создание схемы не является частью учебника, он просто используется здесь как пример.)

![Курс студента много множественных связей](complex-data-model/_static/student-course.png)

Каждая линия связи имеет 1 на одном конце и звездочку (*) в другом, указывающее один ко многим.

Если в таблице регистрации не были включены сведения об оценках, его потребуется только содержат два внешних ключа CourseID и идентификатором StudentID. В этом случае было бы многие ко многим Соединяемая таблица без полезных данных (или таблицы присоединения) в базе данных. Сущности инструктора и Course имеют этот тип связи "многие ко многим" и следующим шагом является создание класса сущности в качестве соединения таблицы без полезных данных.

(Поддерживает 6.x EF неявное соединение таблиц для связи многие ко многим, но основные EF не поддерживает. Дополнительные сведения см. в разделе [обсуждения в репозитории EF Core GitHub](https://github.com/aspnet/EntityFramework/issues/1368).) 

## <a name="the-courseassignment-entity"></a>Сущность CourseAssignment

![CourseAssignment сущности](complex-data-model/_static/courseassignment-entity.png)

Создание *Models/CourseAssignment.cs* следующим кодом:

[!code-csharp[Main](intro/samples/cu/Models/CourseAssignment.cs)]

### <a name="join-entity-names"></a>Присоединение имена сущностей

Соединяемая таблица является обязательным в базе данных для связи, многие ко многим инструктора-курсов, и он должен быть представлен набор сущностей. Обычно имя сущности объединения `EntityName1EntityName2`, который в этом случае будет `CourseInstructor`. Тем не менее рекомендуется выбрать имя, описывающее связь. Модели создаются простой и увеличиваться с соединениями полезных данных нет, часто получение полезных данных более поздней версии. При запуске с именем описания сущности, не придется изменить имя позже. В идеальном случае сущности объединения бы естественным имени (возможно одно слово) в бизнес-среде. Например книги и клиенты могут быть связаны через оценок. Для этого отношения `CourseAssignment` является более предпочтительной, чем `CourseInstructor`.

### <a name="composite-key"></a>Составной ключ

Поскольку внешние ключи, не допускающие значения NULL и вместе уникально идентифицировать каждую строку таблицы, нет необходимости для отдельных первичного ключа. *InstructorID* и *CourseID* свойства должны работать в качестве составного первичного ключа. Единственный способ идентификации составных первичных ключей в EF, — с помощью *fluent API* (он не может выполняться с помощью атрибутов). Вы увидите, как настроить составного первичного ключа в следующем разделе.

Составной ключ гарантирует, что при наличии нескольких строк для одного курса и несколько строк для одного инструктора не может иметь несколько строк для одного инструктора и курса. `Enrollment` Сущности объединения определяет собственный первичный ключ, возможны повторяющиеся значения такого рода. Для предотвращения таких дубликаты, может добавить уникальный индекс полей внешних ключей, или настроить `Enrollment` с основной составного ключа, аналогично `CourseAssignment`. Дополнительные сведения см. в разделе [индексы](https://docs.microsoft.com/ef/core/modeling/indexes).

## <a name="update-the-database-context"></a>Обновление контекст базы данных

Добавьте следующий выделенный код в *Data/SchoolContext.cs* файла:

[!code-csharp[Main](intro/samples/cu/Data/SchoolContext.cs?name=snippet_BeforeInheritance&highlight=15-18,25-31)]

Этот код добавляет новые сущности и настраивает сущности CourseAssignment составного первичного ключа.

## <a name="fluent-api-alternative-to-attributes"></a>Fluent API вместо атрибутов

Код в `OnModelCreating` метод `DbContext` класс использует *fluent API* можно настроить поведение EF. API-Интерфейс называется «fluent», поскольку часто используемые проводить ряда вызовов метода вместе в одной инструкции, как показано в примере из [EF основная документация](https://docs.microsoft.com/ef/core/modeling/#methods-of-configuration):

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .Property(b => b.Url)
        .IsRequired();
}
```

В этом учебнике вы используете fluent API только для сопоставления с базой данных, нельзя выполнить с помощью атрибутов. Тем не менее можно также использовать fluent API для указания форматирования, проверки и правила сопоставления, которые можно сделать с помощью атрибутов, большинство. Некоторые атрибуты, такие как `MinimumLength` не может применяться с помощью плавного API. Как упоминалось ранее, `MinimumLength` не изменяет схему, применяется правило проверки стороны клиента и сервера.

Некоторые разработчики предпочитают использовать fluent API, они могут обновлять свои классы сущностей «очистить». Могут быть использованы смешанные атрибуты и fluent API, если требуется, и существует ряд настроек, можно только с помощью плавного API, но в целом рекомендуется выбрать один из этих двух подходов и использовать согласованно, насколько возможно. Если вы используете оба, обратите внимание, что везде, где возникает конфликт, переопределяет атрибуты Fluent API.

Дополнительные сведения об атрибутах и fluent API см. в разделе [методы конфигурации](https://docs.microsoft.com/ef/core/modeling/#methods-of-configuration).

## <a name="entity-diagram-showing-relationships"></a>Отображение отношений объектов схемы

Ниже показана схема, создаваемая Entity Framework Power Tools для завершенной модели School.

![Схема Entity](complex-data-model/_static/diagram.png)

Помимо линии связей один ко многим (от 1 до \*), вы видите линию связи один к нулю или одному (1 к нулю или одному) между сущности инструктора и OfficeAssignment и линию связи нуль или один ко многим (от 0 до 1 для *) между Сущности инструктора и отдел.

## <a name="seed-the-database-with-test-data"></a>Начальное значение базы данных с тестовыми данными

Замените код в *Data/DbInitializer.cs* файла следующим кодом для предоставления данных начального значения для новых сущностей, которые вы создали.

[!code-csharp[Main](intro/samples/cu/Data/DbInitializer.cs?name=snippet_Final)]

Как видно в первом руководстве, большая часть кода просто создает новые объекты сущности и загружает данные в свойства, необходимые для тестирования. Обратите внимание на то, как обрабатываются связи многие ко многим: код создает связи путем создания сущностей в `Enrollments` и `CourseAssignment` соединения наборов сущностей.

## <a name="add-a-migration"></a>Добавить миграции

Сохраните изменения и выполните построение проекта. Затем откройте командную строку в папке проекта и введите `migrations add` команду (не выполнять команду update-database еще):

```console
dotnet ef migrations add ComplexDataModel
```

Вы получаете предупреждение о возможной потере данных.

```text
An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.
Done. To undo this action, use 'ef migrations remove'
```

При попытке запуска `database update` команды на этом этапе (не еще), будет получена следующая ошибка:

> Конфликт инструкции ALTER TABLE с ограничением FOREIGN KEY «FK_dbo. Course_dbo. Department_DepartmentID». Конфликт произошел в таблицу в базе данных «ContosoUniversity», «dbo. Отдела», столбец «DepartmentID».

Иногда при выполнении миграции с существующими данными, необходимо вставить данные заглушки в базу данных для удовлетворения ограничения внешнего ключа. Код, созданный в `Up` метод добавляет запретом DepartmentID внешний ключ в таблицу Course. Если уже есть строк в таблицу Course при выполнении кода, `AddColumn` операция завершается неудачей, так как SQL Server не знает, какое значение в столбце, который не может иметь значение null. В этом учебнике вы будете запускать миграции на новую базу данных, но в реальном приложении необходимо сделать обрабатывать существующие данные, поэтому следующие инструкции показан пример того, как для этого переноса.

Чтобы сделать этот вид миграции работать с существующими данными, необходимо изменить код, чтобы предоставить значения по умолчанию для нового столбца и создания заглушки отдел с именем «Temp» в качестве подразделения по умолчанию. В результате существующие строки курса будут все связаны с отделом «Temp» после `Up` метода.

* Откройте *{timestamp}_ComplexDataModel.cs* файл. 

* Закомментировать строку кода, который добавляет столбец DepartmentID в таблицу Course.

  [!code-csharp[Main](intro/samples/cu/Migrations/20170215234014_ComplexDataModel.cs?name=snippet_CommentOut&highlight=9-13)]

* Добавьте следующий выделенный код после кода, создающую таблицу отдел:

  [!code-csharp[Main](intro/samples/cu/Migrations/20170215234014_ComplexDataModel.cs?name=snippet_CreateDefaultValue&highlight=22-32)]

В реальном приложении вы пишете код или сценарии для добавления строк отдела, а также связанные строки курса новым строкам отдела. Затем больше не потребуется отдела «Temp» или значение по умолчанию для столбца Course.DepartmentID.

Сохраните изменения и выполните построение проекта.

## <a name="change-the-connection-string-and-update-the-database"></a>Измените строку подключения и обновления базы данных

Теперь у вас есть новый код `DbInitializer` класс, который добавляет данные начальное значение для новых сущностей для пустой базы данных. Чтобы создать новую пустую базу данных EF, измените имя базы данных в строке подключения в *appsettings.json* ContosoUniversity3 или другое имя, вы не использовали на компьютере, который вы используете.

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=ContosoUniversity3;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
```

Сохраните изменения в *appsettings.json*.

> [!NOTE]
> В качестве альтернативы для изменения имени базы данных можно удалить базы данных. Используйте **обозреватель объектов SQL Server** (SSOX) или `database drop` команду CLI:
> ```console
> dotnet ef database drop
> ```

После изменения имени базы данных или удалить базу данных, запустите `database update` команду в окне команд для выполнения миграции.

```console
dotnet ef database update
```

Запустите приложение, чтобы `DbInitializer.Initialize` метод для запуска и заполнение новой базы данных.

Открыть базу данных в SSOX, как это было ранее, а затем разверните **таблиц** узел, чтобы увидеть, что все таблицы были созданы. (При наличии SSOX открыть в более ранних времени щелкните **обновление** кнопки.)

![Таблицы в SSOX](complex-data-model/_static/ssox-tables.png)

Запустите приложение для запуска инициализаторов код, который заполняет базу данных.

Щелкните правой кнопкой мыши **CourseAssignment** таблицы и выберите **данные представления** для убедитесь в наличии данных в ней.

![Данные CourseAssignment в SSOX](complex-data-model/_static/ssox-ci-data.png)

## <a name="summary"></a>Сводка

Теперь у вас есть более сложные модели данных и соответствующей базой данных. В этом руководстве вы узнаете о более подробную информацию для доступа к взаимосвязанных данных.

>[!div class="step-by-step"]
[Назад](migrations.md)
[Вперед](read-related-data.md)  
