---
title: "Основные ASP.NET MVC с основными EF - CRUD - 2 из 10"
author: tdykstra
description: 
ms.author: tdykstra
manager: wpickett
ms.date: 03/15/2017
ms.topic: get-started-article
ms.technology: aspnet
ms.prod: asp.net-core
uid: data/ef-mvc/crud
ms.openlocfilehash: 873e4592ba668bbcb22f761c2a547a2a27d7e443
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
# <a name="create-read-update-and-delete---ef-core-with-aspnet-core-mvc-tutorial-2-of-10"></a>Создания, чтения, обновления и удаления - Core EF учебнику Core ASP.NET MVC (часть 2 из 10)

По [Tom Dykstra](https://github.com/tdykstra) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Contoso университета примера веб-приложения показано, как создавать веб-приложения ASP.NET MVC ядра с помощью основного Entity Framework и Visual Studio. Сведения о учебника серии см [в первом учебнике ряда](intro.md).

В предыдущем учебнике вы создали приложение MVC, хранит и отображает данные с помощью платформы Entity Framework и SQL Server LocalDB. В этом учебнике предстоит просмотреть и настроить CRUD (Создание, чтение, обновление и удаление) код, который MVC функции формирования шаблонов автоматически создает для вас в контроллеры и представления.

> [!NOTE] 
> Он часто используется для реализации шаблона репозитория, чтобы создать уровень абстракции между контроллер и уровня доступа к данным. Чтобы сохранить эти учебники проста и заключается в учит способы использования платформы Entity Framework сам, они не используйте репозиториев. Сведения о репозитории с EF см. в разделе [последнего учебнике этой серии](advanced.md).

В этом учебнике вы будете работать с на следующих сайтах:

![Страница сведений для учащихся](crud/_static/student-details.png)

![Страница создания студента](crud/_static/student-create.png)

![Страница изменения студента](crud/_static/student-edit.png)

![Страница удаления студента](crud/_static/student-delete.png)

## <a name="customize-the-details-page"></a>Настройка страницы сведений

Опущены формирования шаблонов код страницы индекса учащихся `Enrollments` свойства, так как это свойство содержит коллекцию. В **сведения** страницы, как отображать содержимое коллекции в HTML-таблицу.

В *Controllers/StudentsController.cs*, метод действия для сведений о режиме `SingleOrDefaultAsync` метод для извлечения одной `Student` сущности. Добавьте код, вызывающий `Include`. `ThenInclude`, и `AsNoTracking` методов, как показано в следующий выделенный код.

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_Details&highlight=8-12)]

`Include` И `ThenInclude` методы, которые вызывают контекст загрузки `Student.Enrollments` свойство навигации и в пределах каждой регистрации `Enrollment.Course` свойство навигации.  Дополнительные сведения об этих методах в [чтение связанных данных](read-related-data.md) учебника.

`AsNoTracking` Метод повышает производительность в сценариях, где сущностей, возвращаемых не будут обновлены в течение срока службы в текущем контексте. Дополнительные сведения о `AsNoTracking` в конце этого учебника.

### <a name="route-data"></a>Данные о маршруте

Значение ключа, который передается `Details` метод поступают из *маршрутизации данных*. Данные маршрута — это данные, найти связыватель модели в сегменте URL-адреса. Например маршрут по умолчанию задает контроллера, действия и идентификатор сегментов:

[!code-csharp[Main](intro/samples/cu/Startup.cs?name=snippet_Route&highlight=5)]

В следующий URL-адрес маршрута по умолчанию соответствует инструктора как контроллер, индекс как действие и 1 в качестве идентификатора; Это значения данных маршрута.

```
http://localhost:1230/Instructor/Index/1?courseID=2021
```

Последняя часть URL-адрес ("? courseID = 2021») — это строковый параметр запроса. Связыватель модели также будет передавать значение идентификатора для `Details` метод `id` параметра, если он передается как значение строки запроса:

```
http://localhost:1230/Instructor/Index?id=1&CourseID=2021
```

Страницы индекса URL-адреса гиперссылок создаются вспомогательные инструкциями тег представления Razor. В следующем коде Razor `id` параметр соответствует маршрут по умолчанию, поэтому `id` добавляется в данные маршрута.

```html
<a asp-action="Edit" asp-route-id="@item.ID">Edit</a>
```

Этот код создает следующий код HTML при `item.ID` — 6:

```html
<a href="/Students/Edit/6">Edit</a>
```

В следующем коде Razor `studentID` не совпадает с параметром в маршрут по умолчанию, он добавляется в виде строки запроса.

```html
<a asp-action="Edit" asp-route-studentID="@item.ID">Edit</a>
```

Этот код создает следующий код HTML при `item.ID` — 6:

```html
<a href="/Students/Edit?studentID=6">Edit</a>
```

Дополнительные сведения о вспомогательных функций тегов см. в разделе [вспомогательных функций тегов в ASP.NET Core](xref:mvc/views/tag-helpers/intro).

### <a name="add-enrollments-to-the-details-view"></a>Добавить в представлении сведений о регистрации

Откройте *Views/Students/Details.cshtml*. Каждое поле отображается с помощью `DisplayNameFor` и `DisplayFor` вспомогательные объекты, как показано в следующем примере:

[!code-html[](intro/samples/cu/Views/Students/Details.cshtml?range=13-18&highlight=2,5)]

После последнего поля и непосредственно перед закрывающим тегом `</dl>` , добавьте следующий код, чтобы отобразить список регистраций:

[!code-html[](intro/samples/cu/Views/Students/Details.cshtml?range=31-52)]

Если коду отступ неправильный после вставки кода, нажмите клавиши CTRL-K-D, чтобы исправить его.

Этот код выполняет цикл по сущности в `Enrollments` свойство навигации. Для каждой регистрации отображает название курса и уровень. Название курса извлекается из курса сущность, которая хранится в `Course` свойства навигации сущности регистраций.

Запустите приложение, выберите **учащихся** и нажмите кнопку **сведения** ссылку для учащихся. Просмотреть список курсов и оценок для выбранного учащегося:

![Страница сведений для учащихся](crud/_static/student-details.png)

## <a name="update-the-create-page"></a>Обновление страницы создания

В *StudentsController.cs*, изменить HttpPost `Create` метод блок try-catch добавляя и удаляя идентификатор из `Bind` атрибута.

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_Create&highlight=4,6-7,14-21)]

Этот код добавляет студента сущности, созданной связывателя модели ASP.NET MVC в сущность учащихся набор и затем сохраняет изменения в базе данных. (Связыватель модели ссылается на функциональные возможности ASP.NET MVC, упрощающее работу с данными, отправленных в форму, связыватель модели преобразует значения из отправленной формы с типами среды CLR и передает их в параметры метода действия. В данном случае связывателя модели создается экземпляр сущности студента с использованием значения свойства из коллекции форм.)

Вы удалены `ID` из `Bind` атрибут, так как код имеет значение первичного ключа, который SQL Server будет автоматически устанавливать при вставке строки. Входные данные пользователя не задает значение идентификатора.

Кроме `Bind` блок try-catch-атрибут имеет значение только изменения, внесенные в код формирования шаблонов. Если исключение, которое является производным от `DbUpdateException` будет обработано, пока сохраняются изменения, отображаются сообщения об ошибке. `DbUpdateException`исключения иногда вызываются объекты, внешние приложения, а не наличие программной ошибки, поэтому пользователю предлагается повторите попытку. Несмотря на то, что не реализована в этом образце, производственного качества приложения будет занесения исключения. Дополнительные сведения см. в разделе **подробные сведения в журнале** статьи [мониторинг и данные телеметрии (облака реальных построение приложений с Azure)](https://docs.microsoft.com/aspnet/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry).

`ValidateAntiForgeryToken` Атрибут помогает предотвратить атаки подделки межсайтовых запросов. Токен автоматически вставляется в представлении по [FormTagHelper](xref:mvc/views/working-with-forms#the-form-tag-helper) и включается при отправке формы пользователем. Маркер проверяется с `ValidateAntiForgeryToken` атрибута. Дополнительные сведения о CSRF см. в разделе [запрос защиты от подделки](../../security/anti-request-forgery.md).

<a id="overpost"></a>
### <a name="security-note-about-overposting"></a>Примечание по безопасности о overposting

`Bind` Атрибут, который включает в себя код формирования шаблонов на `Create` метод является одним из способов защиты от overposting в создавать сценарии. Предположим, например, сущность Student включает `Secret` свойство, которое необходимо исключить из этой веб-страницы для задания.

```csharp
public class Student
{
    public int ID { get; set; }
    public string LastName { get; set; }
    public string FirstMidName { get; set; }
    public DateTime EnrollmentDate { get; set; }
    public string Secret { get; set; }
}
```

Даже при отсутствии `Secret` поля на веб-странице, злоумышленник может использовать такое средство, как Fiddler или написать сценарий JavaScript для учета `Secret` формирования значения. Без `Bind` , будет окрашена атрибутов, ограничивая поля, которые использует связыватель модели при создании экземпляра студента, связывателя модели `Secret` форму значение и использовать его для создания экземпляра сущности студента. Выберите любое другое значение злоумышленнику, указанный для `Secret` поля формы будет обновлено в базе данных. На следующем рисунке показано добавление средство Fiddler `Secret` поле (со значением «OverPost») для значения из отправленной формы.

![При добавлении секретный поля Fiddler](crud/_static/fiddler.png)

Значение «OverPost» был бы затем успешно добавлен `Secret` свойство вставленных строк, несмотря на то, что вы никогда не предназначен, что веб-страницы можно задать это свойство.

Можно предотвратить, overposting в сценариях редактирования сначала чтение сущности из базы данных и последующего вызова `TryUpdateModel`, передавая список разрешенных явных свойств. Это метод, используемый в этих учебниках.

Альтернативный способ предотвратить overposting, который является предпочтительным, многие разработчики — использовать Просмотр моделей, а не классы сущностей с использованием привязки модели. Включить только те свойства, необходимые для обновления в модели представления. После завершения процесса связывателя модели MVC, скопируйте свойства модели представления экземпляра сущности, при необходимости с помощью такого средства, как AutoMapper. Используйте `_context.Entry` на экземпляр сущности для задания его состояния `Unchanged`и задайте `Property("PropertyName").IsModified` значение true для каждого свойства объекта, включенного в модель представления. Этот метод работает в обоих изменять и создавать сценарии.

### <a name="test-the-create-page"></a>Страница создания тестов

Код в *Views/Students/Create.cshtml* использует `label`, `input`, и `span` (для проверки сообщений) вспомогательных функций для каждого поля тегов.

Запустите приложение, выберите **учащихся** и нажмите кнопку **создать новый**.

Введите имена и даты. Попробуйте ввести недопустимую дату, если браузер позволяет сделать. (Некоторые браузеры заставляет использовать элемент выбора даты.) Нажмите кнопку **создать** для сообщения об ошибке.

![Ошибка при проверке даты](crud/_static/date-error.png)

Это проверка на стороне сервера, получения по умолчанию; в этом руководстве вы увидите, как добавлять атрибуты, которые также создают код для проверки на стороне клиента. Следующий выделенный код показывает проверки модели в `Create` метод.

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_Create&highlight=8)]

Измените значение на допустимое Дата и нажмите кнопку **создать** для просмотра нового студента, которые отображаются в **индекс** страницы.

## <a name="update-the-edit-page"></a>Обновление страницы правки

В *StudentController.cs*, HttpGet `Edit` метод (один без `HttpPost` атрибут) использует `SingleOrDefaultAsync` метод для извлечения выбранную сущность Student, как видно из `Details` метод. Измените этот метод не требуется.

### <a name="recommended-httppost-edit-code-read-and-update"></a>Рекомендуется изменить HttpPost кода: чтения и обновления

Замените метод действия HttpPost изменить следующий код.

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_ReadFirst)]

Эти изменения реализовать рекомендации безопасности, чтобы предотвратить overposting. Scaffolder создан `Bind` атрибута и добавлены сущности, созданные связыватель модели для сущности с `Modified` флаг. Что кода не рекомендуется для многих сценариев, так как `Bind` атрибут очищает все существующие данные в поля, которые не перечислены в `Include` параметра.

Новый код считывает существующую сущность и вызовы `TryUpdateModel` обновить поля в полученную сущность [на основе ввода пользователя в отправленной формы данных](xref:mvc/models/model-binding#how-model-binding-works). Платформа Entity Framework автоматическое отслеживание наборов изменений `Modified` флаг для поля, которые были изменены с помощью входных данных формы. Когда `SaveChanges` вызывается метод, Entity Framework создает инструкции SQL для обновления строки базы данных. Конфликты параллелизма учитываются, а только столбцов таблицы, которые были обновлены пользователем обновляются в базе данных. (Этом руководстве показано, как обрабатывать конфликты параллелизма.)

Рекомендуется для предотвращения оверпостинга, поля, которые должны быть обновляемым, **изменить** страницы, входят в `TryUpdateModel` параметров. (Является пустой строкой, предшествующий список полей в списке параметров префикс для имен полей формы.) В настоящее время нет дополнительных полей, вы защищаете, но список полей, которые должны связыватель модели для привязки гарантирует, что при добавлении поля в модели данных в будущем, автоматически защищены ли они пока не будут добавлены явно здесь.

В результате этих изменений в сигнатуре метода HttpPost `Edit` метод совпадает со значением HttpGet `Edit` метода; таким образом вы переименовали метод `EditPost`.

### <a name="alternative-httppost-edit-code-create-and-attach"></a>Альтернативный образец программного кода редактирования HttpPost: Создание и присоединение

Рекомендуется изменить код HttpPost гарантирует, что только измененные столбцы обновляются и сохраняет данные в свойствах, которые необходимо исключить включены для привязки модели. Однако чтения первый подход требует дополнительных баз данных чтения и может привести к более сложный код для обработки конфликтов параллелизма. Альтернативой является присоединить сущность, созданные связывателя модели к контексту EF и пометьте его как измененный. (Не обновить проект, этот код, он показаны только для иллюстрации необязательно подход.) 

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_CreateAndAttach)]

Этот подход можно использовать при веб-страницы пользовательского интерфейса включает все поля в сущности и можно обновить любой из них.

Используется подход, создать и присоединить формирования шаблонов кода, но только перехватывает `DbUpdateConcurrencyException` исключения и возвращает 404 коды ошибок.  В примере показано перехватывает все исключения обновления базы данных и отображает сообщение об ошибке.

### <a name="entity-states"></a>Состояния сущностей

Отслеживает отслеживания объекта контекст базы данных, будут ли сущностей в памяти, в соответствии с их соответствующих строк в базе данных, и эта информация определяет, что происходит при вызове `SaveChanges` метода. Например, при передаче новую сущность, `Add` метод, который присваивается состояние сущности `Added`. Затем при вызове `SaveChanges` метода, контекст базы данных отдает команду SQL INSERT.

Сущность может иметь одно из следующих состояний:

* `Added`. Сущность еще не существует в базе данных. `SaveChanges` Метод выдает инструкции INSERT.

* `Unchanged`. Не нужно ничего сделать с помощью этой сущности, `SaveChanges` метод. При чтении из базы данных сущности, сущность начинается с этим состоянием.

* `Modified`. Были изменены некоторые или все значения свойств сущности. `SaveChanges` Метод выдает инструкции UPDATE.

* `Deleted`. Сущность была помечена для удаления. `SaveChanges` Метод выполняет инструкцию DELETE.

* `Detached`. Сущность не отслеживается контекст базы данных.

В приложении для настольных систем изменения состояния обычно устанавливаются автоматически. Чтение сущности и изменить некоторые значения свойств. В результате состояние сущности автоматически меняется на `Modified`. Затем при вызове `SaveChanges`, Entity Framework создает инструкцию SQL UPDATE, обновляет только фактические свойства, которые были изменены.

В веб-приложении `DbContext` , изначально считывает сущности и отображает данные для редактирования удаляется после отрисовки страницы. Когда HttpPost `Edit` вызывается метод действия, новый веб-запроса, и у вас есть новый экземпляр `DbContext`. Если перечитать сущности в этот новый контекст моделируются обработки рабочего стола.

Но если вы не хотите выполнять дополнительные операции чтения, необходимо использовать объект сущности, созданные связывателя модели.  Для этого проще всего присвоено состояние сущности изменено, поскольку выполняется в альтернативных приведенный выше код HttpPost редактирования. Затем при вызове `SaveChanges`, Entity Framework, обновляет все столбцы строки базы данных, так как контекст никак не может знать, какие свойства были изменены.

Если вы хотите избежать чтения первый подход, но также требуется, чтобы инструкция SQL UPDATE для обновления только поля, которые пользователь действительно были изменены, код является более сложным. Необходимо сохранить первоначальные значения иным образом (например, с помощью скрытые поля), чтобы они были доступны при HttpPost `Edit` вызывается метод. Затем вы можете создать сущность Student, с помощью исходных значений, вызов `Attach` с этой версией исходной сущности, обновления значений сущности с новыми значениями и затем вызвать `SaveChanges`.

### <a name="test-the-edit-page"></a>Тестовая страница редактирования

Запустите приложение, выберите **учащихся** , затем щелкните **изменить** гиперссылки.

![Страница изменения студентов](crud/_static/student-edit.png)

Изменить некоторые данные, и нажмите кнопку **Сохранить**. **Индекс** открывает страницу и увидеть измененные данные.

## <a name="update-the-delete-page"></a>Обновление страницы удаления

В *StudentController.cs*, код шаблона для HttpGet `Delete` использует метод `SingleOrDefaultAsync` метод для извлечения выбранную сущность Student, как видно в представлениях данных и изменить методы. Тем не менее, для реализации пользовательской ошибки сообщение при вызове `SaveChanges` завершается ошибкой, мы добавим некоторые функциональные возможности этого метода и его соответствующее представление.

Как показано для обновления и создания операций, операций удаления может потребоваться два метода действия. Метод, который вызывается в ответ на запрос GET отображает представление, которое дает пользователю возможность утверждения или отменить операцию удаления. Если пользователь утверждает его, создается запрос POST. Когда это происходит, HttpPost `Delete` вызывается метод, а затем этот метод фактически выполняет операцию удаления.

Вы добавите блок try-catch HttpPost `Delete` метод для обработки всех ошибок, которые могут возникнуть при обновлении базы данных. При возникновении ошибки метод HttpPost Delete вызывает метод HttpGet Delete, передав параметр, указывающий, что произошла ошибка. Метод HttpGet Delete, затем повторно отображает страница подтверждения, а также сообщение об ошибке, предоставляя пользователю возможность отменить или повторить.

Замените HttpGet `Delete` метод действия с следующий код, который управляет отчеты об ошибках.

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_DeleteGet&highlight=1,9,16-21)]

Этот код принимает необязательный параметр, который указывает, является ли метод был вызван после сбоя, чтобы сохранить изменения. Этот параметр имеет значение false при HttpGet `Delete` метод вызывается без предыдущего сбоя. При вызове HttpPost `Delete` метода в ответ на ошибку обновления базы данных параметр имеет значение true, и сообщение об ошибке передается в представление.

### <a name="the-read-first-approach-to-httppost-delete"></a>Подход с использованием первого чтения для удаления HttpPost

Замените HttpPost `Delete` метода действия (с именем `DeleteConfirmed`) следующим кодом, который выполняет операцию удаления фактическое и перехватывает все ошибки обновления базы данных.

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_DeleteWithReadFirst&highlight=6,8-11,13-14,18-23)]

Этот код извлекает выбранной сущности, а затем вызывает `Remove` метод, чтобы задать состояния сущности `Deleted`. При `SaveChanges` вызове SQL DELETE команда создается.

### <a name="the-create-and-attach-approach-to-httppost-delete"></a>Создание и присоединение способ удаления HttpPost

Если приоритетом является повышение производительности в приложении большого объема, поможет избежать ненужных SQL-запроса путем создания экземпляра студента сущности, используя только первичного ключа значение и затем присвоить состояние сущности `Deleted`. Это все, что платформа Entity Framework требуется, чтобы удалить сущность. (Этот код не следует размещать в проекте; именно здесь исключительно для демонстрации альтернативы).

[!code-csharp[Main](intro/samples/cu/Controllers/StudentsController.cs?name=snippet_DeleteWithoutReadFirst&highlight=7-8)]

Если сущность имеет связанные данные, которые также будут удалены, убедитесь, что каскадное удаление настроен в базе данных. В этом случае для удаления сущности EF могут не узнать, что имеются связанные сущности для удаления.

### <a name="update-the-delete-view"></a>Обновление представления удаления

В *Views/Student/Delete.cshtml*, добавить сообщение об ошибке между заголовком h2 и заголовок h3, как показано в следующем примере:

[!code-html[](intro/samples/cu/Views/Students/Delete.cshtml?range=7-9&highlight=2)]

Запустите приложение, выберите **учащихся** и нажмите кнопку **удалить** гиперссылки:

![Удалить страницу подтверждения](crud/_static/student-delete.png)

Нажмите кнопку **удалить**. Без удаленных студента отображается страница индекса. (Вы увидите пример код обработки ошибок в действие в учебнике параллелизмом.)

## <a name="closing-database-connections"></a>Закрытие подключения к базе данных

Чтобы освободить ресурсы, занятые подключения к базе данных, экземпляр контекста должен быть удален как можно быстрее после завершения с ним. Встроенная ASP.NET Core [внедрения зависимостей](../../fundamentals/dependency-injection.md) берет на себя эту задачу для вас.

В *файла Startup.cs*, можно вызвать [метод расширения AddDbContext](https://github.com/aspnet/EntityFrameworkCore/blob/03bcb5122e3f577a84498545fcf130ba79a3d987/src/Microsoft.EntityFrameworkCore/EntityFrameworkServiceCollectionExtensions.cs) для подготовки `DbContext` класс в контейнере ASP.NET DI. Что метод задает время существования службы `Scoped` по умолчанию. `Scoped`означает время существования объекта контекста совпадает с временем жизни запроса web, и `Dispose` метод автоматически вызывается в конце веб-запроса.

## <a name="handling-transactions"></a>Обработка транзакций

По умолчанию платформа Entity Framework неявно реализует транзакции. В сценариях, где можно внести изменения в несколько строк или таблиц, а затем вызвать `SaveChanges`, Entity Framework автоматически гарантирует, что все изменения, внесенные завершится успехом или на всех остальных. Если сначала выполняются некоторые изменения, а затем происходит ошибка, эти изменения автоматически происходит возврат. См. в сценариях, где требуется дополнительный контроль — например, если вы хотите включить действия, выполненные за пределами платформы Entity Framework транзакции-- [транзакции](https://docs.microsoft.com/ef/core/saving/transactions).

## <a name="no-tracking-queries"></a>Нет отслеживания запросов

Если контекст базы данных получает строки таблицы и создает объекты сущности, представляющие их, по умолчанию он хранит информацию о ли сущностей в памяти синхронизированы с папкой базы данных. Данные в памяти действует как кэш и используется, если вы обновили сущность. Это кэширование необязательно, часто в веб-приложение, так как контекста экземпляров обычно кратковременных (новый один создается и удаляется для каждого запроса), а в контексте, осуществляющий чтение сущности обычно удаляется, прежде чем снова используется этой сущности.

Отслеживание объектов сущностей в памяти можно отключить путем вызова `AsNoTracking` метод. Ниже приведены типичные сценарии, в которых может потребоваться сделать:

* Во время существования контекста не нужно обновлять все сущности, и не нужны EF для [автоматически загружать свойства навигации с сущностями, полученные путем отдельных запросов](read-related-data.md). Часто эти условия будут выполнены в методы действий контроллера HttpGet.

* Выполняется запрос, получающий большого объема данных, а лишь малую часть возвращаемых данных будет обновляться. Может быть более эффективным, чтобы отключить отслеживания для большого запроса и выполнить запрос позже для некоторых объектов, которые должны быть обновлены.

* Необходимо присоединить сущности, чтобы обновить его, но ранее получить той же сущности для другой цели. Поскольку сущность уже отслеживается контекстом базы данных, не удается присоединить сущности, который требуется изменить. Один из способов обработки этой ситуации является вызов `AsNoTracking` в предыдущем запросе.

Дополнительные сведения см. в разделе [отслеживания vs. Нет отслеживания](https://docs.microsoft.com/ef/core/querying/tracking).

## <a name="summary"></a>Сводка

Теперь у вас есть полный набор страниц, которые выполняют простые операции CRUD для сущностей студента. В следующем уроке будет расширяют функциональные возможности **индекс** страницы путем добавления сортировку, фильтрацию и разбиение по страницам.

>[!div class="step-by-step"]
[Назад](intro.md)
[Вперед](sort-filter-page.md)  
