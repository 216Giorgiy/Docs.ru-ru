---
title: "Основные ASP.NET MVC с основными EF - параллелизма - 8, 10"
author: tdykstra
description: "Этот учебник показывает, как для обработки конфликтов, когда нескольким пользователям обновлять ту же сущность в то же время."
ms.author: tdykstra
manager: wpickett
ms.date: 03/15/2017
ms.topic: get-started-article
ms.technology: aspnet
ms.prod: asp.net-core
uid: data/ef-mvc/concurrency
ms.openlocfilehash: eee84fe0fbec6ed772342d09931986994903906a
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
# <a name="handling-concurrency-conflicts---ef-core-with-aspnet-core-mvc-tutorial-8-of-10"></a>Обработка конфликтов параллелизма - Core EF учебнику ASP.NET Core MVC (8, 10)

По [Tom Dykstra](https://github.com/tdykstra) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Contoso университета примера веб-приложения показано, как создавать веб-приложения ASP.NET MVC ядра с помощью основного Entity Framework и Visual Studio. Сведения о учебника серии см [в первом учебнике ряда](intro.md).

В предыдущих учебниках вы узнали, как обновлять данные. Этот учебник показывает, как для обработки конфликтов, когда нескольким пользователям обновлять ту же сущность в то же время.

Вы создадите веб-страниц, которые работают с сущности «отдел» и обработки ошибок параллелизма. На следующих рисунках страницы Edit и Delete, включая некоторые сообщения, которые отображаются, если возникает конфликт параллелизма.

![Страница отдела изменения](concurrency/_static/edit-error.png)

![Страница отдела Delete](concurrency/_static/delete-error.png)

## <a name="concurrency-conflicts"></a>Конфликты параллелизма

Конфликт параллелизма возникает, когда один пользователь отображены данные сущности для его изменения, а затем другой пользователь обновляет данные той же сущности перед изменение первый пользователь будет записано в базу данных. Если не включить обнаружение такие конфликты, кто обновляет базу данных, перезаписывает изменения другого пользователя. Во многих приложениях приемлемо этот риск: при наличии нескольких пользователей или несколько обновлений, или если не действительно являются критическими, если некоторые изменения будут перезаписаны, стоимость программирования для параллелизма может перевесить преимущества. В этом случае не нужно настроить приложение для обработки конфликтов параллелизма.

### <a name="pessimistic-concurrency-locking"></a>Пессимистическая блокировка (блокировки)

Если приложению требуется предотвратить случайную потерю данных в сценарии параллелизма, один из способов сделать это — использовать блокировки базы данных. Это называется пессимистичного параллелизма. Например, перед прочтением строки из базы данных запрашивается блокировка для только для чтения или для доступ для обновления. При блокировке строку для обновления доступ другие пользователи не разрешены для блокировки строки, либо для только для чтения или обновления доступа, так как он может получить копию данных, которая находится в процессе изменения. При блокировке строк для доступа только для чтения, другие также можно блокировать его для доступа только для чтения, но не для обновления.

Управление блокировками имеет недостатки. Он может оказаться непростой задачей программы. Она требует значительные ресурсы базы данных управления, и он может вызвать снижение производительности как число пользователей приложения увеличивается. По этим причинам не всех систем управления базами данных поддерживают пессимистичного параллелизма. Entity Framework Core предоставляет нет встроенная поддержка и учебнике не показано, как для его реализации.

### <a name="optimistic-concurrency"></a>Оптимистическая блокировка

Альтернативой пессимистичный параллелизм является оптимистичного параллелизма. Оптимистический параллелизм означает разрешение конфликтов параллелизма активна и затем отклик соответствующим образом, если они есть. Например Мария — страница отдела изменять и изменяет сумму бюджета для английского языка отдела с $350,000.00 на 0,00 долларов.

![Изменение бюджета 0](concurrency/_static/change-budget.png)

Перед щелкает Мария **Сохранить**, Джон посещает той же странице и изменяет поле Дата начала 9/1/2007 9/1/2013.

![Изменение даты начала 2013](concurrency/_static/change-date.png)

Мария щелкает **Сохранить** первый и видит ее изменить, если браузер возвращается на страницу индекса.

![Бюджет изменено на ноль](concurrency/_static/budget-zero.png)

Затем Джон щелкает **Сохранить** на страницу редактирования, которая по-прежнему показывает бюджет 350,000.00 $. Дальнейший ход событий определяется порядок обработки конфликтов параллелизма.

Ниже приведены некоторые из параметров:

* Можно хранить список какие свойства были изменены пользователем и обновлять соответствующие столбцы в базе данных.

     В примере сценария данные не будут потеряны, поскольку различные свойства были обновлены двумя пользователями. При очередном кто-то просматривает английский отдела, они смогут увидеть измененные Джейн и Джона--дату начала для 9/1/2013 и бюджет ноль долларов. Этот метод обновления может снизить количество конфликтов, которые могут привести к потере данных, но его не удается избежать потери данных, если конкурирующих изменений в то же свойство сущности. Работает ли платформа Entity Framework следующим образом зависит от того, как реализовать код обновления. Нецелесообразно часто веб-приложения, так как он может потребоваться поддерживать большое количество состояний, чтобы отслеживать все исходные значения свойств для сущности, а также новые значения. Обслуживание больших объемов состояния может повлиять на производительность приложения, так как он требует ресурсы сервера или должны быть включены на странице веб-(например, в скрытых полях) или в файле cookie.

* Можно разрешить изменение Джона перезаписать Джейн изменений.

     Следующий раз кто-то просматривает отделе английского языка, они увидят 9/1/2013 и восстановленное значение $350,000.00. Это называется *клиент побеждает* или *побеждает последний* сценария. (Все значения из клиента имеют приоритет над возможности хранилища данных). Как отмечено во введении к этому разделу, если этого не сделать, написания кода для обработки параллелизма, она выполняется автоматически.

* Можно запретить изменение Джона обновляется в базе данных.

     Как правило следует отобразить сообщение об ошибке, отображения его текущего состояния данных и позволяют ему для повторного применения изменений, если он по-прежнему хочет сделать их. Это называется *побеждает хранилища* сценария. (Значения хранилища данных имеют приоритет над значениями, отправленные клиентом). В этом учебнике необходимо реализовать сценарий Wins хранилища. Этот метод гарантирует, что изменения не переписываются без пользователя предупреждения о происходящем.

### <a name="detecting-concurrency-conflicts"></a>Обнаружение конфликтов параллелизма

Конфликты можно разрешать путем обработки `DbConcurrencyException` исключения, которые выдает Entity Framework. Чтобы определить, когда необходимо создавать эти исключения, Entity Framework необходима возможность обнаружения конфликтов. Таким образом необходимо настроить базу данных и модели данных соответствующим образом. Ниже приведены некоторые параметры для включения обнаружения конфликтов:

* В таблице базы данных включают столбец отслеживания, который может использоваться для определения момента изменения строки. Затем можно настроить Entity Framework, чтобы включить этот столбец в предложении Where инструкции SQL Update или Delete команд.

     Тип данных столбца отслеживания обычно является `rowversion`. `rowversion` Значение — это число, увеличивающееся каждый раз при обновлении строки. В команде Update или Delete предложение Where, предложение содержит исходное значение столбца отслеживания (версии). Если были изменены другим пользователем, значение в обновляемой строке `rowversion` столбца отличается от исходное значение, поэтому инструкции Update или Delete не удается найти строки обновления из-за Where предложения. Когда команды Entity Framework обнаруживает, что строки не были обновлены, Update или Delete (то есть, когда количество задействованных строк равно нулю), он интерпретирует как конфликт параллелизма.

* Настройка Entity Framework для включения исходных значений для каждого из столбцов в таблице в предложении Where инструкции команды Update и Delete.

     Как и первый вариант, если что-либо в строке изменилась с момента прочтите строки где предложение не возвращает строки для обновления, который Entity Framework интерпретирует как конфликт параллелизма. Для таблиц базы данных, имеющие много столбцов, этот подход может привести к очень больших Where предложений и может потребоваться поддерживать большие объемы состояния. Как отмечалось ранее, обслуживание больших объемов состояния может повлиять на производительность приложения. Поэтому этот подход не рекомендуется и не метод, используемый в этом учебнике.

     Если необходимо реализовать этот подход к параллелизма, необходимо пометить все свойства первичного ключа в сущность, которую необходимо отслеживать параллелизм для добавляя `ConcurrencyCheck` к ним атрибут. Это изменение позволяет платформе Entity Framework выбрать все столбцы в предложении SQL Where инструкции Update и Delete.

В оставшейся части этого учебника вам предстоит добавить `rowversion` отслеживание свойства сущности «отдел», создать контроллер и представления и проверить, что все работает правильно.

## <a name="add-a-tracking-property-to-the-department-entity"></a>Добавление свойства отслеживания в сущности «отдел»

В *Models/Department.cs*, добавьте RowVersion следящее свойство:

[!code-csharp[Main](intro/samples/cu/Models/Department.cs?name=snippet_Final&highlight=26,27)]

`Timestamp` Атрибут указывает, что этот столбец будет включен в предложении Where инструкции команды Update и Delete, отправляемые в базу данных. Атрибут называется `Timestamp` из-за предыдущих версий SQL Server используется SQL `timestamp` типа данных перед SQL `rowversion` заменил его. Тип .NET для `rowversion` — массив байтов.

Если вы предпочитаете использовать fluent API, можно использовать `IsConcurrencyToken` метода (в *Data/SchoolContext.cs*) для указания свойства отслеживания, как показано в следующем примере:

```csharp
modelBuilder.Entity<Department>()
    .Property(p => p.RowVersion).IsConcurrencyToken();
```

При добавлении свойства изменить модель базы данных, необходимо выполнить еще один процесс миграции.

Сохранить изменения, постройте проект и введите следующие команды в командную строку:

```console
dotnet ef migrations add RowVersion
```

```console
dotnet ef database update
```

## <a name="create-a-departments-controller-and-views"></a>Создание подразделения контроллеров и представления

Формировать контроллер отделов и представления, как это было ранее для учащихся, курсы и инструкторов.

![Отдел формирования шаблонов](concurrency/_static/add-departments-controller.png)

В *DepartmentsController.cs* файл, изменить все четыре вхождения «FirstMidName» на «Полное имя», чтобы раскрывающиеся списки администратор отдела будет содержать полное имя инструктора, а не просто фамилию.

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_Dropdown)]

## <a name="update-the-departments-index-view"></a>Обновить представление индекса отделов

Механизм формирования шаблонов в представлении индекса создается столбец RowVersion, но это поле не должно отображаться.

Замените код в *Views/Departments/Index.cshtml* следующим кодом.

[!code-html[Main](intro/samples/cu/Views/Departments/Index.cshtml?highlight=4,7,44)]

Это изменяет заголовок «Отделы» удаляет столбец RowVersion и показано полное имя, а не имя администратора.

## <a name="update-the-edit-methods-in-the-departments-controller"></a>Методы изменения в контроллере отделов обновления

В обоих HttpGet `Edit` метод и `Details` метод, добавьте `AsNoTracking`. В HttpGet `Edit` метод, добавьте упреждающую администратора.

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_EagerLoading&highlight=2,3)]

Замените существующий код для HttpPost `Edit` метод следующим кодом:

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_EditPost)]

Код начинает работу с чтения отдел обновляться. Если `SingleOrDefaultAsync` метод возвращает значение null, отдел был удален другим пользователем. В этом случае код использует значения из отправленной формы для создания сущности отдела, чтобы страницы правки можно повторно с сообщением об ошибке. В качестве альтернативы не нужно повторно создать сущности «отдел», если отображается сообщение об ошибке без повторное отображение поля отдел.

Представление сохраняет исходное `RowVersion` значения в скрытом поле и этот метод получает это значение в `rowVersion` параметра. Перед вызовом метода `SaveChanges`, необходимо установить, исходное `RowVersion` значение свойства в `OriginalValues` коллекции для сущности.

```csharp
_context.Entry(departmentToUpdate).Property("RowVersion").OriginalValue = rowVersion;
```

Затем платформа Entity Framework создает команду SQL UPDATE, эта команда включает предложения WHERE, которое ищет строку, которая содержит исходный `RowVersion` значение. Если нет строк, затронутых командой обновления (не строки имеют исходное `RowVersion` значение), Entity Framework создает исключение `DbUpdateConcurrencyException` исключение.

Код в блоке catch для этого исключения возвращает затронутые сущность Department, обновленные значения из `Entries` свойства объекта исключения.

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?range=164)]

`Entries` Коллекция будет содержать только один `EntityEntry` объекта.  Этот объект можно использовать для получения новых значений, введенных пользователем и текущие значения базы данных.

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?range=165-166)]

Код добавляет сообщения о пользовательской ошибке для каждого столбца, имеющего различные значения базы данных, из какой введенные пользователем на редактирование страницы (только одно поле, приведен здесь для краткости).

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?range=174-178)]

Наконец, код задает `RowVersion` значение `departmentToUpdate` новое значение, извлеченные из базы данных. Этот новый `RowVersion` значение будет храниться в скрытое поле, когда изменение, снова откроется страница и следующий раз пользователь щелкает **Сохранить**, только ошибки параллелизма, которые происходят с момента будет порождено повторно отобразить страницы правки.

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?range=199-200)]

`ModelState.Remove` Инструкция является обязательным, поскольку `ModelState` имеет старый `RowVersion` значение. В представлении `ModelState` значение для поля имеет приоритет над значения свойств модели, если установлены оба.

## <a name="update-the-department-edit-view"></a>Обновить представление изменить подразделение

В *Views/Departments/Edit.cshtml*, внесите следующие изменения:

* Добавление скрытого поля для сохранения `RowVersion` значение свойства, следующий сразу за скрытого поля для `DepartmentID` свойства.

* Добавьте пункт «Выберите Administrator» в раскрывающемся списке.

[!code-html[Main](intro/samples/cu/Views/Departments/Edit.cshtml?highlight=16,34-36)]

## <a name="test-concurrency-conflicts-in-the-edit-page"></a>Тестирование конфликтов параллелизма в страницы правки

Запустите приложение и перейти на страницу индекса отделов. Щелкните правой кнопкой мыши **изменить** гиперссылку для английского языка подразделение и выберите **открыть в новой вкладке**, нажмите кнопку **изменить** гиперссылки для английского языка отдела. Вкладки два браузера теперь отображаются те же сведения.

Измените поле на первой вкладке браузера и нажмите кнопку **Сохранить**.

![Изменение подразделения страница 1 после изменения](concurrency/_static/edit-after-change-1.png)

В браузере будет отображена страница индекса с измененное значение.

Изменение поля на второй вкладке браузера.

![Изменение подразделения страница 2 после изменения](concurrency/_static/edit-after-change-2.png)

Нажмите кнопку **Сохранить**. Вы видите сообщение об ошибке:

![Сообщение об ошибке отдел изменить страницу](concurrency/_static/edit-error.png)

Нажмите кнопку **Сохранить** еще раз. Сохраняется значение, введенное на второй вкладке браузера. Появиться сохраненные значения при появлении страницы индекса.

## <a name="update-the-delete-page"></a>Обновление страницы удаления

На странице Delete Entity Framework обнаруживает конфликты параллелизма, причиной else редактирования отделе так же, как. Когда HttpGet `Delete` метод отображает представление подтверждения, представление включает в себя исходный `RowVersion` значения в скрытом поле. Что значения затем становится доступным для HttpPost `Delete` метод, который вызывается, когда пользователь подтверждения удаления. Когда платформа Entity Framework создает команду SQL DELETE, он включает предложение WHERE с первоначальным `RowVersion` значение. Если результаты команды в ноль строк влияет (то есть строка была изменена после отображается страница подтверждения удаления), исключение параллелизма и HttpGet `Delete` метод вызывается с установленным флагом ошибка значение true, чтобы снова отобразить страница подтверждения с сообщением об ошибке. Это также возможно, что нулевые затронуты, так как строка была удалена другим пользователем, поэтому в этом случае сообщение об ошибке не отображается.

### <a name="update-the-delete-methods-in-the-departments-controller"></a>Методы удаления в контроллере отделов обновления

В *DepartmentsController.cs*, замените HttpGet `Delete` метод следующим кодом:

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_DeleteGet&highlight=1,10,14-17,21-29)]

Этот метод принимает необязательный параметр, который указывает, выполняется ли страница отобразится после ошибки параллелизма. Если этот флаг имеет значение true и отдел, больше не существует, он был удален другим пользователем. В этом случае код выполняет перенаправление на страницу индекса.  Если этот флаг имеет значение true, а отдел существует, он был изменен другим пользователем. В этом случае код отправляет сообщение об ошибке представление, используя `ViewData`.  

Замените код в HttpPost `Delete` метод (с именем `DeleteConfirmed`) следующим кодом:

[!code-csharp[Main](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_DeletePost&highlight=1,3,5-8,11-18)]

В создании кода, который Вы заменили этот метод принято только идентификатор записи:


```csharp
public async Task<IActionResult> DeleteConfirmed(int id)
```

Этот параметр был изменен для отдела экземпляр сущности, созданные связывателя модели. Это дает EF доступ к значению свойства RowVersion помимо ключа записи.

```csharp
public async Task<IActionResult> Delete(Department department)
```

Изменились имя метода действия из `DeleteConfirmed` для `Delete`. Код формирования шаблонов используется имя `DeleteConfirmed` для предоставления метода HttpPost уникальная сигнатура. (Среда CLR требуется перегруженные методы, чтобы иметь параметры другой метод). Теперь, когда сигнатуры уникальны, можно не покидайте соглашение MVC и использовать то же имя для удаления методов HttpPost и HttpGet.

Если подразделение уже удален, `AnyAsync` метод возвращает значение false, и приложение просто возвратится к методу Index.

При одновременном доступе, код заново отобразит страницу подтверждения удаления и предоставляет флаг, указывающий, он должен отображать сообщение об ошибке с параллелизмом.

### <a name="update-the-delete-view"></a>Обновление представления удаления

В *Views/Departments/Delete.cshtml*, замените формирования шаблонов код следующим кодом, который добавляет поля ошибки сообщения и скрытые поля свойств DepartmentID и RowVersion. Изменения выделены.

[!code-html[Main](intro/samples/cu/Views/Departments/Delete.cshtml?highlight=9,38,44,45,48)]

Это вносит следующие изменения:

* Добавляет сообщение об ошибке между `h2` и `h3` заголовков.

* Заменяет FirstMidName FullName в **администратора** поля.

* Удаляет поле RowVersion.

* Добавляет скрытое поле для `RowVersion` свойства.

Запустите приложение и перейти на страницу индекса отделов. Щелкните правой кнопкой мыши **удалить** гиперссылку для английского языка подразделение и выберите **открыть в новой вкладке**, выберите в первой позицией табуляции **изменить** гиперссылки для английского языка отдела.

В первом окне, измените одно из значений и нажмите кнопку **Сохранить**:

![Страница отдела редактирования после изменения, прежде чем удалить](concurrency/_static/edit-after-change-for-delete.png)

На второй вкладке щелкните **удалить**. Вы видите сообщение об ошибке с параллелизмом, а отдел значения обновляются с возможности в базе данных.

![Страница подтверждения удаления отдел с ошибкой параллелизма](concurrency/_static/delete-error.png)

Если щелкнуть **удалить** еще раз, будет перенаправлен на страницу индекса, которая показывает, отдел был удален.

## <a name="update-details-and-create-views"></a>Дополнительные сведения об обновлении и создавать представления

Можно при необходимости очистить формирования шаблонов кода, в области сведений и создания представлений.

Замените код в *Views/Departments/Details.cshtml* удалить столбец RowVersion и Показывать полное имя администратора.

[!code-html[Main](intro/samples/cu/Views/Departments/Details.cshtml?highlight=35)]

Замените код в *Views/Departments/Create.cshtml* Добавление выберите параметр в раскрывающемся списке.

[!code-html[Main](intro/samples/cu/Views/Departments/Create.cshtml?highlight=32-34)]

## <a name="summary"></a>Сводка

На этом завершается Общие сведения для обработки конфликтов параллелизма. Дополнительные сведения о способах обработки параллелизма в ядре EF в разделе [конфликтов параллелизма](https://docs.microsoft.com/ef/core/saving/concurrency). Далее учебнике демонстрируется реализация таблица на иерархию наследования для сущности инструктора и студентов.

>[!div class="step-by-step"]
[Назад](update-related-data.md)
[Вперед](inheritance.md)  
