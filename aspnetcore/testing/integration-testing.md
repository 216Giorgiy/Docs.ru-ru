---
title: "Интеграция тестирования в ASP.NET Core"
author: ardalis
description: "Инструкции по использованию интеграции ASP.NET Core, тестирование, чтобы гарантировать правильную работу компонентов приложения."
ms.author: riande
manager: wpickett
ms.date: 09/25/2017
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: testing/integration-testing
ms.openlocfilehash: 201d16498415498ec1e6a40278f1fb2460546711
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
# <a name="integration-testing-in-aspnet-core"></a>Интеграция тестирования в ASP.NET Core

По [Стив Смит](https://ardalis.com/)

Интеграционного тестирования гарантирует, что компоненты приложения работают корректно, когда собраны вместе. ASP.NET Core предоставляет возможности интеграции тестирования с помощью платформы модульного тестирования и встроенных тестов веб-узел, который может использоваться для обработки запросов без нагрузки на сеть.

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/testing/integration-testing/sample) ([как скачивать](xref:tutorials/index#how-to-download-a-sample))

## <a name="introduction-to-integration-testing"></a>Общие сведения о интеграционного тестирования

Интеграционные тесты проверки различных частях приложения исправной работы друг с другом. В отличие от [модульное тестирование](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test), тесты интеграции часто включают проблемы инфраструктуры приложения, такие как базы данных, файловая система, сетевые ресурсы, или веб-запросов и ответов. Модульные тесты использовать fakes или макетов объектов вместо этих проблем, но интеграционные тесты предназначен для убедитесь, что система работает должным образом с этими системами.

Интеграционные тесты, поскольку они охватывают больше сегменты кода, и они используют элементы инфраструктуры, как правило порядков медленнее, чем модульные тесты. Таким образом рекомендуется ограничить количество тестов интеграции, можно написать, особенно в том случае, если то же самое можно протестировать с модульным тестом.

> [!NOTE]
> Если некоторое поведение можно проверить при помощи модульного теста или интеграционного теста, предпочтительно модульный тест, так как он будет почти всегда будет выполняться быстрее. Может потребоваться десятки и сотни модульных тестов с помощью многих различных входных данных, но лишь небольшое число тестов интеграции, охватывающие наиболее важных сценариев.

Тестирование логики в свои собственные методы обычно совпадает с доменом модульных тестов. Тестирование, как приложение работает в его структуре, например с помощью ASP.NET Core или с базой данных где тесты интеграции начинают действовать. Он не требует слишком много интеграции тестов, чтобы убедиться, что вы можете записать строку в базе данных и их чтения. Не требуется для проверки каждого возможные перестановки вашего кода доступа к данным — необходимо протестировать достаточно, чтобы дает уверенность в том, когда приложение работает правильно.

## <a name="integration-testing-aspnet-core"></a>Интеграция тестирования ASP.NET Core

Настройке до выполнения интеграционных тестов, необходимо будет создать тестовый проект, добавить ссылку на веб-проекта ASP.NET Core и установить средства выполнения тестов. Этот процесс описан в [модульное тестирование](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) документации, а также более подробные сведения о выполнении тестов и рекомендации по именованию тестов и тестовых классов.

> [!NOTE]
> Отдельные модульные тесты и тесты интеграции с помощью разных проектах. Это гарантирует, что не случайно вводят проблем инфраструктуры, связанных в модульные тесты и позволяет легко выбирать конкретный набор тестов для запуска.

### <a name="the-test-host"></a>Узел тестирования

ASP.NET Core включает тест узла, который можно добавить к интеграции тестовые проекты и используется для узла ASP.NET Core приложений, тестирования обслуживанием запросов без необходимости на реальных веб-узел. Предоставленный образец включает проект интеграционного теста, который был настроен для использования [xUnit](https://xunit.github.io) и проверки узла. Она использует `Microsoft.AspNetCore.TestHost` пакет NuGet.

Один раз `Microsoft.AspNetCore.TestHost` пакет включен в проект, вы сможете создать и настроить `TestServer` в тестах. Следующий тест показано, как проверить, что запрос к корню сайта возвращает «Hello World!» и должны выполняться успешно по умолчанию шаблон пустой веб-узел ASP.NET Core, созданные с помощью Visual Studio.

[!code-csharp[Main](../testing/integration-testing/sample/test/PrimeWeb.IntegrationTests/PrimeWebDefaultRequestShould.cs?name=snippet_WebDefault&highlight=7,16,22)]

Этот тест использует шаблон упорядочить Act Assert. На этапе компоновки выполняется в конструктор, который создает экземпляр `TestServer`. Настроенный `WebHostBuilder` будет использоваться для создания `TestHost`; в этом примере `Configure` метода из тестируемой системы (SUT) `Startup` передается класс `WebHostBuilder`. Этот метод будет использоваться для настройки конвейера запросов из `TestServer` идентично как будет настроена SUT сервера.

В Act части теста сделан запрос на `TestServer` экземпляр путь «/» и ответ считывается обратно в строку. Эта строка сравнивается с ожидаемую строку «Hello World!». Если они совпадают, тест выполняется; в противном случае происходит сбой.

Теперь можно добавить несколько дополнительных интеграции тестов, чтобы убедиться, что простые, функции проверки работает через веб-приложения:

[!code-csharp[Main](../testing/integration-testing/sample/test/PrimeWeb.IntegrationTests/PrimeWebCheckPrimeShould.cs?name=snippet_CheckPrime)]

Обратите внимание, который вы пытаетесь не совсем проверить правильность проверки простых чисел с помощью этих тестов, но вместо веб-приложение выполняется как ожидалось. Уже имеется покрытия модульного теста, который дает уверенность в `PrimeService`, как видно из:

![Обозреватель тестов](integration-testing/_static/test-explorer.png)

Дополнительные сведения о модульных тестах в [модульное тестирование](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) статьи.


### <a name="integration-testing-mvcrazor"></a>Тестирование Mvc-Razor интеграции

Тестовые проекты, содержащие представления Razor требуют `<PreserveCompilationContext>` присвоено значение true в *.csproj* файла:


```xml
    <PreserveCompilationContext>true</PreserveCompilationContext>
```

Проекты, этот элемент отсутствует, приведет к ошибке следующего вида:
```
Microsoft.AspNetCore.Mvc.Razor.Compilation.CompilationFailedException: 'One or more compilation failures occurred:
ooebhccx.1bd(4,62): error CS0012: The type 'Attribute' is defined in an assembly that is not referenced. You must add a reference to assembly 'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.
```


## <a name="refactoring-to-use-middleware"></a>Рефакторинг для использования по промежуточного слоя

Рефакторинг — это процесс изменения кода приложения для повышения его разработки без изменения его поведения. Это следует делать в идеале при наличии набора передачи тесты, так как эти справки убедитесь, что поведение системы остается неизменным до и после изменения. Просмотрев способом, в котором простых, логика проверки реализуется в веб-приложении `Configure` метода, вы видите:

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.Run(async (context) =>
    {
        if (context.Request.Path.Value.Contains("checkprime"))
        {
            int numberToCheck;
            try
            {
                numberToCheck = int.Parse(context.Request.QueryString.Value.Replace("?", ""));
                var primeService = new PrimeService();
                if (primeService.IsPrime(numberToCheck))
                {
                    await context.Response.WriteAsync($"{numberToCheck} is prime!");
                }
                else
                {
                    await context.Response.WriteAsync($"{numberToCheck} is NOT prime!");
                }
            }
            catch
            {
                await context.Response.WriteAsync("Pass in a number to check in the form /checkprime?5");
            }
        }
        else
        {
            await context.Response.WriteAsync("Hello World!");
        }
    });
}
```

Этот код работает, но это далеко от способ реализации в приложении ASP.NET Core даже простые, так как этот функциональность этого типа. Предположим, что `Configure` метод выглядит следующим образом, при необходимости добавлять в него такой большой объем кода, каждый раз при добавлении другой URL-адрес конечной точки.

Добавление попробуйте [MVC](xref:mvc/overview) в приложение и создание контроллера для обработки простых проверки. Тем не менее при условии, что в настоящее время не требуются другие MVC функциональные возможности, который немного overkill.

Тем не менее, можно воспользоваться преимуществами ASP.NET Core [по промежуточного слоя](xref:fundamentals/middleware), которое поможет нам инкапсуляции простых, логика в отдельный класс проверки и добиться лучшего [Разделение областей ответственности](http://deviq.com/separation-of-concerns/) в `Configure` метод.

Вы хотите разрешить путь по промежуточного слоя использует, чтобы указать в качестве параметра, поэтому класс по промежуточного слоя ожидает `RequestDelegate` и `PrimeCheckerOptions` экземпляра в своем конструкторе. Если путь запроса не соответствует — это по промежуточного слоя настроен следует ожидать, просто вызвать следующее по промежуточного слоя в цепочке и в дальнейшем ничего. Остальная часть код реализации, которая была `Configure` теперь `Invoke` метод.

> [!NOTE]
> Так как зависит от по промежуточного слоя `PrimeService` службы запрашивается экземпляра данной службы с помощью конструктора. Платформа будет предоставлять эту службу через [внедрения зависимостей](xref:fundamentals/dependency-injection), при условии, что он был настроен, например в `ConfigureServices`.

[!code-csharp[Main](../testing/integration-testing/sample/src/PrimeWeb/Middleware/PrimeCheckerMiddleware.cs?highlight=39-63)]

Так как это по промежуточного слоя выступает в качестве конечной точки в цепи делегатов запроса при соответствует пути, не используется без вызова `_next.Invoke` при этом по промежуточного слоя обрабатывает запрос.

С помощью этого по промежуточного слоя и некоторые полезные методы расширения для упрощения его настройки, созданные рефакторингу `Configure` метод выглядит следующим образом:

[!code-csharp[Main](../testing/integration-testing/sample/src/PrimeWeb/Startup.cs?highlight=9&range=19-33)]

После этого рефакторинга, вы уверены, как и раньше, работает веб-приложение, поскольку тесты интеграции всех завершается успешно.

> [!NOTE]
> Рекомендуется для фиксации изменений в систему управления версиями после завершения рефакторинг и тесты успешно выполнены. Если занятии краткое руководство. Разработка, [рассмотрите возможность добавления фиксации ли цикл красный-зеленый — рефакторинг](https://ardalis.com/rgrc-is-the-new-red-green-refactor-for-test-first-development).

## <a name="resources"></a>Ресурсы

* [Модульное тестирование](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test)
* [ПО промежуточного слоя](xref:fundamentals/middleware)
* [Контроллеры тестирования](xref:mvc/controllers/testing)
