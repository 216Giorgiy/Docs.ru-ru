---
title: "Общие сведения о представлениях"
author: ardalis
description: 
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 668c320d-c050-45e3-8161-2f460dc93b2f
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/views/overview
ms.openlocfilehash: 7abfa7ef855eb95e1a27ba6a699dd923c9e4d7c0
ms.sourcegitcommit: 6ece943781d8a56784bb6160f14da85210d3fcea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/11/2017
---
# <a name="rendering-html-with-views-in-aspnet-core-mvc"></a>Визуализации HTML с представлениями в ASP.NET Core MVC

По [Стив Смит](http://ardalis.com)

Контроллеры ASP.NET Core MVC может возвращать форматированные результатов с помощью *представления*.

## <a name="what-are-views"></a>Что такое представления

В шаблон Model-View-Controller (MVC) *представление* инкапсулирует данные представления взаимодействие пользователя с приложением. Представления — это шаблоны HTML с внедренным кодом, формирующих содержимое, отправляемое клиенту. Представлениях используется [синтаксисом Razor](razor.md), что позволяет коду взаимодействовать с HTML с помощью минимального программного кода или процедуры.

Представления ASP.NET Core MVC являются *.cshtml* файлы, хранящиеся в по умолчанию *представления* папки в приложении. Как правило каждый контроллер будет содержать собственной папке, в которой являются для конкретного контроллера действия.

![Папка Views в обозревателе решений](overview/_static/views_solution_explorer.png)

Помимо представления специфические для действия [разделяемые представления](partial.md), [макеты и другие файлы специальное представление](layout.md) позволяет сократить повторения и разрешить для повторного использования в пределах представления приложения.

## <a name="benefits-of-using-views"></a>Преимущества использования представлений

Представления предоставляют [Разделение областей ответственности](http://deviq.com/separation-of-concerns/) в приложении MVC, инкапсулируя разметки уровня пользовательского интерфейса отдельно от бизнес-логики. ASP.NET MVC представлениях используется [синтаксисом Razor](razor.md) на переключение между HTML разметку и серверные стороны логику мышки. Общие и повторяющиеся аспектов пользовательского интерфейса приложения можно легко использовать повторно между режимами с помощью [макет и директивы общего](layout.md) или [разделяемые представления](partial.md).

## <a name="creating-a-view"></a>Создание представления

Представления, относящиеся к контроллеру создаются в *представления / [Имя_контроллера]* папки. Представления, которые являются общими для контроллеров, помещаются в */представления/Общие* папки. Назовите файл представление таким же, как его соответствующему контроллеру действие и добавить *.cshtml* расширение имени файла. Например, чтобы создать представление для *о* действие на *Главная* контроллера, необходимо создать *About.cshtml* файла в  * /представления/домашние*папки.

Образец файла представления (*About.cshtml*):

[!code-html[Main](../../common/samples/WebApplication1/Views/Home/About.cshtml)]

*Razor* обозначается код `@` символов. Операторы C#, выполняются в Razor, отключить блоки кода в фигурные скобки (`{` `}`), такие как назначение «О программе» для `ViewData["Title"]` элемент, показанный выше. Razor можно использовать для отображения значений в HTML, просто ссылаясь на значение с `@` symbol, как показано в `<h2>` и `<h3>` элементов, описанных выше.

В этом представлении основное внимание уделяется только часть выходных данных, для которого оно отвечает. Остальная часть макет страницы и другие общие аспекты представления, указываются в другом месте. Дополнительные сведения о [макет и логики общего представления](layout.md).

## <a name="how-do-controllers-specify-views"></a>Как сделать контроллеров определение представлений?

Представления обычно возвращаются из действия, как `ViewResult`. Можно создавать и возвращать метод действия `ViewResult` непосредственно, но чаще Если контроллер наследует от `Controller`, просто используем `View` вспомогательный метод, как в этом примере показано:

*HomeController.cs*

[!code-csharp[Main](../../common/samples/WebApplication1/Controllers/HomeController.cs?highlight=5&range=16-21)]

`View` Вспомогательный метод имеет несколько перегрузок, чтобы упростить возвращение представления для разработчиков приложений. При необходимости можно указать представлению для возврата, а также объект модели для передачи в представление.

По возвращении из этого действия *About.cshtml* визуализации представления, показанный выше:

![О странице](overview/_static/about-page.png)

### <a name="view-discovery"></a>Представления обнаружения

Если действие возвращает представление, называется *представление обнаружения* имеет место. Этот процесс определяет, какой файл представления будет использоваться. Если не указан файл определенных представлений, среда выполнения ищет представления для контроллера во-первых, затем выполняется поиск соответствующего имени представления в *Shared* папки.

Если действие возвращает `View` метод, вот так `return View();`, имя действия используется в качестве имени представления. Например если это были вызывается из метода действия с именем «Индекс», было бы эквивалентно передав имя представления «Индекс». Имя представления можно явно передать в метод (`return View("SomeView");`). В обоих случаях представление обнаружения выполняет поиск в файл сопоставления представления:

   1. Представления или\<Имя_контроллера > /\<ViewName > .cshtml

   2. Представления/Общие/\<ViewName > .cshtml

>[!TIP]
> Рекомендуется следовать соглашению простого возврата `View()` из действий, если это возможно, поскольку приводит более гибкий и проще рефакторинга кода.

Путь к файлу представления могут быть предоставлены вместо имени представления. Если с помощью абсолютный путь, начиная с корневого каталога приложения (при необходимости, начиная с «/» или «~ /»), *.cshtml* расширение должно быть указано как часть пути к файлу (например, `return View("Views/Home/About.cshtml");`). Кроме того, можно использовать относительный путь от каталога конкретного контроллера в *представления* каталога для указания представления в разных каталогах (например, `return View("../Manage/Index");` внутри `HomeController`). Аналогичным образом, вы сможете просматривать текущий каталог конкретного контроллера (например, `return View("./About");`). Обратите внимание, что относительные пути не использовать *.cshtml* расширения. Как упоминалось ранее следуйте рекомендациям по организации структуры файлов для представления для отображения связей между контроллерами, действий и представления для удобства и простоты.

> [!NOTE]
> [Разделяемые представления](partial.md) и [просматривать компоненты](view-components.md) использовать механизмы обнаружения, аналогично (но не идентичен).

> [!NOTE]
> Вы можете настроить соглашение по умолчанию в отношении представления находятся в приложении с помощью пользовательского `IViewLocationExpander`.

>[!TIP]
> Имена представлений может учитываться регистр в зависимости от используемой файловой системы. Для совместимости с разными операционными системами всегда учитывать регистр между контроллером и имена действий и связанного представления папки и имен файлов.

## <a name="passing-data-to-views"></a>Передача данных с представлениями

Можно передавать данные представления, используя несколько механизмов. Наиболее надежный подход — указать *модель* типа в представлении (часто называют *viewmodel*, чтобы отличить его от бизнес-типов модели домена), а затем передать экземпляр этого типа в представлении из действия. Мы рекомендуем использовать модель или модель представлений для передачи данных в представлении. Это позволяет воспользоваться преимуществами проверки строгого типа представления. Можно указать модель для представления с помощью `@model` директиву:

<!-- literal_block {"ids": [], "linenos": false, "xml:space": "preserve", "language": "html", "highlight_args": {"hl_lines": [1]}} -->

```html
@model WebApplication1.ViewModels.Address
   <h2>Contact</h2>
   <address>
       @Model.Street<br />
       @Model.City, @Model.State @Model.PostalCode<br />
       <abbr title="Phone">P:</abbr>
       425.555.0100
   </address>
   ```

После модели был определен для представления, переданы в представление экземпляра может осуществляться в режиме строгой типизации с помощью `@Model` как показано выше. Чтобы предоставить экземпляр типа модели к представлению, контроллер передает его в качестве параметра:

<!-- literal_block {"ids": [], "linenos": false, "xml:space": "preserve", "language": "csharp", "highlight_args": {"hl_lines": [13]}} -->

```csharp
public IActionResult Contact()
   {
       ViewData["Message"] = "Your contact page.";

       var viewModel = new Address()
       {
           Name = "Microsoft",
           Street = "One Microsoft Way",
           City = "Redmond",
           State = "WA",
           PostalCode = "98052-6399"
       };
       return View(viewModel);
   }
   ```

Существуют ограничения на типы, которые могут быть предоставлены для представления в виде модели. Корпорация Майкрософт рекомендует передачи простых старых объектов POCO (CLR) Просмотр моделей с минимумом или совсем без поведение, чтобы бизнес-логику можно инкапсулировать в другом месте в приложении. Примером такого подхода является *адрес* viewmodel, используемый в предыдущем примере:

<!-- literal_block {"ids": [], "linenos": false, "xml:space": "preserve", "language": "csharp", "highlight_args": {"hl_lines": [13]}} -->

```csharp
namespace WebApplication1.ViewModels
   {
       public class Address
       {
           public string Name { get; set; }
           public string Street { get; set; }
           public string City { get; set; }
           public string State { get; set; }
           public string PostalCode { get; set; }
       }
   }
   ```

> [!NOTE]
> Ничто не мешает использовать те же классы в качестве модели вашей бизнес-типов и типов модели экрана. Тем не менее, их позволяет вашим представлениям отличаться независимо от модели домена или сохраняемость, а можно предлагать некоторые преимущества безопасности (для моделей, которые пользователи будут отправлять в приложения с помощью [привязки модели](../models/model-binding.md)).

### <a name="loosely-typed-data"></a>Слабо типизированных данных

Помимо строго типизированные представления все представления имеют доступ к слабо типизированный набор данных. Этот же коллекции можно указать ссылкой через либо `ViewData` или `ViewBag` свойства для контроллеров и представлений. `ViewBag` Свойство является оболочкой вокруг `ViewData` , предоставляет динамического представления этой коллекции. Не является отдельной коллекции.

`ViewData`объект словаря осуществляется с помощью `string` ключей. Можно сохранять и извлекать объекты в ней, и необходимо привести их к определенному типу после их извлечения. Можно использовать `ViewData` для передачи данных от контроллера к представлениям, а также представления (разделяемые представления и макеты). Строковые данные могут храниться и использоваться непосредственно, без необходимости для приведения к типу.

Некоторые значения для `ViewData` в действии:

```csharp
public IActionResult SomeAction()
   {
       ViewData["Greeting"] = "Hello";
       ViewData["Address"]  = new Address()
       {
           Name = "Steve",
           Street = "123 Main St",
           City = "Hudson",
           State = "OH",
           PostalCode = "44236"
       };

       return View();
   }
   ```

Работать с данными в представлении:

<!-- literal_block {"ids": [], "linenos": false, "xml:space": "preserve", "language": "html", "highlight_args": {"hl_lines": [3, 6]}} -->

```html
@{
       // Requires cast
       var address = ViewData["Address"] as Address;
   }

   @ViewData["Greeting"] World!

   <address>
       @address.Name<br />
       @address.Street<br />
       @address.City, @address.State @address.PostalCode
   </address>
   ```

`ViewBag` Объектов предоставляет динамический доступ для объектов, хранящихся в `ViewData`. Это может быть удобнее работать с, поскольку он не требует приведения. Тот же пример, как и выше, с помощью `ViewBag` вместо со строгой типизацией `address` экземпляра в представлении:

<!-- literal_block {"ids": [], "linenos": false, "xml:space": "preserve", "language": "html", "highlight_args": {"hl_lines": [1, 4, 5, 6]}} -->

```html
@ViewBag.Greeting World!

   <address>
       @ViewBag.Address.Name<br />
       @ViewBag.Address.Street<br />
       @ViewBag.Address.City, @ViewBag.Address.State @ViewBag.Address.PostalCode
   </address>
   ```

> [!NOTE]
> Поскольку оба будут ссылаться на тот же базовый `ViewData` коллекции, можно комбинировать и совпадают `ViewData` и `ViewBag` при чтении и записи значения, если удобно.

### <a name="dynamic-views"></a>Динамические представления

Представления, которые не объявлять тип модели, но отсутствует экземпляр модели, передаваемых в них может ссылаться динамически данного экземпляра. Например, если экземпляр `Address` передается в представление, которое не объявляет `@model`, по-прежнему будет может ссылаться на свойства этого экземпляра, динамически, как показано представление:

<!-- literal_block {"ids": [], "linenos": false, "xml:space": "preserve", "language": "html", "highlight_args": {"hl_lines": [13, 16, 17, 18]}} -->

```html
<address>
       @Model.Street<br />
       @Model.City, @Model.State @Model.PostalCode<br />
       <abbr title="Phone">P:</abbr>
       425.555.0100
   </address>
   ```

Этот компонент можно предлагать некоторую гибкость, но не предоставляет все защиты компиляции или IntelliSense. Если свойство не существует, страница не пройдет во время выполнения.

## <a name="more-view-features"></a>Дополнительные возможности представления

[Вспомогательных функций тегов](tag-helpers/intro.md) облегчить добавление поведения на стороне сервера в существующий HTML-тегов, устраняя необходимость использовать пользовательский код или вспомогательные методы в представлениях. Вспомогательных функций тегов применяются как атрибуты для HTML-элементов, которые будут пропускаться редакторов, которые не знакомы с ними, позволяя просмотреть разметку на редактирование и подготовке к просмотру в различных средств. Имеют множество применений вспомогательных функций тегов и в частности, можно сделать [работа с формами](working-with-forms.md) гораздо проще.

Создания настраиваемой HTML-разметки, может осуществляться в соответствии с многие встроенные вспомогательные методы HTML и более сложная логика пользовательского интерфейса (возможно, с собственными требованиями данных) можно инкапсулировать в [Просмотр компонентов](view-components.md). Просмотр компонентов обеспечить же разделение областей ответственности, предлагающий контроллеры и представления и позволяет избавиться от необходимости для действий и представления для обработки данных, используемых в общих элементов пользовательского интерфейса.

Как и многие другие аспекты ASP.NET Core представления поддерживают [внедрения зависимостей](../../fundamentals/dependency-injection.md), позволяя службам для [внедрены в представлениях](dependency-injection.md).
