---
title: "Представления в ASP.NET Core MVC"
author: ardalis
description: "Узнайте, как обрабатывать представления презентации данных приложения и взаимодействия с пользователем в ASP.NET Core MVC."
keywords: "ASP.NET Core просмотра MVC, razor, viewmodel, viewdata, viewbag"
ms.author: riande
manager: wpickett
ms.date: 09/26/2017
ms.topic: article
ms.assetid: 668c320d-c050-45e3-8161-2f460dc93b2f
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/views/overview
ms.openlocfilehash: 4530d2f500dd887bf649a753283fb3e4af995322
ms.sourcegitcommit: c2f6c593d81fbd90e6ddd672fe0a5636d06b615a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/14/2017
---
# <a name="views-in-aspnet-core-mvc"></a>Представления в ASP.NET Core MVC

По [Стив Смит](https://ardalis.com/) и [Latham Люк](https://github.com/guardrex)

В **M**одели -**V**росмотр -**C**шаблон ontroller (MVC) *представление* обрабатывает приложения данных представления и взаимодействия с пользователями. Представление является шаблон HTML с внедренными [разметки Razor](xref:mvc/views/razor). Разметка Razor, является код, который взаимодействует с HTML-разметку для создания веб-страницы, который отправляется клиенту.

В ASP.NET Core MVC, представления, *.cshtml* файлы, использующие [языка программирования C#](/dotnet/csharp/) в разметке Razor. Как правило, просматривать файлы группируются в папки для каждого приложения [контроллеров](xref:mvc/controllers/actions). Папки, хранятся в *представления* папку в корне приложения:

![Папка представления в обозревателе Visual Studio решение открыта с открытым для отображения файлов About.cshtml, Contact.cshtml и Index.cshtml корневая папка](overview/_static/views_solution_explorer.png)

*Главная* представленного контроллера *Главная* папки *представления* папки. *Главная* папка содержит представления для *о*, *контакт*, и *индекс* веб-страниц (Домашняя страница). Когда пользователи запрашивают эти три веб-страниц, действия контроллера в *Главная* контроллера определяют, какой из трех представлений используется для построения и возврата веб-страницы для пользователя.

Используйте [макеты](xref:mvc/views/layout) разделы согласованное веб-страницы и снизить повторяющийся код. Макеты часто содержат заголовок, элементы навигации и меню и нижний колонтитул. Колонтитулы обычно содержат стандартный разметки для многих элементов метаданных и ссылки на ресурсы сценариев и стилей. Макеты помогают избежать этот стандартный текст разметки в представления.

[Разделяемые представления](xref:mvc/views/partial) снижения дублирования кода за счет управления допускающих многократное использование частей представления. Например частичное представление может использоваться для Биография автора на веб-сайте блога, который отображается в нескольких представлениях. Биография автора обычного представления содержимого, не требующий код, выполняемый для получения содержимого веб-страницы. Содержимое Биография автора доступна в представление с помощью модели привязки сама по себе, поэтому лучше всего использовать частичное представление для этого типа содержимого.

[Просмотр компонентов](xref:mvc/views/view-components) : аналогично частичного представления, в том, что они позволяют уменьшить повторяющихся частей кода, но они не подходят для Просмотр содержимого, которое требуется код, выполняемый на сервере для визуализации веб-страницы. Просмотр компонентов полезны в тех случаях, когда отображаемого содержимого требует взаимодействия с базы данных, таких как веб-сайта Корзина для покупок. Просмотр компонентов не ограничиваясь привязки модели для создания веб-страницы.

## <a name="benefits-of-using-views"></a>Преимущества использования представлений

Представления позволяют установить [ **S**eparation **o**f **C**oncerns (SoC) разработки](http://deviq.com/separation-of-concerns/) в приложении MVC, разделяя разметки интерфейса пользователя из другие части приложения. После разработки SoC делает приложение модульной, который предоставляет несколько преимуществ:

* Это проще, так как она лучше организована приложение. Представления обычно группируются по функции приложения. Это облегчает поиск связанные представления, при работе с компонентом.
* Слабо части приложения. Можно создать и обновить представления приложения отдельно от бизнес-логику и данные компоненты доступа. Представления приложения можно изменить, не имея обновления других частей приложения.
* Тестирование части интерфейса пользователя приложения, поскольку представления представляют собой отдельные блоки проще.
* Из-за повышения управляемости скорее всего, будут выполнены случайно повторения разделов пользовательского интерфейса.

## <a name="creating-a-view"></a>Создание представления

Представления, относящиеся к контроллеру создаются в *представления / [Имя_контроллера]* папки. Представления, которые являются общими для контроллеров, помещаются в *представления/Общие* папки. Чтобы создать представление, добавьте новый файл и присвойте ему имя, совпадающее с именем его соответствующему контроллеру действие с *.cshtml* расширение имени файла. Чтобы создать представление, которое соответствует *о* действия в *Главная* контроллер, создание *About.cshtml* файла в *представления/домашние*папки:

[!code-cshtml[Main](../../common/samples/WebApplication1/Views/Home/About.cshtml)]

*Razor* разметки начинается с `@` символов. Код выполнения операторы C#, поместив C# в [блоки кода Razor](xref:mvc/views/razor#razor-code-blocks) отключить в фигурные скобки (`{ ... }`). Например, см. раздел Назначение «О программе» `ViewData["Title"]` показано выше. Можно отобразить значения в HTML, просто ссылаясь на значение с `@` символов. Просмотреть содержимое `<h2>` и `<h3>` элементов, описанных выше.

Просмотр контента, показанный выше — только часть всей веб-страницы, который отображается для пользователя. Остальная часть макет страницы и другие общие аспекты представления указываются в других файлах представление. Дополнительные сведения см. в разделе [макета раздела](xref:mvc/views/layout).

## <a name="how-controllers-specify-views"></a>Как указать представления, контроллеры

Представления обычно возвращаются из действия, как [ViewResult](/aspnet/core/api/microsoft.aspnetcore.mvc.viewresult), который является типом [ActionResult](/aspnet/core/api/microsoft.aspnetcore.mvc.actionresult). Методе действия, можно создать и возвращать `ViewResult` напрямую, но, обычно не делается. Поскольку наследуют большинство контроллеров [контроллера](/aspnet/core/api/microsoft.aspnetcore.mvc.controller), можно просто использовать `View` вспомогательный метод для возврата `ViewResult`:

*HomeController.cs*

[!code-csharp[Main](../../common/samples/WebApplication1/Controllers/HomeController.cs?highlight=5&range=16-21)]

По возвращении из этого действия *About.cshtml* , показанном в предыдущем разделе подготавливается к просмотру как следующей веб-странице:

![О страницы к просмотру в браузере Edge](overview/_static/about-page.png)

`View` Вспомогательный метод имеет несколько перегрузок. При необходимости можно указать:

* Явные представлению для возврата:

  ```csharp
  return View("Orders");
  ```
* Объект [модели](xref:mvc/models/model-binding) для передачи представления:

  ```csharp
  return View(Orders);
  ```
* Представления и модель.

  ```csharp
  return View("Orders", Orders);
  ```

### <a name="view-discovery"></a>Представления обнаружения

Если действие возвращает представление, называется *представление обнаружения* имеет место. Этот процесс определяет, какой файл представления используется на основе имени представления. 

Поведение по умолчанию `View` метод (`return View();`) возвращает представление с тем же именем, что и метод действия, из которого он вызывается. Например *о* `ActionResult` имя метода контроллера используется для поиска с именем файла представления *About.cshtml*. Во-первых, среда выполнения ищет в *представления / [Имя_контроллера]* папки для представления. Если он не находит соответствующее представление, он выполняет *Shared* папки для представления.

Не важно, если возвращается неявно `ViewResult` с `return View();` или явным образом передать имя представления для `View` метод с `return View("<ViewName>");`. В обоих случаях представление обнаружения выполняет поиск соответствующего файла представления в следующем порядке:

   1. *Представления или\[Имя_контроллера]\[ViewName] .cshtml*
   1. *Представления/Общие/\[ViewName] .cshtml*

Путь к файлу представления могут быть предоставлены вместо имени представления. Если с помощью абсолютный путь, начиная с корневого каталога приложения (при необходимости, начиная с «/» или «~ /»), *.cshtml* должно быть указано расширение:

```csharp
return View("Views/Home/About.cshtml");
```

Можно также использовать относительный путь для указания представления в разных каталогах без *.cshtml* расширения. Внутри `HomeController`, можно вернуть *индекс* представление вашей *управление* представления по относительному пути:

```csharp
return View("../Manage/Index");
```

Аналогичным образом, можно указать текущий каталог конкретного контроллера с «. /» префикс:

```csharp
return View("./About");
```

[Разделяемые представления](xref:mvc/views/partial) и [просматривать компоненты](xref:mvc/views/view-components) использовать механизмы обнаружения, аналогично (но не идентичен).

Вы можете настроить соглашение по умолчанию для способ представления находятся в приложении с помощью пользовательского [IViewLocationExpander](/aspnet/core/api/microsoft.aspnetcore.mvc.razor.iviewlocationexpander).

Представление обнаружения использует поиск просмотреть файлы по имени файла. Если базовая файловая система с учетом регистра, имена представлений, скорее всего, регистр учитывается. Для совместимости с разными операционными системами учитывать регистр между контроллером и имена действий и имена файлов и папок связанного представления. Если возникнет сообщение об ошибке, который не удается найти файл представления при работе с учетом регистра файловой системы, убедитесь, что регистр соответствует между запрошенное представление файла и имя файла представления.

Следуйте рекомендациям по организации структуры файлов для представлений, чтобы отразить отношения между контроллерами, действий и представления для удобства и простоты.

## <a name="passing-data-to-views"></a>Передача данных с представлениями

Можно передавать данные представления, используя несколько подходов. Наиболее надежный подход — указать [модель](xref:mvc/models/model-binding) типа в представлении. Эта модель часто называется *viewmodel*. Экземпляр типа viewmodel передачи в представление из действия.

Использование viewmodel для передачи данных в представление позволяет воспользоваться преимуществами представлению *строгого* проверку типов. *Строгая типизация* (или *строго типизированных*) означает, что каждая переменная и константа имеет явно определенного типа (например, `string`, `int`, или `DateTime`). Во время компиляции проверяется правильность типов, используемых в представлении.

[Visual Studio](https://www.visualstudio.com/vs/) и [кода Visual Studio](https://code.visualstudio.com/) список членов строго типизированный класс, используя функцию [IntelliSense](/visualstudio/ide/using-intellisense). Если вы хотите просмотреть свойства viewmodel, введите имя переменной для viewmodel, за которым следует (`.`). Это помогает быстрее писать код с меньшим количеством ошибок.

Укажите модель с помощью `@model` директивы. Использование модели с `@Model`:

```cshtml
@model WebApplication1.ViewModels.Address

<h2>Contact</h2>
<address>
    @Model.Street<br>
    @Model.City, @Model.State @Model.PostalCode<br>
    <abbr title="Phone">P:</abbr> 425.555.0100
</address>
```

Для предоставления модели представления, контроллер передает его в качестве параметра:

```csharp
public IActionResult Contact()
{
    ViewData["Message"] = "Your contact page.";

    var viewModel = new Address()
    {
        Name = "Microsoft",
        Street = "One Microsoft Way",
        City = "Redmond",
        State = "WA",
        PostalCode = "98052-6399"
    };

    return View(viewModel);
}
```

Существуют ограничения на типы модели, которые могут использоваться для представления. Мы рекомендуем использовать **P**чный **O**ld **C**LR **O**viewmodels объекта (POCO) с незначительной или нулевой (методы) задано поведение. Как правило, классы viewmodel хранятся либо в *моделей* папки или отдельного *ViewModels* папку в корне приложения. *Адрес* viewmodel, используемый в приведенном выше примере является viewmodel POCO, хранятся в файле с именем *Address.cs*:

```csharp
namespace WebApplication1.ViewModels
{
    public class Address
    {
        public string Name { get; set; }
        public string Street { get; set; }
        public string City { get; set; }
        public string State { get; set; }
        public string PostalCode { get; set; }
    }
}
```

> [!NOTE]
> Ничего не запрещает использовать те же классы для типов viewmodel и ваш бизнес-типов модели. Тем не менее использование отдельных моделей позволяет представлений, чтобы отличаться независимо от бизнес-логику и данные доступа частей приложения. Разделение моделей и viewmodels также имеет преимущества безопасности, если модели используют [привязки модели](xref:mvc/models/model-binding) и [проверки](xref:mvc/models/validation) для данных, передаваемых в приложение со стороны пользователя.


<a name="VD_VB"></a>

### <a name="weakly-typed-data-viewdata-and-viewbag"></a>Слабо типизированных данных (ViewData и ViewBag)

Примечание: `ViewBag` доступен не на страницах Razor.

Помимо строго типизированного представления представления имеют доступ к *слабо типизированной* (также называемый *слабо типизированной*) сбор данных. В отличие от строгие типы *слабое типы* (или *свободные типы*) означает, что не явно объявить тип данных, которые вы используете. Коллекция слабо типизированных данных можно использовать для передачи небольших объемов данных и из него контроллеры и представления.

| Передача данных между...                        | Пример                                                                        |
| ------------------------------------------------- | ------------------------------------------------------------------------------ |
| Контроллером и представлением                             | Заполнение раскрывающегося списка с данными.                                          |
| Просмотр и [режим разметки](xref:mvc/views/layout)   | Установка  **\<title >** содержимое элемента в режиме разметки из файла представления.  |
| [Частичное представление](xref:mvc/views/partial) и представления | Мини-приложение, отображающий данные, основанные на веб-страницы по запросу пользователя.      |

Эта коллекция позволяет ссылаться на через `ViewData` или `ViewBag` свойства для контроллеров и представлений. `ViewData` Свойство представляет собой словарь слабо типизированных объектов. `ViewBag` Свойство является оболочкой вокруг `ViewData` , предоставляющий динамических свойств для базового `ViewData` коллекции.

`ViewData`и `ViewBag` динамически разрешаются во время выполнения. Так как они не обеспечивают проверку типов во время компиляции, они обычно более ошибкам, чем с помощью viewmodel. По этой причине некоторые разработчики предпочитают минимально или никогда не использовать `ViewData` и `ViewBag`.


<a name="VD"></a>

**ViewData**

`ViewData`— [ViewDataDictionary](/aspnet/core/api/microsoft.aspnetcore.mvc.viewfeatures.viewdatadictionary) объектов, доступных через `string` ключей. Строковые данные могут храниться и использоваться напрямую не требуется для приведения к типу, но другие необходимо привести `ViewData` значений для конкретных типов объектов, при их извлечении. Можно использовать `ViewData` передачи данных из контроллеры с представлениями и в пределах представления, включая [разделяемые представления](xref:mvc/views/partial) и [макеты](xref:mvc/views/layout).

Ниже приведен пример, который задает значения для приветствие и адрес с помощью `ViewData` в действии:

```csharp
public IActionResult SomeAction()
{
    ViewData["Greeting"] = "Hello";
    ViewData["Address"]  = new Address()
    {
        Name = "Steve",
        Street = "123 Main St",
        City = "Hudson",
        State = "OH",
        PostalCode = "44236"
    };

    return View();
}
```

Работать с данными в представлении:

```cshtml
@{
    // Since Address isn't a string, it requires a cast.
    var address = ViewData["Address"] as Address;
}

@ViewData["Greeting"] World!

<address>
    @address.Name<br>
    @address.Street<br>
    @address.City, @address.State @address.PostalCode
</address>
```

**ViewBag**

Примечание: `ViewBag` доступен не на страницах Razor.

`ViewBag`— [DynamicViewData](/aspnet/core/api/microsoft.aspnetcore.mvc.viewfeatures.internal.dynamicviewdata) объект, предоставляющий динамический доступ для объектов, хранящихся в `ViewData`. `ViewBag`может быть удобнее работать с, поскольку он не требует приведения. В следующем примере показано, как использовать `ViewBag` с тем же, как с помощью `ViewData` выше:

```csharp
public IActionResult SomeAction()
{
    ViewBag.Greeting = "Hello";
    ViewBag.Address  = new Address()
    {
        Name = "Steve",
        Street = "123 Main St",
        City = "Hudson",
        State = "OH",
        PostalCode = "44236"
    };

    return View();
}
```

```cshtml
@ViewBag.Greeting World!

<address>
    @ViewBag.Address.Name<br>
    @ViewBag.Address.Street<br>
    @ViewBag.Address.City, @ViewBag.Address.State @ViewBag.Address.PostalCode
</address>
```

**Одновременное использование ViewData и ViewBag**

Примечание: `ViewBag` доступен не на страницах Razor.

Поскольку `ViewData` и `ViewBag` ссылаться на тот же базовый `ViewData` коллекции, можно использовать оба `ViewData` и `ViewBag` его смешивать и сопоставление между ними при чтении и записи значения.

Установка заголовка с помощью `ViewBag` и описание с помощью `ViewData` в верхней части *About.cshtml* представления:

```cshtml
@{
    Layout = "/Views/Shared/_Layout.cshtml";
    ViewBag.Title = "About Contoso";
    ViewData["Description"] = "Let us tell you about Contoso's philosophy and mission.";
}
```

Чтение свойств, но обратная использование `ViewData` и `ViewBag`. В *_Layout.cshtml* файла, получите title, используя `ViewData` и получить описание с помощью `ViewBag`:

```cshtml
<!DOCTYPE html>
<html lang="en">
<head>
    <title>@ViewData["Title"]</title>
    <meta name="description" content="@ViewBag.Description">
    ...
```

Помните, что строки не требуют приведение для `ViewData`. Можно использовать `@ViewData["Title"]` без приведения.

Использование обеих `ViewData` и `ViewBag` в одном works времени, что смешивание и сопоставление чтения и записи свойства. Подготавливается к просмотру следующую разметку:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>About Contoso</title>
    <meta name="description" content="Let us tell you about Contoso's philosophy and mission.">
    ...
```

**Представление различий между ViewData и ViewBag**

 `ViewBag`доступен не на страницах Razor.

* `ViewData`
  * Является производным от [ViewDataDictionary](/aspnet/core/api/microsoft.aspnetcore.mvc.viewfeatures.viewdatadictionary), поэтому он поддерживает словарь свойств, которые можно использовать, такие как `ContainsKey`, `Add`, `Remove`, и `Clear`.
  * Ключи в словаре являются строками, поэтому может быть пробелов. Пример: `ViewData["Some Key With Whitespace"]`
  * Любой тип, отличный от `string` должны быть приведены в представлении, чтобы использовать `ViewData`.
* `ViewBag`
  * Является производным от [DynamicViewData](/aspnet/core/api/microsoft.aspnetcore.mvc.viewfeatures.internal.dynamicviewdata), поэтому оно позволяет создавать динамические свойства, с помощью точечной нотации (`@ViewBag.SomeKey = <value or object>`), и приведение не требуется. Синтаксис `ViewBag` позволяет быстрее добавить контроллеры и представления.
  * Проще проверять значения null. Пример: `@ViewBag.Person?.Name`

**Когда следует использовать ViewData или ViewBag**

Оба `ViewData` и `ViewBag` не менее допустимые подходы для передачи небольших объемов данных между контроллерами и представлениями. Выбрать один из них зависит от приоритета. Можно комбинировать и сопоставлять `ViewData` и `ViewBag` объектов, тем не менее, код проще для понимания и обслуживания с одним из подходов использовать постоянно. Оба подхода используют динамически разрешенных во время выполнения и таким образом подвержена приводит к ошибкам времени выполнения. Некоторые команды разработчиков избежать их.

### <a name="dynamic-views"></a>Динамические представления

Представления, которые не следует объявлять модели типа с помощью `@model` и которые имеют экземпляр модели, переданные им (например, `return View(Address);`) могут ссылаться на свойства этого экземпляра динамически:

```cshtml
<address>
    @Model.Street<br>
    @Model.City, @Model.State @Model.PostalCode<br>
    <abbr title="Phone">P:</abbr> 425.555.0100
</address>
```

Этот компонент обеспечивает гибкость, но не предлагает защиту компиляции или IntelliSense. Если свойство не существует, происходит сбой создания веб-страницы во время выполнения.

## <a name="more-view-features"></a>Дополнительные возможности представления

[Вспомогательных функций тегов](xref:mvc/views/tag-helpers/intro) облегчить добавление поведения на стороне сервера в существующий HTML-теги. Использование вспомогательных функций тегов позволяет избежать необходимости писать пользовательский код или вспомогательные объекты внутри представлений. Вспомогательных функций тегов применяются как атрибуты для HTML-элементов и редакторов, которые не удается обработать их, учитываются. Это позволяет редактировать и визуализации разметки представления в различных средств.

Создание настраиваемой HTML-разметки, может осуществляться с многие встроенные вспомогательные методы HTML. Более сложная логика пользовательского интерфейса могут быть обработаны [Просмотр компонентов](xref:mvc/views/view-components). Просмотр компонентов содержат же SoC, контроллеры и представления предоставляют. Их можно устранить потребность в действиями и представлениями, обрабатывающих данные, используемые Общие элементы пользовательского интерфейса.

Как и многие другие аспекты ASP.NET Core представления поддерживают [внедрения зависимостей](xref:fundamentals/dependency-injection), позволяя службам для [внедрены в представлениях](xref:mvc/views/dependency-injection).
