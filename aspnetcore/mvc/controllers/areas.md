---
title: "Области"
author: rick-anderson
description: "Показано, как работать с областями."
keywords: "ASP.NET Core, областей, маршрутизация, представления"
ms.author: riande
manager: wpickett
ms.date: 02/14/2017
ms.topic: article
ms.assetid: 5e16d5e8-5696-4cb2-8ec7-d36be305c922
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/areas
ms.openlocfilehash: cd0302fa1668979df9bbd6cb36f82742d325c5e9
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
# <a name="areas"></a>Области

По [Кумар Dhananjay](https://twitter.com/debug_mode) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Области — это функция ASP.NET MVC, используемое для систематизации связанные функциональные возможности в группу в отдельном пространстве имен (для маршрутизации) и структуру папок (для представления). Использование областей создает иерархию с целью маршрутизации путем добавления другого параметра маршрута, `area`в `controller` и `action`.

Области позволяют разделить большой ASP.NET Core MVC, веб-приложения на более мелкие функциональные группы. Область является структурой MVC, Расположенной внутри приложения. В проект MVC логические компоненты, например модели, контроллера и представления хранятся в разных папках и MVC использует соглашения об именовании, чтобы создать связь между этими компонентами. Для большого приложения может быть выгодно для разделения приложения на отдельные области высокий уровень функциональных возможностей. Например, для электронной коммерции приложение с несколько подразделений, таких как извлечение, выставлении счетов и поиска и т. д. Каждый из этих частей имеют свои собственные логический компонент представления, контроллеры и модели. В этом сценарии можно использовать области для физически секционирования бизнес-компоненты, в том же проекте.

Область может определяться как более мелкие функциональные единицы в проект ASP.NET Core MVC которых имеет собственный набор контроллеров, представлений и моделей.

Рассмотрите возможность использования областей в MVC проекта при:

* Приложение состоит из нескольких высокого уровня функциональные компоненты, которые должны быть логически разделены

* Необходимо секционировать проект MVC, чтобы каждой функциональной области могут обрабатываться независимо друг от друга

Область функций:

* В приложении ASP.NET Core MVC может быть любое количество областей

* Каждая область имеет свой собственный контроллеры, модели и представления

* Позволяет организовать больших проектов MVC на несколько высокоуровневые компоненты, которые могут быть выполнены независимо друг от друга

* Поддерживает несколько контроллеров с тем же именем — при условии, что они имеют разные *областей*

Давайте рассмотрим пример, чтобы продемонстрировать, как создаются и используются области. Предположим, что у вас есть приложение магазина, которое имеет два различных группирований контроллеры и представления: продуктов и служб. Типичная папка структуру, использование областей MVC выглядит ниже:

* Имя проекта

  * Области

    * Продукты

      * Контроллеры

        * HomeController.cs

        * ManageController.cs

      * Представления

        * Главная страница

          * Index.cshtml

        * Управление

          * Index.cshtml

    * Службы

      * Контроллеры

        * HomeController.cs

      * Представления

        * Главная страница

          * Index.cshtml

Когда MVC пытается визуализации представления в область, по умолчанию, он пытается найти в следующих местах:

```text
/Areas/<Area-Name>/Views/<Controller-Name>/<Action-Name>.cshtml
   /Areas/<Area-Name>/Views/Shared/<Action-Name>.cshtml
   /Views/Shared/<Action-Name>.cshtml
   ```

Это расположение по умолчанию, которые могут быть изменены через `AreaViewLocationFormats` на `Microsoft.AspNetCore.Mvc.Razor.RazorViewEngineOptions`.

Например, ниже кода, вместо того, как «Области» имя папки, он был изменен на «Категории».

```csharp
services.Configure<RazorViewEngineOptions>(options =>
   {
       options.AreaViewLocationFormats.Clear();
       options.AreaViewLocationFormats.Add("/Categories/{2}/Views/{1}/{0}.cshtml");
       options.AreaViewLocationFormats.Add("/Categories/{2}/Views/Shared/{0}.cshtml");
       options.AreaViewLocationFormats.Add("/Views/Shared/{0}.cshtml");
   });
   ```

Один следует заметить, что структура *представления* папка находится только один, который считается важным здесь и содержимое остальных папок, например *контроллеров* и *моделей* does **не** имеет значения. Например, не обязаны иметь *контроллеров* и *моделей* папку вообще. Это происходит потому, что содержимое *контроллеров* и *моделей* — только код, который возвращает компилируется в DLL-библиотеку там, где и как содержимое *представления* не до запроса, представление была предпринята.

После того как вы определили в иерархии папок, необходимо указать MVC, каждый контроллер, сопоставлена с областями. Это сделать с помощью оформления имени контроллера с `[Area]` атрибута.

```csharp
...
   namespace MyStore.Areas.Products.Controllers
   {
       [Area("Products")]
       public class HomeController : Controller
       {
           // GET: /Products/Home/Index
           public IActionResult Index()
           {
               return View();
           }

           // GET: /Products/Home/Create
           public IActionResult Create()
           {
               return View();
           }
       }
   }
   ```

Настройка определения маршрута, который работает с только что созданный областей. [Маршрутизации к действиям контроллера](routing.md) статье подробно создание определений маршрутов, включая использование стандартных маршрутов и маршрутов с атрибутами. В этом примере мы будем использовать обычные маршрута. Чтобы сделать это, откройте *файла Startup.cs* файл и измените его, добавив `areaRoute` с именем ниже определения маршрута.

```csharp
...
   app.UseMvc(routes =>
   {
     routes.MapRoute(
         name: "areaRoute",
         template: "{area:exists}/{controller=Home}/{action=Index}/{id?}");

     routes.MapRoute(
         name: "default",
         template: "{controller=Home}/{action=Index}/{id?}");
   });
   ```

Просмотр `http://<yourApp>/products`, `Index` метод действия `HomeController` в `Products` области будет вызываться.

## <a name="link-generation"></a>Компоновки

* Создание ссылок из действия в пределах одной области на основе контроллера для другого действия в пределах одного контроллера.

  Предположим, что аналогично путь текущего запроса`/Products/Home/Create`

  Синтаксис HtmlHelper:`@Html.ActionLink("Go to Product's Home Page", "Index")`

  Синтаксис вспомогательной функции тегов:`<a asp-action="Index">Go to Product's Home Page</a>`

  Обратите внимание, что мы не должны предоставлять значения «область» и «контроллер» здесь уже доступны в контексте текущего запроса. Эти типы значений, называются `ambient` значения.

* Создание ссылок из действия в пределах одной области на основе контроллера в другое действие на другой контроллер

  Предположим, что аналогично путь текущего запроса`/Products/Home/Create`

  Синтаксис HtmlHelper:`@Html.ActionLink("Go to Manage Products’  Home Page", "Index", "Manage")`

  Синтаксис вспомогательной функции тегов:`<a asp-controller="Manage" asp-action="Index">Go to Manage Products’  Home Page</a>`

  Обратите внимание, что здесь используется значение окружения «области», но явно задано значение «controller» выше.

* Создание ссылок из действия в пределах одной области контроллера в другое действие на основе другой контроллер и другой области.

  Предположим, что аналогично путь текущего запроса`/Products/Home/Create`

  Синтаксис HtmlHelper:`@Html.ActionLink("Go to Services’ Home Page", "Index", "Home", new { area = "Services" })`

  Синтаксис вспомогательной функции тегов:`<a asp-area="Services" asp-controller="Home" asp-action="Index">Go to Services’ Home Page</a>`

  Обратите внимание, что здесь используются значения не окружения.

* Создание ссылки из действия в зависимости от контроллера в другое действие на другой контроллер и **не** в области.

  Синтаксис HtmlHelper:`@Html.ActionLink("Go to Manage Products’  Home Page", "Index", "Home", new { area = "" })`

  Синтаксис вспомогательной функции тегов:`<a asp-area="" asp-controller="Manage" asp-action="Index">Go to Manage Products’  Home Page</a>`

  Поскольку мы хотим создать ссылки на не области на основе действия контроллера, мы пустой значение окружения для «область» ниже.

## <a name="publishing-areas"></a>Публикации областей

Все `*.cshtml` и `wwwroot/**` файлы публикуются на выходных данных, когда `<Project Sdk="Microsoft.NET.Sdk.Web">` включается в *.csproj* файла.
