---
title: "Фильтры"
author: ardalis
description: "Узнайте, как * фильтры * работы и способ их использования в ASP.NET Core MVC."
keywords: "ASP.NET Core, фильтры, фильтры mvc, фильтры действий, фильтры авторизации, фильтры ресурсов, фильтры результатов, фильтры исключений"
ms.author: tdykstra
manager: wpickett
ms.date: 12/12/2016
ms.topic: article
ms.assetid: 531bda08-aa5b-4471-8f08-96add22c8683
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/filters
ms.openlocfilehash: 34a5be6e77f8558c9b3c257575272e167ed95ea4
ms.sourcegitcommit: 8f4d4fad1ca27adf9e396f5c205c9875a3963664
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2017
---
# <a name="filters"></a>Фильтры

По [Tom Dykstra](https://github.com/tdykstra/) и [Стив Смит](https://ardalis.com/)

*Фильтры* в ASP.NET Core MVC позволяют выполнить код до или после определенных этапов в конвейер обработки запросов.

 Встроенные фильтры дескриптор задач, таких как авторизации (ограничивая его доступ к ресурсам, которые пользователь не имеет разрешения для), гарантируя, что все запросы использовать HTTPS и ответ, кэширование (сокращенные вычисления конвейер обработки запросов для возврата кэшированного ответа). 

Можно создать пользовательские фильтры для обработки проблем с перекрестными приложения. Каждый раз, когда вы хотите избежать дублирования кода для действий, фильтры являются решением. Например можно объединить код обработки ошибок в фильтр исключений.

[Просмотреть или загрузить пример из GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample).

## <a name="how-do-filters-work"></a>Как работают фильтры

Фильтры выполняются в рамках *конвейера вызова действия MVC*, которые иногда называются *конвейера фильтра*.  Фильтр-конвейер запускается после MVC выбирает действие для выполнения.

![Запрос обрабатывается через другие по промежуточного слоя, маршрутизация по промежуточного слоя, Выбор действия и конвейера вызова действия MVC. Обработка запроса продолжается обратно через Выбор действия маршрутизации по промежуточного слоя и различных других по промежуточного слоя перед тем как стать ответ, отправляемый клиенту.](filters/_static/filter-pipeline-1.png)

### <a name="filter-types"></a>Типы фильтров

Каждый тип фильтра выполняется на различных этапах конвейера фильтра.

* [Фильтры авторизации](#authorization-filters) выполняются первыми, а также используются для определения, является ли текущий пользователь имеет права для текущего запроса. Они могут сокращенным конвейера, если запрос не авторизован. 

* [Фильтры ресурсов](#resource-filters) применяются в первую очередь для обработки запроса после авторизации.  Они могут выполняться код перед rest конвейера фильтра, а после завершения оставшуюся часть конвейера. Они используются для реализации кэширования или в противном случае краткой записи конвейера фильтра для повышения производительности. Так как они выполняться до привязки модели, они полезны для все, что необходимо для оказания влияния на привязки модели.

* [Фильтры действий](#action-filters) может выполнять код непосредственно перед и после вызова метода отдельные действия. Они могут использоваться для управления аргументы, передаваемые в действие и результат, возвращаемый из действия.

* [Фильтры исключений](#exception-filters) применяются для глобальных политик для необработанных исключений, возникающих до ничего записан в тексте ответа.

* [Привести фильтры](#result-filters) можно запустить код непосредственно перед и после выполнения результаты отдельных действий. Они только при успешном выполнении метода действия и полезны для логики, необходимо заключать выполнения представления или модуля форматирования.

На следующей диаграмме показан, как взаимодействуют эти типы фильтров в конвейере фильтра.

![Запрос обрабатывается через фильтры авторизации, фильтры ресурсов, привязки модели, фильтры действий, выполнение действия и преобразование результата действия, фильтры исключений, фильтры результатов и результат выполнения. На способ ожидания запрос только обрабатывается результат фильтры и фильтры ресурсов перед тем как стать ответ, отправляемый клиенту.](filters/_static/filter-pipeline-2.png)

## <a name="implementation"></a>Реализация

Фильтры поддерживает синхронные и асинхронные реализации, посредством определения другой интерфейс. Выберите вариант async или синхронизации в зависимости от типа задачи, которую необходимо выполнить. 

Код синхронной фильтры, которые могут выполняться оба до и после их этап конвейера определить на*рабочей области*выполнение и на*этапа*выполнения методов. Например `OnActionExecuting` вызывается перед вызовом метода действия и `OnActionExecuted` вызывается после метода действия.

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleActionFilter.cs?highlight=6,8,13)]

Асинхронные фильтры определяют один на*этапа*ExecutionAsync метод. Этот метод принимает *FilterType*ExecutionDelegate делегат, который выполняет этап конвейера фильтра. Например `ActionExecutionDelegate` вызовы метода действия и могут выполнять код до и после его вызова.

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleAsyncActionFilter.cs?highlight=6,8-10,13)]

Для нескольких этапов фильтр в одном классе могут реализовывать интерфейсы. Например [ActionFilterAttribute](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute) абстрактный класс реализует интерфейс `IActionFilter` и `IResultFilter`, а также их асинхронные эквиваленты.

> [!NOTE]
> Реализуйте **либо** синхронной или асинхронной версии интерфейса фильтр, который не оба. Платформа сначала проверяет ли фильтр реализует асинхронный интерфейс, и если да, он вызывает. В противном случае она вызывает интерфейс синхронные методы. Если для реализации обоих интерфейсов на один класс, называется асинхронного метода. При использовании абстрактных классов, таких как [ActionFilterAttribute](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute) нужно переопределить только синхронных методов или асинхронного метода для каждого типа.

### <a name="ifilterfactory"></a>IFilterFactory

Объект `IFilterFactory` реализует интерфейс `IFilter`. Таким образом `IFilterFactory` экземпляр можно использовать в качестве `IFilter` экземпляра в любом месте конвейера фильтра. Когда платформа готовится для вызова фильтра, попытается выполнить приведение к типу `IFilterFactory`. Если этот приведение выполнено успешно, `CreateInstance` вызов метода для создания `IFilter` экземпляр, который будет вызываться. Это обеспечивает очень гибким, поскольку конвейера точный фильтр не нужно задавать явным образом при запуске приложения.

Можно реализовать `IFilterFactory` в реализациях атрибут как другой подход к созданию фильтров:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/AddHeaderWithFactoryAttribute.cs?name=snippet_IFilterFactory&highlight=1,4,5,6,7)]

### <a name="built-in-filter-attributes"></a>Встроенный фильтр атрибутов

Платформа включает встроенные фильтры на основе атрибутов, можно создать подкласс и настройки. Например следующий результат фильтр добавляет заголовок ответа.

<a name="add-header-attribute"></a>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/AddHeaderAttribute.cs?highlight=5,16)]

Атрибуты позволяют фильтры, чтобы принимать аргументы, как показано в приведенном выше примере. Бы добавить этот атрибут к контроллеру или методу действия и укажите имя и значение заголовка HTTP.

[!code-csharp[Main](./filters/sample/src/FiltersSample/Controllers/SampleController.cs?name=snippet_AddHeader&highlight=1)]

Результат `Index` действия приведен ниже — на нижнем правом углу отображаются заголовки ответа.

![Разработчик от средства из Microsoft Edge отображение заголовки ответа, включая автор Стив Смит@ardalis](filters/_static/add-header.png)

Некоторые из интерфейсов фильтра имеют соответствующих атрибутов, которые могут использоваться как базовые классы для пользовательских реализаций.

Атрибуты фильтра:

* `ActionFilterAttribute`
* `ExceptionFilterAttribute`
* `ResultFilterAttribute`
* `FormatFilterAttribute`
* `ServiceFilterAttribute`
* `TypeFilterAttribute`

`TypeFilterAttribute`и `ServiceFilterAttribute` объясняются [далее в этой статье](#dependency-injection).

## <a name="filter-scopes-and-order-of-execution"></a>Фильтр области и порядок выполнения

Фильтр можно добавить в конвейер, в одном из трех *областей*. Можно добавить фильтр к методу определенного действия или в класс контроллера с помощью атрибута. Или можно зарегистрировать фильтр глобально (для всех контроллеров и действий) путем добавления его в `MvcOptions.Filters` коллекции в `ConfigureServices` метод `Startup` класса:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Startup.cs?name=snippet_ConfigureServices&highlight=5-8)]

### <a name="default-order-of-execution"></a>По умолчанию порядок выполнения

При наличии нескольких фильтров для определенного этапа конвейера, область определяет порядок выполнения фильтров по умолчанию.  Глобальные фильтры заключить классов фильтров, которые в свою очередь заключить метод фильтры. Это иногда называется вложенности «Русский фигурку», как любое такое расширение области окружает предыдущей области, например [вложенности фигурку](https://wikipedia.org/wiki/Matryoshka_doll). Обычно вы получаете требуемого поведения переопределения без необходимости явно определить упорядочение.

В результате такая вложенность *после* код фильтров выполняется в порядке, обратном порядку *перед* кода. Последовательность выглядит следующим образом:

* *Перед* кода глобально фильтров
  * *Перед* кода фильтров, применяемых к контроллерам
    * *Перед* код фильтров, примененных к методам действий
    * *После* код фильтров, примененных к методам действий
  * *После* кода фильтров, применяемых к контроллерам
* *После* кода глобально фильтров
  
Ниже приведен пример, в котором показан порядок вызова методов какой фильтр синхронной фильтров действий.

| Sequence | Область фильтра | Метод Filter |
|:--------:|:------------:|:-------------:|
| 1 | Global | `OnActionExecuting` |
| 2 | Контроллер | `OnActionExecuting` |
| 3 | Метод | `OnActionExecuting` |
| 4 | Метод | `OnActionExecuted` |
| 5 | Контроллер | `OnActionExecuted` |
| 6 | Global | `OnActionExecuted` |

Эта последовательность показывает, что метод фильтра, вложенные в контроллер фильтр, и вложенный фильтр контроллера в глобальный фильтр. Вставить другой способом, если вы внутри фильтр async,*этапа*метод ExecutionAsync все фильтры с более тесную областью время выполнения кода в стеке.

> [!NOTE]
> Каждый контроллер, который наследует от `Controller` базового класса включает `OnActionExecuting` и `OnActionExecuted` методы. Эти методы wrap фильтров, запустите для выполнения данного действия: `OnActionExecuting` вызывается перед любые фильтры, и `OnActionExecuted` вызывается после все фильтры.

### <a name="overriding-the-default-order"></a>Переопределение порядок по умолчанию

Последовательность выполнения по умолчанию можно переопределить путем реализации `IOrderedFilter`. Этот интерфейс предоставляет `Order` свойство, которое имеет приоритет над областью для определения порядка выполнения. Фильтр с более низким `Order` будет иметь значение его *перед* код, выполняемый до, фильтр с более высокого значения `Order`. Фильтр с более низким `Order` будет иметь значение его *после* код, выполняемый после этого фильтра с более высоким `Order` значение. Можно задать `Order` свойства с помощью параметра конструктора:

```csharp
[MyFilter(Name = "Controller Level Attribute", Order=1)]
```

Если же 3 показано в предыдущем примере, но набор фильтров `Order` свойства контроллера и глобальные фильтры, 1 и 2 соответственно, применяются в зеркальном отображении порядок выполнения.

| Sequence | Область фильтра | Свойство `Order` | Метод Filter |
|:--------:|:------------:|:-----------------:|:-------------:|
| 1 | Метод | 0 | `OnActionExecuting` |
| 2 | Контроллер | 1  | `OnActionExecuting` |
| 3 | Global | 2  | `OnActionExecuting` |
| 4 | Global | 2  | `OnActionExecuted` |
| 5 | Контроллер | 1  | `OnActionExecuted` |
| 6 | Метод | 0  | `OnActionExecuted` |

`Order` Свойство важнее области при определении порядка выполнения фильтров. Фильтры сортируются сначала по порядку, то область используется для разорвать связи. Все встроенные фильтры реализуют `IOrderedFilter` и задать значение по умолчанию `Order` значение 0, поэтому области определяет порядок, если не задать `Order` ненулевое значение.

## <a name="cancellation-and-short-circuiting"></a>Отмена и сокращенное вычисление

Краткой записи конвейера фильтра в любой момент, задав `Result` свойство `context` указанный параметр в метод фильтра. Для экземпляра следующий фильтр ресурсов предотвращает выполнение оставшуюся часть конвейера.

<a name="short-circuiting-resource-filter"></a>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/ShortCircuitingResourceFilterAttribute.cs?highlight=12,13,14,15)]

В следующем коде показано как `ShortCircuitingResourceFilter` и `AddHeader` целевой фильтр `SomeResource` метода действия. Тем не менее так как `ShortCircuitingResourceFilter` выполняется первой (так как он является фильтром ресурсов и `AddHeader` имеет фильтр действий) и игнорирует оставшуюся часть конвейера, `AddHeader` фильтра никогда не будет работать для `SomeResource` действие. Это поведение останется таким же, если оба фильтра применяются на уровне метода действия, предоставляемые `ShortCircuitingResourceFilter` вначале (из-за его тип фильтра или явное использование `Order` свойства, например).

[!code-csharp[Main](./filters/sample/src/FiltersSample/Controllers/SampleController.cs?name=snippet_AddHeader&highlight=1,9)]

## <a name="dependency-injection"></a>Внедрение зависимостей

Фильтры можно добавлять по типу или экземпляр. При добавлении экземпляра, что экземпляр будет использоваться для каждого запроса. При добавлении типа, он будет иметь тип активации, то есть экземпляр создается для каждого запроса и все зависимости конструктор будет взят из [внедрения зависимостей](../../fundamentals/dependency-injection.md) (DI). Добавление фильтра по типу эквивалентно `filters.Add(new TypeFilterAttribute(typeof(MyFilter)))`.

Фильтры, которые реализованы в виде атрибутов и добавляются непосредственно на контроллере классы или методы действия не может иметь конструктор зависимостей, предоставляемые [внедрения зависимостей](../../fundamentals/dependency-injection.md) (DI). Это так, как атрибуты должны иметь свои параметры конструктора указано, где они применяются. Это ограничение принципов работы атрибутов.

Если фильтры имеют зависимости, которые следует получить доступ с DI, существует несколько поддерживаемых подходов. Можно применить фильтр методу класса или действие, с помощью одного из следующих:

* `ServiceFilterAttribute`
* `TypeFilterAttribute`
* `IFilterFactory`реализован в атрибуте

> [!NOTE]
> Одну зависимость, можно получить из DI — средство ведения журнала. Однако следует избегать создания и использования фильтров исключительно в целях ведения журнала, поскольку [ведение журналов встроенная функция](../../fundamentals/logging.md) уже всеми необходимыми. Если вы собираетесь добавить фильтры ведения журнала, следует обращать внимание на домен в бизнесе или поведение, характерное для фильтра, вместо действия MVC или другие события framework.

### <a name="servicefilterattribute"></a>ServiceFilterAttribute

Объект `ServiceFilter` извлекает из DI экземпляр фильтра. Добавить фильтр к контейнеру в `ConfigureServices`и ссылаться на него в `ServiceFilter` атрибута

[!code-csharp[Main](./filters/sample/src/FiltersSample/Startup.cs?name=snippet_ConfigureServices&highlight=11)]

[!code-csharp[Main](../../mvc/controllers/filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_ServiceFilter&highlight=1)]

С помощью `ServiceFilter` без регистрации результаты типа фильтра в исключение:

```
System.InvalidOperationException: No service for type
'FiltersSample.Filters.AddHeaderFilterWithDI' has been registered.
```

`ServiceFilterAttribute`реализует `IFilterFactory`, которая предоставляет один метод для создания `IFilter` экземпляра. В случае использования `ServiceFilterAttribute`, `IFilterFactory` интерфейса `CreateInstance` метод реализуется для загрузки указанного типа из контейнера служб (DI).

### <a name="typefilterattribute"></a>TypeFilterAttribute

`TypeFilterAttribute`очень похоже на `ServiceFilterAttribute` (а также реализует `IFilterFactory`), но его тип не разрешается напрямую из DI контейнера. Вместо этого он создает экземпляр типа с помощью `Microsoft.Extensions.DependencyInjection.ObjectFactory`.

Из-за этого различия типов, на которые ссылаются с помощью `TypeFilterAttribute` необходимо сначала зарегистрировать с контейнером (но они по-прежнему будут иметь их зависимости, выполненные с помощью контейнера). Кроме того `TypeFilterAttribute` при необходимости может принимать аргументы конструктора для типа. Следующий пример демонстрирует передавать аргументы типа с помощью `TypeFilterAttribute`:

[!code-csharp[Main](../../mvc/controllers/filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_TypeFilter&highlight=1,2)]

Если у вас есть фильтр, который не требует никаких аргументов, но которого есть конструктор зависимости, которые должны заполняться DI, можно использовать собственные атрибута с заданным именем на классы и методы, а не `[TypeFilter(typeof(FilterType))]`). Фильтр показывает, как это можно реализовать:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleActionFilterAttribute.cs?name=snippet_TypeFilterAttribute&highlight=1,3,7)]

Этот фильтр может применяться к классы или методы, используя `[SampleActionFilter]` синтаксис, вместо того чтобы использовать `[TypeFilter]` или `[ServiceFilter]`.

## <a name="authorization-filters"></a>Фильтры авторизации

*Фильтры авторизации* управления доступом к методам действий и первый фильтры для выполнения в рамках конвейера фильтра. Они имеют только перед методом, в отличие от большинства фильтров, которые поддерживают до и после методы. При создании собственных инфраструктуры авторизации следует только написать фильтр настраиваемой авторизации. Предпочитаете настройку политик авторизации или написание пользовательской политики авторизации по сравнению с написанием пользовательского фильтра. Встроенный фильтр реализации просто отвечает за вызов система авторизации.

Обратите внимание, что вы не должны вызывать исключения в фильтры авторизации, так как ничего не будет обрабатывать исключение (фильтры исключений не будет обрабатывать их). Вместо этого запрос и выполнить поиск другим способом.

Дополнительные сведения о [авторизации](../../security/authorization/index.md).

## <a name="resource-filters"></a>Фильтры ресурсов

*Фильтры ресурсов* реализации `IResourceFilter` или `IAsyncResourceFilter` интерфейс и их выполнение включает большую часть конвейера фильтра. (Только [фильтры авторизации](#authorization-filters) выполняются перед их.) Фильтры ресурсов особенно полезны в тех случаях, если вам нужно краткой записи большую часть работы, который выполняет запрос. Например при ответе уже находится в кэше кэширования фильтра можно избежать оставшуюся часть конвейера.

[Короткие сокращенного вычисления фильтр ресурсов](#short-circuiting-resource-filter) выше является примером фильтра ресурсов. Еще один пример — [DisableFormValueModelBindingAttribute](https://github.com/aspnet/Entropy/blob/rel/1.1.1/samples/Mvc.FileUpload/Filters/DisableFormValueModelBindingAttribute.cs), что запрещает привязки модели, доступ к данным формы. Это полезно в случаях, когда вы знаете, ты получать передачи больших файлов и должны запускаться формы, считываемых в память.

## <a name="action-filters"></a>Фильтры действий

*Фильтры действий* реализации `IActionFilter` или `IAsyncActionFilter` интерфейс и их выполнение окружает выполнение методов действия.

Ниже приведен пример действия фильтра.

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleActionFilter.cs?name=snippet_ActionFilter)]

[ActionExecutingContext](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionexecutingcontext) содержит следующие свойства:

* `ActionArguments`-позволяет управлять входные данные для действия.
* `Controller`-позволяет управлять экземпляр контроллера. 
* `Result`-Это игнорирует выполнения метода действия и фильтры последующих действий. Также создает исключение предотвращает выполнение метода действия и последующие фильтры, но рассматривается как сбой вместо успешного результата.

[ActionExecutedContext](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionexecutedcontext) предоставляет `Controller` и `Result` плюс следующие свойства:

* `Canceled`-будет иметь значение true, если выполнение действия была сокращенное другим фильтром.
* `Exception`-будет иметь значение null, если действие или фильтр последующих действий вызвал исключение. Задание этого свойства значение null, эффективно «handles» исключение, и `Result` будет выполняться, как если бы он были возвращены обычно из метода действия.

Для `IAsyncActionFilter`, вызов `ActionExecutionDelegate` выполняет все последующие действия фильтры и метод действия, возвращая `ActionExecutedContext`. Для краткой записи, назначьте `ActionExecutingContext.Result` некоторые результату экземпляра и не вызывают `ActionExecutionDelegate`.

Платформа предоставляет абстрактный `ActionFilterAttribute` , можно создать подкласс. 

Автоматически проверять состояние модели и возвращает все ошибки, если недопустимое состояние, можно использовать фильтр действий:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/ValidateModelAttribute.cs)]

`OnActionExecuted` Выполняется метод после метода действия и может см и работа с результатами действия через `ActionExecutedContext.Result` свойство. `ActionExecutedContext.Canceled`будет присвоено значение true, если выполнение действия была сокращенное другим фильтром. `ActionExecutedContext.Exception`будет присвоено значение отличное от null, если действие или фильтр последующих действий вызвал исключение. Установка `ActionExecutedContext.Exception` значение null, эффективно «handles» исключение, и `ActionExectedContext.Result` затем будет выполняться, как если бы он были возвращены обычно из метода действия.

## <a name="exception-filters"></a>Фильтры исключений

*Фильтры исключений* реализации `IExceptionFilter` или `IAsyncExceptionFilter` интерфейса. Они могут использоваться для реализации распространенных ошибок при обработке политики для приложения. 

Следующий образец фильтр исключения используется представление ошибки пользовательского разработчика для отображения сведений об исключениях, возникающих, когда приложение находится в разработке:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/CustomExceptionFilterAttribute.cs?name=snippet_ExceptionFilter&highlight=1,14)]

Фильтры исключений имеют два события (для перед и после) — только реализовать `OnException` (или `OnExceptionAsync`). 

Фильтры исключений обработки необработанных исключений, возникающих при создании контроллера [привязки модели](../models/model-binding.md), фильтры действий или методам действий. Они не будет перехватывать исключения, возникающие в фильтры ресурсов, фильтры результатов или MVC результат выполнения.

Для обработки исключения, задайте `ExceptionContext.ExceptionHandled` свойство значение true или записывать ответ. Это предотвратит распространение исключения. Обратите внимание, что фильтр исключений нельзя включить исключение в «успешно». Фильтр действий можно сделать.

> [!NOTE]
> В ASP.NET версии 1.1, ответ не отправляется, если задать `ExceptionHandled` значение true **и** записи ответа. В этом случае ASP.NET Core 1.0 отправки ответа и ASP.NET Core 1.1.2 вернется к 1.0 поведение. Дополнительные сведения см. в разделе [выдавать #5594](https://github.com/aspnet/Mvc/issues/5594) в репозитории GitHub. 

Фильтры исключений подходят для перехвата исключений, возникающих в рамках действия MVC, но они не обладает такой гибкостью, как по промежуточного слоя обработки ошибок. Предпочтение по промежуточного слоя в общем случае и использовать фильтры, только когда нужен для обработки ошибок *по-разному* основании действие MVC, которое было выбрано. Например приложение может иметь методы действий для обеих конечных точек API, а также для представления или HTML. Конечные точки API может вернуть сведения об ошибке, как JSON, во время действия на основе представления может вернуть страницу ошибки, как HTML.

Платформа предоставляет абстрактный `ExceptionFilterAttribute` , можно создать подкласс. 

## <a name="result-filters"></a>Фильтры результатов

*Привести фильтры* реализации `IResultFilter` или `IAsyncResultFilter` интерфейс и их выполнение окружает выполнения результатов действия. 

Ниже приведен пример результата фильтра, который добавляет заголовок НТТР.

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/LoggingAddHeaderFilter.cs?name=snippet_ResultFilter)]

Тип выполняемой результат зависит от рассматриваемой действия. Действие MVC, возвращение представления будет включать все razor обработки как часть `ViewResult` при выполнении. Метод API может выполнять некоторые сериализации как часть выполнения результата. Дополнительные сведения о [результаты действий](actions.md)

Фильтры результатов выполняются только для результаты успешных тестов — Если действие или фильтров действий выдают результат действия. Фильтры результатов не выполняются, когда фильтры исключений обработки исключения.

`OnResultExecuting` Метод может прерывания выполнения результата действия и последующие результирующие фильтры, задав `ResultExecutingContext.Cancel` значение true. Обычно следует писать объект ответа, когда сокращенного вычисления для предотвращения создания пустой ответ. Исключение предотвратит выполнения результата действия и последующие фильтры, но будет рассматриваться как сбой вместо успешного результата.

Когда `OnResultExecuted` выполняется метод, ответ скорее всего отправляются на клиент и их нельзя изменить дальнейшей (если не возникло исключение). `ResultExecutedContext.Canceled`будет присвоено значение true, если результат выполнения действия была сокращенное другим фильтром.

`ResultExecutedContext.Exception`будет присвоено значение отличное от null, если результат действия или последующие результирующие Фильтр вызвал исключение. Параметр `Exception` для null эффективно обрабатывает исключение и предотвращает исключения повторно вызывается MVC более поздней версии в конвейере. Когда обработка исключений в фильтре результата, может не быть может записывать любые данные в ответ. Если результат действия вызывает исключение во время до его выполнения и заголовки уже были записаны на клиент, отсутствует надежный механизм для отправки, то код сбоя.

Для `IAsyncResultFilter` вызов `await next()` на `ResultExecutionDelegate` выполняет все последующие результирующие фильтры и результата действия. Краткой записи, задайте `ResultExecutingContext.Cancel` в значение true и не вызывайте `ResultExectionDelegate`.

Платформа предоставляет абстрактный `ResultFilterAttribute` , можно создать подкласс. [AddHeaderAttribute](#add-header-attribute) приведенный выше класс является примером атрибут фильтра результатов.

## <a name="using-middleware-in-the-filter-pipeline"></a>С помощью по промежуточного слоя в конвейере фильтра

Фильтры ресурсов работают как [по промежуточного слоя](../../fundamentals/middleware.md) в том, что они заключить выполнения все данные, поступающие в конвейере. Однако фильтры отличаются от по промежуточного слоя, что они являются частью MVC, это означает, что они имеют доступ к контекст MVC и конструкции.

В ASP.NET Core 1.1 можно использовать по промежуточного слоя в конвейере фильтра. Вы можете делать, если у вас есть компонент по промежуточного слоя, которому требуется доступ к маршрутизации MVC данных или пакет, который следует запустить только для некоторых контроллеров или действия.

Чтобы использовать в качестве фильтра по промежуточного слоя, создайте тип с `Configure` метод, который задает по промежуточного слоя, который необходимо внедрить в конвейере фильтра. Ниже приведен пример использования по промежуточного слоя локализации для установления текущего языка и региональных параметров для запроса:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/LocalizationPipeline.cs?name=snippet_MiddlewareFilter&highlight=3,21)]

Затем можно использовать `MiddlewareFilterAttribute` для запуска по промежуточного слоя для выбранного контроллера или действия или глобально:

[!code-csharp[Main](./filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_MiddlewareFilter&highlight=2)]

Фильтры по промежуточного слоя, выполняются на одном этапе конвейера фильтра как фильтры ресурсов до привязки модели и после оставшуюся часть конвейера.

## <a name="next-actions"></a>Дальнейшие действия

Для экспериментов с фильтрами, [загрузки, тестирования и изменить пример](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample).
