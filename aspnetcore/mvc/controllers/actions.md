---
title: "Обработка запросов с контроллеров в ASP.NET Core MVC"
author: ardalis
description: 
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 07/03/2017
ms.topic: article
ms.assetid: 9da9eb52-8583-4069-af91-155ba3529d7f
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/actions
ms.openlocfilehash: 5dc6c7dc70027bb79875f389d535119a2543b873
ms.sourcegitcommit: 9cdbfd0d670d70b9c354216aabee260c52dad5ee
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2017
---
# <a name="handling-requests-with-controllers-in-aspnet-core-mvc"></a>Обработка запросов с контроллеров в ASP.NET Core MVC

По [Стив Смит](https://ardalis.com/) и [Скотт Addie](https://github.com/scottaddie)

Контроллеры, действий и результатов действий являются основной частью как разработчикам создавать приложения с помощью ASP.NET Core MVC.

## <a name="what-is-a-controller"></a>Что такое контроллера?

Контроллер используется для определения и группировки набора действий. Действие (или *метод действия*) — это метод контроллер, который обрабатывает запросы. Контроллеры логически группировать подобные действия. Объединение действий позволяет общие наборы правил, например маршрутизации, кэширование и авторизации, применяемые в совокупности. Запросы, сопоставляются с действия через [маршрутизации](xref:mvc/controllers/routing).

По соглашению классы контроллера:
* Находиться на корневом уровне проекта *контроллеров* папки
* Наследовать от`Microsoft.AspNetCore.Mvc.Controller`

Контроллер — допускающих создание экземпляров классов, в которой по крайней мере одно из следующих условий верно:
* Имя класса является суффиксом «Controller»
* Этот класс наследует от класса, имя которого является суффиксом «Controller»
* Класс снабжен `[Controller]` атрибута

Класс контроллера не должен иметь связанный с ним `[NonController]` атрибута.

Необходимо следовать контроллеров [явные зависимости принцип](http://deviq.com/explicit-dependencies-principle/). Существует несколько подходов к реализации этот принцип. Если несколько действий контроллера требуют той же службы, рассмотрите возможность использования [внедрение конструктора](xref:mvc/controllers/dependency-injection#constructor-injection) запрашивать эти зависимости. Если службе требуется только одно действие методом, рассмотрите возможность использования [действия внедрения](xref:mvc/controllers/dependency-injection#action-injection-with-fromservices) для запроса зависимость.

В пределах **M**одели -**V**росмотр -**C**шаблон ontroller контроллер отвечает за начальной обработки запроса и создание экземпляра модели. Как правило бизнес-решения должно выполняться в пределах модели.

Контроллер принимает результат модели обработки (если есть) и возвращает правильное представление и его связанного представления данных или результат вызова API. Дополнительные сведения по [Обзор из основных компонентов MVC ASP.NET](xref:mvc/overview) и [Приступая к работе с Visual Studio и ASP.NET Core MVC](xref:tutorials/first-mvc-app/start-mvc).

Контроллер *уровня пользовательского интерфейса* абстракции. Его функции являются убедитесь в допустимости данных запроса и выбрать, какие представления (или результат для API) должны быть возвращены. В хорошо организованную приложения он не включает непосредственно данных access или бизнес-логики. Вместо этого контроллера делегирует служб обработки этих обязанностей.

## <a name="defining-actions"></a>Определение действий

Открытые методы на контроллере, кроме тех, которые декорированных `[NonAction]` атрибута, — это действия. Параметры для действия привязаны к данные запроса и проверяются с помощью [привязки модели](xref:mvc/models/model-binding). Выполняется проверка модели для всех элементов, привязанным к модели. `ModelState.IsValid` Значение свойства показывает успешность привязки модели и проверки.

Методы действия должен содержать логику для сопоставления запроса для значения бизнеса. Бизнесе обычно должны быть представлены в виде служб, осуществляющих доступ к контроллеру через [внедрения зависимостей](xref:mvc/controllers/dependency-injection). Действия затем сопоставьте результат действия бизнес-приложений.

Действия могут возвращать значение, но часто вернуть экземпляр `IActionResult` (или `Task<IActionResult>` для асинхронных методов), формирует ответ. Метод действия отвечает за выбор *тип ответа*. Результат действия *отвечает*.

### <a name="controller-helper-methods"></a>Контроллер вспомогательные методы

Контроллеры обычно наследуют от [контроллера](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.controller), хотя это не является обязательным. Наследование от `Controller` предоставляет доступ к трем категориям вспомогательные методы:

#### <a name="1-methods-resulting-in-an-empty-response-body"></a>1. Методы, что приводит к пустым телом ответа

Не `Content-Type` HTTP-заголовок ответа включено, так как текст ответа не имеет содержимого для описания.

Существует два типа результата в этой категории: перенаправление и код состояния HTTP.

* **Код состояния HTTP**

    Этот тип возвращает код состояния HTTP. Некоторые вспомогательные методы этого типа представляют собой `BadRequest`, `NotFound`, и `Ok`. Например `return BadRequest();` создает код состояния 400, при выполнении. Если такие методы, как `BadRequest`, `NotFound`, и `Ok` являются перегружены, они больше не считаться ответчики код состояния HTTP, так как выполняется согласование содержимого.

* **Перенаправления**

    Этот тип возвращает перенаправление на действие или назначения (с помощью `Redirect`, `LocalRedirect`, `RedirectToAction`, или `RedirectToRoute`). Например `return RedirectToAction("Complete", new {id = 123});` перенаправляет `Complete`, передав анонимный объект.

    Тип результата перенаправления отличается от типа код состояния HTTP в основном в добавлении `Location` заголовка HTTP-ответа.

#### <a name="2-methods-resulting-in-a-non-empty-response-body-with-a-predefined-content-type"></a>2. Методы, возникающие в теле ответа непустой с Предопределенный тип содержимого

Большинство вспомогательные методы в этой категории включают `ContentType` свойства, что позволяет задать `Content-Type` заголовок ответа для описания тела ответа.

Существует два типа результата в этой категории: [представление](xref:mvc/views/overview) и [ответ в формате](xref:mvc/models/formatting).

* **Вид**

    Этот тип возвращает представление, которое использует модель для подготовки к просмотру HTML. Например `return View(customer);` передает модели в представлении для привязки данных.

* **Форматированные ответа**

    Этот тип возвращает JSON или аналогичные формат обмена данными для представления объекта особым образом. Например `return Json(customer);` сериализует указанный объект в формат JSON.
    
    Другие часто используются методы этого типа: `File`, `PhysicalFile`, и `VirtualFile`. Например `return PhysicalFile(customerFilePath, "text/xml");` возвращает XML-файла, описываемого `Content-Type` значение заголовка ответа «text/xml».

#### <a name="3-methods-resulting-in-a-non-empty-response-body-formatted-in-a-content-type-negotiated-with-the-client"></a>3. Методы, возникающие в текст ответа не пустой, отформатированное в тип содержимого, согласование с клиентом

Эта категория называется лучше **согласования содержимого**. [Согласование содержимого](xref:mvc/models/formatting#content-negotiation) применяется, когда действие возвращает [ObjectResult](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.objectresult) типа или что-то отличное от [IActionResult](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.iactionresult) реализации. Действие, которое возвращает значение, отличное от`IActionResult` реализации (например, `object`) также возвращает ответ в формате.

Включают некоторые вспомогательные методы этого типа `BadRequest`, `CreatedAtRoute`, и `Ok`. Примеры этих методов `return BadRequest(modelState);`, `return CreatedAtRoute("routename", values, newobject);`, и `return Ok(value);`соответственно. Обратите внимание, что `BadRequest` и `Ok` выполняют согласование содержимого только в том случае, если передано значение, не передавать значения, они вместо служат в качестве типов результатов код состояния HTTP. `CreatedAtRoute` Метод, с другой стороны, всегда выполняет согласование содержимого с момента его перегрузок, которые требуется передать значение.

### <a name="cross-cutting-concerns"></a>Проблемы пересечения

Приложения обычно имеют части рабочего процесса. Например, приложение, которое требует проверки подлинности для доступа к покупательской корзине, или приложение, кэширует данные на некоторых страницах. Чтобы выполнить логику до или после метода действия, используйте *фильтра*. С помощью [фильтры](xref:mvc/controllers/filters) в решении общих задач, можно уменьшить дублирования, позволяя выполните [не повторять самостоятельно (ПРОБНОГО) принцип](http://deviq.com/don-t-repeat-yourself/).

Наиболее фильтрации атрибутов, например `[Authorize]`, могут применяться на уровне контроллер или действие, в зависимости от нужного уровня гранулярности.

Обработка ошибок и кэширование ответов часто являются перекрестными проблемы:
   * [Обработка ошибок](xref:mvc/controllers/filters#exception-filters)
   * [Кэширование ответов](xref:performance/caching/response)

Многие проблемы пересечения можно обрабатывать с помощью фильтров или настраиваемый [по промежуточного слоя](xref:fundamentals/middleware).
