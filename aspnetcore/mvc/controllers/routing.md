---
title: "Маршрутизация в действиях контроллера"
author: rick-anderson
description: 
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 03/14/2017
ms.topic: article
ms.assetid: 26250a4d-bf62-4d45-8549-26801cf956e9
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/routing
ms.openlocfilehash: da67124ffc874c4f83fff077c6429e9f3e571587
ms.sourcegitcommit: 0b6c8e6d81d2b3c161cd375036eecbace46a9707
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2017
---
# <a name="routing-to-controller-actions"></a>Маршрутизация в действиях контроллера

По [Nowak Райана](https://github.com/rynowak) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

ASP.NET Core MVC использует маршрутизации [по промежуточного слоя](../../fundamentals/middleware.md) для сопоставления URL-адреса входящих запросов и сопоставить их действия. Маршруты, определяются в код запуска или атрибуты. Маршруты описаны сопоставления URL-пути к действиям. Маршруты, также используются для создания URL-адреса (для ссылок) отправки в ответах. 

Традиционно либо направляются действия или атрибут маршрутизации. Размещение маршрут на контроллер или действие упрощает атрибут маршрутизации. В разделе [смешанный маршрутизации](#routing-mixed-ref-label) для получения дополнительной информации.

В этом документе объясняется взаимодействие между MVC и маршрутизации, а также как типичные Создание приложения MVC функции маршрутизации. В разделе [маршрутизации](xref:fundamentals/routing) сведения о расширенной маршрутизации.

## <a name="setting-up-routing-middleware"></a>Настройка маршрутизации по промежуточного слоя

В вашей *Настройка* метода может появиться код, аналогичный:

```csharp
app.UseMvc(routes =>
{
   routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
```

Внутри вызова `UseMvc`, `MapRoute` используется для создания одного маршрута, мы будем называть `default` маршрута. Маршрут будет использоваться для большинства приложений MVC с помощью шаблона аналогично `default` маршрута.

Шаблон маршрута `"{controller=Home}/{action=Index}/{id?}"` может соответствовать пути URL-адрес, например `/Products/Details/5` , который извлечет значения маршрута `{ controller = Products, action = Details, id = 5 }` по маркирование путь. MVC попытается найти контроллер с именем `ProductsController` и выполните действие `Details`:

```csharp
public class ProductsController : Controller
{
   public IActionResult Details(int id) { ... }
}
```

Обратите внимание, что в этом примере привязки модели будет использовать значение `id = 5` для задания `id` параметра `5` при вызове этого действия. В разделе [привязки модели](../models/model-binding.md) для получения дополнительных сведений.

С помощью `default` маршрута:

```csharp
routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
```

Шаблон маршрута:

* `{controller=Home}`Определяет `Home` по умолчанию`controller`

* `{action=Index}`Определяет `Index` по умолчанию`action`

* `{id?}`Определяет `id` как необязательные

По умолчанию и параметры необязательно маршрута не обязательно должны присутствовать в URL-адрес для сопоставления. В разделе [ссылка на шаблон маршрута](../../fundamentals/routing.md#route-template-reference) подробное описание синтаксиса шаблона маршрута.

`"{controller=Home}/{action=Index}/{id?}"`можно сопоставить URL-адрес `/` и создает значения маршрута `{ controller = Home, action = Index }`. Значения для `controller` и `action` сделать использование значений по умолчанию `id` не создает значение, поскольку отсутствует соответствующий сегмент URL-пути. MVC будет использовать эти значения маршрута для выбора `HomeController` и `Index` действия:

```csharp
public class HomeController : Controller
{
  public IActionResult Index() { ... }
}
```

С помощью данного определения контроллера и шаблон маршрута, `HomeController.Index` действие будет выполняться для любого из следующих путей URL-адрес:

* `/Home/Index/17`

* `/Home/Index`

* `/Home`

* `/`

Удобный метод `UseMvcWithDefaultRoute`:

```csharp
app.UseMvcWithDefaultRoute();
```

Можно использовать для замены:

```csharp
app.UseMvc(routes =>
{
   routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
```

`UseMvc`и `UseMvcWithDefaultRoute` добавить экземпляр `RouterMiddleware` для конвейера по промежуточного слоя. MVC не взаимодействует непосредственно с по промежуточного слоя и использует маршрутизацию для обработки запросов. MVC подключен ко всем маршрутам через экземпляр `MvcRouteHandler`. Код внутри `UseMvc` — примерно следующего содержания:

<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->

```csharp
var routes = new RouteBuilder(app);

// Add connection to MVC, will be hooked up by calls to MapRoute.
routes.DefaultHandler = new MvcRouteHandler(...);

// Execute callback to register routes.
// routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");

// Create route collection and add the middleware.
app.UseRouter(routes.Build());
```

`UseMvc`непосредственно не определяет все маршруты, он добавляет в коллекцию маршрутов для заполнителя `attribute` маршрута. Перегрузка `UseMvc(Action<IRouteBuilder>)` позволяет добавлять собственные объекты, а также поддерживает маршрутизацию атрибута.  `UseMvc`и все его вариантов добавляется заполнитель для атрибута маршрута — атрибут маршрутизации доступна всегда независимо от того, как настроить `UseMvc`. `UseMvcWithDefaultRoute`определяет маршрут по умолчанию и поддерживает маршрутизацию атрибута. [Маршрутизацией атрибутов](#attribute-routing-ref-label) раздел содержит дополнительные сведения о маршрутизации атрибута.

<a name=routing-conventional-ref-label></a>

## <a name="conventional-routing"></a>Обычная маршрутизация

`default` Маршрута:

<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->

```csharp
routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
```

Примером может служить *Обычная маршрутизация*. Мы называем этот стиль *Обычная маршрутизация* , так как он устанавливает *соглашение* для пути URL-адресов:

* Первый сегмент пути сопоставляется с именем контроллера

* второй сопоставляется с именем действия.

* Третий сегмента используется для необязательного `id` используется для сопоставления с сущностью модели

С помощью этого `default` маршрут, URL-адрес `/Products/List` сопоставляется `ProductsController.List` действия, и `/Blog/Article/17` сопоставляется `BlogController.Article`. Это сопоставление основана на именах контроллера и действия **только** и не зависит от пространства имен расположений файлов исходного кода и параметры метода.

> [!TIP]
> С помощью стандартной маршрутизации с маршрут по умолчанию позволяет быстро создавать приложения без необходимости придумать новый шаблон URL-адреса для каждого из действий, определенных пользователем. Для приложения с действиями CRUD стиля имеющие согласованности для URL-адреса между контроллерами помогают упростить код и делает более предсказуемым пользовательского интерфейса.

> [!WARNING]
> `id` Определяется как необязательный шаблон маршрута, это означает, что ваши действия могут выполняться без кода, входящее в состав URL-адреса. Обычно что произойдет, если `id` исключается из URL-адрес — что он будет присвоено `0` привязкой модели и в результате не сущности будут находиться в соответствующей базе данных `id == 0`. Атрибут маршрутизации может предоставить точного управления, чтобы сделать код, необходимый для некоторых действий, но не других. По соглашению, документация будет содержать необязательные параметры, например `id` при вероятнее всего, появятся в правильный тип использования.

## <a name="multiple-routes"></a>Несколько маршрутов

Можно добавить несколько маршрутов внутри `UseMvc` , добавив дополнительные вызовы `MapRoute`. Это позволит вам определить несколько соглашения или добавить обычной маршруты, которые выделены для определенного действия, такие как:

<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->

```csharp
app.UseMvc(routes =>
{
   routes.MapRoute("blog", "blog/{*article}",
            defaults: new { controller = "Blog", action = "Article" });
   routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
}
```

`blog` Маршрут здесь *выделенной обычной маршрута*, это означает, что он использует традиционных систем маршрутизации, но предназначенный для определенных действий. Поскольку `controller` и `action` не отображаются в шаблоне маршрута как параметры, они могут иметь только значения по умолчанию и таким образом этот маршрут всегда сопоставлять действие `BlogController.Article`.

Маршруты в коллекции маршрутов упорядочены и обрабатываются в порядке их добавления. Поэтому в этом примере `blog` маршрута будет предпринята перед `default` маршрута.

> [!NOTE]
> *Выделенные обычной маршруты* часто используют параметры универсальным маршрут, например `{*article}` для захвата оставшуюся часть URL-адрес. Это можно сделать маршрута «слишком жадное» это означает, что он совпадает с URL-адреса, которые предназначены для сопоставления с других маршрутов. Поместите маршруты «жадного» ниже в таблице маршрутов, чтобы устранить эту проблему.

### <a name="fallback"></a>Откат

В ходе обработки запроса MVC проверит, что значения маршрута может использоваться для поиска контроллера и действия в приложении. Если значения маршрута не соответствуют действие маршрута не считается соответствующим и далее маршрута будет предпринята. Это называется *резервной*, и он предназначен для упрощения случаях перекрытия обычной маршруты.

### <a name="disambiguating-actions"></a>Неоднозначными действия

Если два действия совпадают по маршрутизация, MVC должны устранить неоднозначность в выберите кандидата «рекомендации», либо исключение. Пример:

<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->

```csharp
public class ProductsController : Controller
{
   public IActionResult Edit(int id) { ... }

   [HttpPost]
   public IActionResult Edit(int id, Product product) { ... }
}
```

Этот контроллер определяет два действия, которые будет соответствовать URL-адрес `/Products/Edit/17` и маршрутизации данных `{ controller = Products, action = Edit, id = 17 }`. Это типичный шаблон для контроллеров MVC где `Edit(int)` отображает форму для изменения продукта, и `Edit(int, Product)` обрабатывает отправленной формы. Для этого потребуется MVC выбрать `Edit(int, Product)` Если запрашивается HTTP `POST` и `Edit(int)` при команду HTTP-либо еще.

`HttpPostAttribute` ( `[HttpPost]` ) — Это реализация `IActionConstraint` , разрешает только действие выделяется при HTTP-команда `POST`. Наличие `IActionConstraint` делает `Edit(int, Product)` соответствует лучше, чем `Edit(int)`, поэтому `Edit(int, Product)` будут применяться первыми.

Необходимо только создавать пользовательские `IActionConstraint` реализации в специализированных сценариев, но важно понимать роль атрибутов, например `HttpPostAttribute` -похожие атрибуты определяются для других команд HTTP. В обычной маршрутизации являются общими для действий использовать то же имя действия в том случае, если они являются частью `show form -> submit form` рабочего процесса. Удобство этот шаблон будет становятся более очевидными, просмотрев [IActionConstraint основные сведения о](#understanding-iactionconstraint) раздела.

Если соответствует несколько маршрутов, и MVC не удается найти маршрут «рекомендации», он будет вызывать `AmbiguousActionException`.

<a name=routing-route-name-ref-label></a>

### <a name="route-names"></a>Имена маршрутов

Строки `"blog"` и `"default"` в следующих примерах, имена маршрутов:


```csharp
app.UseMvc(routes =>
{
   routes.MapRoute("blog", "blog/{*article}",
               defaults: new { controller = "Blog", action = "Article" });
   routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
```

Имена маршрутов помогут маршрута логическое имя именованный маршрут может использоваться для создания URL-адресов. Это значительно упрощает создание URL-адрес при упорядочение маршрутов может стать сложным создания URL-адресов. Имена маршрутов должны быть уникальными на уровне приложения.

Имена маршрутов не оказывают влияния на URL-адрес, соответствующий или обработка запросов; они используются только для создания URL-адресов. [Маршрутизация](xref:fundamentals/routing) содержатся более подробные сведения о создании URL-адреса, включая создания URL-адресов в MVC конкретных вспомогательных методов.

<a name=attribute-routing-ref-label></a>

## <a name="attribute-routing"></a>Атрибут маршрутизации

Атрибут маршрутизации использует набор атрибутов для сопоставления действия шаблонов маршрута. В следующем примере `app.UseMvc();` используется в `Configure` метод и ни один маршрут не передается. `HomeController` Будут соответствовать набору аналогично маршрут по умолчанию URL-адреса `{controller=Home}/{action=Index}/{id?}` будет соответствовать:

```csharp
public class HomeController : Controller
{
   [Route("")]
   [Route("Home")]
   [Route("Home/Index")]
   public IActionResult Index()
   {
      return View();
   }
   [Route("Home/About")]
   public IActionResult About()
   {
      return View();
   }
   [Route("Home/Contact")]
   public IActionResult Contact()
   {
      return View();
   }
}
```

`HomeController.Index()` Действие будет выполняться для всех путей URL-адрес `/`, `/Home`, или `/Home/Index`.

> [!NOTE]
> В этом примере представлены программирования основное отличие между атрибутом и обычной маршрутизации. Маршрутизация атрибут требует дальнейшего ввода данных для определения маршрута; маршрут по умолчанию обычной более четко обрабатывает маршрутов. Тем не менее маршрутизацией атрибутов позволяет (и требует) точный контроль, из которых шаблонов маршрута применяются к каждому действию.

С атрибутом маршрутизации имя контроллера и имена действий воспроизведение **не** роли, в которой выбрано действие. В этом примере будет соответствовать же URL-адреса в предыдущем примере.

```csharp
public class MyDemoController : Controller
{
   [Route("")]
   [Route("Home")]
   [Route("Home/Index")]
   public IActionResult MyIndex()
   {
      return View("Index");
   }
   [Route("Home/About")]
   public IActionResult MyAbout()
   {
      return View("About");
   }
   [Route("Home/Contact")]
   public IActionResult MyContact()
   {
      return View("Contact");
   }
}
```

> [!NOTE]
> Выше шаблонов маршрута не определяют параметры маршрута для `action`, `area`, и `controller`. На самом деле эти параметры маршрута в атрибут маршрутов не разрешены. Поскольку шаблон маршрута уже связан с действием, не имеет смысла для синтаксического анализа имя действия по URL-адресу.

## <a name="attribute-routing-with-httpverb-attributes"></a>Атрибут маршрутизации с атрибутами Http [команда]

Атрибут маршрутизации можно также сделать использование `Http[Verb]` атрибуты, такие как `HttpPostAttribute`. Все эти атрибуты могут принимать шаблона маршрута. В этом примере показано два действий, которые соответствуют один и тот же шаблон маршрута:

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->

```csharp
[HttpGet("/products")]
public IActionResult ListProducts()
{
   // ...
}

[HttpPost("/products")]
public IActionResult CreateProduct(...)
{
   // ...
}
```

Для пути URL-адрес, например `/products` `ProductsApi.ListProducts` действие будет выполняться при HTTP-команда `GET` и `ProductsApi.CreateProduct` будет выполняться при HTTP-команда `POST`. Сначала маршрутизации атрибут соответствует URL-адрес с набором шаблонов маршрута, определенные атрибутами маршрута. После соответствует шаблон маршрута, `IActionConstraint` ограничения применяются, чтобы определить, какие действия могут быть выполнены.

> [!TIP]
> При построении REST API, довольно редко, что вы хотите использовать `[Route(...)]` на метод действия. Рекомендуется использовать более конкретного `Http*Verb*Attributes` необходимо точно определить, поддерживает API. Клиенты REST API-интерфейсов, должны знать, что пути и HTTP-команды сопоставить определенные логические операции.

Поскольку маршрут атрибута применяется к определенное действие, легко изменять параметры, необходимые в рамках определения шаблона маршрута. В этом примере `id` является неотъемлемой частью URL-адрес.

```csharp
public class ProductsApiController : Controller
{
   [HttpGet("/products/{id}", Name = "Products_List")]
   public IActionResult GetProduct(int id) { ... }
}
```

`ProductsApi.GetProduct(int)` Действие будет выполнено для пути URL-адрес, например `/products/3` , но не для пути URL-адрес, например `/products`. В разделе [маршрутизации](../../fundamentals/routing.md) полное описание шаблонов маршрута и связанные параметры.

## <a name="route-name"></a>Имя маршрута

В следующем коде определяется *имя маршрута* из `Products_List`:

```csharp
public class ProductsApiController : Controller
{
   [HttpGet("/products/{id}", Name = "Products_List")]
   public IActionResult GetProduct(int id) { ... }
}
```

Имена маршрутов можно использовать для создания URL-адрес, на основании конкретного маршрута. Имена маршрутов не оказывают влияния на поведение маршрутизации сопоставления URL-адрес и используются только для создания URL-адресов. Имена маршрутов должны быть уникальными на уровне приложения.

> [!NOTE]
> Сравните это с обычной *маршрут по умолчанию*, который определяет `id` параметр как необязательные (`{id?}`). Эта возможность точного указания API-интерфейсы имеет преимущества, например `/products` и `/products/5` для отправки для различных действий.

<a name=routing-combining-ref-label></a>

### <a name="combining-routes"></a>Объединение маршрутов

Чтобы сделать атрибут маршрутизации менее повторяющихся, атрибуты маршрута на контроллере, объединяются с атрибуты маршрута в отдельных операциях. Какой-либо шаблон маршрута на контроллере добавляются к шаблонов маршрута для действия. Делает помещения атрибута маршрута для контроллера **все** действий в контроллере маршрутизацию атрибута.

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->

```csharp
[Route("products")]
public class ProductsApiController : Controller
{
   [HttpGet]
   public IActionResult ListProducts() { ... }

   [HttpGet("{id}")]
   public ActionResult GetProduct(int id) { ... }
}
```

В этом примере URL-адрес `/products` можно сопоставить `ProductsApi.ListProducts`и URL-адрес `/products/5` может соответствовать `ProductsApi.GetProduct(int)`. Оба эти действия только соответствовать HTTP `GET` поскольку маркируются с `HttpGetAttribute`.

Направления примененных действий, которые начинаются с шаблонов `/` нельзя получить вместе с шаблоны маршрута, примененные к контроллеру. В этом примере соответствует набору URL-адрес путей, похожих на *маршрут по умолчанию*.

```csharp
[Route("Home")]
public class HomeController : Controller
{
    [Route("")]      // Combines to define the route template "Home"
    [Route("Index")] // Combines to define the route template "Home/Index"
    [Route("/")]     // Does not combine, defines the route template ""
    public IActionResult Index()
    {
        ViewData["Message"] = "Home index";
        var url = Url.Action("Index", "Home");
        ViewData["Message"] = "Home index" + "var url = Url.Action; =  " + url;
        return View();
    }

    [Route("About")] // Combines to define the route template "Home/About"
    public IActionResult About()
    {
        return View();
    }   
}
```

<a name=routing-ordering-ref-label></a>

### <a name="ordering-attribute-routes"></a>Упорядочение атрибутов маршрутов

В отличие от обычных маршруты, которые выполняются в определенном порядке маршрутизацией атрибутов строит дерево и сопоставляет все маршруты одновременно. Это аналогично тому как-если записи маршрута были помещены в идеальный порядок; Наиболее конкретные пути имеют возможность выполнения более общих маршрутов.

Например, такая как маршрут `blog/search/{topic}` является более точным определением, чем маршрут как `blog/{*article}`. Говоря логически `blog/search/{topic}` маршрута «выполняется» во-первых, по умолчанию, поскольку это только разумно упорядочение. С помощью стандартной маршрутизации, разработчик отвечает за размещение маршруты в требуемом порядке.

Маршруты атрибута можно настроить порядок с помощью `Order` всех атрибутов маршрутов платформы. Маршруты обрабатываются в соответствии с возрастающем сортировки `Order` свойство. Порядок по умолчанию `0`. Настройка маршрута с помощью `Order = -1` выполняется раньше, чем маршруты, в которых не задано заказа. Настройка маршрута с помощью `Order = 1` будет выполняться после упорядочения маршрута по умолчанию.

> [!TIP]
> Избегайте в зависимости от `Order`. Если пространстве URL-адреса требует явного порядка значений правильно направить, он скорее всего путаницу также клиентам. В целом маршрутизацией атрибутов будет выбирать правильный маршрут с соответствующим URL-адрес. Если порядок по умолчанию, используемый для создания URL-адресов не работает, используя имя маршрута, как переопределения обычно проще, чем применение `Order` свойство.

<a name=routing-token-replacement-templates-ref-label></a>

## <a name="token-replacement-in-route-templates-controller-action-area"></a>Токен замены в шаблонах маршрутов ([контроллер] [действие] [область])

Для удобства поддержки маршруты атрибута *заменить токен* путем заключения маркер в квадратные скобки (`[`, `]`). Токены `[action]`, `[area]`, и `[controller]` будут заменены значениями имя действия, имя области и имя контроллера, из действия, в котором определен маршрут. В этом примере действий может соответствовать пути URL-адресов, как описано в комментариях:

[!code-csharp[Main](routing/sample/main/Controllers/ProductsController.cs?range=7-11,13-17,20-22)]

На последнем этапе построения маршруты атрибутов происходит замена токенов. Приведенный выше пример будет функционировать так же, как следующий код:

[!code-csharp[Main](routing/sample/main/Controllers/ProductsController2.cs?range=7-11,13-17,20-22)]

Маршруты атрибутов может также быть совмещено с наследованием. Это очень мощная в сочетании с замещения токена.

```csharp
[Route("api/[controller]")]
public abstract class MyBaseController : Controller { ... }

public class ProductsController : MyBaseController
{
   [HttpGet] // Matches '/api/Products'
   public IActionResult List() { ... }

   [HttpPost("{id}")] // Matches '/api/Products/{id}'
   public IActionResult Edit(int id) { ... }
}
```

Замена токенов также применяется к имена маршрутов, определяемый маршрутов с атрибутами. `[Route("[controller]/[action]", Name="[controller]_[action]")]`Создает имя маршрута, уникальное для каждого действия.

Для сопоставления разделитель литерала замещения токена `[` или `]`, экранировать его повторяя символ (`[[` или `]]`).

<a name=routing-multiple-routes-ref-label></a>

### <a name="multiple-routes"></a>Несколько маршрутов

Атрибут маршрутизации поддерживает определение нескольких маршрутов достижения те же действия. Наиболее распространенное использование является имитируют поведение *обычной маршрут по умолчанию* как показано в следующем примере:

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->

```csharp
[Route("[controller]")]
public class ProductsController : Controller
{
   [Route("")]     // Matches 'Products'
   [Route("Index")] // Matches 'Products/Index'
   public IActionResult Index()
}
```

Размещение различных атрибутов маршрутов на контроллере означает каждый из них объединит с каждым из атрибутов маршрутов на методы действий.

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->

```csharp
[Route("Store")]
[Route("[controller]")]
public class ProductsController : Controller
{
   [HttpPost("Buy")]     // Matches 'Products/Buy' and 'Store/Buy'
   [HttpPost("Checkout")] // Matches 'Products/Checkout' and 'Store/Checkout'
   public IActionResult Buy()
}
```

При различных атрибутов маршрутов (, реализующие `IActionConstraint`) помещаются в действие, а затем объединяет каждое действие ограничение с помощью шаблона маршрута из атрибута, который она определена.

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->

```csharp
[Route("api/[controller]")]
public class ProductsController : Controller
{
   [HttpPut("Buy")]      // Matches PUT 'api/Products/Buy'
   [HttpPost("Checkout")] // Matches POST 'api/Products/Checkout'
   public IActionResult Buy()
}
```

> [!TIP]
> С помощью нескольких маршрутов на действия может показаться мощные, лучше хранить пространстве URL-адреса приложения простой и четко определенных. Используйте несколько маршрутов на действия только в том случае, при необходимости, например для поддержки существующих клиентов.

<a name=routing-attr-options></a>

### <a name="specifying-attribute-route-optional-parameters-default-values-and-constraints"></a>Указание атрибута маршрута необязательные параметры, значения по умолчанию и ограничений

Маршруты атрибута поддерживают один и тот же синтаксис встроенного как обычной маршруты, чтобы указать необязательные параметры, значения по умолчанию и ограничения.

```csharp
[HttpPost("product/{id:int}")]
public IActionResult ShowProduct(int id)
{
   // ...
}
```

В разделе [ссылка на шаблон маршрута](../../fundamentals/routing.md#route-template-reference) подробное описание синтаксиса шаблона маршрута.

<a name=routing-cust-rt-attr-irt-ref-label></a>

### <a name="custom-route-attributes-using-iroutetemplateprovider"></a>Настраиваемый маршрут атрибутов с помощью`IRouteTemplateProvider`

Все атрибуты маршрута, доступные в framework ( `[Route(...)]`, `[HttpGet(...)]` , т. д.) реализуют `IRouteTemplateProvider` интерфейса. MVC выполняет поиск атрибутов в контроллер классы и методы действий при запуске и использует те, которые реализуют приложения `IRouteTemplateProvider` для создания начального набора маршрутов.

Можно реализовать `IRouteTemplateProvider` определение собственных атрибутов маршрута. Каждый `IRouteTemplateProvider` можно задать один маршрут с помощью шаблона настраиваемый маршрут порядок и имя:

```csharp
public class MyApiControllerAttribute : Attribute, IRouteTemplateProvider
{
   public string Template => "api/[controller]";

   public int? Order { get; set; }

   public string Name { get; set; }
}
```

В приведенном выше примере атрибут автоматически задает `Template` для `"api/[controller]"` при `[MyApiController]` применяется.

<a name=routing-app-model-ref-label></a>

### <a name="using-application-model-to-customize-attribute-routes"></a>С помощью модели приложений для настройки маршрутов с атрибутами

*Модель приложения* — это объектная модель, созданными при запуске все метаданные, используемые платформой MVC для маршрутизации и выполнения действий. *Модель приложения* включает в себя все данные, собранные из атрибутов маршрутов (через `IRouteTemplateProvider`). Можно написать *соглашения* для изменения модели приложения во время запуска для настройки поведения маршрутизации. В этом разделе показан простой пример настройки маршрутизации с помощью модели приложения.

[!code-csharp[Main](routing/sample/main/NamespaceRoutingConvention.cs)]

<a name=routing-mixed-ref-label></a>

## <a name="mixed-routing-attribute-routing-vs-conventional-routing"></a>Смешанный маршрутизации: атрибут vs обычной маршрутизацию

MVC-приложений можно смешивать использование обычных и атрибут маршрутизации. Он является типичным обычной маршруты для контроллеров, обслуживающий HTML-страниц для браузеров, а атрибут маршрутизации для контроллеров, обслуживающий API-интерфейсов REST.

Традиционно либо направляются действия или атрибут маршрутизации. Размещение маршрут на контроллер или действие упрощает атрибут маршрутизации. Действия, которые определяют маршруты атрибутов не удается подключиться через обычные маршруты и наоборот. **Любой** атрибут маршрута на контроллере делает все действия в атрибуте контроллера маршрутизации.

> [!NOTE]
> Что отличает два типа маршрутизации систем — это процесс, который применяется после URL-адрес соответствует шаблону маршрута. В Обычная маршрутизация значения маршрута при поиске используются для выбора из таблицы подстановок всех обычных действий перенаправленное действия и контроллера. Атрибут маршрутизации, каждый шаблон уже связан с действием, и требуется без дальнейшего просмотра.

<a name=routing-url-gen-ref-label></a>

## <a name="url-generation"></a>Создание URL-адреса

Для создания URL-адрес ссылки на действия MVC-приложений можно использовать функции маршрутизации для создания URL-адрес. Создание URL-адреса позволяет исключить URL-адреса жесткого задания, что делает код более надежным и простым в обслуживании. В этом разделе основное внимание уделяется возможности создания URL-адрес, предоставленные MVC и рассматриваются только основные сведения о работе создания URL-адресов. В разделе [маршрутизации](../../fundamentals/routing.md) подробное описание создания URL-адресов.

`IUrlHelper` Интерфейс является базовой инфраструктуры между MVC и маршрутизации для создания URL-адресов. Вы найдете экземпляр `IUrlHelper` через `Url` свойство контроллеров, представлений и просмотр компонентов.

В этом примере `IUrlHelper` через используется интерфейс `Controller.Url` свойства для создания URL-адрес другого действия.

[!code-csharp[Main](routing/sample/main/Controllers/UrlGenerationController.cs?name=snippet_1)]

Если приложение использует значение по умолчанию обычной маршрутизации, значение `url` переменная будет пути строки URL-адреса `/UrlGeneration/Destination`. Этот URL-адрес создается по Маршрутизация путем объединения значения маршрута из текущего запроса (окружения значений), с помощью значений, переданных `Url.Action` и подстановка эти значения в шаблоне маршрута:

```
ambient values: { controller = "UrlGeneration", action = "Source" }
values passed to Url.Action: { controller = "UrlGeneration", action = "Destination" }
route template: {controller}/{action}/{id?}

result: /UrlGeneration/Destination
```

Каждый параметр маршрута в шаблоне маршрута имеет его значение заменяют соответствующие имена со значениями и окружения значения. Параметр маршрута, который имеет значение можно использовать значение по умолчанию, если он имеется, или можно пропустить, если он является необязательным (как в случае `id` в этом примере). Создании URL-адреса завершится ошибкой, если какой-либо параметр необходимые маршрута не имеет соответствующее значение. В случае создания URL-адреса для маршрута следующий маршрут, предпринимается попытка до попытки все маршруты, или найдено совпадение.

Пример `Url.Action` выше предполагается Обычная маршрутизация, но URL-адрес поколения работает точно так же при маршрутизации атрибута, однако концепции отличаются. При обычной маршрутизации значения маршрута используются для расширения шаблон и значения маршрута для `controller` и `action` обычно отображаются в этом шаблоне - это работает, поскольку соответствуют соответствовавшего маршрутизации URL-адреса *соглашение*. В маршрутизации атрибутов, значений маршрута для `controller` и `action` не могут отображаться в шаблоне - вместо этого они используются для поиска шаблон, который должен использовать.

В этом примере используется атрибут маршрутизации:

[!code-csharp[Main](routing/sample/main/StartupUseMvc.cs?name=snippet_1)]

[!code-csharp[Main](routing/sample/main/Controllers/UrlGenerationControllerAttr.cs?name=snippet_1)]

MVC создает таблицу подстановки всех действий по Маршрутизация атрибута и будет соответствовать `controller` и `action` значения для выбора маршрута шаблон, используемый для создания URL-адресов. В примере выше `custom/url/to/destination` создается.

### <a name="generating-urls-by-action-name"></a>Создание URL-адреса, имя действия

`Url.Action` (`IUrlHelper` . `Action`) и все связанные перегрузки, все они основаны на этой идеи, что вы хотите указать, что создании связи путем указания имени контроллера и действия.

> [!NOTE]
> При использовании `Url.Action`, значения текущего маршрута для `controller` и `action` задаются автоматически - значение `controller` и `action` являются частью обоих *окружения значения* **и** *значения*. Метод `Url.Action`, всегда использует текущие значения `action` и `controller` и будет создавать URL-путь к текущему действию.

Маршрутизация пытается использовать значения в окружения значения для заполнения сведений, которые не предоставляют при формировании URL-адреса. С помощью маршрута как `{a}/{b}/{c}/{d}` и окружения значения `{ a = Alice, b = Bob, c = Carol, d = David }`, маршрутизации предоставляет достаточно сведений для создания URL-адреса без дополнительных значений — поскольку направлять все параметры имеют значения. Если вы добавили значение `{ d = Donovan }`, значение `{ d = David }` будет проигнорировано, и созданный URL-адрес будет `Alice/Bob/Carol/Donovan`.

> [!WARNING]
> URL-пути являются иерархическими. В примере выше, если вы добавили значение `{ c = Cheryl }`, оба значения `{ c = Carol, d = David }` будет проигнорировано. В этом случае мы больше не задано значение `d` и создания URL-адресов не удастся. Необходимо указать нужное значение `c` и `d`.  Ожидается возникновение неполадок с маршрут по умолчанию (`{controller}/{action}/{id?}`)-это на практике, как возникает редко, но `Url.Action` будет всегда явно указывать `controller` и `action` значение.

Больше перегрузки `Url.Action` также принимают дополнительный *значения маршрута* объекта для предоставления значений для параметров маршрута, отличный от `controller` и `action`. Вы увидите наиболее часто используется с `id` как `Url.Action("Buy", "Products", new { id = 17 })`. По соглашению *значения маршрута* объект обычно является анонимный тип объекта, но это также может быть `IDictionary<>` или *обычный объект .NET*. Все значения дополнительных маршрута, не соответствующих параметров маршрута, помещаются в строку запроса.

[!code-csharp[Main](routing/sample/main/Controllers/TestController.cs)]

> [!TIP]
> Чтобы создать абсолютный URL-адрес, используйте перегрузку, которая принимает `protocol`:`Url.Action("Buy", "Products", new { id = 17 }, protocol: Request.Scheme)`

<a name=routing-gen-urls-route-ref-label></a>

### <a name="generating-urls-by-route"></a>Создание URL-адреса, маршрут

Приведенный выше код показано создание URL-адреса, передав имя контроллера и действия. `IUrlHelper`также предоставляет `Url.RouteUrl` семейство методов. Эти методы похожи на `Url.Action`, но они не копирует текущие значения `action` и `controller` значения маршрута. Укажите имя маршрута для использования конкретного маршрута для формирования URL-адрес, обычно является наиболее распространенное использование *без* указания имени контроллера или действия.

[!code-csharp[Main](routing/sample/main/Controllers/UrlGenerationControllerRouting.cs?name=snippet_1)]

<a name=routing-gen-urls-html-ref-label></a>

### <a name="generating-urls-in-html"></a>Создание URL-адреса в формате HTML

`IHtmlHelper`предоставляет `HtmlHelper` методы `Html.BeginForm` и `Html.ActionLink` для создания `<form>` и `<a>` элементы соответственно. Эти методы используют `Url.Action` метод для создания URL-адреса и принятии аналогичные аргументов. `Url.RouteUrl` Companions для `HtmlHelper` , `Html.BeginRouteForm` и `Html.RouteLink` которого имеют одинаковые функции.

TagHelpers создания URL-адресов через `form` вспомогательной функции тегов и `<a>` вспомогательной функции тегов. Они используют `IUrlHelper` для их реализации. В разделе [работа с формами](../views/working-with-forms.md) для получения дополнительной информации.

В представлениях `IUrlHelper` доступна через `Url` свойства для создания URL-адрес любого ad-hoc, не представленных выше.

<a name=routing-gen-urls-action-ref-label></a>

### <a name="generating-urls-in-action-results"></a>Создание URL-адреса в результаты действий

В вышеприведенных примерах показано использование `IUrlHelper` в контроллере, пока наиболее распространенное использование в контроллере для формирования URL-адрес как часть результата действия.

`ControllerBase` И `Controller` базовые классы предоставляют удобные методы для результатов действий, которые ссылаются на другое действие. Один обычно используется для перенаправления после принимать входные данные пользователя.

```csharp
public Task<IActionResult> Edit(int id, Customer customer)
{
    if (ModelState.IsValid)
    {
        // Update DB with new details.
        return RedirectToAction("Index");
    }
}
```

Фабричные методы результаты действия следуют схеме, к методам `IUrlHelper`.

<a name=routing-dedicated-ref-label></a>

### <a name="special-case-for-dedicated-conventional-routes"></a>Особым случаем для выделенного обычной маршрутов

Обычная маршрутизация можно использовать специальный вид определение маршрут с именем *выделенной обычной маршрута*. В следующем примере маршрут с именем `blog` выделенной обычной маршрутом.

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->

```csharp
app.UseMvc(routes =>
{
    routes.MapRoute("blog", "blog/{*article}",
        defaults: new { controller = "Blog", action = "Article" });
    routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
```

С помощью этих определений маршрутов `Url.Action("Index", "Home")` создаст URL-адрес `/` с `default` маршрута, но и почему? Догадаться значения маршрута `{ controller = Home, action = Index }` должен быть достаточно, чтобы создать URL-адрес с помощью `blog`, и результат будет `/blog?action=Index&controller=Home`.

Выделенный обычной маршруты полагаться на специальное поведение значений по умолчанию, у которых нет соответствующего параметра маршрута, который блокирует маршрута «слишком жадного» с создания URL-адресов. В этом случае значения по умолчанию, `{ controller = Blog, action = Article }`и ни `controller` , ни `action` отображается в виде параметра маршрута. При маршрутизации выполняет создания URL-адресов, предоставленных значений должны соответствовать значения по умолчанию. URL-адрес с помощью создания `blog` завершится сбоем, поскольку значения `{ controller = Home, action = Index }` не соответствуют `{ controller = Blog, action = Article }`. Маршрутизация затем возвращается к повторите `default`, которая завершается успешно.

<a name=routing-areas-ref-label></a>

## <a name="areas"></a>Области

[Области](areas.md) — это функция MVC, используемое для систематизации связанные функциональные возможности в группу как отдельное маршрутизации-пространство имен (для действий контроллеров) и структуру папок (для представления). Использование областей позволяет приложению несколько контроллеров с тем же именем — при условии, что они имеют разные *областей*. Использование областей создает иерархию с целью маршрутизации путем добавления другого параметра маршрута, `area` для `controller` и `action`. В этом разделе обсуждается, как маршрутизации взаимодействует с областями - разделе [областей](areas.md) подробные сведения об использовании области с представлениями.

В следующем примере настраивается MVC для использования обычной маршрута по умолчанию и *область маршрута* для области с именем `Blog`:

[!code-csharp[Main](routing/sample/AreasRouting/Startup.cs?name=snippet1)]

При сопоставлении URL-путь, например `/Manage/Users/AddUser`, первый маршрут сформирует значения маршрута `{ area = Blog, controller = Users, action = AddUser }`. `area` Маршрут значение создается путем значение по умолчанию для `area`, на самом деле маршрута, созданные `MapAreaRoute` эквивалентно следующему:

[!code-csharp[Main](routing/sample/AreasRouting/Startup.cs?name=snippet2)]

`MapAreaRoute`создает маршрут, используя значение по умолчанию и ограничения для `area` имени указанного область, в этом случае `Blog`. Значение по умолчанию обеспечивает всегда дает маршрута `{ area = Blog, ... }`, ограничение требует значение `{ area = Blog, ... }` для создания URL-адресов.

> [!TIP]
> Обычная маршрутизация зависит от порядка сортировки. В общем случае маршруты с областями следует разместить выше в таблице маршрутов, как они являются более точным определением, чем маршруты без области.

Используя приведенный выше пример, значения маршрута будет соответствовать следующее действие:

[!code-csharp[Main](routing/sample/AreasRouting/Areas/Blog/Controllers/UsersController.cs)]

`AreaAttribute` Является то, что обозначает контроллере в рамках области, говорят, что этот контроллер находится в `Blog` области. Контроллеры без `[Area]` атрибута не являются членами любую область и будет **не** соответствует при `area` маршрута значение предоставляется маршрутизации. В следующем примере первый контроллер в списке можно сопоставить значения маршрута `{ area = Blog, controller = Users, action = AddUser }`.

[!code-csharp[Main](routing/sample/AreasRouting/Areas/Blog/Controllers/UsersController.cs)]

[!code-csharp[Main](routing/sample/AreasRouting/Areas/Zebra/Controllers/UsersController.cs)]

[!code-csharp[Main](routing/sample/AreasRouting/Controllers/UsersController.cs)]

> [!NOTE]
> Пространство имен для каждого контроллера показано ниже для полноты - контроллеров должны иметь именования конфликт и выдают ошибку. Класс пространства имен не оказывают влияния на маршрутизации в MVC.

Первые два контроллеры являются членами области и соответствовать только обеспечивается их имя соответствующей области `area` значения маршрута. Третий контроллер не является членом любой области, а может только совпадение, если никакого значения для `area` обеспечивается маршрутизации.

> [!NOTE]
> С точки зрения соответствия *значение не*, отсутствие `area` значение такое же, как если бы значение `area` были null или является пустой строкой.

При выполнении действия внутри области, значения маршрута `area` могут быть использованы как *значение окружения* для маршрутизации, используемый для создания URL-адрес. Это означает, что по умолчанию областей выступать в *прикрепленные* для создания URL-адресов, как показано в следующем примере.

[!code-csharp[Main](routing/sample/AreasRouting/Startup.cs?name=snippet3)]

<!-- literal_block {"ids": [], "names": [], "highlight_args": {"linenostart": 1}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#", "source": "/Users/shirhatti/src/Docs/aspnet/mvc/controllers/routing/sample/AreasRouting/Areas/Duck/Controllers/UsersController.cs"} -->

[!code-csharp[Main](routing/sample/AreasRouting/Areas/Duck/Controllers/UsersController.cs)]

<a name=iactionconstraint-ref-label></a>

## <a name="understanding-iactionconstraint"></a>Основные сведения о IActionConstraint

> [!NOTE]
> Этот раздел содержит подробное на внутренние компоненты инфраструктуры и как MVC выбирает действие для выполнения. Типичное приложение не требуется пользовательский`IActionConstraint`

Скорее всего уже использовалась `IActionConstraint` даже если вы не знакомы с интерфейсом. `[HttpGet]` Атрибута и аналогичных `[Http-VERB]` атрибуты, реализующие `IActionConstraint` для ограничения выполнения метода действия.

```csharp
public class ProductsController : Controller
{
    [HttpGet]
    public IActionResult Edit() { }

    public IActionResult Edit(...) { }
}
```

При условии, что обычная маршрут по умолчанию URL-адрес `/Products/Edit` приведет к получению значения `{ controller = Products, action = Edit }`, которой будет соответствовать **оба** действий, показано ниже. В `IActionConstraint` терминология, было бы сказать, что оба эти действия относятся к типу кандидатов - оба они соответствуют данные маршрута.

При `HttpGetAttribute` выполняется, появится сообщение, *Edit()* соответствует *получить* и не совпадают с HTTP-команду. `Edit(...)` Действие не имеет ограничения, определенные и поэтому будет соответствовать любой HTTP-команду. Поэтому при условии, что `POST` — только `Edit(...)` соответствует. Но для `GET` обоих этих действий можно по-прежнему соответствуют - Однако действие с `IActionConstraint` всегда считается *лучше* чем действие без. Поэтому так как `Edit()` имеет `[HttpGet]` он считается более точным и будет выбрана, если можно сопоставить обоих этих действий.

По существу `IActionConstraint` представляет собой форму *перегрузка*, но вместо перегрузка методов с тем же именем, перегрузка между действиями, которые соответствуют же URL-адрес. Атрибут маршрутизации также использует `IActionConstraint` и может привести к действия от различных контроллеров обоих рассматриваемую кандидатов.

<a name=iactionconstraint-impl-ref-label></a>

### <a name="implementing-iactionconstraint"></a>Реализация IActionConstraint

Самый простой способ реализации `IActionConstraint` необходимо создать класс, производный от `System.Attribute` и поместите его в действия и контроллеры. MVC автоматически обнаруживать любые `IActionConstraint` , которые применяются как атрибуты. Модель приложения можно использовать для применения ограничений, а это, вероятно, самый гибкий подход, поскольку он позволяет metaprogram, как они применяются.

В следующем примере ограничение выбирает действие на основе *код страны* из данных маршрута. [Полный пример на GitHub](https://github.com/aspnet/Entropy/blob/dev/samples/Mvc.ActionConstraintSample.Web/CountrySpecificAttribute.cs).

```csharp
public class CountrySpecificAttribute : Attribute, IActionConstraint
{
    private readonly string _countryCode;

    public CountrySpecificAttribute(string countryCode)
    {
        _countryCode = countryCode;
    }

    public int Order
    {
        get
        {
            return 0;
        }
    }

    public bool Accept(ActionConstraintContext context)
    {
        return string.Equals(
            context.RouteContext.RouteData.Values["country"].ToString(),
            _countryCode,
            StringComparison.OrdinalIgnoreCase);
    }
}
```

Вы отвечаете за реализацию `Accept` метод и выбрав команду «Заказ» на ограничение для выполнения. В этом случае `Accept` возвращает `true` для обозначения действие совпадение при `country` маршрутизации совпадений значение. Это поведение отличается от `RouteValueAttribute` тем, что позволяет резервный в действие без атрибутов. Образец показывает, что если при определении `en-US` действие, а затем код страны, например `fr-FR` вернется к контроллеру более универсальный, у которого нет `[CountrySpecific(...)]` применения.

`Order` Свойство принимает решение, какую *этапа* ограничение является частью. Ограничения действия выполняются в группах, на основе `Order`. Например, все платформы получены атрибуты метода HTTP использовать тот же `Order` значение, чтобы они выполняются в том же состоянии. Может быть необходимо для реализации требуемой политик стадий.

> [!TIP]
> Чтобы определить значение для `Order` определите, следует ли применять в ограничении до методы HTTP. Более низкие показатели выполняются в первую очередь.
