---
title: Тестирование логики контроллера в ASP.NET Core
author: ardalis
description: Узнайте, как протестировать логику контроллера в ASP.NET Core с помощью Moq и xUnit.
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/testing
ms.openlocfilehash: a0073e4de361c37a6854ceaf54ffd9eaea4837d4
ms.sourcegitcommit: 43bd79667bbdc8a07bd39fb4cd6f7ad3e70212fb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2018
ms.locfileid: "34567053"
---
# <a name="test-controller-logic-in-aspnet-core"></a>Тестирование логики контроллера в ASP.NET Core

Автор: [Стив Смит](https://ardalis.com/) (Steve Smith)

Контроллеры в приложениях ASP.NET MVC должны быть компактными и направленными на решение задач пользовательского интерфейса. Большие контроллеры, не связанные с задачами пользовательского интерфейса, труднее тестировать и поддерживать.

[Просмотреть или скачать образец с GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a>Тестирование контроллеров

Контроллеры — это центральный элемент любого приложения ASP.NET Core MVC. По этой причине необходима уверенность в том, что они работают, как планировалось. С помощью автоматических тестов можно убедиться в этом и обнаружить ошибки до ввода контроллеров в рабочую среду. Важно избегать реализации в контроллерах лишних функций, а тесты должны быть ориентированы только на функции контроллеров.

Логике контролера следует быть минимальной и не связанной с бизнес-логикой или проблемами инфраструктуры (например, с доступом к данным). Тестировать нужно логику контроллера, а не платформу. Тестируйте *работу* контроллера на основе допустимых и недопустимых значений. Проверяйте ответы контроллера на основе результата выполняемой им бизнес-операции.

Типичные функции контроллера:

* Проверяет значение `ModelState.IsValid`.
* Возвращает ответ об ошибке, если состояние `ModelState` недопустимо.
* Возвращает бизнес-элемент из хранилища.
* Выполняет действие с бизнес-элементом.
* Сохраняет бизнес-элемент в хранилище.
* Возвращает соответствующий результат `IActionResult`.

## <a name="unit-testing"></a>Модульное тестирование

[Модульное тестирование](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) предполагает тестирование части приложения изолированно от его инфраструктуры и зависимостей. При модульном тестировании логики контроллера тестируется только содержимое отдельного действия, но не поведение его зависимостей или сама платформа. Выполняя модульное тестирование действий контроллера, следует сосредоточиться только на его поведении. В рамках модульного тестирования контроллера не учитываются такие аспекты, как [фильтры](filters.md), [маршрутизация](../../fundamentals/routing.md) или [привязка модели](../models/model-binding.md). Благодаря нацеленности на отдельный компонент модульные тесты, как правило, проще создавать, а выполняются они быстрее. Правильно составленный набор модульных тестов можно выполнять часто без значительных затрат. Однако модульные тесты не выявляют проблемы с взаимодействием между компонентами. Для этого используется [тестирование интеграции](xref:mvc/controllers/testing#integration-testing).

Если вы создаете пользовательские фильтры, маршруты и т. д., их следует подвергать модульному тестированию, но не в рамках тестирования определенного действия контроллера. Они должны тестироваться отдельно.

> [!TIP]
> [Создавайте и выполняйте модульные тесты с помощью Visual Studio](/visualstudio/test/unit-test-your-code).

Для демонстрации модульного тестирования рассмотрим представленный ниже контроллер. Он выводит список сеансов мозгового штурма и позволяет создавать такие сеансы с помощью запроса POST.

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

Контроллер следует [принципу явных зависимостей](http://deviq.com/explicit-dependencies-principle/), предполагающему предоставление экземпляра `IBrainstormSessionRepository` при внедрении зависимостей. Благодаря этому его достаточно легко протестировать с помощью платформы макетов объектов, например [Moq](https://www.nuget.org/packages/Moq/). В методе `HTTP GET Index` нет циклов или ветвления, и он вызывает лишь один метод. Чтобы протестировать этот метод `Index`, необходимо проверить, возвращается ли результат `ViewResult` с объектом `ViewModel` из метода `List` репозитория.

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

Метод `HomeController` `HTTP POST Index` (показанный выше) должен проверять, выполняются ли следующие действия:

* Метод действия возвращает результат `ViewResult` типа "Неверный запрос" с соответствующими данными, если свойство `ModelState.IsValid` имеет значение `false`.

* Вызывается метод `Add` репозитория, и возвращается результат `RedirectToActionResult` с правильными аргументами, если свойство `ModelState.IsValid` имеет значение true.

Недопустимое состояние модели можно проверить, добавив ошибки с помощью метода `AddModelError`, как показано в первом тесте ниже.

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

Первый тест проверяет, возвращается ли тот же результат `ViewResult`, что и для запроса `GET`, если состояние `ModelState` недопустимо. Обратите внимание на то, что он не пытается передать недопустимую модель. Это бы в любом случае не удалось, так как привязка модели не запущена (хотя [тест интеграции](xref:mvc/controllers/testing#integration-testing) использовал бы тестовую привязку модели). В этом случае привязка модели не тестируется. Эти модульные тесты проверяют только действия, выполняемые кодом в методе действия.

Второй тест проверяет, добавляется ли новый объект `BrainstormSession` (через репозиторий) и возвращает ли метод результат `RedirectToActionResult` с ожидаемыми свойствами, если состояние `ModelState` допустимо. Макеты вызовов, которые не выполняются, обычно игнорируются, но вызов `Verifiable` в конце вызова Setup позволяет проверить его в тесте. Для этого служит вызов метода `mockRepo.Verify`, в результате которого тест будет считаться непройденным, если требуемый метод не был вызван.

> [!NOTE]
> Библиотека Moq, используемая в этом примере, позволяет легко сочетать проверяемые (строгие) макеты и непроверяемые (которые также называют нестрогими макетами или заглушками). Узнайте больше о [настройке поведения макетов с помощью Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).

Другой контроллер в приложении выводит сведения, связанные с определенным сеансом мозгового штурма. Он содержит логику для обработки недопустимых значений id:

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

Действие контроллера имеет три тестируемых случая, по одному на каждый оператор `return`:

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

Приложение предоставляет функциональные возможности в виде веб-интерфейса API (список идей, связанных с сеансом мозгового штурма, и метод для добавления новых идей в сеанс):

<a name="ideas-controller"></a>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

Метод `ForSession` возвращает список типов `IdeaDTO`. Старайтесь не возвращать бизнес-элементы непосредственно через вызовы API, так как они часто содержат больше данных, чем требуется клиенту API, и связывают внутреннюю модель предметной области приложения с интерфейсом API, доступным извне, чего следует избегать. Сопоставлять элементы предметной области и типы, возвращаемые по сети, можно вручную (с помощью инструкции LINQ `Select`, как показано здесь) или с помощью такой библиотеки, как [AutoMapper](https://github.com/AutoMapper/AutoMapper).

Модульные тесты для методов API `Create` и `ForSession`:

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

Как уже говорилось ранее, чтобы протестировать поведение метода в случае, если состояние `ModelState` недопустимо, следует добавить ошибку модели в контроллер в рамках теста. Не пытайтесь тестировать проверку модели или привязку модели с помощью модульных тестов — проверяйте только поведение метода действия при определенных значениях `ModelState`.

Во втором тесте предполагается, что репозиторий возвращает значение NULL, поэтому макет репозитория настроен так, чтобы возвращать значение NULL. Создавать тестовую базу данных (в памяти или где-либо еще) и запрос, возвращающий этот результат, не нужно — это можно сделать в одном операторе, как показано в примере.

Последний тест проверяет, вызывается ли метод `Update` репозитория. Как и ранее, макет вызывается с помощью метода `Verifiable`, а затем вызывается метод `Verify` макета репозитория для подтверждения выполнения проверяемого метода. Проверка того, сохранил ли метод `Update` данные, не относится к задачам модульного теста. Это можно сделать с помощью теста интеграции.

## <a name="integration-testing"></a>Тестирование интеграции

[Тестирование интеграции](xref:test/integration-tests) предназначено для проверки того, правильно ли работают отдельные модули приложения вместе. Как правило, все, что можно проверить с помощью модульного теста, можно также проверить с помощью теста интеграции, но не наоборот. Однако тесты интеграции обычно выполняются гораздо медленнее модульных тестов. Поэтому лучше всего проверить все, что можно, с помощью модульных тестов, а тесты интеграции применять для сценариев, предусматривающих совместную работу.

Хотя макеты объектов могут быть полезны, они редко используются в тестах интеграции. При модульном тестировании макеты объектов — это эффективный способ управлять поведением компонентов, не относящихся к тестируемому модулю, но связанных с его работой. В тесте интеграции для проверки правильной работы всей подсистемы используются реальные компоненты.

### <a name="application-state"></a>Состояние приложения

Важным моментом при тестировании интеграции является настройка состояния приложения. Тесты должны выполняться независимо друг от друга, поэтому в начале каждого теста приложение должно находиться в известном состоянии. Если приложение не использует базу данных и не имеет хранилища, проблемы в этом может не быть. Однако большинство реальных приложений сохраняют свое состояние в каком-либо хранилище данных, поэтому изменения, внесенные одним из тестов, могут влиять на другой, если не сбросить хранилище данных. С помощью встроенного сервера `TestServer` очень легко размещать приложения ASP.NET Core в тестах интеграции, но это необязательно обеспечивает доступ к данным, используемым приложением. Если вы используете реальную базу данных, один из подходов состоит в подключении приложения к тестовой базе данных, которая доступна для тестов, и ее сбросе в известное состояние перед выполнением каждого теста.

В этом примере приложения используется поддержка InMemoryDatabase, предоставляемая платформой Entity Framework Core, поэтому к нему нельзя просто подключиться из тестового проекта. Вместо этого предоставим доступ к методу `InitializeDatabase` в классе `Startup` приложения. Он будет вызываться при запуске приложения в среде `Development`. Тесты интеграции автоматически получают возможность пользоваться им, если они задают среду `Development`. Теперь не нужно беспокоиться о сбросе базы данных, так как база данных InMemoryDatabase будет сбрасываться каждый раз при перезапуске приложения.

Класс `Startup`:

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

Как вы увидите, метод `GetTestSession` будет часто использоваться в приведенных далее тестах интеграции.

### <a name="accessing-views"></a>Доступ к представлениям

Каждый класс теста интеграции настраивает сервер `TestServer`, на котором будет выполняться приложение ASP.NET Core. По умолчанию `TestServer` размещает веб-приложение в папке, в которой он выполняется. В данном случае это папка тестового проекта. Поэтому при попытке протестировать действия контроллера, возвращающие `ViewResult`, может возникнуть следующая ошибка:

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

Чтобы устранить эту проблему, необходимо настроить корень содержимого сервера так, чтобы он мог находить представления тестируемого проекта. Для этого следует вызвать метод `UseContentRoot` в классе `TestFixture`, как показано ниже.

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

Класс `TestFixture` отвечает за настройку и создание сервера `TestServer`, а также настройку взаимодействия клиента `HttpClient` с `TestServer`. Каждый тест интеграции использует свойство `Client` для подключения к тестовому серверу и выполнения запроса.

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

В первом приведенном выше тесте `responseString` содержит преобразованный для просмотра код HTML из представления, который можно проверить на соответствие ожидаемым результатам.

Второй тест формирует запрос POST формы с уникальным именем сеанса, отправляет его в приложение, после чего проверяет, возвращено ли ожидаемое перенаправление.

### <a name="api-methods"></a>Методы API

Если приложение предоставляет веб-интерфейсы API, желательно проверять правильность их выполнения с помощью автоматических тестов. Встроенный класс `TestServer` позволяет легко тестировать веб-интерфейсы API. Если методы API используют привязку модели, обязательно следует проверять свойство `ModelState.IsValid`. Тесты интеграции — подходящее средство для проверки того, правильно ли работает проверка модели.

Следующий набор тестов предназначен для проверки метода `Create` в представленном выше классе [IdeasController](xref:mvc/controllers/testing#ideas-controller):

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

В отличие от тестов интеграции для действий, возвращающих представления HTML, методы веб-интерфейсов API, которые возвращают результаты, обычно можно десериализировать как строго типизированные объекты. Это продемонстрировано в последнем из приведенных выше тестов. В этом случае тест десериализирует результат в экземпляр `BrainstormSession` и проверяет, правильно ли идея была добавлена в коллекцию идей.

Дополнительные примеры тестов интеграции можно найти в [образце проекта](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample) для этой статьи.
