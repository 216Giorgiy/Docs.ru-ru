---
title: "Тестирование логики контроллер в ASP.NET Core"
author: ardalis
description: "Дополнительные сведения о тестировании логика контроллеров в ASP.NET Core заказа и xUnit."
keywords: "ASP.NET Core контроллера, тестирования, тестирование, модульный тест, модульное тестирование, интеграции тестирования, интеграционного тестирования, xUnit"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: dd4135ec-2b15-410c-b3fb-3d12eed4a1ac
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/testing
ms.openlocfilehash: d5b2bd0200082000aeaf8015cfff9c8c1ec1bdd9
ms.sourcegitcommit: 5355c96a1768e5a1d5698a98c190e7addcc4ded5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/05/2017
---
# <a name="testing-controller-logic-in-aspnet-core"></a><span data-ttu-id="153f5-104">Тестирование логики контроллер в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="153f5-104">Testing controller logic in ASP.NET Core</span></span>

<span data-ttu-id="153f5-105">По [Стив Смит](http://ardalis.com)</span><span class="sxs-lookup"><span data-stu-id="153f5-105">By [Steve Smith](http://ardalis.com)</span></span>

<span data-ttu-id="153f5-106">Контроллеры в приложениях ASP.NET MVC должно быть небольшим и ориентированы на проблемы пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="153f5-106">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="153f5-107">Большие контроллеры, работающие с аспектами без пользовательского интерфейса труднее тестировать и поддерживать.</span><span class="sxs-lookup"><span data-stu-id="153f5-107">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="153f5-108">Просмотреть или загрузить пример из GitHub</span><span class="sxs-lookup"><span data-stu-id="153f5-108">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="153f5-109">Контроллеры тестирования</span><span class="sxs-lookup"><span data-stu-id="153f5-109">Testing controllers</span></span>

<span data-ttu-id="153f5-110">Контроллеры являются центральным элементом любого приложения ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="153f5-110">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="153f5-111">Таким образом должен иметь уверенность, что они работают должным образом для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="153f5-111">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="153f5-112">Автоматические тесты можно получить у этого достоверности и выявить ошибки, прежде чем они достигнут рабочей.</span><span class="sxs-lookup"><span data-stu-id="153f5-112">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="153f5-113">Очень важно избегать размещения ненужные обязанности в контроллерах и убедитесь, тесты внимание только на контроллере обязанности.</span><span class="sxs-lookup"><span data-stu-id="153f5-113">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="153f5-114">Логика контроллера должно быть минимальным и не сосредоточиться на логике или инфраструктуры бизнесе (например, доступ к данным).</span><span class="sxs-lookup"><span data-stu-id="153f5-114">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="153f5-115">Проверьте логику контроллера, не framework.</span><span class="sxs-lookup"><span data-stu-id="153f5-115">Test controller logic, not the framework.</span></span> <span data-ttu-id="153f5-116">Тест как контроллер *ведет себя* зависимости от входных данных допустимое или недопустимое.</span><span class="sxs-lookup"><span data-stu-id="153f5-116">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="153f5-117">Проверка на основе результатов бизнес-операции, выполняемые ею ответы контроллера.</span><span class="sxs-lookup"><span data-stu-id="153f5-117">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="153f5-118">Обязанности типичные контроллера:</span><span class="sxs-lookup"><span data-stu-id="153f5-118">Typical controller responsibilities:</span></span>

* <span data-ttu-id="153f5-119">Проверьте `ModelState.IsValid`.</span><span class="sxs-lookup"><span data-stu-id="153f5-119">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="153f5-120">Вернуть ответ с ошибкой, если `ModelState` является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="153f5-120">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="153f5-121">Получить бизнес-сущность из хранилища сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="153f5-121">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="153f5-122">Выполните действие в бизнес-сущности.</span><span class="sxs-lookup"><span data-stu-id="153f5-122">Perform an action on the business entity.</span></span>
* <span data-ttu-id="153f5-123">Сохраните бизнес-сущности сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="153f5-123">Save the business entity to persistence.</span></span>
* <span data-ttu-id="153f5-124">Возвращает соответствующий `IActionResult`.</span><span class="sxs-lookup"><span data-stu-id="153f5-124">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="153f5-125">Модульное тестирование</span><span class="sxs-lookup"><span data-stu-id="153f5-125">Unit testing</span></span>

<span data-ttu-id="153f5-126">[Модульное тестирование](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) включает в себя проверку частью приложения отдельно от инфраструктуры и зависимости.</span><span class="sxs-lookup"><span data-stu-id="153f5-126">[Unit testing](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="153f5-127">При тестировании модульное тестирование логику контроллера, содержимое одним действием, не поведения из ее зависимостей или сам платформы.</span><span class="sxs-lookup"><span data-stu-id="153f5-127">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="153f5-128">Как модульного тестирования ваши действия контроллера, убедитесь, что сосредоточиться только на его поведение.</span><span class="sxs-lookup"><span data-stu-id="153f5-128">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="153f5-129">Модульный тест контроллер позволяет избежать таких вещей, как [фильтры](filters.md), [маршрутизации](../../fundamentals/routing.md), или [привязки модели](../models/model-binding.md).</span><span class="sxs-lookup"><span data-stu-id="153f5-129">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="153f5-130">Обычно сосредоточиться на тестировании только одно модульные тесты — просто для записи и быстро выполнять.</span><span class="sxs-lookup"><span data-stu-id="153f5-130">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="153f5-131">Грамотно сконструированные набор модульные тесты могут выполняться без большой нагрузки часто.</span><span class="sxs-lookup"><span data-stu-id="153f5-131">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="153f5-132">Тем не менее, модульные тесты не обнаруживают проблемы во взаимодействии между компонентами, которая является целью [интеграционного тестирования](xref:mvc/controllers/testing#integration-testing).</span><span class="sxs-lookup"><span data-stu-id="153f5-132">However, unit tests do not detect issues in the interaction between components, which is the purpose of [integration testing](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="153f5-133">При написании настраиваемые фильтры, маршрутов и т. д следует модульный тест их, но не как часть тесты на действие конкретном контроллере.</span><span class="sxs-lookup"><span data-stu-id="153f5-133">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="153f5-134">Их необходимо тестировать отдельно.</span><span class="sxs-lookup"><span data-stu-id="153f5-134">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="153f5-135">[Создание и запуск модульных тестов с помощью Visual Studio](https://www.visualstudio.com/get-started/code/create-and-run-unit-tests-vs).</span><span class="sxs-lookup"><span data-stu-id="153f5-135">[Create and run unit tests with Visual Studio](https://www.visualstudio.com/get-started/code/create-and-run-unit-tests-vs).</span></span>

<span data-ttu-id="153f5-136">Чтобы продемонстрировать модульного тестирования, просмотрите следующий контроллер.</span><span class="sxs-lookup"><span data-stu-id="153f5-136">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="153f5-137">Здесь отображается список мозговой сеансы и новые мозговой сеансов с помощью POST:</span><span class="sxs-lookup"><span data-stu-id="153f5-137">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

<span data-ttu-id="153f5-138">[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]</span><span class="sxs-lookup"><span data-stu-id="153f5-138">[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]</span></span>

<span data-ttu-id="153f5-139">Следующий контроллер [принцип явные зависимости](http://deviq.com/explicit-dependencies-principle/), ожидается внедрения зависимостей снабжать экземпляр `IBrainstormSessionRepository`.</span><span class="sxs-lookup"><span data-stu-id="153f5-139">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="153f5-140">Это позволяет просто для тестирования с помощью платформы макетов объектов, таких как [заказа](https://www.nuget.org/packages/Moq/).</span><span class="sxs-lookup"><span data-stu-id="153f5-140">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="153f5-141">`HTTP GET Index` Метод не имеет цикла или ветвления и только вызовов одного метода.</span><span class="sxs-lookup"><span data-stu-id="153f5-141">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="153f5-142">Чтобы проверить это `Index` метод, необходимо проверить, `ViewResult` возвращается, с `ViewModel` из репозитория `List` метод.</span><span class="sxs-lookup"><span data-stu-id="153f5-142">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

<span data-ttu-id="153f5-143">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]</span><span class="sxs-lookup"><span data-stu-id="153f5-143">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]</span></span>

<span data-ttu-id="153f5-144">`HomeController` `HTTP POST Index` Следует проверить (в приведенном выше примере):</span><span class="sxs-lookup"><span data-stu-id="153f5-144">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="153f5-145">Метод действия возвращает неправильный запрос `ViewResult` с соответствующими данными при `ModelState.IsValid` —`false`</span><span class="sxs-lookup"><span data-stu-id="153f5-145">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="153f5-146">`Add` Вызове метода в репозиторий и `RedirectToActionResult` возвращается с правильные аргументы при `ModelState.IsValid` имеет значение true.</span><span class="sxs-lookup"><span data-stu-id="153f5-146">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="153f5-147">Состояние недопустимой модели можно протестировать путем добавления ошибок с помощью `AddModelError` показанное в первом тесте.</span><span class="sxs-lookup"><span data-stu-id="153f5-147">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

<span data-ttu-id="153f5-148">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]</span><span class="sxs-lookup"><span data-stu-id="153f5-148">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]</span></span>

<span data-ttu-id="153f5-149">Первый тест подтверждает при `ModelState` не является допустимым, же `ViewResult` возвращается как для `GET` запроса.</span><span class="sxs-lookup"><span data-stu-id="153f5-149">The first test confirms when `ModelState` is not valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="153f5-150">Обратите внимание, что тест не пытался передать недопустимый модели.</span><span class="sxs-lookup"><span data-stu-id="153f5-150">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="153f5-151">Все равно не работает, так как привязки модели не выполняется (хотя [интеграционного теста](xref:mvc/controllers/testing#integration-testing) используется привязка модели упражнения).</span><span class="sxs-lookup"><span data-stu-id="153f5-151">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="153f5-152">В этом случае привязка модели не тестируется.</span><span class="sxs-lookup"><span data-stu-id="153f5-152">In this case, model binding is not being tested.</span></span> <span data-ttu-id="153f5-153">Эти модульные тесты только тестировании делает код в метод действия.</span><span class="sxs-lookup"><span data-stu-id="153f5-153">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="153f5-154">Второй тест проверяет, что при `ModelState` является допустимым, новый `BrainstormSession` добавляется (с помощью репозитория), а метод возвращает `RedirectToActionResult` с ожидаемыми свойствами.</span><span class="sxs-lookup"><span data-stu-id="153f5-154">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="153f5-155">Макеты вызовов, которые не вызываются обычно игнорируется, но вызывающий `Verifiable` в конце установки вызова позволяет проверить в тесте.</span><span class="sxs-lookup"><span data-stu-id="153f5-155">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="153f5-156">Это делается с помощью вызова метода `mockRepo.Verify`, которой будет сбоя теста, если ожидаемый метод не был вызван.</span><span class="sxs-lookup"><span data-stu-id="153f5-156">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method was not called.</span></span>

> [!NOTE]
> <span data-ttu-id="153f5-157">Библиотека заказа, используемый в этом примере упрощает смешивания проверяемый или «strict» макеты с не поддающейся фиктивных (также называется «свободный» фиктивных заглушки).</span><span class="sxs-lookup"><span data-stu-id="153f5-157">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="153f5-158">Дополнительные сведения о [Настройка поведения макетов с заказа](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span><span class="sxs-lookup"><span data-stu-id="153f5-158">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="153f5-159">Другой контроллер в приложении отображаются сведения, относящиеся к мозговой определенного сеанса.</span><span class="sxs-lookup"><span data-stu-id="153f5-159">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="153f5-160">Она содержит логику для работы с недопустимым идентификатором значения.</span><span class="sxs-lookup"><span data-stu-id="153f5-160">It includes some logic to deal with invalid id values:</span></span>

<span data-ttu-id="153f5-161">[!code-csharp[Main](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]</span><span class="sxs-lookup"><span data-stu-id="153f5-161">[!code-csharp[Main](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]</span></span>

<span data-ttu-id="153f5-162">Действие контроллер имеет три случая, чтобы проверить, по одной для каждого `return` инструкции:</span><span class="sxs-lookup"><span data-stu-id="153f5-162">The controller action has three cases to test, one for each `return` statement:</span></span>

<span data-ttu-id="153f5-163">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]</span><span class="sxs-lookup"><span data-stu-id="153f5-163">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]</span></span>

<span data-ttu-id="153f5-164">Приложение предоставляет функциональные возможности, что веб-API (список планов, связанные с мозговой сеанса, а также метод для добавления новых идей в сеансе):</span><span class="sxs-lookup"><span data-stu-id="153f5-164">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name=ideas-controller></a>

<span data-ttu-id="153f5-165">[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]</span><span class="sxs-lookup"><span data-stu-id="153f5-165">[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]</span></span>

<span data-ttu-id="153f5-166">`ForSession` Метод возвращает список `IdeaDTO` типов.</span><span class="sxs-lookup"><span data-stu-id="153f5-166">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="153f5-167">Старайтесь не возвращать вашей бизнес-сущности домена напрямую через вызовы API, так как часто они включают больше данных, чем API клиента требуется, и они без необходимости подключать модель внутреннего домена приложения с помощью API, доступ к которым предоставляется извне.</span><span class="sxs-lookup"><span data-stu-id="153f5-167">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="153f5-168">Сопоставление между сущностями домена и типов, будет возвращать по сети можно сделать вручную (с использованием LINQ `Select` как показано ниже) или с помощью библиотеки, такой как [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span><span class="sxs-lookup"><span data-stu-id="153f5-168">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="153f5-169">Модульные тесты для `Create` и `ForSession` методов API:</span><span class="sxs-lookup"><span data-stu-id="153f5-169">The unit tests for the `Create` and `ForSession` API methods:</span></span>

<span data-ttu-id="153f5-170">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]</span><span class="sxs-lookup"><span data-stu-id="153f5-170">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]</span></span>

<span data-ttu-id="153f5-171">Как уже говорилось ранее, чтобы проверить поведение метода при `ModelState` является недопустимым, добавить в контроллер ошибку модели в рамках теста.</span><span class="sxs-lookup"><span data-stu-id="153f5-171">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="153f5-172">Не пытайтесь проверить привязки модели проверки или модели в модульные тесты — просто проверить поведение метода действия при возникновении конфликтов с конкретным `ModelState` значение.</span><span class="sxs-lookup"><span data-stu-id="153f5-172">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="153f5-173">Второй тест зависит от репозитория, возвращение null, поэтому макета репозитория должен возвращать значение null.</span><span class="sxs-lookup"><span data-stu-id="153f5-173">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="153f5-174">Нет необходимости для создания тестовой базы данных (в памяти или иным способом) и создайте запрос, который будет возвращать этот результат — это можно сделать в одной инструкции, как показано.</span><span class="sxs-lookup"><span data-stu-id="153f5-174">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="153f5-175">Последней проверки проверяет, что репозитория `Update` вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="153f5-175">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="153f5-176">Как это делалось ранее макетов вызывается с `Verifiable` и затем макеты репозитория `Verify` метод вызывается для подтверждения проверяемый метод был выполнен.</span><span class="sxs-lookup"><span data-stu-id="153f5-176">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="153f5-177">Это не модульного теста ответственность за убедитесь, что `Update` метод сохранены данные, может выполняться с интеграционного теста.</span><span class="sxs-lookup"><span data-stu-id="153f5-177">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="153f5-178">Тестирование интеграции</span><span class="sxs-lookup"><span data-stu-id="153f5-178">Integration testing</span></span>

<span data-ttu-id="153f5-179">[Интеграционного тестирования](../../testing/integration-testing.md) сделано для отдельных модулей в работу приложения правильно друг с другом.</span><span class="sxs-lookup"><span data-stu-id="153f5-179">[Integration testing](../../testing/integration-testing.md) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="153f5-180">Как правило все, что можно проверить с помощью модульного теста, можно проверить с помощью интеграционного теста, но обратное не так.</span><span class="sxs-lookup"><span data-stu-id="153f5-180">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="153f5-181">Однако интеграционные тесты обычно гораздо медленнее, чем модульные тесты.</span><span class="sxs-lookup"><span data-stu-id="153f5-181">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="153f5-182">Таким образом рекомендуется проверить все, что можно с помощью модульных тестов и использовать интеграционные тесты для сценариев, предполагающих несколькими участниками.</span><span class="sxs-lookup"><span data-stu-id="153f5-182">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="153f5-183">Несмотря на то, что они по-прежнему могут оказаться полезными, макетов объектов редко используются в тесты интеграции.</span><span class="sxs-lookup"><span data-stu-id="153f5-183">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="153f5-184">В модульных тестах макетов объектов являются эффективным способом для управления поведением участники совместной работы за пределами тестируемой единицы в целях тестирования.</span><span class="sxs-lookup"><span data-stu-id="153f5-184">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="153f5-185">В к интеграционному тесту чтобы убедиться, что подсистема целиком вместе правильно работает используются реальные участники совместной работы.</span><span class="sxs-lookup"><span data-stu-id="153f5-185">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="153f5-186">Состояние приложения</span><span class="sxs-lookup"><span data-stu-id="153f5-186">Application state</span></span>

<span data-ttu-id="153f5-187">Одно важное требование при выполнении интеграционного тестирования — Установка состояния приложения.</span><span class="sxs-lookup"><span data-stu-id="153f5-187">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="153f5-188">Тесты должны выполняться независимо друг от друга, и поэтому каждого теста должно начинаться с приложением в известном состоянии.</span><span class="sxs-lookup"><span data-stu-id="153f5-188">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="153f5-189">Если приложения не используют базу данных или любой сохраняемости, это может оказаться проблемой.</span><span class="sxs-lookup"><span data-stu-id="153f5-189">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="153f5-190">Тем не менее большинство реальных приложений сохранить их состояние для какого-либо вида хранилища данных, поэтому любые изменения, произведенные в один тест может повлиять другого теста, пока не будет сброшен в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="153f5-190">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="153f5-191">С помощью встроенной `TestServer`, очень проста для узла приложения ASP.NET Core наши тесты интеграции, но, не предоставляет обязательно доступ к данным, он будет использовать.</span><span class="sxs-lookup"><span data-stu-id="153f5-191">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="153f5-192">Если вы используете существующую базу данных, один подход заключается в приложение соединиться с базой данных теста, который тесты могут открывать и убедитесь, сбрасывается в известное состояние до выполнения каждого теста.</span><span class="sxs-lookup"><span data-stu-id="153f5-192">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="153f5-193">В этом образце приложения используется поддержка InMemoryDatabase Entity Framework Core, поэтому я просто не может подключиться к нему из тестового проекта.</span><span class="sxs-lookup"><span data-stu-id="153f5-193">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="153f5-194">Вместо этого я предоставлять `InitializeDatabase` метода в приложении `Startup` класс, который вызова при запуске приложения, если он находится в `Development` среде.</span><span class="sxs-lookup"><span data-stu-id="153f5-194">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="153f5-195">Интеграция тестов автоматически выиграть от этого при условии, что они установить среду `Development`.</span><span class="sxs-lookup"><span data-stu-id="153f5-195">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="153f5-196">Не нужно беспокоиться о сбросе базы данных, так как InMemoryDatabase сбрасывается при каждом перезапуске приложения.</span><span class="sxs-lookup"><span data-stu-id="153f5-196">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="153f5-197">`Startup` Класса:</span><span class="sxs-lookup"><span data-stu-id="153f5-197">The `Startup` class:</span></span>

<span data-ttu-id="153f5-198">[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]</span><span class="sxs-lookup"><span data-stu-id="153f5-198">[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]</span></span>

<span data-ttu-id="153f5-199">Вы увидите `GetTestSession` метода часто используются в приведенных ниже тестах интеграции.</span><span class="sxs-lookup"><span data-stu-id="153f5-199">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="153f5-200">Доступ к представлениям</span><span class="sxs-lookup"><span data-stu-id="153f5-200">Accessing views</span></span>

<span data-ttu-id="153f5-201">Настраивает каждого класса теста интеграции `TestServer` , будет выполняться приложение ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="153f5-201">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="153f5-202">По умолчанию `TestServer` размещает веб-приложения в папке, где он запущен - в этом случае папки проекта.</span><span class="sxs-lookup"><span data-stu-id="153f5-202">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="153f5-203">Таким образом, при попытке проверить действия контроллера, которые возвращают `ViewResult`, появится это сообщение об ошибке:</span><span class="sxs-lookup"><span data-stu-id="153f5-203">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "none"} -->

```none
The view 'Index' was not found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="153f5-204">Чтобы устранить эту проблему, необходимо настроить содержимое корневого сервера, чтобы он мог найти представления для тестируемого проекта.</span><span class="sxs-lookup"><span data-stu-id="153f5-204">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="153f5-205">Это делается путем вызова `UseContentRoot` в `TestFixture` класса, показано ниже:</span><span class="sxs-lookup"><span data-stu-id="153f5-205">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

<span data-ttu-id="153f5-206">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]</span><span class="sxs-lookup"><span data-stu-id="153f5-206">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]</span></span>

<span data-ttu-id="153f5-207">`TestFixture` Класс отвечает за настройку и создание `TestServer`, задает `HttpClient` для взаимодействия с `TestServer`.</span><span class="sxs-lookup"><span data-stu-id="153f5-207">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="153f5-208">Каждая интеграции проверяет использует `Client` свойства для подключения к серверу тест и выполните запрос.</span><span class="sxs-lookup"><span data-stu-id="153f5-208">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

<span data-ttu-id="153f5-209">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]</span><span class="sxs-lookup"><span data-stu-id="153f5-209">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]</span></span>

<span data-ttu-id="153f5-210">В первом тесте выше `responseString` содержит фактический созданный HTML в представлении могут проверяться для подтверждения того, он содержит ожидаемые результаты.</span><span class="sxs-lookup"><span data-stu-id="153f5-210">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="153f5-211">Второй тест создает формы POST с уникальное имя сеанса и отправляет его в приложение, а затем проверяет, возвращается ожидаемый перенаправления.</span><span class="sxs-lookup"><span data-stu-id="153f5-211">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="153f5-212">Методы API</span><span class="sxs-lookup"><span data-stu-id="153f5-212">API methods</span></span>

<span data-ttu-id="153f5-213">Если ваше приложение предоставляет веб-API, его следует автоматических тестов подтверждения, они выполняются, как ожидалось.</span><span class="sxs-lookup"><span data-stu-id="153f5-213">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="153f5-214">Встроенная `TestServer` облегчает тестирование веб-API.</span><span class="sxs-lookup"><span data-stu-id="153f5-214">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="153f5-215">Если свои методы API с использованием привязки модели, необходимо всегда проверять `ModelState.IsValid`, и тесты интеграции – подходящее место для подтверждения правильности проверки модели.</span><span class="sxs-lookup"><span data-stu-id="153f5-215">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="153f5-216">Следующий набор тестов целевой `Create` метод в [IdeasController](xref:mvc/controllers/testing#ideas-controller) класс, показанный выше:</span><span class="sxs-lookup"><span data-stu-id="153f5-216">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

<span data-ttu-id="153f5-217">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]</span><span class="sxs-lookup"><span data-stu-id="153f5-217">[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]</span></span>

<span data-ttu-id="153f5-218">В отличие от тестов интеграции действий, которые возвращает HTML-представления методы веб-API, которые возвращают результаты обычно можно десериализовать в виде строго типизированных объектов, как показано выше последней проверки.</span><span class="sxs-lookup"><span data-stu-id="153f5-218">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="153f5-219">В этом случае тест десериализует результат `BrainstormSession` экземпляром и подтверждает, что идея правильно был добавлен в его коллекцию идеи.</span><span class="sxs-lookup"><span data-stu-id="153f5-219">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="153f5-220">В этой статье вы найдете дополнительные примеры интеграционные тесты [образец проекта](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span><span class="sxs-lookup"><span data-stu-id="153f5-220">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
