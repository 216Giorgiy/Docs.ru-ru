---
title: "Тестирование логики контроллер в ASP.NET Core"
author: ardalis
description: "Дополнительные сведения о тестировании логика контроллеров в ASP.NET Core заказа и xUnit."
keywords: "ASP.NET Core контроллера, тестирования, тестирование, модульный тест, модульное тестирование, интеграции тестирования, интеграционного тестирования, xUnit"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: dd4135ec-2b15-410c-b3fb-3d12eed4a1ac
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/testing
ms.openlocfilehash: aa60912e06946bd0df4936d33c88d3bf7b69984c
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
# <a name="testing-controller-logic-in-aspnet-core"></a>Тестирование логики контроллер в ASP.NET Core

По [Стив Смит](https://ardalis.com/)

Контроллеры в приложениях ASP.NET MVC должно быть небольшим и ориентированы на проблемы пользовательского интерфейса. Большие контроллеры, работающие с аспектами без пользовательского интерфейса труднее тестировать и поддерживать.

[Просмотреть или загрузить пример из GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a>Контроллеры тестирования

Контроллеры являются центральным элементом любого приложения ASP.NET Core MVC. Таким образом должен иметь уверенность, что они работают должным образом для вашего приложения. Автоматические тесты можно получить у этого достоверности и выявить ошибки, прежде чем они достигнут рабочей. Очень важно избегать размещения ненужные обязанности в контроллерах и убедитесь, тесты внимание только на контроллере обязанности.

Логика контроллера должно быть минимальным и не сосредоточиться на логике или инфраструктуры бизнесе (например, доступ к данным). Проверьте логику контроллера, не framework. Тест как контроллер *ведет себя* зависимости от входных данных допустимое или недопустимое. Проверка на основе результатов бизнес-операции, выполняемые ею ответы контроллера.

Обязанности типичные контроллера:

* Проверьте `ModelState.IsValid`.
* Вернуть ответ с ошибкой, если `ModelState` является недопустимым.
* Получить бизнес-сущность из хранилища сохраняемости.
* Выполните действие в бизнес-сущности.
* Сохраните бизнес-сущности сохраняемости.
* Возвращает соответствующий `IActionResult`.

## <a name="unit-testing"></a>Модульное тестирование

[Модульное тестирование](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) включает в себя проверку частью приложения отдельно от инфраструктуры и зависимости. При тестировании модульное тестирование логику контроллера, содержимое одним действием, не поведения из ее зависимостей или сам платформы. Как модульного тестирования ваши действия контроллера, убедитесь, что сосредоточиться только на его поведение. Модульный тест контроллер позволяет избежать таких вещей, как [фильтры](filters.md), [маршрутизации](../../fundamentals/routing.md), или [привязки модели](../models/model-binding.md). Обычно сосредоточиться на тестировании только одно модульные тесты — просто для записи и быстро выполнять. Грамотно сконструированные набор модульные тесты могут выполняться без большой нагрузки часто. Тем не менее, модульные тесты не обнаруживают проблемы во взаимодействии между компонентами, которая является целью [интеграционного тестирования](xref:mvc/controllers/testing#integration-testing).

При написании настраиваемые фильтры, маршрутов и т. д следует модульный тест их, но не как часть тесты на действие конкретном контроллере. Их необходимо тестировать отдельно.

> [!TIP]
> [Создание и запуск модульных тестов с помощью Visual Studio](https://docs.microsoft.com/visualstudio/test/unit-test-your-code).

Чтобы продемонстрировать модульного тестирования, просмотрите следующий контроллер. Здесь отображается список мозговой сеансы и новые мозговой сеансов с помощью POST:

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

Следующий контроллер [принцип явные зависимости](http://deviq.com/explicit-dependencies-principle/), ожидается внедрения зависимостей снабжать экземпляр `IBrainstormSessionRepository`. Это позволяет просто для тестирования с помощью платформы макетов объектов, таких как [заказа](https://www.nuget.org/packages/Moq/). `HTTP GET Index` Метод не имеет цикла или ветвления и только вызовов одного метода. Чтобы проверить это `Index` метод, необходимо проверить, `ViewResult` возвращается, с `ViewModel` из репозитория `List` метод.

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

`HomeController` `HTTP POST Index` Следует проверить (в приведенном выше примере):

* Метод действия возвращает неправильный запрос `ViewResult` с соответствующими данными при `ModelState.IsValid` —`false`

* `Add` Вызове метода в репозиторий и `RedirectToActionResult` возвращается с правильные аргументы при `ModelState.IsValid` имеет значение true.

Состояние недопустимой модели можно протестировать путем добавления ошибок с помощью `AddModelError` показанное в первом тесте.

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

Первый тест подтверждает при `ModelState` не является допустимым, же `ViewResult` возвращается как для `GET` запроса. Обратите внимание, что тест не пытался передать недопустимый модели. Все равно не работает, так как привязки модели не выполняется (хотя [интеграционного теста](xref:mvc/controllers/testing#integration-testing) используется привязка модели упражнения). В этом случае привязка модели не тестируется. Эти модульные тесты только тестировании делает код в метод действия.

Второй тест проверяет, что при `ModelState` является допустимым, новый `BrainstormSession` добавляется (с помощью репозитория), а метод возвращает `RedirectToActionResult` с ожидаемыми свойствами. Макеты вызовов, которые не вызываются обычно игнорируется, но вызывающий `Verifiable` в конце установки вызова позволяет проверить в тесте. Это делается с помощью вызова метода `mockRepo.Verify`, которой будет сбоя теста, если ожидаемый метод не был вызван.

> [!NOTE]
> Библиотека заказа, используемый в этом примере упрощает смешивания проверяемый или «strict» макеты с не поддающейся фиктивных (также называется «свободный» фиктивных заглушки). Дополнительные сведения о [Настройка поведения макетов с заказа](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).

Другой контроллер в приложении отображаются сведения, относящиеся к мозговой определенного сеанса. Она содержит логику для работы с недопустимым идентификатором значения.

[!code-csharp[Main](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

Действие контроллер имеет три случая, чтобы проверить, по одной для каждого `return` инструкции:

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

Приложение предоставляет функциональные возможности, что веб-API (список планов, связанные с мозговой сеанса, а также метод для добавления новых идей в сеансе):

<a name="ideas-controller"></a>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

`ForSession` Метод возвращает список `IdeaDTO` типов. Старайтесь не возвращать вашей бизнес-сущности домена напрямую через вызовы API, так как часто они включают больше данных, чем API клиента требуется, и они без необходимости подключать модель внутреннего домена приложения с помощью API, доступ к которым предоставляется извне. Сопоставление между сущностями домена и типов, будет возвращать по сети можно сделать вручную (с использованием LINQ `Select` как показано ниже) или с помощью библиотеки, такой как [AutoMapper](https://github.com/AutoMapper/AutoMapper)

Модульные тесты для `Create` и `ForSession` методов API:

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

Как уже говорилось ранее, чтобы проверить поведение метода при `ModelState` является недопустимым, добавить в контроллер ошибку модели в рамках теста. Не пытайтесь проверить привязки модели проверки или модели в модульные тесты — просто проверить поведение метода действия при возникновении конфликтов с конкретным `ModelState` значение.

Второй тест зависит от репозитория, возвращение null, поэтому макета репозитория должен возвращать значение null. Нет необходимости для создания тестовой базы данных (в памяти или иным способом) и создайте запрос, который будет возвращать этот результат — это можно сделать в одной инструкции, как показано.

Последней проверки проверяет, что репозитория `Update` вызывается метод. Как это делалось ранее макетов вызывается с `Verifiable` и затем макеты репозитория `Verify` метод вызывается для подтверждения проверяемый метод был выполнен. Это не модульного теста ответственность за убедитесь, что `Update` метод сохранены данные, может выполняться с интеграционного теста.

## <a name="integration-testing"></a>Тестирование интеграции

[Интеграционного тестирования](../../testing/integration-testing.md) сделано для отдельных модулей в работу приложения правильно друг с другом. Как правило все, что можно проверить с помощью модульного теста, можно проверить с помощью интеграционного теста, но обратное не так. Однако интеграционные тесты обычно гораздо медленнее, чем модульные тесты. Таким образом рекомендуется проверить все, что можно с помощью модульных тестов и использовать интеграционные тесты для сценариев, предполагающих несколькими участниками.

Несмотря на то, что они по-прежнему могут оказаться полезными, макетов объектов редко используются в тесты интеграции. В модульных тестах макетов объектов являются эффективным способом для управления поведением участники совместной работы за пределами тестируемой единицы в целях тестирования. В к интеграционному тесту чтобы убедиться, что подсистема целиком вместе правильно работает используются реальные участники совместной работы.

### <a name="application-state"></a>Состояние приложения

Одно важное требование при выполнении интеграционного тестирования — Установка состояния приложения. Тесты должны выполняться независимо друг от друга, и поэтому каждого теста должно начинаться с приложением в известном состоянии. Если приложения не используют базу данных или любой сохраняемости, это может оказаться проблемой. Тем не менее большинство реальных приложений сохранить их состояние для какого-либо вида хранилища данных, поэтому любые изменения, произведенные в один тест может повлиять другого теста, пока не будет сброшен в хранилище данных. С помощью встроенной `TestServer`, очень проста для узла приложения ASP.NET Core наши тесты интеграции, но, не предоставляет обязательно доступ к данным, он будет использовать. Если вы используете существующую базу данных, один подход заключается в приложение соединиться с базой данных теста, который тесты могут открывать и убедитесь, сбрасывается в известное состояние до выполнения каждого теста.

В этом образце приложения используется поддержка InMemoryDatabase Entity Framework Core, поэтому я просто не может подключиться к нему из тестового проекта. Вместо этого я предоставлять `InitializeDatabase` метода в приложении `Startup` класс, который вызова при запуске приложения, если он находится в `Development` среде. Интеграция тестов автоматически выиграть от этого при условии, что они установить среду `Development`. Не нужно беспокоиться о сбросе базы данных, так как InMemoryDatabase сбрасывается при каждом перезапуске приложения.

`Startup` Класса:

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

Вы увидите `GetTestSession` метода часто используются в приведенных ниже тестах интеграции.

### <a name="accessing-views"></a>Доступ к представлениям

Настраивает каждого класса теста интеграции `TestServer` , будет выполняться приложение ASP.NET Core. По умолчанию `TestServer` размещает веб-приложения в папке, где он запущен - в этом случае папки проекта. Таким образом, при попытке проверить действия контроллера, которые возвращают `ViewResult`, появится это сообщение об ошибке:

```
The view 'Index' was not found. The following locations were searched:
(list of locations)
```

Чтобы устранить эту проблему, необходимо настроить содержимое корневого сервера, чтобы он мог найти представления для тестируемого проекта. Это делается путем вызова `UseContentRoot` в `TestFixture` класса, показано ниже:

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

`TestFixture` Класс отвечает за настройку и создание `TestServer`, задает `HttpClient` для взаимодействия с `TestServer`. Каждая интеграции проверяет использует `Client` свойства для подключения к серверу тест и выполните запрос.

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

В первом тесте выше `responseString` содержит фактический созданный HTML в представлении могут проверяться для подтверждения того, он содержит ожидаемые результаты.

Второй тест создает формы POST с уникальное имя сеанса и отправляет его в приложение, а затем проверяет, возвращается ожидаемый перенаправления.

### <a name="api-methods"></a>Методы API

Если ваше приложение предоставляет веб-API, его следует автоматических тестов подтверждения, они выполняются, как ожидалось. Встроенная `TestServer` облегчает тестирование веб-API. Если свои методы API с использованием привязки модели, необходимо всегда проверять `ModelState.IsValid`, и тесты интеграции – подходящее место для подтверждения правильности проверки модели.

Следующий набор тестов целевой `Create` метод в [IdeasController](xref:mvc/controllers/testing#ideas-controller) класс, показанный выше:

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

В отличие от тестов интеграции действий, которые возвращает HTML-представления методы веб-API, которые возвращают результаты обычно можно десериализовать в виде строго типизированных объектов, как показано выше последней проверки. В этом случае тест десериализует результат `BrainstormSession` экземпляром и подтверждает, что идея правильно был добавлен в его коллекцию идеи.

В этой статье вы найдете дополнительные примеры интеграционные тесты [образец проекта](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).
