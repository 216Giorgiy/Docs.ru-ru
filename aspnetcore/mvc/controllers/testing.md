---
title: Тестирование логики контроллера в ASP.NET Core
author: ardalis
description: Узнайте, как протестировать логику контроллера в ASP.NET Core с помощью Moq и xUnit.
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/testing
ms.openlocfilehash: a0073e4de361c37a6854ceaf54ffd9eaea4837d4
ms.sourcegitcommit: 43bd79667bbdc8a07bd39fb4cd6f7ad3e70212fb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2018
ms.locfileid: "34567053"
---
# <a name="test-controller-logic-in-aspnet-core"></a><span data-ttu-id="41e78-103">Тестирование логики контроллера в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="41e78-103">Test controller logic in ASP.NET Core</span></span>

<span data-ttu-id="41e78-104">Автор: [Стив Смит](https://ardalis.com/) (Steve Smith)</span><span class="sxs-lookup"><span data-stu-id="41e78-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="41e78-105">Контроллеры в приложениях ASP.NET MVC должны быть компактными и направленными на решение задач пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="41e78-105">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="41e78-106">Большие контроллеры, не связанные с задачами пользовательского интерфейса, труднее тестировать и поддерживать.</span><span class="sxs-lookup"><span data-stu-id="41e78-106">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="41e78-107">Просмотреть или скачать образец с GitHub</span><span class="sxs-lookup"><span data-stu-id="41e78-107">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="41e78-108">Тестирование контроллеров</span><span class="sxs-lookup"><span data-stu-id="41e78-108">Testing controllers</span></span>

<span data-ttu-id="41e78-109">Контроллеры — это центральный элемент любого приложения ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="41e78-109">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="41e78-110">По этой причине необходима уверенность в том, что они работают, как планировалось.</span><span class="sxs-lookup"><span data-stu-id="41e78-110">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="41e78-111">С помощью автоматических тестов можно убедиться в этом и обнаружить ошибки до ввода контроллеров в рабочую среду.</span><span class="sxs-lookup"><span data-stu-id="41e78-111">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="41e78-112">Важно избегать реализации в контроллерах лишних функций, а тесты должны быть ориентированы только на функции контроллеров.</span><span class="sxs-lookup"><span data-stu-id="41e78-112">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="41e78-113">Логике контролера следует быть минимальной и не связанной с бизнес-логикой или проблемами инфраструктуры (например, с доступом к данным).</span><span class="sxs-lookup"><span data-stu-id="41e78-113">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="41e78-114">Тестировать нужно логику контроллера, а не платформу.</span><span class="sxs-lookup"><span data-stu-id="41e78-114">Test controller logic, not the framework.</span></span> <span data-ttu-id="41e78-115">Тестируйте *работу* контроллера на основе допустимых и недопустимых значений.</span><span class="sxs-lookup"><span data-stu-id="41e78-115">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="41e78-116">Проверяйте ответы контроллера на основе результата выполняемой им бизнес-операции.</span><span class="sxs-lookup"><span data-stu-id="41e78-116">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="41e78-117">Типичные функции контроллера:</span><span class="sxs-lookup"><span data-stu-id="41e78-117">Typical controller responsibilities:</span></span>

* <span data-ttu-id="41e78-118">Проверяет значение `ModelState.IsValid`.</span><span class="sxs-lookup"><span data-stu-id="41e78-118">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="41e78-119">Возвращает ответ об ошибке, если состояние `ModelState` недопустимо.</span><span class="sxs-lookup"><span data-stu-id="41e78-119">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="41e78-120">Возвращает бизнес-элемент из хранилища.</span><span class="sxs-lookup"><span data-stu-id="41e78-120">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="41e78-121">Выполняет действие с бизнес-элементом.</span><span class="sxs-lookup"><span data-stu-id="41e78-121">Perform an action on the business entity.</span></span>
* <span data-ttu-id="41e78-122">Сохраняет бизнес-элемент в хранилище.</span><span class="sxs-lookup"><span data-stu-id="41e78-122">Save the business entity to persistence.</span></span>
* <span data-ttu-id="41e78-123">Возвращает соответствующий результат `IActionResult`.</span><span class="sxs-lookup"><span data-stu-id="41e78-123">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="41e78-124">Модульное тестирование</span><span class="sxs-lookup"><span data-stu-id="41e78-124">Unit testing</span></span>

<span data-ttu-id="41e78-125">[Модульное тестирование](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) предполагает тестирование части приложения изолированно от его инфраструктуры и зависимостей.</span><span class="sxs-lookup"><span data-stu-id="41e78-125">[Unit testing](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="41e78-126">При модульном тестировании логики контроллера тестируется только содержимое отдельного действия, но не поведение его зависимостей или сама платформа.</span><span class="sxs-lookup"><span data-stu-id="41e78-126">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="41e78-127">Выполняя модульное тестирование действий контроллера, следует сосредоточиться только на его поведении.</span><span class="sxs-lookup"><span data-stu-id="41e78-127">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="41e78-128">В рамках модульного тестирования контроллера не учитываются такие аспекты, как [фильтры](filters.md), [маршрутизация](../../fundamentals/routing.md) или [привязка модели](../models/model-binding.md).</span><span class="sxs-lookup"><span data-stu-id="41e78-128">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="41e78-129">Благодаря нацеленности на отдельный компонент модульные тесты, как правило, проще создавать, а выполняются они быстрее.</span><span class="sxs-lookup"><span data-stu-id="41e78-129">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="41e78-130">Правильно составленный набор модульных тестов можно выполнять часто без значительных затрат.</span><span class="sxs-lookup"><span data-stu-id="41e78-130">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="41e78-131">Однако модульные тесты не выявляют проблемы с взаимодействием между компонентами. Для этого используется [тестирование интеграции](xref:mvc/controllers/testing#integration-testing).</span><span class="sxs-lookup"><span data-stu-id="41e78-131">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration tests](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="41e78-132">Если вы создаете пользовательские фильтры, маршруты и т. д., их следует подвергать модульному тестированию, но не в рамках тестирования определенного действия контроллера.</span><span class="sxs-lookup"><span data-stu-id="41e78-132">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="41e78-133">Они должны тестироваться отдельно.</span><span class="sxs-lookup"><span data-stu-id="41e78-133">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="41e78-134">[Создавайте и выполняйте модульные тесты с помощью Visual Studio](/visualstudio/test/unit-test-your-code).</span><span class="sxs-lookup"><span data-stu-id="41e78-134">[Create and run unit tests with Visual Studio](/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="41e78-135">Для демонстрации модульного тестирования рассмотрим представленный ниже контроллер.</span><span class="sxs-lookup"><span data-stu-id="41e78-135">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="41e78-136">Он выводит список сеансов мозгового штурма и позволяет создавать такие сеансы с помощью запроса POST.</span><span class="sxs-lookup"><span data-stu-id="41e78-136">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="41e78-137">Контроллер следует [принципу явных зависимостей](http://deviq.com/explicit-dependencies-principle/), предполагающему предоставление экземпляра `IBrainstormSessionRepository` при внедрении зависимостей.</span><span class="sxs-lookup"><span data-stu-id="41e78-137">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="41e78-138">Благодаря этому его достаточно легко протестировать с помощью платформы макетов объектов, например [Moq](https://www.nuget.org/packages/Moq/).</span><span class="sxs-lookup"><span data-stu-id="41e78-138">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="41e78-139">В методе `HTTP GET Index` нет циклов или ветвления, и он вызывает лишь один метод.</span><span class="sxs-lookup"><span data-stu-id="41e78-139">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="41e78-140">Чтобы протестировать этот метод `Index`, необходимо проверить, возвращается ли результат `ViewResult` с объектом `ViewModel` из метода `List` репозитория.</span><span class="sxs-lookup"><span data-stu-id="41e78-140">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="41e78-141">Метод `HomeController` `HTTP POST Index` (показанный выше) должен проверять, выполняются ли следующие действия:</span><span class="sxs-lookup"><span data-stu-id="41e78-141">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="41e78-142">Метод действия возвращает результат `ViewResult` типа "Неверный запрос" с соответствующими данными, если свойство `ModelState.IsValid` имеет значение `false`.</span><span class="sxs-lookup"><span data-stu-id="41e78-142">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="41e78-143">Вызывается метод `Add` репозитория, и возвращается результат `RedirectToActionResult` с правильными аргументами, если свойство `ModelState.IsValid` имеет значение true.</span><span class="sxs-lookup"><span data-stu-id="41e78-143">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="41e78-144">Недопустимое состояние модели можно проверить, добавив ошибки с помощью метода `AddModelError`, как показано в первом тесте ниже.</span><span class="sxs-lookup"><span data-stu-id="41e78-144">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="41e78-145">Первый тест проверяет, возвращается ли тот же результат `ViewResult`, что и для запроса `GET`, если состояние `ModelState` недопустимо.</span><span class="sxs-lookup"><span data-stu-id="41e78-145">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="41e78-146">Обратите внимание на то, что он не пытается передать недопустимую модель.</span><span class="sxs-lookup"><span data-stu-id="41e78-146">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="41e78-147">Это бы в любом случае не удалось, так как привязка модели не запущена (хотя [тест интеграции](xref:mvc/controllers/testing#integration-testing) использовал бы тестовую привязку модели).</span><span class="sxs-lookup"><span data-stu-id="41e78-147">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="41e78-148">В этом случае привязка модели не тестируется.</span><span class="sxs-lookup"><span data-stu-id="41e78-148">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="41e78-149">Эти модульные тесты проверяют только действия, выполняемые кодом в методе действия.</span><span class="sxs-lookup"><span data-stu-id="41e78-149">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="41e78-150">Второй тест проверяет, добавляется ли новый объект `BrainstormSession` (через репозиторий) и возвращает ли метод результат `RedirectToActionResult` с ожидаемыми свойствами, если состояние `ModelState` допустимо.</span><span class="sxs-lookup"><span data-stu-id="41e78-150">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="41e78-151">Макеты вызовов, которые не выполняются, обычно игнорируются, но вызов `Verifiable` в конце вызова Setup позволяет проверить его в тесте.</span><span class="sxs-lookup"><span data-stu-id="41e78-151">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="41e78-152">Для этого служит вызов метода `mockRepo.Verify`, в результате которого тест будет считаться непройденным, если требуемый метод не был вызван.</span><span class="sxs-lookup"><span data-stu-id="41e78-152">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="41e78-153">Библиотека Moq, используемая в этом примере, позволяет легко сочетать проверяемые (строгие) макеты и непроверяемые (которые также называют нестрогими макетами или заглушками).</span><span class="sxs-lookup"><span data-stu-id="41e78-153">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="41e78-154">Узнайте больше о [настройке поведения макетов с помощью Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span><span class="sxs-lookup"><span data-stu-id="41e78-154">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="41e78-155">Другой контроллер в приложении выводит сведения, связанные с определенным сеансом мозгового штурма.</span><span class="sxs-lookup"><span data-stu-id="41e78-155">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="41e78-156">Он содержит логику для обработки недопустимых значений id:</span><span class="sxs-lookup"><span data-stu-id="41e78-156">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="41e78-157">Действие контроллера имеет три тестируемых случая, по одному на каждый оператор `return`:</span><span class="sxs-lookup"><span data-stu-id="41e78-157">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="41e78-158">Приложение предоставляет функциональные возможности в виде веб-интерфейса API (список идей, связанных с сеансом мозгового штурма, и метод для добавления новых идей в сеанс):</span><span class="sxs-lookup"><span data-stu-id="41e78-158">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="41e78-159">Метод `ForSession` возвращает список типов `IdeaDTO`.</span><span class="sxs-lookup"><span data-stu-id="41e78-159">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="41e78-160">Старайтесь не возвращать бизнес-элементы непосредственно через вызовы API, так как они часто содержат больше данных, чем требуется клиенту API, и связывают внутреннюю модель предметной области приложения с интерфейсом API, доступным извне, чего следует избегать.</span><span class="sxs-lookup"><span data-stu-id="41e78-160">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="41e78-161">Сопоставлять элементы предметной области и типы, возвращаемые по сети, можно вручную (с помощью инструкции LINQ `Select`, как показано здесь) или с помощью такой библиотеки, как [AutoMapper](https://github.com/AutoMapper/AutoMapper).</span><span class="sxs-lookup"><span data-stu-id="41e78-161">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="41e78-162">Модульные тесты для методов API `Create` и `ForSession`:</span><span class="sxs-lookup"><span data-stu-id="41e78-162">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="41e78-163">Как уже говорилось ранее, чтобы протестировать поведение метода в случае, если состояние `ModelState` недопустимо, следует добавить ошибку модели в контроллер в рамках теста.</span><span class="sxs-lookup"><span data-stu-id="41e78-163">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="41e78-164">Не пытайтесь тестировать проверку модели или привязку модели с помощью модульных тестов — проверяйте только поведение метода действия при определенных значениях `ModelState`.</span><span class="sxs-lookup"><span data-stu-id="41e78-164">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="41e78-165">Во втором тесте предполагается, что репозиторий возвращает значение NULL, поэтому макет репозитория настроен так, чтобы возвращать значение NULL.</span><span class="sxs-lookup"><span data-stu-id="41e78-165">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="41e78-166">Создавать тестовую базу данных (в памяти или где-либо еще) и запрос, возвращающий этот результат, не нужно — это можно сделать в одном операторе, как показано в примере.</span><span class="sxs-lookup"><span data-stu-id="41e78-166">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="41e78-167">Последний тест проверяет, вызывается ли метод `Update` репозитория.</span><span class="sxs-lookup"><span data-stu-id="41e78-167">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="41e78-168">Как и ранее, макет вызывается с помощью метода `Verifiable`, а затем вызывается метод `Verify` макета репозитория для подтверждения выполнения проверяемого метода.</span><span class="sxs-lookup"><span data-stu-id="41e78-168">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="41e78-169">Проверка того, сохранил ли метод `Update` данные, не относится к задачам модульного теста. Это можно сделать с помощью теста интеграции.</span><span class="sxs-lookup"><span data-stu-id="41e78-169">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="41e78-170">Тестирование интеграции</span><span class="sxs-lookup"><span data-stu-id="41e78-170">Integration testing</span></span>

<span data-ttu-id="41e78-171">[Тестирование интеграции](xref:test/integration-tests) предназначено для проверки того, правильно ли работают отдельные модули приложения вместе.</span><span class="sxs-lookup"><span data-stu-id="41e78-171">[Integration tests](xref:test/integration-tests) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="41e78-172">Как правило, все, что можно проверить с помощью модульного теста, можно также проверить с помощью теста интеграции, но не наоборот.</span><span class="sxs-lookup"><span data-stu-id="41e78-172">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="41e78-173">Однако тесты интеграции обычно выполняются гораздо медленнее модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="41e78-173">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="41e78-174">Поэтому лучше всего проверить все, что можно, с помощью модульных тестов, а тесты интеграции применять для сценариев, предусматривающих совместную работу.</span><span class="sxs-lookup"><span data-stu-id="41e78-174">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="41e78-175">Хотя макеты объектов могут быть полезны, они редко используются в тестах интеграции.</span><span class="sxs-lookup"><span data-stu-id="41e78-175">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="41e78-176">При модульном тестировании макеты объектов — это эффективный способ управлять поведением компонентов, не относящихся к тестируемому модулю, но связанных с его работой.</span><span class="sxs-lookup"><span data-stu-id="41e78-176">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="41e78-177">В тесте интеграции для проверки правильной работы всей подсистемы используются реальные компоненты.</span><span class="sxs-lookup"><span data-stu-id="41e78-177">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="41e78-178">Состояние приложения</span><span class="sxs-lookup"><span data-stu-id="41e78-178">Application state</span></span>

<span data-ttu-id="41e78-179">Важным моментом при тестировании интеграции является настройка состояния приложения.</span><span class="sxs-lookup"><span data-stu-id="41e78-179">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="41e78-180">Тесты должны выполняться независимо друг от друга, поэтому в начале каждого теста приложение должно находиться в известном состоянии.</span><span class="sxs-lookup"><span data-stu-id="41e78-180">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="41e78-181">Если приложение не использует базу данных и не имеет хранилища, проблемы в этом может не быть.</span><span class="sxs-lookup"><span data-stu-id="41e78-181">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="41e78-182">Однако большинство реальных приложений сохраняют свое состояние в каком-либо хранилище данных, поэтому изменения, внесенные одним из тестов, могут влиять на другой, если не сбросить хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="41e78-182">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="41e78-183">С помощью встроенного сервера `TestServer` очень легко размещать приложения ASP.NET Core в тестах интеграции, но это необязательно обеспечивает доступ к данным, используемым приложением.</span><span class="sxs-lookup"><span data-stu-id="41e78-183">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="41e78-184">Если вы используете реальную базу данных, один из подходов состоит в подключении приложения к тестовой базе данных, которая доступна для тестов, и ее сбросе в известное состояние перед выполнением каждого теста.</span><span class="sxs-lookup"><span data-stu-id="41e78-184">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="41e78-185">В этом примере приложения используется поддержка InMemoryDatabase, предоставляемая платформой Entity Framework Core, поэтому к нему нельзя просто подключиться из тестового проекта.</span><span class="sxs-lookup"><span data-stu-id="41e78-185">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="41e78-186">Вместо этого предоставим доступ к методу `InitializeDatabase` в классе `Startup` приложения. Он будет вызываться при запуске приложения в среде `Development`.</span><span class="sxs-lookup"><span data-stu-id="41e78-186">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="41e78-187">Тесты интеграции автоматически получают возможность пользоваться им, если они задают среду `Development`.</span><span class="sxs-lookup"><span data-stu-id="41e78-187">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="41e78-188">Теперь не нужно беспокоиться о сбросе базы данных, так как база данных InMemoryDatabase будет сбрасываться каждый раз при перезапуске приложения.</span><span class="sxs-lookup"><span data-stu-id="41e78-188">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="41e78-189">Класс `Startup`:</span><span class="sxs-lookup"><span data-stu-id="41e78-189">The `Startup` class:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="41e78-190">Как вы увидите, метод `GetTestSession` будет часто использоваться в приведенных далее тестах интеграции.</span><span class="sxs-lookup"><span data-stu-id="41e78-190">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="41e78-191">Доступ к представлениям</span><span class="sxs-lookup"><span data-stu-id="41e78-191">Accessing views</span></span>

<span data-ttu-id="41e78-192">Каждый класс теста интеграции настраивает сервер `TestServer`, на котором будет выполняться приложение ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="41e78-192">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="41e78-193">По умолчанию `TestServer` размещает веб-приложение в папке, в которой он выполняется. В данном случае это папка тестового проекта.</span><span class="sxs-lookup"><span data-stu-id="41e78-193">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="41e78-194">Поэтому при попытке протестировать действия контроллера, возвращающие `ViewResult`, может возникнуть следующая ошибка:</span><span class="sxs-lookup"><span data-stu-id="41e78-194">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="41e78-195">Чтобы устранить эту проблему, необходимо настроить корень содержимого сервера так, чтобы он мог находить представления тестируемого проекта.</span><span class="sxs-lookup"><span data-stu-id="41e78-195">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="41e78-196">Для этого следует вызвать метод `UseContentRoot` в классе `TestFixture`, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="41e78-196">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="41e78-197">Класс `TestFixture` отвечает за настройку и создание сервера `TestServer`, а также настройку взаимодействия клиента `HttpClient` с `TestServer`.</span><span class="sxs-lookup"><span data-stu-id="41e78-197">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="41e78-198">Каждый тест интеграции использует свойство `Client` для подключения к тестовому серверу и выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="41e78-198">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="41e78-199">В первом приведенном выше тесте `responseString` содержит преобразованный для просмотра код HTML из представления, который можно проверить на соответствие ожидаемым результатам.</span><span class="sxs-lookup"><span data-stu-id="41e78-199">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="41e78-200">Второй тест формирует запрос POST формы с уникальным именем сеанса, отправляет его в приложение, после чего проверяет, возвращено ли ожидаемое перенаправление.</span><span class="sxs-lookup"><span data-stu-id="41e78-200">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="41e78-201">Методы API</span><span class="sxs-lookup"><span data-stu-id="41e78-201">API methods</span></span>

<span data-ttu-id="41e78-202">Если приложение предоставляет веб-интерфейсы API, желательно проверять правильность их выполнения с помощью автоматических тестов.</span><span class="sxs-lookup"><span data-stu-id="41e78-202">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="41e78-203">Встроенный класс `TestServer` позволяет легко тестировать веб-интерфейсы API.</span><span class="sxs-lookup"><span data-stu-id="41e78-203">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="41e78-204">Если методы API используют привязку модели, обязательно следует проверять свойство `ModelState.IsValid`. Тесты интеграции — подходящее средство для проверки того, правильно ли работает проверка модели.</span><span class="sxs-lookup"><span data-stu-id="41e78-204">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="41e78-205">Следующий набор тестов предназначен для проверки метода `Create` в представленном выше классе [IdeasController](xref:mvc/controllers/testing#ideas-controller):</span><span class="sxs-lookup"><span data-stu-id="41e78-205">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="41e78-206">В отличие от тестов интеграции для действий, возвращающих представления HTML, методы веб-интерфейсов API, которые возвращают результаты, обычно можно десериализировать как строго типизированные объекты. Это продемонстрировано в последнем из приведенных выше тестов.</span><span class="sxs-lookup"><span data-stu-id="41e78-206">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="41e78-207">В этом случае тест десериализирует результат в экземпляр `BrainstormSession` и проверяет, правильно ли идея была добавлена в коллекцию идей.</span><span class="sxs-lookup"><span data-stu-id="41e78-207">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="41e78-208">Дополнительные примеры тестов интеграции можно найти в [образце проекта](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample) для этой статьи.</span><span class="sxs-lookup"><span data-stu-id="41e78-208">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
