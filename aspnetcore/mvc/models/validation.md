---
title: "Проверка модели в ASP.NET Core MVC"
author: rachelappel
description: "Дополнительные сведения о проверке модели в ASP.NET Core MVC."
ms.author: riande
manager: wpickett
ms.date: 12/18/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/models/validation
ms.openlocfilehash: 91db17e103723ac411a2ad4f3f9549860f250cce
ms.sourcegitcommit: 3e303620a125325bb9abd4b2d315c106fb8c47fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2018
---
# <a name="introduction-to-model-validation-in-aspnet-core-mvc"></a>Общие сведения о проверке модели в ASP.NET Core MVC

По [Рэйчел Аппель](https://github.com/rachelappel)

## <a name="introduction-to-model-validation"></a>Общие сведения о проверке модели

Прежде чем приложение сохраняет данные в базе данных, приложение должно проверить данные. Данные необходимо проверить наличие потенциальных угроз безопасности, проверить его соответствующим образом форматируется с помощью типа и размера, что она должна соответствовать правил. Проверка не требуется, хотя он может быть сложно реализовать и избыточность. В MVC проверка выполняется на клиенте и сервере.

К счастью .NET абстрагированы проверки в атрибутов проверки. Эти атрибуты содержат код проверки, тем самым уменьшая объем кода, который необходимо написать.

[Просмотреть или загрузить пример из GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/models/validation/sample).

## <a name="validation-attributes"></a>Атрибуты проверки

Атрибуты проверки — это способ для настройки проверки модели, поэтому она аналогична концептуально проверки для полей в таблицах базы данных. Сюда входят ограничения, такие как назначение типов данных или обязательных полей. Другие виды проверки включают применение шаблонов данных для применения бизнес-правил, например кредитной карты, номер телефона или адрес электронной почты. Атрибуты проверки сделать применения этих требований гораздо проще и удобнее в использовании.

Ниже приведен аннотируемого `Movie` модели из приложения, которое хранит сведения о фильмах и телепередачи. Большинство свойств являются обязательными, и требования к длине имеют несколько свойств строки. Кроме того, есть ограничения числового диапазона на месте для `Price` значение $999,99, а также настраиваемый атрибут проверки от 0.

[!code-csharp[Main](validation/sample/Movie.cs?range=6-29)]

Просто прочтя модели раскроется правил о данных для этого приложения, упрощая процесс для обслуживания кода. Ниже приведены несколько популярных встроенной проверке атрибутов.

* `[CreditCard]`: Проверяет свойство имеет формат кредитной карты.

* `[Compare]`: Проверяет два свойства в модели совпадения.

* `[EmailAddress]`: Проверяет свойство имеет формат электронной почты.

* `[Phone]`: Проверяет свойство имеет формат телефона.

* `[Range]`: Проверяет его значение свойства находится в указанном диапазоне.

* `[RegularExpression]`: Проверяет, что данные соответствуют указанному регулярному выражению.

* `[Required]`: Делает свойство обязательное.

* `[StringLength]`: Осуществляет проверку на строковое свойство максимум данной максимальной длины.

* `[Url]`: Проверяет свойство имеет формат URL-адреса.

MVC поддерживает любой атрибут, который является производным от `ValidationAttribute` для целей проверки. Множество полезных проверки атрибутов можно найти в [System.ComponentModel.DataAnnotations](https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations) пространства имен.

Возможны случаи, в которых требуется больше возможностей, чем встроенные атрибуты. В тех случаях, можно создать собственные настраиваемые атрибуты проверки путем наследования от `ValidationAttribute` или изменение модели для реализации `IValidatableObject`.

## <a name="notes-on-the-use-of-the-required-attribute"></a>При использовании необходимого атрибута

[Типы значений](/dotnet/csharp/language-reference/keywords/value-types), не допускающие значение null (например, `decimal`, `int`, `float` и `DateTime`), являются обязательными и не требуют атрибута `Required`. Приложение не выполняет проверки на стороне сервера проверки для запретом типов, помеченных `Required`.

Привязка модели MVC, которая не связаны с проверки и атрибуты проверки, отклоняет отправки формы поля, содержащего отсутствует значение или пробелов, не допускающим типа. В случае отсутствия `BindRequired` атрибутов для целевого свойства привязки модели игнорирует отсутствующих данных для типов допускают значение NULL, где отсутствует поле формы из входящих данных формы.

[Атрибута BindRequired](/aspnet/core/api/microsoft.aspnetcore.mvc.modelbinding.bindrequiredattribute) (см. также [Настройка поведения привязки модели с атрибутами](xref:mvc/models/model-binding#customize-model-binding-behavior-with-attributes)) полезна для обеспечения завершения данных формы. При применении к свойству, система привязки модели требуется значение для этого свойства. При применении к типу, система привязки модели необходимо задать значения для всех свойств объекта этого типа.

При использовании [Nullable\<T > тип](/dotnet/csharp/programming-guide/nullable-types/) (например, `decimal?` или `System.Nullable<decimal>`) и пометить его `Required`, флажок проверки на стороне сервера выполняется как бы стандартного допускает значения NULL типа (для свойства Пример, `string`).

Проверка на стороне клиента требуется значение для поля формы, которое соответствует свойству модели, помеченной `Required` и для свойства запретом типа, который еще не отмечен как `Required`. `Required`можно использовать для управления сообщение об ошибке проверки на стороне клиента.

## <a name="model-state"></a>Состояние модели

Состояние модели представляет ошибок проверки в введенные значения формы HTML.

MVC по-прежнему Проверка полей, пока не достигнет максимальное количество ошибок (по умолчанию — 200). Это число можно настроить, вставив следующий код в `ConfigureServices` метод в *файла Startup.cs* файла:

[!code-csharp[Main](validation/sample/Startup.cs?range=27)]

## <a name="handling-model-state-errors"></a>Состояние модели обработки ошибок

Проверка модели, происходит перед каждой вызываемого действия контроллера, и ответственность метода действия для проверки `ModelState.IsValid` и реагировать соответствующим образом. Во многих случаях соответствующие реакции является возврат ответ с ошибкой, в идеале с подробными сведениями о причине, причину ошибки проверки модели.

Некоторые приложения выберет следовать стандартного соглашения для обработки ошибок проверки модели, при которых фильтр может быть необходимо реализовать такую политику. Следует проверить поведение свои действия с состояниями допустимые и недопустимые модели.

## <a name="manual-validation"></a>Ручная проверка

После завершения привязки модели и проверки, можно повторить его части. Например пользователь может быть введен текст в поле, ожидается целое число, или необходимо вычислить значение для свойства модели.

Необходимо вручную выполнить проверку. Чтобы сделать это, вызовите `TryValidateModel` метода, как показано ниже:

[!code-csharp[Main](validation/sample/MoviesController.cs?range=52)]

## <a name="custom-validation"></a>Пользовательской проверки

Для большинства задач проверки работы атрибутов проверки. Тем не менее некоторые правила проверки характерные для вашего бизнеса. Правила может быть распространенные методы проверки данных, такие как поле является обязательным или она соответствует диапазону значений. В этих сценариях настраиваемых атрибутов проверки — это эффективное решение. Создание собственных настраиваемых атрибутов проверки в MVC можно легко. Наследовать только от `ValidationAttribute`и Переопределите `IsValid` метод. `IsValid` Метод принимает два параметра: первый — объект с именем *значение* , а второй — `ValidationContext` объект с именем *validationContext*. *Значение* ссылается на фактическое значение из поля, проверка вашего пользовательского проверяющего элемента управления.

В следующем образце бизнес-правило том, что пользователи не могут устанавливать жанр *классический* к фильму, выпущенные после выхода 1960. `[ClassicMovie]` Атрибут сначала проверяет жанр и если это classic, затем выполняется проверка является более поздней, чем 1960 даты выпуска. Если он освобождается после 1960, проверка завершается с ошибками. Атрибут принимает целочисленный параметр, представляющее год, можно использовать для проверки данных. Можно записать значение параметра в конструктор атрибута, как показано ниже:

[!code-csharp[Main](validation/sample/ClassicMovieAttribute.cs?range=9-29)]

`movie` Переменной выше представляет `Movie` объект, содержащий данные из отправки формы для проверки. В этом случае код проверки проверяет дату и жанр в `IsValid` метод `ClassicMovieAttribute` класса согласно правилам. По окончании успешной проверки `IsValid` возвращает `ValidationResult.Success` кода, и если проверка завершается неудачно, `ValidationResult` с сообщением об ошибке. Когда пользователь изменяет `Genre` поля и отправляет форму, `IsValid` метод `ClassicMovieAttribute` будет проверить, является ли фильма классические. Как и все встроенные атрибут применять `ClassicMovieAttribute` к свойству, такие как `ReleaseDate` для обеспечения проверки происходит, как показано в предыдущем примере кода. Поскольку пример работает только с `Movie` типов, лучшим вариантом является использование `IValidatableObject` как показано в следующем абзаце.

Кроме того, этот же код может быть переведена в модель, реализовав `Validate` метод `IValidatableObject` интерфейса. Хотя настраиваемых атрибутов проверки подходят для проверки отдельных свойств, реализация `IValidatableObject` можно использовать для реализации проверки на уровне класса, как показано ниже.

[!code-csharp[Main](validation/sample/MovieIValidatable.cs?range=32-40)]

## <a name="client-side-validation"></a>Проверки на стороне клиента

Проверки на стороне клиента является большое удобство для пользователей. Он сохраняет время, в противном случае они бы проводят ожидание кругового пути на сервере. Бизнес-терминологией даже несколько долей секунды, умноженные сотни раз в день до добавляет ожидается большое количество времени, затрат и трудностей. Простой и непосредственный проверки позволяет пользователям работать более продуктивно и создавать более высокое качество входных и выходных данных.

Необходимо иметь представление с правильной ссылки на скрипты JavaScript на месте для проверки на стороне клиента для работы, как показано ниже.

[!code-cshtml[Main](validation/sample/Views/Shared/_Layout.cshtml?range=37)]

[!code-cshtml[Main](validation/sample/Views/Shared/_ValidationScriptsPartial.cshtml)]

[Ненавязчивой проверки jQuery](https://github.com/aspnet/jquery-validation-unobtrusive) сценарий — пользовательского интерфейса библиотеки Microsoft и лежит популярный [jQuery проверки](https://jqueryvalidation.org/) подключаемого модуля. Без jQuery ненавязчивой проверки будет иметь ту же логику проверки в двух местах кода: один раз в атрибутах проверки стороны сервера для свойств модели, а затем снова на клиентские скрипты (примеры для jQuery проверки элемента [ `validate()` ](https://jqueryvalidation.org/validate/) метод показывает, как сложных это может стать). Вместо этого в MVC [вспомогательных функций тегов](xref:mvc/views/tag-helpers/intro) и [вспомогательных методов HTML](xref:mvc/views/overview) могут использовать атрибуты проверки и метаданные из свойства модели для визуализации HTML 5 типа [атрибуты данных](http://w3c.github.io/html/dom.html#embedding-custom-non-visible-data-with-the-data-attributes) в элементы формы, которые требуется проверить. MVC создает `data-` встроенных и пользовательских атрибутов. ненавязчивой проверки jQuery разбор демонстрируется `data-` атрибуты и передает логику проверки, эффективно «копирование» логику проверки стороны сервера клиенту jQuery. Для отображения ошибок проверки на стороне клиента с помощью соответствующего тега вспомогательные методы, как показано ниже:

[!code-cshtml[Main](validation/sample/Views/Movies/Create.cshtml?highlight=4,5&range=19-25)]

Выше вспомогательных функций тегов визуализацию HTML ниже. Обратите внимание, что `data-` выходных атрибутов в документ HTML, соответствующие атрибуты проверки для `ReleaseDate` свойства. `data-val-required` Атрибута ниже содержит сообщение об ошибке для отображения, если пользователь не заполните поле даты выпуска. ненавязчивой проверки jQuery передает это значение jQuery проверки [ `required()` ](https://jqueryvalidation.org/required-method/) метод, который затем отображает это сообщение в соответствующем  **\<span >** элемента.

```html
<form action="/Movies/Create" method="post">
    <div class="form-horizontal">
        <h4>Movie</h4>
        <div class="text-danger"></div>
        <div class="form-group">
            <label class="col-md-2 control-label" for="ReleaseDate">ReleaseDate</label>
            <div class="col-md-10">
                <input class="form-control" type="datetime"
                data-val="true" data-val-required="The ReleaseDate field is required."
                id="ReleaseDate" name="ReleaseDate" value="" />
                <span class="text-danger field-validation-valid"
                data-valmsg-for="ReleaseDate" data-valmsg-replace="true"></span>
            </div>
        </div>
    </div>
</form>
```

Проверка на стороне клиента предотвращает отправку до формы является допустимым. Кнопки "Отправить" запускает JavaScript, который отправляет форму или отображаются сообщения об ошибках.

MVC определяет значения атрибутов типа на основе типа данных .NET, возможно переопределено с помощью свойства `[DataType]` атрибуты. Базовый `[DataType]` атрибута не выполняет проверку real серверную. Браузеры выберите собственные сообщения об ошибках и отобразить эти ошибки, однако их следует, однако пакет ненавязчивой проверки jQuery можно переопределить сообщения и отображать их согласованно с другими разделами. Это происходит, наиболее очевидно, что если пользователи применять `[DataType]` подклассов, такие как `[EmailAddress]`.

### <a name="add-validation-to-dynamic-forms"></a>Добавление проверки в динамических форм

Поскольку ненавязчивой проверки jQuery передает логики проверки и параметры проверки jQuery при первой загрузке страницы, динамически создаваемых формы не будет автоматически работают проверки. Вместо этого необходимо сообщить jQuery ненавязчивой проверки для синтаксического анализа динамическая форма сразу же после его создания. В следующем примере кода показано, как можно настроить проверки на стороне клиента в форме добавлен с помощью AJAX.

```js
$.get({
    url: "https://url/that/returns/a/form",
    dataType: "html",
    error: function(jqXHR, textStatus, errorThrown) {
        alert(textStatus + ": Could not add form. " + errorThrown);
    },
    success: function(newFormHTML) {
        var container = document.getElementById("form-container");
        container.insertAdjacentHTML("beforeend", newFormHTML);
        var forms = container.getElementsByTagName("form");
        var newForm = forms[forms.length - 1];
        $.validator.unobtrusive.parse(newForm);
    }
})
```

`$.validator.unobtrusive.parse()` Метод принимает jQuery селектор для одного аргумента. Этот метод указывает jQuery ненавязчивой проверки для синтаксического анализа `data-` атрибуты формы внутри этого выбора. Значения этих атрибутов передаются подключаемого модуля проверки jQuery, чтобы видно, правила проверки желаемую стороне формы.

### <a name="add-validation-to-dynamic-controls"></a>Добавление проверки для динамических элементов управления

Можно также обновить правила проверки в форме, когда отдельные элементы управления, такие как `<input/>`s и `<select/>`s, создаются динамически. Невозможно передать селекторы для этих элементов для `parse()` непосредственно из-за форму уже проверен и не будут обновлены. Вместо этого сначала удалите существующие данные проверки, и повторной обработки всей формы, как показано ниже:

```js
$.get({
    url: "https://url/that/returns/a/control",
    dataType: "html",
    error: function(jqXHR, textStatus, errorThrown) {
        alert(textStatus + ": Could not add form. " + errorThrown);
    },
    success: function(newInputHTML) {
        var form = document.getElementById("my-form");
        form.insertAdjacentHTML("beforeend", newInputHTML);
        form.removeData("validator")    // Added by the raw jQuery Validate
            .removeData("unobtrusiveValidation");   // Added by jQuery Unobtrusive Validation
        $.validator.unobtrusive.parse(form);
    }
})
```

## <a name="iclientmodelvalidator"></a>IClientModelValidator

Можно создать пользовательский атрибут, логика стороны клиента и [ненавязчивой проверки](http://jqueryvalidation.org/documentation/) будет выполняться на клиентском компьютере автоматически в процессе проверки. Первым шагом является контролировать, какие данные атрибуты добавляются путем реализации `IClientModelValidator` интерфейс, как показано ниже:

[!code-csharp[Main](validation/sample/ClassicMovieAttribute.cs?range=30-42)]

Созданные поля атрибутов, которые реализуют этот интерфейс можно добавить атрибуты HTML. Анализ результатов для `ReleaseDate` элемент показывает код HTML, который аналогичен предыдущему примеру, за исключением того, теперь является `data-val-classicmovie` атрибут, который был определен в `AddValidation` метод `IClientModelValidator`.

```html
<input class="form-control" type="datetime"
    data-val="true"
    data-val-classicmovie="Classic movies must have a release year earlier than 1960."
    data-val-classicmovie-year="1960"
    data-val-required="The ReleaseDate field is required."
    id="ReleaseDate" name="ReleaseDate" value="" />
```

Проверки ненавязчивого использует данные в `data-` атрибуты для отображения сообщений об ошибках. Тем не менее, не знает о правилах jQuery, или сообщения до момента добавления элемента jQuery `validator` объекта. Это показано в следующем примере, который добавляет метод с именем `classicmovie` с кодом проверки пользовательских клиентских jQuery `validator` объекта.

[!code-javascript[Main](validation/sample/Views/Movies/Create.cshtml?range=71-93)]

Теперь jQuery содержит данные для выполнения пользовательской проверки JavaScript, а также сообщение об ошибке для отображения, если этот код проверки возвращает значение false.

## <a name="remote-validation"></a>Удаленной проверки

Удаленной проверки является компонент используется для проверки данных на стороне клиента к данным на сервере. Например приложение может потребоваться проверить электронной почты или имя пользователя уже используется, и он большой объем данных для этого необходимо выполнить запрос. Загрузка больших наборов данных для проверки одного или нескольких полей потребляет слишком много ресурсов. Он также может предоставлять конфиденциальную информацию. Альтернативой является выполнение кругового пути запроса для проверки поля.

Можно реализовать удаленной проверки в два этапа. Во-первых, следует пометить модели с помощью `[Remote]` атрибута. `[Remote]` Атрибут принимает несколько перегрузок, которые можно использовать для перенаправления на стороне клиента JavaScript соответствующий код вызова. В приведенном ниже примере указывает на `VerifyEmail` метод действия `Users` контроллера.

[!code-csharp[Main](validation/sample/User.cs?range=7-8)]

Второй шаг размещения кода проверки в соответствующий метод действия, как определено в `[Remote]` атрибута. Согласно jQuery проверки [ `remote()` ](https://jqueryvalidation.org/remote-method/) документации по методу:

> Строку JSON, который должен быть требуется ответ serverside `"true"` для допустимых элементов и может быть `"false"`, `undefined`, или `null` для недопустимые элементы, используя сообщение об ошибке по умолчанию. Если ответ serverside представляет собой строку, например. `"That name is already taken, try peter123 instead"`, эта строка будет отображаться как пользовательское сообщение об ошибке вместо используемого по умолчанию.

Определение `VerifyEmail()` метода следует таким правилам, как показано ниже. Он возвращает ошибку проверки сообщения, если сообщение электронной почты, или `true` Если сообщение электронной почты свободен и помещает результат в `JsonResult` объекта. Затем на стороне клиента можно использовать возвращаемое значение для продолжения или отображения ошибки, при необходимости.

[!code-csharp[Main](validation/sample/UsersController.cs?range=19-28)]

Теперь при вводе сообщения электронной почты, JavaScript, в представлении вызывает удаленный ли сообщение электронной почты, переведены в и, если да, отображается сообщение об ошибке. В противном случае пользователь может отправить форму обычным образом.

`AdditionalFields` Свойство `[Remote]` атрибут полезен для проверки комбинаций полей данных на сервере. Например если `User` модели выше имеет два дополнительных свойства вызывается `FirstName` и `LastName`, может потребоваться убедитесь, что нет существующих пользователей уже есть этой пары имен. Определить новые свойства, как показано в следующем коде:

[!code-csharp[Main](validation/sample/User.cs?range=10-13)]

`AdditionalFields`могли быть заданы явно на строки `"FirstName"` и `"LastName"`, но с помощью [ `nameof` ](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/nameof) оператор, как это упрощает позже рефакторинга. Метод действия для выполнения проверки необходимо затем принять два аргумента, один для значения `FirstName` и один для значения `LastName`.


[!code-csharp[Main](validation/sample/UsersController.cs?range=30-39)]

Теперь при вводе имени и фамилии, JavaScript:

* Вызывает удаленный для просмотра, если этой пары имен были выполнены.
* Если после создания пары отображается сообщение об ошибке. 
* Если не выполнено, пользователь может отправить форму.

Если необходимо проверить два или более дополнительных полей с `[Remote]` атрибут, можно предоставлять их как список с разделителями запятыми. Например, чтобы добавить `MiddleName` в модель свойство `[Remote]` атрибута, как показано в следующем коде:

```cs
[Remote(action: "VerifyName", controller: "Users", AdditionalFields = nameof(FirstName) + "," + nameof(LastName))]
public string MiddleName { get; set; }
```

`AdditionalFields`, как и все аргументы атрибута должно быть константное выражение. Таким образом, не должны использовать [интерполируются строка](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interpolated-strings) или вызвать [ `string.Join()` ](https://msdn.microsoft.com/en-us/library/system.string.join(v=vs.110).aspx) для инициализации `AdditionalFields`. Для каждого дополнительные поля, добавляемого `[Remote]` атрибут, необходимо добавить другого аргумента соответствующего метода действия контроллера.
