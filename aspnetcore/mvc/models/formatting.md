---
title: "Данные форматирования ответа в ASP.NET Core MVC"
author: ardalis
description: "Инструкции по форматированию данные ответа в ASP.NET Core MVC."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/models/formatting
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: ddda494e0db22031af9d20325e14e8458756cbfd
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
# <a name="introduction-to-formatting-response-data-in-aspnet-core-mvc"></a>Общие сведения о форматировании данных ответа в ASP.NET Core MVC

По [Стив Смит](https://ardalis.com/)

ASP.NET Core MVC имеет встроенную поддержку для форматирования данных ответа, используя форматы фиксированной или в ответ на спецификации клиента.

[Просмотреть или загрузить пример из GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/models/formatting/sample).

## <a name="format-specific-action-results"></a>Результаты действий конкретного формата

Некоторые типы результатов действий характерные для определенного формата, таких как `JsonResult` и `ContentResult`. Действия может возвращать определенные результаты, всегда форматируются определенным образом. Например, возвращая `JsonResult` будет возвращать данные в формате JSON, независимо от параметров клиента. Аналогично, возвращая `ContentResult` возвращают строковые данные в формате обычного текста (как будет возвратить строку).

> [!NOTE]
> Действие не требуется возвращать любой определенный тип; MVC поддерживает любое значение, возвращаемое объектом. Если действие возвращает `IActionResult` реализацию и контроллер наследует от `Controller`, разработчики имеют много вспомогательные методы, соответствующие параметры. Результаты из действий, которые возвращают объекты, которые не являются `IActionResult` типы будут сериализованы с помощью соответствующей `IOutputFormatter` реализации.

Для возврата данных в определенном формате из контроллера, который наследует от `Controller` базового класса, используйте встроенные вспомогательный метод `Json` для возврата JSON и `Content` для обычного текста. Метод действия должен возвращать тип определенного результата (например, `JsonResult`) или `IActionResult`.

Возврат данных в формате JSON:

[!code-csharp[Main](./formatting/sample/Controllers/Api/AuthorsController.cs?highlight=3,5&range=21-26)]

Образец ответа из этого действия:

![Вкладка «сеть» средств разработчика в Microsoft Edge, показывающая тип содержимого ответа — application/json](formatting/_static/json-response.png)

Обратите внимание, что тип содержимого ответа `application/json`, показанный в списке сетевых запросов и в разделе заголовки ответа. Также Обратите внимание, в списке вариантов, представленных браузера в заголовке Accept в разделе заголовки запроса (в данном случае Microsoft Edge). Текущий метод игнорирует этот заголовок; obeying он описывается ниже.

Чтобы вернуть данные в формате обычного текста, используйте `ContentResult` и `Content` поддержки:

[!code-csharp[Main](./formatting/sample/Controllers/Api/AuthorsController.cs?highlight=3,5&range=47-52)]

Ответ от этого действия:

![Вкладка «сеть» средств разработчика в Microsoft Edge, показывающая тип содержимого ответа — text/plain](formatting/_static/text-response.png)

Обратите внимание, в этом случае `Content-Type` возвращаемое `text/plain`. Можно также выполнить таким же образом, с помощью только строковый тип ответа:

[!code-csharp[Main](./formatting/sample/Controllers/Api/AuthorsController.cs?highlight=3,5&range=54-59)]

>[!TIP]
> Для нетривиального действия с несколькими возвращаемого типа или параметры (например, на основе результатов операций, выполняемых различные коды состояния HTTP), предпочтительно `IActionResult` как тип возвращаемого значения.

## <a name="content-negotiation"></a>Согласование содержимого

Согласование содержимого (*conneg* сокращенно) происходит, когда клиент задает [заголовок Accept](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html). JSON используется формат по умолчанию для ASP.NET Core MVC. Согласование содержимого реализуется `ObjectResult`. Он также встроена в код состояния, определенного действия результаты, возвращенные из вспомогательных методов (все основанные на `ObjectResult`). Также можно возвратить тип модели (класс был определен в качестве типа передачи данных) и платформа будет автоматически включать его в `ObjectResult` для вас.

Следующий метод действия использует `Ok` и `NotFound` вспомогательные методы:

[!code-csharp[Main](./formatting/sample/Controllers/Api/AuthorsController.cs?highlight=8,10&range=28-38)]

Если не был запрошен в другом формате и сервер может вернуть запрошенный формат ответа формата JSON будут возвращены. Можно использовать средства, подобного [Fiddler](http://www.telerik.com/fiddler) создать запрос, содержащий заголовок Accept и указать другой формат. В этом случае, если на сервере *форматирования* дающую ответа в запрошенном пользователем формате, будет возвращен результат в формате предпочитаемый клиента.

![Fiddler консоль, показывающая, вручную создать запрос со значением заголовка Accept application/XML GET](formatting/_static/fiddler-composer.png)

В приведенном выше снимке экрана Fiddler редактор используется для создания запроса, указав `Accept: application/xml`. По умолчанию ASP.NET Core MVC поддерживает только JSON, так что даже если указан другой формат, возвращаемый результат будет по-прежнему формата JSON. Вы увидите, как добавить дополнительные модули форматирования в следующем разделе.

Действия контроллера может возвращать POCO (обычные старые объекты CLR), в этом случае ASP.NET MVC автоматически создаст `ObjectResult` , создает оболочку этого объекта. Клиент получит форматированные сериализованного объекта (по умолчанию используется формат JSON, XML или в других форматах можно настроить). Если объекта возвращается `null`, платформа возвратит `204 No Content` ответа.

Возвращает тип объекта:

[!code-csharp[Main](./formatting/sample/Controllers/Api/AuthorsController.cs?highlight=3&range=40-45)]

В этом образце запроса для псевдонима допустимым автор получит ответ 200 ОК с данными автора. Недопустимый псевдоним запрос получит 204 Нет содержимого ответа. Ниже приведены снимки экрана, показывающий ответа в форматах XML и JSON.

### <a name="content-negotiation-process"></a>Процесс согласования содержимого

Содержимого *согласование* поместите происходит только в случае, если `Accept` заголовок отображается в запросе. Если запрос содержит заголовок accept, платформа перечисляет типы носителей в заголовке accept в порядке предпочтения и попытается найти средство форматирования, который может производить ответа в одном из форматов, указанных в заголовке accept. В случае, если модуль форматирования не найден, можно удовлетворить запрос клиента, платформа будет пытаться найти первый модуль форматирования, который может производить ответ (если разработчик настроил параметр `MvcOptions` для возврата 406 неприемлемо вместо). Если в запросе указан XML, но не был настроен модуль форматирования XML, будет использовать модуль форматирования JSON. В общем случае если модуль форматирования не настроен, можно указать требуемый формат, то используется первый модуль форматирования, который можно форматировать объект. Если заголовок не указан, первый модуль форматирования, который может обрабатывать объекта, возвращаемого будет использоваться для сериализации ответа. В этом случае не все согласования происходящей - сервер определяет, какой формат, который будет использоваться.

> [!NOTE]
> Если заголовок Accept содержит `*/*`, заголовок будет игнорироваться, если `RespectBrowserAcceptHeader` имеет значение true для `MvcOptions`.

### <a name="browsers-and-content-negotiation"></a>Браузеры и согласования содержимого

В отличие от типичные клиенты API веб-браузеры, как правило, для предоставления `Accept` заголовки, которые включают широкий набор форматов, включая подстановочные знаки. По умолчанию при обнаружении платформу, запрос поступает из браузера, он игнорирует `Accept` заголовок и вместо него возвращаемое содержимое в приложении настройки по умолчанию формат (JSON пока иначе настроены). Это обеспечивает более согласованной работы при использовании различных браузеров для использовать интерфейсы API.

Если вы предпочитаете заголовки accept браузере честь приложения, это можно настроить как часть конфигурации MVC, задав `RespectBrowserAcceptHeader` для `true` в `ConfigureServices` метод в *файла Startup.cs*.

```csharp
services.AddMvc(options =>
{
    options.RespectBrowserAcceptHeader = true; // false by default
});
```

## <a name="configuring-formatters"></a>Настройка модулей форматирования

Если приложению для поддержки дополнительных форматов, помимо стандартных JSON, можно добавить пакеты NuGet и настроить MVC для их поддержки. Существуют отдельные модули форматирования для ввода и вывода. Входной модули форматирования, используемые [привязки модели](model-binding.md); модули форматирования выходных данных, используемые для форматирования ответов. Можно также настроить [пользовательские модули форматирования](../advanced/custom-formatters.md).

### <a name="adding-xml-format-support"></a>Добавление поддержки формата XML

Чтобы добавить поддержку форматирования XML-кода, установите `Microsoft.AspNetCore.Mvc.Formatters.Xml` пакет NuGet.

Добавить XmlSerializerFormatters конфигурацию MVC в *файла Startup.cs*:

[!code-csharp[Main](./formatting/sample/Startup.cs?name=snippet1&highlight=2)]

Кроме того можно добавить только форматирования выходных данных:

```csharp
services.AddMvc(options =>
{
    options.OutputFormatters.Add(new XmlSerializerOutputFormatter());
});
```

Эти два подхода выполняет сериализацию результатов с помощью `System.Xml.Serialization.XmlSerializer`. При желании можно использовать `System.Runtime.Serialization.DataContractSerializer` путем добавления его связанный форматирования:

```csharp
services.AddMvc(options =>
{
    options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter());
});
```

После добавления поддержки форматирования XML на контроллер методы должны возвращать формат в запросе `Accept` заголовок как Fiddler, этот пример:

![Fiddler консоли: необработанные вкладке для запроса отображается значение заголовка Accept приложения/xml. Необработанный вкладки для ответа показывает значение заголовка Content-Type, application/XML.](formatting/_static/xml-response.png)

Можно увидеть на вкладке инспекторах, был сделан запрос на получение необработанных `Accept: application/xml` задан заголовок. В области отображается ответ `Content-Type: application/xml` заголовок и `Author` сериализованный объект в формат XML.

Вкладка редактор для изменения запроса для указания `application/json` в `Accept` заголовок. Выполнение запроса и ответа будут отформатированы в качестве JSON:

![Fiddler консоли: необработанные вкладке для запроса отображается значение заголовка Accept — application/json. Необработанный вкладки для ответа показывает значение заголовка Content-Type приложение/json.](formatting/_static/json-response-fiddler.png)

На этом снимке экрана можно увидеть в запросе задан заголовок `Accept: application/json` и ответ указывает таким же, как его `Content-Type`. `Author` Объекта отображается в тексте ответа в формате JSON.

### <a name="forcing-a-particular-format"></a>Принудительное определенного формата

Если вы хотите ограничить форматы ответа для конкретного действия можно выполнить, можно применить `[Produces]` фильтра. `[Produces]` Фильтр указывает форматы ответа для определенных действий (или контроллера). Как и большинство [фильтры](../controllers/filters.md), могут применяться в действия, контроллера или глобальной области.

```csharp
[Produces("application/json")]
public class AuthorsController
```

`[Produces]` Фильтр будет принудительно всем действиям в `AuthorsController` для возврата ответов формата JSON, даже если были настроены другие модули форматирования для приложения и предоставляются клиентом `Accept` заголовок запроса другой, доступной формат. В разделе [фильтры](../controllers/filters.md) для получения дополнительных сведений, включая способы применения фильтров глобально.

### <a name="special-case-formatters"></a>Специальные вариантов форматирования данных

Некоторые особые случаи реализуются с помощью встроенных модулей форматирования. По умолчанию `string` возвращаемые типы будут отформатированы в качестве *text/plain* (*текст или HTML-* по запросу через `Accept` заголовок). Это поведение можно удалить, удалив `TextOutputFormatter`. Удаление модулей форматирования в `Configure` метод в *файла Startup.cs* (см. ниже). Действия, которые имеют объекта модели возвращают тип вернет 204 Нет содержимого ответа при возврате `null`. Это поведение можно удалить, удалив `HttpNoContentOutputFormatter`. В следующем примере кода удаляет `TextOutputFormatter` и `HttpNoContentOutputFormatter`.

```csharp
services.AddMvc(options =>
{
    options.OutputFormatters.RemoveType<TextOutputFormatter>();
    options.OutputFormatters.RemoveType<HttpNoContentOutputFormatter>();
});
```

Без `TextOutputFormatter`, `string` возврата типов возврата 406 неприемлемо, например. Обратите внимание, если модуль форматирования XML существует, он будет формата `string` возвращаемые типы, если `TextOutputFormatter` удаляется.

Без `HttpNoContentOutputFormatter`, объектов со значением null форматируются с помощью настроенных модуля форматирования. Например, модуль форматирования JSON просто возвращает ответ с текстом `null`, а модуль форматирования XML вернет пустым элементом XML с атрибутом `xsi:nil="true"` значение.

## <a name="response-format-url-mappings"></a>Сопоставления URL-адрес ответа формат

Клиенты могут запрашивать определенного формата как часть URL-адрес, например, в строке запроса или часть пути, либо используя расширение файла определенного формата, например XML или .json. Сопоставление пути запроса должно быть указано в маршрут, который использует API-интерфейса. Пример:

```csharp
[FormatFilter]
public class ProductsController
{
    [Route("[controller]/[action]/{id}.{format?}")]
    public Product GetById(int id)
```

Запрошенный формат должен задаваться в качестве необязательного файла расширения и использовать этот маршрут. `[FormatFilter]` Атрибут проверяет наличие значения в формате `RouteData` и назначит формат ответа соответствующий модуль форматирования при создании ответа.

| Маршрут                      | Formatter                          |
| -------------------------- | ---------------------------------- |
| `/products/GetById/5`      | Модуль форматирования выходных данных по умолчанию       |
| `/products/GetById/5.json` | Модуль форматирования JSON (если настроено) |
| `/products/GetById/5.xml`  | Модуль форматирования XML (если настроено)  |
