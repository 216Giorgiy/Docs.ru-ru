---
title: Использование шаблона проекта Angular с ASP.NET Core
author: SteveSandersonMS
description: Дополнительные сведения о начале работы с шаблоном проекта одностраничного приложения (SPA) ASP.NET Core для Angular и Angular CLI.
manager: wpickett
monikerRange: '>= aspnetcore-2.0'
ms.author: scaddie
ms.custom: mvc
ms.date: 02/21/2018
ms.devlang: csharp
ms.prod: aspnet-core
ms.technology: aspnet
ms.topic: article
uid: spa/angular
ms.openlocfilehash: 244fece83279ae4d9ead9b345fcdd66ad6ed4225
ms.sourcegitcommit: 466300d32f8c33e64ee1b419a2cbffe702863cdf
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/27/2018
ms.locfileid: "34555434"
---
# <a name="use-the-angular-project-template-with-aspnet-core"></a>Использование шаблона проекта Angular с ASP.NET Core

::: moniker range="= aspnetcore-2.0"

> [!NOTE]
> Информация о шаблоне проекта Angular, который включен в ASP.NET Core 2.0, в этой документации отсутствует. Речь идет о более новом шаблоне Angular, который можно обновить вручную. По умолчанию этот шаблон включен в ASP.NET Core 2.1.

::: moniker-end

Обновленный шаблон проекта Angular обеспечивает удобную отправную точку для приложений ASP.NET Core с использованием Angular и Angular CLI для реализации богатого пользовательского интерфейса (UI) на стороне клиента.

Шаблон является эквивалентом созданию проекта ASP.NET Core, выступающего в качестве серверного API, и проекта Angular CLI в качестве пользовательского интерфейса. В шаблоне предлагается удобное размещения обоих типов проектов в проекте отдельного приложения. Что в свою очередь позволит создать и опубликовать проект приложения как единое целое.

## <a name="create-a-new-app"></a>Создание нового приложения

При использовании ASP.NET Core 2.0 необходимо убедиться, что [для шаблона проекта Angular установлены обновления](xref:spa/index#installation). Если вы используете ASP.NET Core 2.1, установка обновлений не требуется.

Создайте из командной строки новый проект в пустом каталоге с помощью команды `dotnet new angular`. Например, следующие команды позволяют создать приложение в каталоге *my-new-app* и перейти к этому каталогу:

```console
dotnet new angular -o my-new-app
cd my-new-app
```

Запустите приложение в Visual Studio или в .NET Core CLI.

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio/)

Откройте созданный файл проекта *.csproj* и запустите в нем приложение в обычном режиме.

В процессе сборки при первом запуске восстанавливаются зависимости npm. Это может занять несколько минут. Последующие сборки выполняются гораздо быстрее.

# <a name="net-core-clitabnetcore-cli"></a>[Интерфейс командной строки .NET Core](#tab/netcore-cli/)

Убедитесь, что у вас существует переменная среда `ASPNETCORE_Environment`, которой соответствует значение `Development`. Запустите команду `SET ASPNETCORE_Environment=Development` в ОС Windows (в приглашениях, отличных от PowerShell). А в ОС Linux или macOS запустите команду `export ASPNETCORE_Environment=Development`.

Чтобы проверить наличие ошибок при создании приложения, запустите команду [dotnet-build](/dotnet/core/tools/dotnet-build). При первом запуске процесса создания будут восстановлены зависимости npm, на что может потребоваться несколько минут. Последующие сборки выполняются гораздо быстрее.

Чтобы запустить приложение, выполните команду [dotnet run](/dotnet/core/tools/dotnet-run). Следующее сообщение будет записано в журнал.

```console
Now listening on: http://localhost:<port>
```

Перейдите по этому URL-адресу в браузере.

Это приложение будет запущено в качестве экземпляра сервера Angular CLI в фоновом режиме. Будет записано следующее сообщение: *сервер разработки NG Live ожидает вызова localhost:&lt;otherport&gt;, откройте браузер на странице http://localhost:&lt:otherport&gt;/*. Это сообщение необходимо проигнорировать&mdash;оно **не** является URL-адресом объединенного приложения ASP.NET Core и Angular CLI.

---

С помощью шаблона проекта будут созданы приложения ASP.NET Core и Angular. Приложение ASP.NET Core предназначено для использования в таких сферах как: получение доступа к данным, авторизация и других проблемных вопросах на стороне сервера. Приложение Angular, которое находится в подкаталоге *ClientApp*, предназначено для решения проблем, связанных с пользовательским интерфейсом.

## <a name="add-pages-images-styles-modules-etc"></a>Добавление страниц, изображений, стилей, модулей, и т. д

Приложение Angular CLI находится в стандартном каталоге *ClientApp*. Дополнительные сведения см. в [документации по Angular](https://github.com/angular/angular-cli/wiki).

Между приложением Angular, созданным этим шаблоном, и тем, которое создано Angular CLI (через `ng new`), существует небольшая разница, однако возможности приложений остаются без изменений. Приложение, созданное с помощью шаблона, содержит макет на основе набора инструментов [Bootstrap](https://getbootstrap.com/) и примеры базовой маршрутизации.

## <a name="run-ng-commands"></a>Выполнение команды ng

Перейдите в подкаталог *ClientApp* в командной строке.

```console
cd ClientApp
```

Если инструмент `ng` был установлен с атрибутом глобально, вы можете использовать любую из команд. Например, можно выполнить команду `ng lint`, `ng test` или любую из [дополнительных команд Angular CLI](https://github.com/angular/angular-cli/wiki#additional-commands). Запускать команду `ng serve` не имеет смысла, так как приложение ASP.NET Core выполняет обслуживание как части сервера, так и клиентской части приложения. `ng serve` также используется для внутренней разработки.

При отсутствии установленного инструмента `ng`, используйте `npm run ng`. Например, можно запустить `npm run ng lint` или `npm run ng test`.

## <a name="install-npm-packages"></a>Установка пакетов npm

Чтобы установить пакеты сторонних производителей npm, откройте командную строку из подкаталога *ClientApp*. Пример:

```console
cd ClientApp
npm install --save <package_name>
```

## <a name="publish-and-deploy"></a>Публикация и развертывание

В процессе разработки приложение работает в режиме, оптимизированном для удобства разработчиков. Например, пакеты JavaScript включают в себя исходные карты (так, чтобы при отладке можно было увидеть исходный код TypeScript). Приложение отслеживает изменения в файлах TypeScript, HTML и CSS на диске, и когда эти файлы меняются, автоматически их повторно компилирует и перезагружает.

В рабочей среде обслуживается версия приложения, которая оптимизирована для производительности. Это настроено автоматически. При публикации конфигурация сборки выполняет операцию минификации, скомпилированной сборки Ahead of Time (AoT) клиентского кода. В отличии от средств сборки, производственная сборка не требует установки Node.js на сервер (если только вы не включили параметр [отрисовка на стороне сервера](#server-side-rendering)).

Можно использовать стандартные [методы размещения и развертывания ASP.NET Core](xref:host-and-deploy/index).

## <a name="run-ng-serve-independently"></a>Запуск команды ng serve в автономном режиме

Проект настроен для запуска собственного экземпляра сервера Angular CLI в фоновом режиме, когда приложение ASP.NET Core запускается в режиме разработки. Это удобно, так как нет необходимости вручную запускать отдельный сервер.

У этой настройки по умолчанию имеется недостаток. Каждый раз, когда код на C# изменяется, приложение ASP.NET Core необходимо перезапустить, что приводит к перезапуску сервера Angular CLI. Чтобы начать резервное копирование, необходимо около 10 секунд. Если вы часто изменяете код C# и не хотите ждать, пока Angular CLI перезапустится, тогда независимо от процесса ASP.NET Core запустите сервер Angular CLI извне. Для этого:

1. Перейдите в подкаталог *ClientApp* в командной строке и запустите сервер разработки Angular CLI.

    ```console
    cd ClientApp
    npm start
    ```

    > [!IMPORTANT]
    > Используйте команду `npm start`, а не `ng serve`, чтобы запустить сервер разработки Angular CLI, что позволит учитывать конфигурацию в файле *package.json*. Чтобы передать дополнительные параметры серверу Angular CLI, добавьте их в соответствующую строку `scripts` файла *package.json*.

2. Чтобы использовать внешний экземпляр Angular CLI вместо запуска одного из своих экземпляров, измените приложение ASP.NET Core. В классе *Startup* замените вызов `spa.UseAngularCliServer` следующим значением:

    ```csharp
    spa.UseProxyToSpaDevelopmentServer("http://localhost:4200");
    ```

При запуске приложения ASP.NET Core экземпляр сервера Angular CLI запускаться не будет. Вместо него будет использоваться экземпляр, запускаемый вручную. Это ускорит запуск и перезагрузку. Теперь не придется каждый раз дожидаться повторной сборки клиентского приложения в Angular CLI.

## <a name="server-side-rendering"></a>Отрисовка на стороне сервера

В качестве повышения производительности можно выбрать выполнение предварительной визуализации программы Angular на нескольких серверах, так же как и запустить ее в клиенте. Это значит, браузеры получат разметку HTML, которая отображает первоначальный пользовательский интерфейс приложения, поэтому он отображается перед загрузкой и выполнением пакетов JavaScript. Большая часть реализации основывается на функции Angular, под названием [Angular Universal](https://universal.angular.io/).

> [!TIP]
> Включение параметра отрисовки на стороне сервера (SSR) вводит ряд дополнительных осложнений как во время разработки, так и при развертывании. Чтобы узнать, соответствует ли SSR необходимым требованиям, ознакомьтесь с разделом [Недостатки SSR](#drawbacks-of-ssr).

Чтобы включить SSR, в проект необходимо внести ряд дополнений.

В классе *Startup*, *после* строки, в которой настраивается `spa.Options.SourcePath`, и *перед* вызовом `UseAngularCliServer` или `UseProxyToSpaDevelopmentServer`, необходимо добавить следующий код:

[!code-csharp[](sample/AngularServerSideRendering/Startup.cs?name=snippet_Call_UseSpa&highlight=5-12)]

С помощью этого кода в режиме разработки будет создан пакет SSR путем запуска сценария `build:ssr`, который находится по адресу *ClientApp\package.json*. Это позволит создать приложения Angular `ssr`, которое на данный момент не определено.

В конце массива `apps`, который находится в *ClientApp/.angular-cli.json*, определите дополнительное приложение `ssr`. Используйте следующие параметры.

[!code-json[](sample/AngularServerSideRendering/ClientApp/.angular-cli.json?range=24-41)]

Для этой новой конфигурации приложения с поддержкой SSR требуются два дополнительных файла: *tsconfig.server.json* и *main.server.ts*. Файл *tsconfig.server.json* указывает параметры компиляции для TypeScript. Файл *main.server.ts* служит точкой входа кода во время обработки SSR.

Добавьте новый файл *tsconfig.server.json* в каталог *ClientApp/src* (рядом с существующим файлом *tsconfig.app.json*), который будет содержать следующий код:

[!code-json[](sample/AngularServerSideRendering/ClientApp/src/tsconfig.server.json)]

Это файл настроек компилятора Angular Ahead of Time (AoT) для поиска модуля `app.server.module`. Добавить настройки можно путем создания файла по адресу *ClientApp/src/app/app.server.module.ts* (наряду с существующим файлом *app.module.ts*), в котором будет содержаться следующий код:

[!code-typescript[](sample/AngularServerSideRendering/ClientApp/src/app/app.server.module.ts)]

Этот модуль наследуется `app.module` от клиентской стороны и определяет, какие дополнительные модули Angular доступны во время процесса SSR.

Обратите внимание, что новая запись `ssr` в файле *.angular-cli.json* ссылается на файл точки входа *main.server.ts*. Которого пока нет, но далее он буде создан. В каталоге *ClientApp/src/main.server.ts* создайте файл (наряду с существующим файлом *main.ts*), который будет содержать следующий код:

[!code-typescript[](sample/AngularServerSideRendering/ClientApp/src/main.server.ts)]

ASP.NET Core выполняет код этого файла для каждого запроса при запуске промежуточного программного обеспечения `UseSpaPrerendering`, добавленного в класс *Startup*. Он занимается получением `params` из кода .NET (например, запрашиваемого URL-адреса) и вызовом API Angular SSR для получения HTML-файла.

Строго говоря, это достаточно, чтобы запустить SSR в режиме разработки. Крайне важно сделать последнее изменение, чтобы при публикации приложение работало правильно. В главном файле *.csproj* своего приложения установите для свойства `BuildServerSideRenderer` значение `true`:

[!code-xml[](sample/AngularServerSideRendering/AngularServerSideRendering.csproj?name=snippet_EnableBuildServerSideRenderer)]

Это позволит настроить процесс сборки для запуска `build:ssr` во время публикации и развертывания файлов SSR на сервере. Выполнение SSR завершится ошибкой, если этот параметр не включить.

Вне зависимости от режима запуска (производственный или режим разработки) с помощью кода Angular на сервере будет выполнена предварительная визуализация HTML. Клиентский код выполняется в обычном режиме.

### <a name="pass-data-from-net-code-into-typescript-code"></a>Передача данных от .NET к TypeScript

Во время работы SSR может возникнуть необходимость передать данные отдельных запросов из ASP.NET Core в Angular. Например, можно передать сведения из файла cookie или данные, полученные из базы данных. Чтобы это сделать, необходимо внести изменения в класс *Startup*. В обратном вызове `UseSpaPrerendering` для `options.SupplyData` установите указанное ниже значение.

```csharp
options.SupplyData = (context, data) =>
{
    // Creates a new value called isHttpsRequest that's passed to TypeScript code
    data["isHttpsRequest"] = context.Request.IsHttps;
};
```

С помощью обратного вызова `SupplyData` можно передавать произвольные данные, отдельные запросы, а также JSON-сериализируемые данные (например, строки, логические значения или числа). Для кода в файле *main.server.ts* эти данные будут получены в качестве `params.data`. Например, в предыдущем примере кода логическое значение передается как `params.data.isHttpsRequest` в обратный вызов `createServerRenderer`. Также эти данные можно передавать другим частям приложения любым способом, поддерживаемым Angular. Например, ознакомьтесь с тем, как *main.server.ts* передает значения `BASE_URL` любому компоненту, конструктор которого объявлен получателем.

### <a name="drawbacks-of-ssr"></a>Недостатки SSR

Не все приложения получают преимущество от использования SSR. Основное преимущество — воспринимаемая производительность. При использовании вашего приложения посетители, у которых низкая скорость сетевого подключения или медленные мобильные устройства, быстро обнаруживают первоначальный пользовательский интерфейс, даже если для получения или анализа пакетов JavaScript требуется некоторое время. Тем не менее в основном многие одностраничные приложения (SPA) используются в быстрых внутренних сетях компании на быстрых компьютерах, где приложение появляется почти мгновенно.

В тоже время при использовании SSR существует ряд недостатков. В процесс разработки вносится дополнительная сложность. Код должен быть запущен в двух разных средах как на стороне клиента, так и на стороне сервера (в среде Node.js, вызываемой из ASP.NET Core). Ниже приведены некоторые аспекты, которые необходимо учитывать.

* Для SSR необходимо, чтобы на рабочих серверах был установлен Node.js. В некоторых сценариях это происходит автоматически (например, службы приложений Azure), а в других — нет (например, Azure Service Fabric).
* Установка флага сборки `BuildServerSideRenderer` приведет к публикации каталога *node_modules*. В этой папке находятся более 20 000 файлов, что повлечет за собой увеличение времени развертывания.
* Для запуска кода в среде Node.js нельзя полагаться на такие существующие API JavaScript как `window` или `localStorage`. Если во время выполнения SSR для кода (или некоторых используемых библиотек сторонних разработчиков) будут использованы эти API, выполнение SSR завершится сбоем. Например, не используйте jQuery, так как часто он использует на браузерные API. Чтобы предотвратить возникновение ошибки, необходимо избегать использовать SSR или браузерных API-интерфейсов и библиотек. Любые вызовы могут быть перенесены в проверки API, чтобы гарантировать, что они не будут вызваны во время SSR. Например, в коде JavaScript или TypeScript можно использовать следующую проверку:

    ```javascript
    if (typeof window !== 'undefined') {
        // Call browser-specific APIs here
    }
    ```
