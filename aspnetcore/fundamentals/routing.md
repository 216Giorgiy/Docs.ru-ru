---
title: "Маршрутизация в ASP.NET Core"
author: ardalis
description: "Узнайте, как функции маршрутизации ASP.NET Core отвечает за сопоставление входящего запроса к обработчику маршрута."
keywords: ASP.NET Core
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: bbbcf9e4-3c4c-4f50-b91e-175fe9cae4e2
ms.technology: aspnet
ms.prod: asp.net-core
uid: fundamentals/routing
ms.openlocfilehash: 5dd8bee7228587d7e13f128bc8f16102fb70a412
ms.sourcegitcommit: 8f4d4fad1ca27adf9e396f5c205c9875a3963664
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2017
---
# <a name="routing-in-aspnet-core"></a>Маршрутизация в ASP.NET Core

По [Nowak Райана](https://github.com/rynowak), [Стив Смит](https://ardalis.com/), и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Функции маршрутизации отвечает за сопоставление входящего запроса к обработчику маршрута. Маршруты определяются в приложении ASP.NET и настроить при запуске приложения. Маршрут при необходимости можно извлечь значения из URL-адреса, содержащиеся в запросе, а затем эти значения могут использоваться для обработки запроса. Используя данные о маршруте из приложения ASP.NET, функции маршрутизации также могут создавать URL-адреса, которые сопоставляются обработчики маршрутов. Таким образом маршрутизации можно найти обработчик маршрутов на основе URL-адрес или URL-адрес, соответствующий заданным маршрутом обработчика, на основе сведений обработчик маршрута.

>[!IMPORTANT]
> В этом документе рассматриваются низкого уровня ASP.NET Core маршрутизации. Для маршрутизации ASP.NET Core MVC, в разделе [маршрутизации действия контроллера](../mvc/controllers/routing.md)

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/routing/sample) ([как скачивать](xref:tutorials/index#how-to-download-a-sample))

## <a name="routing-basics"></a>Основы маршрутизации

Использует маршрутизации *маршруты* (реализации [IRouter](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.routing.irouter)) для:

* сопоставить входящие запросы на *маршрутизации обработчиков*

* Создание URL-адреса, используемые в ответах

Как правило приложение имеет одну коллекцию маршрутов. При получении запроса, коллекцию маршрутов обрабатываются в порядке. Входящий запрос ищет маршрут, соответствующий URL-адрес запроса путем вызова `RouteAsync` метод на всех доступных маршрутов в семействе маршрутов. Напротив ответ маршрутизацию для формирования URL-адреса (например, для перенаправления или ссылки) на основании информации маршрута и таким образом избежать необходимости жестко URL-адреса, что обеспечивает удобство поддержки.

Маршрутизация подключен к [по промежуточного слоя](middleware.md) продаж по `RouterMiddleware` класса. [ASP.NET MVC](../mvc/overview.md) добавляет маршрутизации для конвейера по промежуточного слоя в процессе его настройки. Дополнительные сведения об использовании маршрутизации в качестве автономного компонента см. в разделе [с помощью маршрутизации-по промежуточного слоя](#using-routing-middleware).

<a name="url-matching-ref"></a>

### <a name="url-matching"></a>URL-адрес соответствует

URL-адрес соответствует — это процесс, с которой маршрутизации отправляет входящий запрос на *обработчик*. Этот процесс обычно основывается на данных в URL-адрес, но можно расширить, добавив считать все данные в запросе. Возможность отправки запросов для разделения обработчики — ключ к масштабированию размера и сложности приложения.

Введите входящие запросы `RouterMiddleware`, который вызывает `RouteAsync` метод для каждого маршрута в последовательности. `IRouter` Выбирает экземпляр ли *обработки* запроса, задав `RouteContext.Handler` в ненулевое значение `RequestDelegate`. Если маршрут задает обработчик для запроса, обработка останавливается и обработчик маршрута будет вызываться для обработки запроса. Если обработчик не найден для запроса, проверяются все маршруты, по промежуточного слоя вызывает *Далее* и вызывается следующее по промежуточного слоя в конвейере.

Основной входных данных для `RouteAsync` — `RouteContext.HttpContext` связанный с текущим запросом. `RouteContext.Handler` И `RouteContext.RouteData` выходов, будет установлено после того, соответствует маршрут.

Соответствие во время `RouteAsync` также задать свойства `RouteContext.RouteData` с учетом обработки запросов, выполненные соответствующими значениями. Если маршрут соответствует запросу, `RouteContext.RouteData` будет содержать состояние важные сведения о *результат*.

`RouteData.Values`представляет собой словарь *значения маршрута* , произведенного из маршрута. Эти значения обычно определяется маркирование URL-адрес и может использоваться для получения входных данных пользователя или для проведения дальнейшей диспетчеризации внутри приложения.

`RouteData.DataTokens`является набором свойств дополнительные данные, связанные с сопоставленного маршрута. `DataTokens`предоставляются для поддержки связывание состояние, в котором обнаружено соответствие данных со всех маршрутов, поэтому приложение может принять решение позже исходя какой маршрут. Эти значения, определяемые разработчиком и выполните **не** влияют на поведение маршрутизации каким-либо образом. Кроме того значения, помещается в маркеры данных могут быть любого типа, в отличие от значений маршрута, которые должны быть легко могут быть преобразованы в строки и обратно.

`RouteData.Routers`Представляет список маршрутов, которые участвуют в согласовании запрос успешно. Маршруты могут быть вложенными друг в друга и `Routers` свойство отражает путь через логическое дерево маршруты, которые привели к совпадению. Как правило, первый элемент в `Routers` представляет коллекцию маршрутов и должен использоваться для создания URL-адресов. Последний элемент в `Routers` является обработчик маршрутов, который соответствует.

### <a name="url-generation"></a>Создание URL-адреса

Создание URL-адрес — это процесс, с которых маршрутизация можно создавать на основе набора значений маршрута пути URL. Это обеспечивает логическое разделение обработчиков и URL-адреса, которые обращаются к этим.

Создания URL-адресов следует аналогичный итеративный процесс, но запускается пользователем или framework кода, вызывающего `GetVirtualPath` метод коллекции маршрутов. Каждый *маршрута* будет иметь его `GetVirtualPath` метод, вызываемый в последовательности до ненулевой `VirtualPathData` возвращается.

Основной входные данные для `GetVirtualPath` являются:

* `VirtualPathContext.HttpContext`

* `VirtualPathContext.Values`

* `VirtualPathContext.AmbientValues`

Маршруты в основном используют значения маршрута, предоставляемые `Values` и `AmbientValues` решаете, где можно создать URL-адрес и какие значения следует включить. `AmbientValues` Представляют набор значений маршрута, которые были созданы из поиска соответствий текущего запроса с системы маршрутизации. Напротив `Values` значения маршрута, определяющие способ создания нужный URL-адреса для текущей операции. `HttpContext` Предоставляется в случае, если маршрут должен получать служб или дополнительные данные, связанные с текущим контекстом.

Совет: Можно рассматривать `Values` как набор переопределения для `AmbientValues`. Создание URL-адрес пытается повторно использовать значения маршрута из текущего запроса для упрощения создания URL-адресов для ссылок с помощью того же маршрута и значения маршрута.

Выходные данные `GetVirtualPath` — `VirtualPathData`. `VirtualPathData`является параллельное `RouteData`; он содержит `VirtualPath` выходной URL-адрес, а также некоторые дополнительные свойства, которые должны быть настроены с маршрутом.

`VirtualPathData.VirtualPath` Свойство содержит *виртуальный путь* созданный маршрут. В зависимости от потребностей необходимо обработать дополнительные пути. Для экземпляра Если нужно отобразить созданный URL-адрес в формате HTML необходимо добавить базовый путь приложения.

`VirtualPathData.Router` Является ссылкой на маршрут, который успешно создал URL-адрес.

`VirtualPathData.DataTokens` Свойства представляет собой словарь дополнительные данные, относящиеся к маршрута, созданный URL-адрес. Это параллельный из `RouteData.DataTokens`.

### <a name="creating-routes"></a>Создание маршрутов

Служба маршрутизации предоставляет `Route` класс как стандартную реализацию `IRouter`. `Route`использует *шаблон маршрута* синтаксис для определения шаблонов, которые будут сравниваться с URL-адрес при `RouteAsync` вызывается. `Route`будет использовать один и тот же шаблон маршрута для создания URL-адреса при `GetVirtualPath` вызывается.

Большинство приложений будет создать маршруты, вызвав `MapRoute` или одну из подобных методов расширения, определенные в `IRouteBuilder`. Все эти методы будет создан экземпляр `Route` и добавьте его в коллекцию маршрутов.

Примечание: `MapRoute` не принимает параметр обработчика маршрута — он только добавляет маршруты, которые будут проводиться `DefaultHandler`. Так как обработчик по умолчанию является `IRouter`, он может принять решение не обрабатывает запрос. Например ASP.NET MVC обычно настраивается, обработчик по умолчанию, который обрабатывает только запросы, которые соответствуют доступных контроллера и действия. Дополнительные сведения о маршрутизации в MVC см. в разделе [маршрутизации для действий контроллеров](../mvc/controllers/routing.md).

Это пример `MapRoute` вызов, используемый типичное определение маршрута ASP.NET MVC:

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

Этот шаблон будет соответствовать пути URL-адрес, например `/Products/Details/17` и извлечение значений маршрута `{ controller = Products, action = Details, id = 17 }`. Значения маршрута, определяются разделение на сегменты URL-адрес и сопоставления каждый сегмент *направления параметра* в шаблоне маршрута. Параметры маршрута являются именованными. Они определяются, заключив в фигурные скобки имя параметра `{ }`.

Выше шаблон может также соответствовать URL-адрес `/` и приведет к получению значения `{ controller = Home, action = Index }`. Это происходит потому, что `{controller}` и `{action}` маршрут иметь значения по умолчанию и `id` маршрута параметр является необязательным. Знак равенства `=` знак за которым следует значение после значения по умолчанию для параметра определяет имя параметра маршрута. Знак вопроса `?` после имени параметра маршрута определяет параметр необязательным. Направления параметра со значением по умолчанию *всегда* образует значение маршрута, если этот маршрут соответствует — необязательные параметры не дает значение маршрута в случае отсутствия нет соответствующий сегмент пути URL-адрес.

В разделе [ссылка на шаблон для маршрута](#route-template-reference) подробное описание функции шаблона маршрута и синтаксис.

Данный пример включает *маршрутизации ограничение*:

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
```

Этот шаблон будет соответствовать пути URL-адрес, например `/Products/Details/17`, но не `/Products/Details/Apples`. Определение параметра маршрута `{id:int}` определяет *маршрутизации ограничение* для `id` направления параметра. Ограничения маршрута реализовать `IRouteConstraint` и проверять значения маршрута, чтобы проверить их. В этом примере значение маршрута `id` должен допускать преобразование в целое число. В разделе [ссылка для ограничения маршрута](#route-constraint-reference) более подробное описание ограничения маршрута, предоставляемых платформой.

Дополнительные перегрузки `MapRoute` примите значения для `constraints`, `dataTokens`, и `defaults`. Эти дополнительные параметры `MapRoute` определяются как тип `object`. Типичное использование этих параметров является передача объект анонимно типизированных маршрутов имена свойств анонимного типа сопоставления имен параметров.

Следующие два примера создайте эквивалентные маршруты:

```csharp
routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
```

Совет: Встроенный синтаксис для определения ограничений и значений по умолчанию может быть более удобным для простой маршрутов. Однако есть функции, такие как маркеры данных, которые не поддерживаются встроенный синтаксис.

В этом примере показаны некоторые дополнительные возможности:

```csharp
routes.MapRoute(
  name: "blog",
  template: "Blog/{*article}",
  defaults: new { controller = "Blog", action = "ReadArticle" });
```

Этот шаблон будет соответствовать пути URL-адрес, например `/Blog/All-About-Routing/Introduction` и будет извлекать значения `{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }`. Значения маршрута по умолчанию для `controller` и `action` создаются в маршруте, даже если в шаблоне нет соответствующих параметров маршрута. Значения по умолчанию, могут быть указаны в шаблоне маршрута. `article` Маршрут параметр определен как *универсальным* , внешний вид звездочка `*` перед именем параметра маршрута. Параметры маршрута универсальным захватить остаток URL-адрес и также может совпасть с пустой строкой.

В этом примере добавляется маркеры ограничений и данные маршрута:

```csharp
routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
```

Этот шаблон будет соответствовать пути URL-адрес, например `/Products/5` и будет извлекать значения `{ controller = Products, action = Details, id = 5 }` и маркеры данных `{ locale = en-US }`.

![Локальные токены Windows](routing/_static/tokens.png)

<a name="id1"></a>

### <a name="url-generation"></a>Создание URL-адреса

`Route` Класс также может выполнять создания URL-адресов, объединяя набор значений маршрута с его шаблоном маршрута. Это логически обратный процесс сопоставления URL-адрес.

Совет: Чтобы лучше понять создания URL-адресов, представьте себе какой URL-адрес, необходимо создать и затем подумайте о том, как шаблон маршрута будет соответствовать этот URL-адрес. Какие значения будут получены? Это эквивалентно грубого о принципах создания URL-адресов в `Route` класса.

В этом примере используется базовый стиль маршрут ASP.NET MVC:

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

С помощью значения маршрута `{ controller = Products, action = List }`, URL-адрес будет создать этот маршрут `/Products/List`. Значения маршрута, заменяются на соответствующие параметры маршрута для формирования URL-адрес. Поскольку `id` не является обязательной направления параметра, то это не проблема, что значение не указано.

С помощью значения маршрута `{ controller = Home, action = Index }`, URL-адрес будет создать этот маршрут `/`. Значения маршрута, которые были указаны соответствуют значениям по умолчанию, и сегменты, соответствующий эти значения можно безопасно пропустить. Обратите внимание, что URL-адресов обоих созданных приема-передачи с этим определением маршрута будет создавать одинаковые значения маршрута, которые были использованы для создания URL-адрес.

Совет: Следует использовать приложения с помощью ASP.NET MVC `UrlHelper` для создания URL-адресов, а не вызывают непосредственно маршрутизации.

Дополнительные сведения о процессе создания URL-адреса см. в разделе [ссылка URL-адрес формирования](#url-generation-reference).

## <a name="using-routing-middleware"></a>С помощью маршрутизации по промежуточного слоя

Добавьте пакет NuGet «Microsoft.AspNetCore.Routing».

Добавить маршрут в контейнер службы в *файла Startup.cs*:

[!code-csharp[Main](../fundamentals/routing/sample/RoutingSample/Startup.cs?highlight=3&start=11&end=14)]

Необходимо настроить маршруты в `Configure` метод `Startup` класса. В следующем примере использует эти API-интерфейсы:

* `RouteBuilder`
* `Build`
* `MapGet`Соответствует только HTTP-запросы GET
* `UseRouter`

```csharp
public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory)
{
    var trackPackageRouteHandler = new RouteHandler(context =>
    {
        var routeValues = context.GetRouteData().Values;
        return context.Response.WriteAsync(
            $"Hello! Route values: {string.Join(", ", routeValues)}");
    });

    var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

    routeBuilder.MapRoute(
        "Track Package Route",
        "package/{operation:regex(^(track|create|detonate)$)}/{id:int}");

    routeBuilder.MapGet("hello/{name}", context =>
    {
        var name = context.GetRouteValue("name");
        // This is the route handler when HTTP GET "hello/<anything>"  matches
        // To match HTTP GET "hello/<anything>/<anything>,
        // use routeBuilder.MapGet("hello/{*name}"
        return context.Response.WriteAsync($"Hi, {name}!");
    });

    var routes = routeBuilder.Build();
    app.UseRouter(routes);
}
```

В таблице ниже показаны ответы с заданным URI.

| URI | Ответ  |
| ------- | -------- |
| /Package/CREATE/3  | Hello! Значения маршрута: [операции создания], [идентификатор 3] |
| / пакета и отслеживание/3  | Hello! Значения маршрута: [операция, отслеживать] [идентификатор -3] |
| пакет, отслеживать/3 / | Hello! Значения маршрута: [операция, отслеживать] [идентификатор -3]  |
| / Package/отслеживания / | \<Переход в совпадение > |
| ПОЛУЧИТЬ /hello/Joe | Здравствуйте, Joe! |
| POST /hello/Joe | \<Переход к следующему, соответствует только HTTP GET > |
| ПОЛУЧИТЬ /hello/Joe/Smith | \<Переход в совпадение > |

Если вы настраиваете один маршрут, вызовите `app.UseRouter` передав `IRouter` экземпляра. Не требуется вызывать `RouteBuilder`.

Платформа предоставляет набор методов для создания маршрутов, таких как:

* `MapRoute`
* `MapGet`
* `MapPost`
* `MapPut`
* `MapDelete`
* `MapVerb`

Некоторые из этих методов, таких как `MapGet` требуют `RequestDelegate` должны быть предоставлены. `RequestDelegate` Будет использоваться в качестве *обработчика маршрута* при этот маршрут соответствует. Другие методы в этом семействе позволяют настраивать конвейера по промежуточного слоя, который будет использоваться в качестве обработчика маршрута. Если *карты* метод не принимает обработчик, таких как `MapRoute`, то будет использоваться `DefaultHandler`.

`Map[Verb]` Методы использования ограничений для ограничения маршрута HTTP-команда в имя метода. Например, в разделе [MapGet](https://github.com/aspnet/Routing/blob/1.0.0/src/Microsoft.AspNetCore.Routing/RequestDelegateRouteBuilderExtensions.cs#L85-L88) и [MapVerb](https://github.com/aspnet/Routing/blob/1.0.0/src/Microsoft.AspNetCore.Routing/RequestDelegateRouteBuilderExtensions.cs#L156-L180).

## <a name="route-template-reference"></a>Ссылка на шаблон маршрута

Токены внутри фигурных скобок (`{ }`) определяют *направления параметров* которой будет привязан расстановке маршрута. Можно определить более одного параметра маршрута в сегменте маршрута, но они должны быть разделены литеральное значение. Например `{controller=Home}{action=Index}` будет допустимым маршрута, так как нет литерального значения между `{controller}` и `{action}`. Эти параметры маршрута должен иметь имя и может быть указан дополнительные атрибуты.

Литеральный текст, отличные от параметров маршрута (например, `{id}`) и разделитель пути `/` должны соответствовать тексту в URL-АДРЕСЕ. Совпадений текста без учета регистра и основан на декодированное представление пути URL-адреса. Сопоставляемый параметр разделитель литерала маршрута `{` или `}`, экранировать его повторяя символ (`{{` или `}}`).

Шаблоны URL-адресов, которые пытаются записать имя файла с расширением необязательно иметь дополнительные соображения. Например, с помощью шаблона `files/{filename}.{ext?}` — Если оба `filename` и `ext` существует, оба значения будут заполнены. Если только `filename` существует в URL-адрес маршрута совпадений, так как завершающие период `.` является необязательным. Следующие URL-адреса будет соответствовать этому маршруту:

* `/files/myFile.txt`
* `/files/myFile.`
* `/files/myFile`

Можно использовать `*` символ в качестве префикса для параметра маршрута для привязки к остальная часть URI - это называется *универсальным* параметра. Например `blog/{*slug}` будет соответствовать любой URI, который запущен с `/blog` и любое значение, следующий за ним (которого будет назначаться `slug` маршрутизации значение). Параметры универсальным также может совпасть с пустой строкой.

Возможно, параметры маршрута *значения по умолчанию*назначенной, указав значение по умолчанию после имени параметра, разделенные `=`. Например `{controller=Home}` обычно определяются `Home` как значение по умолчанию для `controller`. Значение по умолчанию используется в том случае, если значение не присутствуют в URL-адрес для параметра. Помимо значения по умолчанию параметров маршрута может быть необязательным (указан путем добавления `?` в конец имени параметра, как `id?`). Разница между необязательный и «имеет значение по умолчанию», параметр маршрута со значением по умолчанию всегда возвращает значение, указывающее; Необязательный параметр имеет значение только в том случае, если таковой имеется.

Параметры маршрута также могут иметь ограничения, которые должны соответствовать значения маршрута, связанного с URL-адреса. Добавление двоеточия `:` и имя ограничения после указывает имя параметра маршрута *встроенное ограничение* для параметра маршрута. Если ограничение требует аргументы, те, предоставляемых заключены в круглые скобки `( )` после имени ограничения. Несколько встроенных ограничений, которые можно задать путем добавления другого двоеточие `:` и имя ограничения. Имя ограничения передается `IInlineConstraintResolver` службы для создания экземпляра `IRouteConstraint` для использования при обработке URL-адрес. Например, шаблон маршрута `blog/{article:minlength(10)}` указывает `minlength` ограничение с аргументом `10`. Дополнительные ограничения маршрута описание и список ограничений, которые предоставляет платформа см. в разделе [ссылка для ограничения маршрута](#route-constraint-reference).

В следующей таблице продемонстрированы некоторые шаблоны маршрута и их поведение.

| Шаблон маршрута | Пример сопоставления URL-адреса | Примечания |
| -------- | -------- | ------- |
| hello  | /Hello  | Соответствует только один путь`/hello` |
| {Страницы = Home} | / | Соответствует и задает `Page` для`Home` |
| {Страницы = Home}  | Или обратитесь в службу  | Соответствует и задает `Page` для`Contact` |
| {controller} / {action} / {id}? | / / Список продуктов | Сопоставляет `Products` контроллера и `List` действие |
| {controller} / {action} / {id}? | / Продукты/подробности/123  |  Сопоставляет `Products` контроллера и `Details` действие.  `id`значение 123 |
| {контроллера = Home} / {action = индекс} / {id}? | /  |  Сопоставляет `Home` контроллера и `Index` метода. `id` учитывается. |

С помощью шаблона обычно является самым простым подходом к маршрутизации. Ограничения по умолчанию можно также указать за пределами шаблона маршрута.

Совет: Включить [ведение журнала](logging.md) для просмотра как встроенных реализаций маршрутизации, такие как `Route`, соответствовать запросам.

## <a name="route-constraint-reference"></a>Ссылка на ограничения маршрута

Ограничения маршрута выполняемую при `Route` имеет соответствует синтаксис входящего URL-адреса и размечается URL-адрес в значения маршрута. Ограничения маршрута обычно проверить значение маршрута, связанные через шаблон маршрута и внесите простой Да/Нет принятия решений о того, является ли значение допустимым. Некоторые ограничения маршрута используйте данные вне значения маршрута необходимо учитывать, можно ли отправить запрос. Например `HttpMethodRouteConstraint` может принять или отклонить запрос на основе его команд HTTP.

>[!WARNING]
> Старайтесь не использовать ограничения для **проверку входных данных**, так как при этом, введено недопустимое приведет к 404 (не найдено) вместо 400 с соответствующее сообщение об ошибке. Ограничения маршрута должна быть использована для **устранения неоднозначности** между похожие маршруты не будет выполнять проверку входных данных для определенного маршрута.

В следующей таблице продемонстрированы некоторые ограничения маршрута и их ожидаемого поведения.

| ограничение | Пример | Пример совпадений | Примечания |
| --------   | ------- | ------------- | ----- |
| `int` | `{id:int}` | `123456789`, `-123456789`  | Соответствует любому целому |
| `bool`  | `{active:bool}` | `true`, `FALSE` | Соответствует `true` или `false` (без учета регистра) |
| `datetime` | `{dob:datetime}` | `2016-12-31`, `2016-12-31 7:32pm`  | Соответствует допустимым `DateTime` значение (в инвариантный язык и региональные параметры — см. предупреждение) |
| `decimal` | `{price:decimal}` | `49.99`, `-1,000.01` | Соответствует допустимым `decimal` значение (в инвариантный язык и региональные параметры — см. предупреждение) |
| `double`  | `{weight:double}` | `1.234`, `-1,001.01e8` | Соответствует допустимым `double` значение (в инвариантный язык и региональные параметры — см. предупреждение) |
| `float`  | `{weight:float}` | `1.234`, `-1,001.01e8` | Соответствует допустимым `float` значение (в инвариантный язык и региональные параметры — см. предупреждение) |
| `guid`  | `{id:guid}` | `CD2C1638-1638-72D5-1638-DEADBEEF1638`, `{CD2C1638-1638-72D5-1638-DEADBEEF1638}` | Соответствует допустимым `Guid` значение |
| `long` | `{ticks:long}` | `123456789`, `-123456789` | Соответствует допустимым `long` значение |
| `minlength(value)` | `{username:minlength(4)}` | `Rick` | Строка должна быть менее 4 символов |
| `maxlength(value)` | `{filename:maxlength(8)}` | `Richard` | Строка должна быть не более 8 символов. |
| `length(length)` | `{filename:length(12)}` | `somefile.txt` | Строка должна быть ровно 12 символов |
| `length(min,max)` | `{filename:length(8,16)}` | `somefile.txt` | Строка должна быть 8 и более 16 символов |
| `min(value)` | `{age:min(18)}` | `19` | Целое значение должно быть по крайней мере 18 |
| `max(value)` | `{age:max(120)}` |  `91` | Целое значение должно быть не более 120 |
| `range(min,max)` | `{age:range(18,120)}` | `91` | Целое значение должно быть по крайней мере 18, но не более 120 |
| `alpha` | `{name:alpha}` | `Rick` | Строка должен состоять из одного или нескольких символов алфавита (`a`-`z`, без учета регистра) |
| `regex(expression)` | `{ssn:regex(^\\d{{3}}-\\d{{2}}-\\d{{4}}$)}` | `123-45-6789` | Строка должна соответствовать регулярному выражению (см. Советы по определение регулярного выражения) |
| `required`  | `{name:required}` | `Rick` |  Принудительно обеспечивает, что значение не параметра присутствует во время создания URL-адресов |

>[!WARNING]
> Ограничения маршрута, позволяющие проверить URL-адрес можно преобразовать в тип CLR (например, `int` или `DateTime`) всегда использовать инвариантный язык и региональные параметры — они предполагают нелокализуемые URL-адрес. Ограничения маршрута, предоставленные платформой, не изменяйте значения, хранящиеся в значения маршрута. Все значения маршрута, извлеченными из URL-адрес будет храниться в виде строк. Например [ограничения маршрута Float](https://github.com/aspnet/Routing/blob/1.0.0/src/Microsoft.AspNetCore.Routing/Constraints/FloatRouteConstraint.cs#L44-L60) будет предпринята попытка преобразовать значение маршрут в float, но преобразованное значение используется только для проверки может быть преобразована в значение с плавающей запятой.

## <a name="regular-expressions"></a>Регулярные выражения 

Платформа ASP.NET Core добавляет `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant` конструктору регулярного выражения. В разделе [перечисление RegexOptions](https://docs.microsoft.com/dotnet/api/system.text.regularexpressions.regexoptions) описание этих членов.

Регулярные выражения Используйте разделители и маркеров, аналогичны выполняемым службой маршрутизации и в языке C#. Необходимо экранировать токены регулярного выражения. Например, чтобы использовать регулярное выражение `^\d{3}-\d{2}-\d{4}$` в маршрутизации, она должна иметь `\` символов, введенных в качестве `\\` в C# исходный файл для экранирования `\` строка escape-символ (если используется [verbatim строковые литералы](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/string). `{` , `}` , "[" И "]" символы следует экранировать путем удвоения их escape-символы-разделители параметров службы маршрутизации.  В следующей таблице показаны регулярного выражения и escape-версии.

| Выражение               | Бумага для заметок |
| ----------------- | ------------ | 
| `^\d{3}-\d{2}-\d{4}$` | Регулярное выражение |
| `^\\d{{3}}-\\d{{2}}-\\d{{4}}$` | Escape-последовательность  |
| `^[a-z]{2}$` | Регулярное выражение |
| `^[[a-z]]{{2}}$` | Escape-последовательность  |

Регулярные выражения, используемые в маршрутизации часто начинается с `^` (совпадение начальной позиции строки) буквы и заканчиваться `$` символ (конечное положение строки совпадают). `^` И `$` символов убедитесь, что соответствует регулярному выражению значение параметра всем маршруте. Без `^` и `$` символов регулярных выражений будет соответствовать любой подстроке внутри строки, который часто не требуется. В следующей таблице показаны некоторые примеры и объясняется, почему они совпадают, или не соответствует.

| Выражение               | Строка | Соответствие | Комментарий |
| ----------------- | ------------ |  ------------ |  ------------ | 
| `[a-z]{2}` | hello | да | совпадений подстрок |
| `[a-z]{2}` | 123abc456 | да | совпадений подстрок |
| `[a-z]{2}` | mz | да | соответствует выражению |
| `[a-z]{2}` | MZ | да | без учета регистра |
| `^[a-z]{2}$` |  hello | Нет | в разделе `^` и `$` выше |
| `^[a-z]{2}$` |  123abc456 | Нет | в разделе `^` и `$` выше |

Ссылаться на [регулярные выражения .NET Framework](https://docs.microsoft.com/dotnet/standard/base-types/regular-expression-language-quick-reference) Дополнительные сведения о синтаксисе регулярных выражений.

Ограничение параметра с известным набором возможных значений, используйте регулярные выражения. Например `{action:regex(^(list|get|create)$)}` соответствует только `action` маршрутизации значение `list`, `get`, или `create`. При передаче в словарь ограничения, строка «^ (список | get | создать) $» соответствует. Ограничения, передаваемые в словаре ограничения (не inline внутри шаблона), которые не соответствуют одному из известных ограничений также рассматриваются как регулярные выражения.

## <a name="url-generation-reference"></a>Создание URL-ссылки

В приведенном ниже примере показано, как создать ссылку на заданный словарь значений маршрута маршрут и `RouteCollection`.

[!code-csharp[Main](../fundamentals/routing/sample/RoutingSample/Startup.cs?range=45-59)]

`VirtualPath` Создан в конце в предыдущем примере является `/package/create/123`.

Второй параметр для `VirtualPathContext` конструктор — это совокупность *окружения значения*. Окружения значения более удобного, ограничивая количество значений, которые разработчик должен указать в определенном контексте запроса. Текущие значения маршрута из текущего запроса считаются окружения значения для генерации ссылок. Например, в приложении ASP.NET MVC в `About` действие `HomeController`, не требуется задать значение маршрута контроллера для связи с `Index` действия (внешнее значение `Home` будет использоваться).

Окружения значения, не соответствующие параметру учитываются и окружения значения также игнорируются, явно предоставленные значение переопределяет, отсчитываемого слева направо в URL-АДРЕСЕ.

Значения, которые предоставляются явно, но которого не совпадают, ничего добавляются к строке запроса. В следующей таблице показаны результат, при использовании шаблона маршрута `{controller}/{action}/{id?}`.

| Значения окружающей среды | Явные значения | Результат |
| -------------   | -------------- | ------ |
| контроллер = «Главная» | Действие = «About» | `/Home/About` |
| контроллер = «Главная» | контроллер = действие «заказ» = «О» | `/Order/About` |
| контроллер = «Home» color = «Red» | Действие = «About» | `/Home/About` |
| контроллер = «Главная» | Действие = цвет «Азот» = «Red» | `/Home/About?color=Red`

Если маршрут имеет значение по умолчанию, не соответствующие параметру, явно указано, значение должно соответствовать значение по умолчанию. Пример:

```csharp
routes.MapRoute("blog_route", "blog/{*slug}",
  defaults: new { controller = "Blog", action = "ReadPost" });
```

Когда указаны соответствующие значения для контроллера и действия, компоновки только создает ссылку для данного маршрута.
