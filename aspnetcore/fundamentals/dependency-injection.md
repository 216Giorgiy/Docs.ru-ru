---
title: "Внедрение зависимостей в ASP.NET Core"
author: ardalis
description: "Узнайте, как ASP.NET Core реализует внедрения зависимостей и способ его использования."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: fundamentals/dependency-injection
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 7a5a0991694b2c7caa79dbc09f6471d614f67dac
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
# <a name="introduction-to-dependency-injection-in-aspnet-core"></a><span data-ttu-id="ce700-103">Общие сведения о внедрение зависимостей в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="ce700-103">Introduction to Dependency Injection in ASP.NET Core</span></span>

<a name="fundamentals-dependency-injection"></a>

<span data-ttu-id="ce700-104">По [Стив Смит](https://ardalis.com/) и [Скотт Addie](https://scottaddie.com)</span><span class="sxs-lookup"><span data-stu-id="ce700-104">By [Steve Smith](https://ardalis.com/) and [Scott Addie](https://scottaddie.com)</span></span>

<span data-ttu-id="ce700-105">ASP.NET Core является разработана с нуля для поддержки и воспользоваться внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ce700-105">ASP.NET Core is designed from the ground up to support and leverage dependency injection.</span></span> <span data-ttu-id="ce700-106">ASP.NET Core приложения могут использовать службы встроенная платформа, задав их внедрены в методы в классе при запуске, и службы приложения могут быть настроены для внедрения также.</span><span class="sxs-lookup"><span data-stu-id="ce700-106">ASP.NET Core applications can leverage built-in framework services by having them injected into methods in the Startup class, and application services can be configured for injection as well.</span></span> <span data-ttu-id="ce700-107">Контейнер служб по умолчанию, предоставляемый ASP.NET Core предоставляет минимальной возможность задать и не предназначен для замены другие контейнеры.</span><span class="sxs-lookup"><span data-stu-id="ce700-107">The default services container provided by ASP.NET Core provides a minimal feature set and isn't intended to replace other containers.</span></span>

<span data-ttu-id="ce700-108">[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/dependency-injection/sample) ([как скачивать](xref:tutorials/index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="ce700-108">[View or download sample code](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/dependency-injection/sample) ([how to download](xref:tutorials/index#how-to-download-a-sample))</span></span>

## <a name="what-is-dependency-injection"></a><span data-ttu-id="ce700-109">Что такое внедрения зависимости</span><span class="sxs-lookup"><span data-stu-id="ce700-109">What is Dependency Injection?</span></span>

<span data-ttu-id="ce700-110">Внедрение зависимостей (DI) — это метод по достижению слабой связи между объектами и участники совместной работы или зависимости.</span><span class="sxs-lookup"><span data-stu-id="ce700-110">Dependency injection (DI) is a technique for achieving loose coupling between objects and their collaborators, or dependencies.</span></span> <span data-ttu-id="ce700-111">Вместо того чтобы напрямую при создании экземпляра участники совместной работы, или с помощью ссылки на статические объектов, класс должен выполнять свои действия предназначены для класса каким-либо образом.</span><span class="sxs-lookup"><span data-stu-id="ce700-111">Rather than directly instantiating collaborators, or using static references, the objects a class needs in order to perform its actions are provided to the class in some fashion.</span></span> <span data-ttu-id="ce700-112">Чаще всего классы объявите их зависимости, через своих конструкторов, позволяя выполните [явные зависимости принцип](http://deviq.com/explicit-dependencies-principle/).</span><span class="sxs-lookup"><span data-stu-id="ce700-112">Most often, classes will declare their dependencies via their constructor, allowing them to follow the [Explicit Dependencies Principle](http://deviq.com/explicit-dependencies-principle/).</span></span> <span data-ttu-id="ce700-113">Такой подход известен как «конструктор инъекция».</span><span class="sxs-lookup"><span data-stu-id="ce700-113">This approach is known as "constructor injection".</span></span>

<span data-ttu-id="ce700-114">Когда классы создаются с помощью DI помните, они все более слабо так, как они не имеют прямой, жестко зависимости на их участники совместной работы.</span><span class="sxs-lookup"><span data-stu-id="ce700-114">When classes are designed with DI in mind, they're more loosely coupled because they don't have direct, hard-coded dependencies on their collaborators.</span></span> <span data-ttu-id="ce700-115">Это соответствует [принципом инверсии зависимостей](http://deviq.com/dependency-inversion-principle/), указывающее, что *«высокий уровень модули не следует зависят от низкого уровня модули; оба должны зависеть от абстракций».*</span><span class="sxs-lookup"><span data-stu-id="ce700-115">This follows the [Dependency Inversion Principle](http://deviq.com/dependency-inversion-principle/), which states that *"high level modules shouldn't depend on low level modules; both should depend on abstractions."*</span></span> <span data-ttu-id="ce700-116">Вместо ссылки на определенных реализаций, классы запроса абстрактные классы (обычно `interfaces`) предоставляются которого к ним при создании класса.</span><span class="sxs-lookup"><span data-stu-id="ce700-116">Instead of referencing specific implementations, classes request abstractions (typically `interfaces`) which are provided to them when the class is constructed.</span></span> <span data-ttu-id="ce700-117">Извлечение зависимостей в интерфейсах и обеспечивая реализацию этих интерфейсов в качестве параметров также является примером [шаблон разработки стратегии](http://deviq.com/strategy-design-pattern/).</span><span class="sxs-lookup"><span data-stu-id="ce700-117">Extracting dependencies into interfaces and providing implementations of these interfaces as parameters is also an example of the [Strategy design pattern](http://deviq.com/strategy-design-pattern/).</span></span>

<span data-ttu-id="ce700-118">При разработке системы для использования DI, множество классов, запрашивающего их зависимости через их конструктор (или свойства), бывает полезно иметь класс выделенного при создании этих классов с их связанные зависимости.</span><span class="sxs-lookup"><span data-stu-id="ce700-118">When a system is designed to use DI, with many classes requesting their dependencies via their constructor (or properties), it's helpful to have a class dedicated to creating these classes with their associated dependencies.</span></span> <span data-ttu-id="ce700-119">Эти классы называются *контейнеры*, или, точнее говоря, [инверсии управления (IoC)](http://deviq.com/inversion-of-control/) контейнерами или контейнерами внедрения зависимости (DI).</span><span class="sxs-lookup"><span data-stu-id="ce700-119">These classes are referred to as *containers*, or more specifically, [Inversion of Control (IoC)](http://deviq.com/inversion-of-control/) containers or Dependency Injection (DI) containers.</span></span> <span data-ttu-id="ce700-120">Контейнер — по существу фабрику, которая отвечает за предоставление экземпляры типов, которые запрашиваются из него.</span><span class="sxs-lookup"><span data-stu-id="ce700-120">A container is essentially a factory that's responsible for providing instances of types that are requested from it.</span></span> <span data-ttu-id="ce700-121">Если данный тип объявлен этот пакет имеет зависимости, что контейнер был настроен для предоставления типы зависимостей, он создаст зависимостей в ходе создания запрошенного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="ce700-121">If a given type has declared that it has dependencies, and the container has been configured to provide the dependency types, it will create the dependencies as part of creating the requested instance.</span></span> <span data-ttu-id="ce700-122">Таким образом можно предоставить классы без необходимости создания любого объекта, жестко сложные графики зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ce700-122">In this way, complex dependency graphs can be provided to classes without the need for any hard-coded object construction.</span></span> <span data-ttu-id="ce700-123">Помимо создания объектов с зависимостями, контейнеры, обычно управлять временем жизни объектов в приложении.</span><span class="sxs-lookup"><span data-stu-id="ce700-123">In addition to creating objects with their dependencies, containers typically manage object lifetimes within the application.</span></span>

<span data-ttu-id="ce700-124">ASP.NET Core включает встроенные простого контейнера (представленного `IServiceProvider` интерфейса), поддерживающем внедрение конструктора по умолчанию и ASP.NET можно использовать посредством DI определенных служб.</span><span class="sxs-lookup"><span data-stu-id="ce700-124">ASP.NET Core includes a simple built-in container (represented by the `IServiceProvider` interface) that supports constructor injection by default, and ASP.NET makes certain services available through DI.</span></span> <span data-ttu-id="ce700-125">ASP. Контейнер NET ссылается на типы, он управляет как *службы*.</span><span class="sxs-lookup"><span data-stu-id="ce700-125">ASP.NET's container refers to the types it manages as *services*.</span></span> <span data-ttu-id="ce700-126">В остальной части этой статьи *служб* будет ссылаться на типы, которые управляются контейнер IoC ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="ce700-126">Throughout the rest of this article, *services* will refer to types that are managed by ASP.NET Core's IoC container.</span></span> <span data-ttu-id="ce700-127">Необходимо настроить службы встроенного контейнера в `ConfigureServices` метод в вашем приложении `Startup` класса.</span><span class="sxs-lookup"><span data-stu-id="ce700-127">You configure the built-in container's services in the `ConfigureServices` method in your application's `Startup` class.</span></span>

> [!NOTE]
> <span data-ttu-id="ce700-128">Martin Fowler записал широко статьи [инверсии контейнеры элементов управления и шаблон внедрения зависимостей](https://www.martinfowler.com/articles/injection.html).</span><span class="sxs-lookup"><span data-stu-id="ce700-128">Martin Fowler has written an extensive article on [Inversion of Control Containers and the Dependency Injection Pattern](https://www.martinfowler.com/articles/injection.html).</span></span> <span data-ttu-id="ce700-129">Шаблоны и методики Майкрософт имеет значительные описание [внедрения зависимостей](https://msdn.microsoft.com/library/hh323705.aspx).</span><span class="sxs-lookup"><span data-stu-id="ce700-129">Microsoft Patterns and Practices also has a great description of [Dependency Injection](https://msdn.microsoft.com/library/hh323705.aspx).</span></span>

> [!NOTE]
> <span data-ttu-id="ce700-130">В этой статье описывается внедрение зависимостей применительно ко всем приложениям ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="ce700-130">This article covers Dependency Injection as it applies to all ASP.NET applications.</span></span> <span data-ttu-id="ce700-131">Внедрение зависимостей в MVC контроллеры рассматривается в [внедрения зависимостей и контроллеров](../mvc/controllers/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="ce700-131">Dependency Injection within MVC controllers is covered in [Dependency Injection and Controllers](../mvc/controllers/dependency-injection.md).</span></span>

### <a name="constructor-injection-behavior"></a><span data-ttu-id="ce700-132">Внедрение поведение конструктора</span><span class="sxs-lookup"><span data-stu-id="ce700-132">Constructor Injection Behavior</span></span>

<span data-ttu-id="ce700-133">Внедрение конструктора требует рассматриваемой конструктор *открытый*.</span><span class="sxs-lookup"><span data-stu-id="ce700-133">Constructor injection requires that the constructor in question be *public*.</span></span> <span data-ttu-id="ce700-134">В противном случае приложение создаст исключение `InvalidOperationException`:</span><span class="sxs-lookup"><span data-stu-id="ce700-134">Otherwise, your app will throw an `InvalidOperationException`:</span></span>

> <span data-ttu-id="ce700-135">Не удалось найти подходящий конструктор для типа «YourType».</span><span class="sxs-lookup"><span data-stu-id="ce700-135">A suitable constructor for type 'YourType' couldn't be located.</span></span> <span data-ttu-id="ce700-136">Убедитесь, тип конкретизирован и службы, зарегистрированные для всех параметров открытого конструктора.</span><span class="sxs-lookup"><span data-stu-id="ce700-136">Ensure the type is concrete and services are registered for all parameters of a public constructor.</span></span>


<span data-ttu-id="ce700-137">Внедрение конструктора необходимо, только один соответствующий конструктор.</span><span class="sxs-lookup"><span data-stu-id="ce700-137">Constructor injection requires that only one applicable constructor exist.</span></span> <span data-ttu-id="ce700-138">Перегрузки конструктора поддерживаются, но может существовать только одна перегрузка, аргументы которых можно все удовлетворять внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ce700-138">Constructor overloads are supported, but only one overload can exist whose arguments can all be fulfilled by dependency injection.</span></span> <span data-ttu-id="ce700-139">Если существует несколько экземпляров, приложение будет вызывать `InvalidOperationException`:</span><span class="sxs-lookup"><span data-stu-id="ce700-139">If more than one exists, your app will throw an `InvalidOperationException`:</span></span>

> <span data-ttu-id="ce700-140">В типе «YourType» найдено несколько конструкторов принимает все типы данного аргумента.</span><span class="sxs-lookup"><span data-stu-id="ce700-140">Multiple constructors accepting all given argument types have been found in type 'YourType'.</span></span> <span data-ttu-id="ce700-141">Должен быть только один соответствующий конструктор.</span><span class="sxs-lookup"><span data-stu-id="ce700-141">There should only be one applicable constructor.</span></span>

<span data-ttu-id="ce700-142">Конструкторы могут принимать аргументы, которые не предоставляются внедрения зависимостей, но они должны поддерживать значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="ce700-142">Constructors can accept arguments that are not provided by dependency injection, but these must support default values.</span></span> <span data-ttu-id="ce700-143">Пример:</span><span class="sxs-lookup"><span data-stu-id="ce700-143">For example:</span></span>

```csharp
// throws InvalidOperationException: Unable to resolve service for type 'System.String'...
public CharactersController(ICharacterRepository characterRepository, string title)
{
    _characterRepository = characterRepository;
    _title = title;
}

// runs without error
public CharactersController(ICharacterRepository characterRepository, string title = "Characters")
{
    _characterRepository = characterRepository;
    _title = title;
}
```

## <a name="using-framework-provided-services"></a><span data-ttu-id="ce700-144">С помощью службы, предоставленные платформой</span><span class="sxs-lookup"><span data-stu-id="ce700-144">Using Framework-Provided Services</span></span>

<span data-ttu-id="ce700-145">`ConfigureServices` Метод в `Startup` класс отвечает за определение службы будет использоваться приложением, включая возможности платформы Entity Framework Core и ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="ce700-145">The `ConfigureServices` method in the `Startup` class is responsible for defining the services the application will use, including platform features like Entity Framework Core and ASP.NET Core MVC.</span></span> <span data-ttu-id="ce700-146">Изначально `IServiceCollection` для `ConfigureServices` имеет следующие определенные службы (в зависимости от [настройку узла](xref:fundamentals/hosting)):</span><span class="sxs-lookup"><span data-stu-id="ce700-146">Initially, the `IServiceCollection` provided to `ConfigureServices` has the following services defined (depending on [how the host was configured](xref:fundamentals/hosting)):</span></span>

| <span data-ttu-id="ce700-147">Тип службы</span><span class="sxs-lookup"><span data-stu-id="ce700-147">Service Type</span></span> | <span data-ttu-id="ce700-148">Время существования</span><span class="sxs-lookup"><span data-stu-id="ce700-148">Lifetime</span></span> |
| ----- | ------- |
| [<span data-ttu-id="ce700-149">Microsoft.AspNetCore.Hosting.IHostingEnvironment</span><span class="sxs-lookup"><span data-stu-id="ce700-149">Microsoft.AspNetCore.Hosting.IHostingEnvironment</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.ihostingenvironment) | <span data-ttu-id="ce700-150">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-150">Singleton</span></span> |
| [<span data-ttu-id="ce700-151">Microsoft.Extensions.Logging.ILoggerFactory</span><span class="sxs-lookup"><span data-stu-id="ce700-151">Microsoft.Extensions.Logging.ILoggerFactory</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.logging.iloggerfactory) | <span data-ttu-id="ce700-152">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-152">Singleton</span></span> |
| [<span data-ttu-id="ce700-153">Microsoft.Extensions.Logging.ILogger&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ce700-153">Microsoft.Extensions.Logging.ILogger&lt;T&gt;</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.logging.ilogger) | <span data-ttu-id="ce700-154">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-154">Singleton</span></span> |
| [<span data-ttu-id="ce700-155">Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</span><span class="sxs-lookup"><span data-stu-id="ce700-155">Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.builder.iapplicationbuilderfactory) | <span data-ttu-id="ce700-156">Временной</span><span class="sxs-lookup"><span data-stu-id="ce700-156">Transient</span></span> |
| [<span data-ttu-id="ce700-157">Microsoft.AspNetCore.Http.IHttpContextFactory</span><span class="sxs-lookup"><span data-stu-id="ce700-157">Microsoft.AspNetCore.Http.IHttpContextFactory</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.http.ihttpcontextfactory) | <span data-ttu-id="ce700-158">Временной</span><span class="sxs-lookup"><span data-stu-id="ce700-158">Transient</span></span> |
| [<span data-ttu-id="ce700-159">Microsoft.Extensions.Options.IOptions&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ce700-159">Microsoft.Extensions.Options.IOptions&lt;T&gt;</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.options.ioptions-1) | <span data-ttu-id="ce700-160">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-160">Singleton</span></span> |
| [<span data-ttu-id="ce700-161">System.Diagnostics.DiagnosticSource</span><span class="sxs-lookup"><span data-stu-id="ce700-161">System.Diagnostics.DiagnosticSource</span></span>](https://docs.microsoft.com/dotnet/core/api/system.diagnostics.diagnosticsource) | <span data-ttu-id="ce700-162">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-162">Singleton</span></span> |
| [<span data-ttu-id="ce700-163">System.Diagnostics.DiagnosticListener</span><span class="sxs-lookup"><span data-stu-id="ce700-163">System.Diagnostics.DiagnosticListener</span></span>](https://docs.microsoft.com/dotnet/core/api/system.diagnostics.diagnosticlistener) | <span data-ttu-id="ce700-164">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-164">Singleton</span></span> |
| [<span data-ttu-id="ce700-165">Microsoft.AspNetCore.Hosting.IStartupFilter</span><span class="sxs-lookup"><span data-stu-id="ce700-165">Microsoft.AspNetCore.Hosting.IStartupFilter</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.istartupfilter) | <span data-ttu-id="ce700-166">Временной</span><span class="sxs-lookup"><span data-stu-id="ce700-166">Transient</span></span> |
| [<span data-ttu-id="ce700-167">Microsoft.Extensions.ObjectPool.ObjectPoolProvider</span><span class="sxs-lookup"><span data-stu-id="ce700-167">Microsoft.Extensions.ObjectPool.ObjectPoolProvider</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.objectpool.objectpoolprovider) | <span data-ttu-id="ce700-168">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-168">Singleton</span></span> |
| [<span data-ttu-id="ce700-169">Microsoft.Extensions.Options.IConfigureOptions&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ce700-169">Microsoft.Extensions.Options.IConfigureOptions&lt;T&gt;</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.options.iconfigureoptions-1) | <span data-ttu-id="ce700-170">Временной</span><span class="sxs-lookup"><span data-stu-id="ce700-170">Transient</span></span> |
| [<span data-ttu-id="ce700-171">Microsoft.AspNetCore.Hosting.Server.IServer</span><span class="sxs-lookup"><span data-stu-id="ce700-171">Microsoft.AspNetCore.Hosting.Server.IServer</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.server.iserver) | <span data-ttu-id="ce700-172">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-172">Singleton</span></span> |
| [<span data-ttu-id="ce700-173">Microsoft.AspNetCore.Hosting.IStartup</span><span class="sxs-lookup"><span data-stu-id="ce700-173">Microsoft.AspNetCore.Hosting.IStartup</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.istartup) | <span data-ttu-id="ce700-174">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-174">Singleton</span></span> |
| [<span data-ttu-id="ce700-175">Microsoft.AspNetCore.Hosting.IApplicationLifetime</span><span class="sxs-lookup"><span data-stu-id="ce700-175">Microsoft.AspNetCore.Hosting.IApplicationLifetime</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.iapplicationlifetime) | <span data-ttu-id="ce700-176">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="ce700-176">Singleton</span></span> |

<span data-ttu-id="ce700-177">Ниже приведен пример того, как добавить дополнительные службы в контейнер с помощью нескольких методов расширения, такие как `AddDbContext`, `AddIdentity`, и `AddMvc`.</span><span class="sxs-lookup"><span data-stu-id="ce700-177">Below is an example of how to add additional services to the container using a number of extension methods like `AddDbContext`, `AddIdentity`, and `AddMvc`.</span></span>

[!code-csharp[Main](../common/samples/WebApplication1/Startup.cs?highlight=5-6,8-10,12&range=39-56)]

<span data-ttu-id="ce700-178">Функции и возможности ASP.NET, например MVC, по промежуточного слоя Следуйте соглашению об использовании одного добавить*ServiceName* метод расширения для регистрации всех служб, необходимых для этой функции.</span><span class="sxs-lookup"><span data-stu-id="ce700-178">The features and middleware provided by ASP.NET, such as MVC, follow a convention of using a single Add*ServiceName* extension method to register all of the services required by that feature.</span></span>

>[!TIP]
> <span data-ttu-id="ce700-179">Можно запросить определенных предоставленные платформой служб в `Startup` методы через их списки параметров - в разделе [запуска приложения](startup.md) для получения дополнительных сведений.</span><span class="sxs-lookup"><span data-stu-id="ce700-179">You can request certain framework-provided services within `Startup` methods through their parameter lists - see [Application Startup](startup.md) for more details.</span></span>

## <a name="registering-your-own-services"></a><span data-ttu-id="ce700-180">Регистрация собственного служб</span><span class="sxs-lookup"><span data-stu-id="ce700-180">Registering Your Own Services</span></span>

<span data-ttu-id="ce700-181">Можно зарегистрировать служб приложения следующим образом.</span><span class="sxs-lookup"><span data-stu-id="ce700-181">You can register your own application services as follows.</span></span> <span data-ttu-id="ce700-182">Первый универсального типа представляет тип (обычно интерфейс), который будет запрашиваться из контейнера.</span><span class="sxs-lookup"><span data-stu-id="ce700-182">The first generic type represents the type (typically an interface) that will be requested from the container.</span></span> <span data-ttu-id="ce700-183">Второго универсального типа представляет конкретный тип, который будет создавать экземпляры контейнером и использоваться для выполнения таких запросов.</span><span class="sxs-lookup"><span data-stu-id="ce700-183">The second generic type represents the concrete type that will be instantiated by the container and used to fulfill such requests.</span></span>

[!code-csharp[Main](../common/samples/WebApplication1/Startup.cs?range=53-54)]

> [!NOTE]
> <span data-ttu-id="ce700-184">Каждый `services.Add<ServiceName>` метод расширения добавляет (и потенциально настраивает) службы.</span><span class="sxs-lookup"><span data-stu-id="ce700-184">Each `services.Add<ServiceName>` extension method adds (and potentially configures) services.</span></span> <span data-ttu-id="ce700-185">Например `services.AddMvc()` добавляет MVC требует службы.</span><span class="sxs-lookup"><span data-stu-id="ce700-185">For example, `services.AddMvc()` adds the services MVC requires.</span></span> <span data-ttu-id="ce700-186">Рекомендуется следовать соглашению, поместив методы расширения в `Microsoft.Extensions.DependencyInjection` пространства имен для инкапсуляции группы службы регистрации.</span><span class="sxs-lookup"><span data-stu-id="ce700-186">It's recommended that you follow this convention, placing extension methods in the `Microsoft.Extensions.DependencyInjection` namespace, to encapsulate groups of service registrations.</span></span>

<span data-ttu-id="ce700-187">`AddTransient` Метод используется для сопоставления с конкретной службы, экземпляры которых создаются отдельно для каждого объекта, который требуется для абстрактных типов.</span><span class="sxs-lookup"><span data-stu-id="ce700-187">The `AddTransient` method is used to map abstract types to concrete services that are instantiated separately for every object that requires it.</span></span> <span data-ttu-id="ce700-188">Этот процесс известен как службы *время существования*, и время существования Дополнительные параметры описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="ce700-188">This is known as the service's *lifetime*, and additional lifetime options are described below.</span></span> <span data-ttu-id="ce700-189">Очень важно для выбора соответствующего времени жизни для каждой из служб, которые можно зарегистрировать.</span><span class="sxs-lookup"><span data-stu-id="ce700-189">It's important to choose an appropriate lifetime for each of the services you register.</span></span> <span data-ttu-id="ce700-190">Новый экземпляр службы должен быть предусмотрен для каждого класса, он запрашивает?</span><span class="sxs-lookup"><span data-stu-id="ce700-190">Should a new instance of the service be provided to each class that requests it?</span></span> <span data-ttu-id="ce700-191">Использовать один экземпляр на протяжении данного веб-запроса?</span><span class="sxs-lookup"><span data-stu-id="ce700-191">Should one instance be used throughout a given web request?</span></span> <span data-ttu-id="ce700-192">Или следует использовать один экземпляр в течение времени существования приложения?</span><span class="sxs-lookup"><span data-stu-id="ce700-192">Or should a single instance be used for the lifetime of the application?</span></span>

<span data-ttu-id="ce700-193">В этом образце для данной статьи является простой контроллер, который отображает имена символов, вызывается `CharactersController`.</span><span class="sxs-lookup"><span data-stu-id="ce700-193">In the sample for this article, there's a simple controller that displays character names, called `CharactersController`.</span></span> <span data-ttu-id="ce700-194">Его `Index` метод отображает текущий список символов, хранящихся в приложении и инициализирует коллекцию с небольшим количеством символов, если нет ни одного.</span><span class="sxs-lookup"><span data-stu-id="ce700-194">Its `Index` method displays the current list of characters that have been stored in the application, and initializes the collection with a handful of characters if none exist.</span></span> <span data-ttu-id="ce700-195">Обратите внимание, что, несмотря на то, что в данном приложении используется Entity Framework Core и `ApplicationDbContext` класса для сохранения, ни один из, она становится очевидной, если в контроллере.</span><span class="sxs-lookup"><span data-stu-id="ce700-195">Note that although this application uses Entity Framework Core and the `ApplicationDbContext` class for its persistence, none of that's apparent in the controller.</span></span> <span data-ttu-id="ce700-196">Вместо этого было абстрагированы механизм доступа конкретные данные за интерфейс, `ICharacterRepository`, что соответствует [шаблон репозитория](http://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="ce700-196">Instead, the specific data access mechanism has been abstracted behind an interface, `ICharacterRepository`, which follows the [repository pattern](http://deviq.com/repository-pattern/).</span></span> <span data-ttu-id="ce700-197">Экземпляр `ICharacterRepository` запрашиваемой через конструктор, который назначен закрытое поле, которое затем используется для доступа к символам, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="ce700-197">An instance of `ICharacterRepository` is requested via the constructor and assigned to a private field, which is then used to access characters as necessary.</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Controllers/CharactersController.cs?highlight=3,5,6,7,8,14,21-27&range=8-36)]

<span data-ttu-id="ce700-198">`ICharacterRepository` Определяет два метода, который требуется работать с контроллером `Character` экземпляров.</span><span class="sxs-lookup"><span data-stu-id="ce700-198">The `ICharacterRepository` defines the two methods the controller needs to work with `Character` instances.</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Interfaces/ICharacterRepository.cs?highlight=8,9)]

<span data-ttu-id="ce700-199">Этот интерфейс реализуется в свою очередь конкретный тип `CharacterRepository`, который используется во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ce700-199">This interface is in turn implemented by a concrete type, `CharacterRepository`, that's used at runtime.</span></span>

> [!NOTE]
> <span data-ttu-id="ce700-200">Способ DI используется с `CharacterRepository` класс является общей модели, можно выполнить для всех служб приложения, не только в «репозитории» или классов доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ce700-200">The way DI is used with the `CharacterRepository` class is a general model you can follow for all of your application services, not just in "repositories" or data access classes.</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Models/CharacterRepository.cs?highlight=9,11,12,13,14)]

<span data-ttu-id="ce700-201">Обратите внимание, что `CharacterRepository` запросов `ApplicationDbContext` в своем конструкторе.</span><span class="sxs-lookup"><span data-stu-id="ce700-201">Note that `CharacterRepository` requests an `ApplicationDbContext` in its constructor.</span></span> <span data-ttu-id="ce700-202">Довольно часто для внедрения зависимости для использования в цепочке манере наподобие этого, с каждой запрошенной зависимости, в свою очередь запрашивает собственные зависимости.</span><span class="sxs-lookup"><span data-stu-id="ce700-202">It's not unusual for dependency injection to be used in a chained fashion like this, with each requested dependency in turn requesting its own dependencies.</span></span> <span data-ttu-id="ce700-203">Контейнер отвечает за разрешает все зависимости на графе и возвращения службы полностью устранены.</span><span class="sxs-lookup"><span data-stu-id="ce700-203">The container is responsible for resolving all of the dependencies in the graph and returning the fully resolved service.</span></span>

> [!NOTE]
> <span data-ttu-id="ce700-204">Создание запрошенный объект и все объекты, которые требуется и все объекты, их требуется, иногда называется *граф объекта*.</span><span class="sxs-lookup"><span data-stu-id="ce700-204">Creating the requested object, and all of the objects it requires, and all of the objects those require, is sometimes referred to as an *object graph*.</span></span> <span data-ttu-id="ce700-205">Аналогичным образом, общий набор зависимостей, которые должны быть устранены, обычно называют *дерево зависимостей* или *граф зависимостей*.</span><span class="sxs-lookup"><span data-stu-id="ce700-205">Likewise, the collective set of dependencies that must be resolved is typically referred to as a *dependency tree* or *dependency graph*.</span></span>

<span data-ttu-id="ce700-206">В этом случае оба `ICharacterRepository` и в свою очередь `ApplicationDbContext` должен быть зарегистрирован в контейнере службы `ConfigureServices` в `Startup`.</span><span class="sxs-lookup"><span data-stu-id="ce700-206">In this case, both `ICharacterRepository` and in turn `ApplicationDbContext` must be registered with the services container in `ConfigureServices` in `Startup`.</span></span> <span data-ttu-id="ce700-207">`ApplicationDbContext`настраивается при вызове метода расширения `AddDbContext<T>`.</span><span class="sxs-lookup"><span data-stu-id="ce700-207">`ApplicationDbContext` is configured with the call to the extension method `AddDbContext<T>`.</span></span> <span data-ttu-id="ce700-208">В следующем коде показано регистрацию `CharacterRepository` типа.</span><span class="sxs-lookup"><span data-stu-id="ce700-208">The following code shows the registration of the `CharacterRepository` type.</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Startup.cs?highlight=3-5,11&range=16-32)]

<span data-ttu-id="ce700-209">Контексты Entity Framework должны быть добавлены в контейнер службы с помощью `Scoped` времени существования.</span><span class="sxs-lookup"><span data-stu-id="ce700-209">Entity Framework contexts should be added to the services container using the `Scoped` lifetime.</span></span> <span data-ttu-id="ce700-210">Это является занимается автоматически при использовании вспомогательных методов, как показано выше.</span><span class="sxs-lookup"><span data-stu-id="ce700-210">This is taken care of automatically if you use the helper methods as shown above.</span></span> <span data-ttu-id="ce700-211">Репозитории, которые позволят использовать платформы Entity Framework следует использовать то же время существования.</span><span class="sxs-lookup"><span data-stu-id="ce700-211">Repositories that will make use of Entity Framework should use the same lifetime.</span></span>

>[!WARNING]
> <span data-ttu-id="ce700-212">Устранение основных опасности необходимо использовать с осторожностью `Scoped` из Singleton-классом.</span><span class="sxs-lookup"><span data-stu-id="ce700-212">The main danger to be wary of is resolving a `Scoped` service from a singleton.</span></span> <span data-ttu-id="ce700-213">Вполне вероятно, в этом случае, служба будет иметь неверное состояние при обработке последующих запросов.</span><span class="sxs-lookup"><span data-stu-id="ce700-213">It's likely in such a case that the service will have incorrect state when processing subsequent requests.</span></span>

<span data-ttu-id="ce700-214">Службы, имеющие зависимости следует зарегистрировать их в контейнере.</span><span class="sxs-lookup"><span data-stu-id="ce700-214">Services that have dependencies should register them in the container.</span></span> <span data-ttu-id="ce700-215">Если конструктор служб требуется примитив, таких как `string`, это могут быть добавлены с помощью [конфигурации](xref:fundamentals/configuration/index) и [параметры шаблона](xref:fundamentals/configuration/options).</span><span class="sxs-lookup"><span data-stu-id="ce700-215">If a service's constructor requires a primitive, such as a `string`, this can be injected by using [configuration](xref:fundamentals/configuration/index) and the [options pattern](xref:fundamentals/configuration/options).</span></span>

## <a name="service-lifetimes-and-registration-options"></a><span data-ttu-id="ce700-216">Время существования службы и параметры регистрации</span><span class="sxs-lookup"><span data-stu-id="ce700-216">Service Lifetimes and Registration Options</span></span>

<span data-ttu-id="ce700-217">Службы ASP.NET могут быть настроены следующие параметры времени жизни:</span><span class="sxs-lookup"><span data-stu-id="ce700-217">ASP.NET services can be configured with the following lifetimes:</span></span>

<span data-ttu-id="ce700-218">**Временной**</span><span class="sxs-lookup"><span data-stu-id="ce700-218">**Transient**</span></span>

<span data-ttu-id="ce700-219">Время существования временной службы создаются каждый раз, когда запрошены.</span><span class="sxs-lookup"><span data-stu-id="ce700-219">Transient lifetime services are created each time they're requested.</span></span> <span data-ttu-id="ce700-220">Это время существования лучше всего подходит для простой и без сохранения состояния службы.</span><span class="sxs-lookup"><span data-stu-id="ce700-220">This lifetime works best for lightweight, stateless services.</span></span>

<span data-ttu-id="ce700-221">**Scoped**</span><span class="sxs-lookup"><span data-stu-id="ce700-221">**Scoped**</span></span>

<span data-ttu-id="ce700-222">Служб времени существования с областью создаются один раз для каждого запроса.</span><span class="sxs-lookup"><span data-stu-id="ce700-222">Scoped lifetime services are created once per request.</span></span>

<span data-ttu-id="ce700-223">**Singleton**</span><span class="sxs-lookup"><span data-stu-id="ce700-223">**Singleton**</span></span>

<span data-ttu-id="ce700-224">Службы времени жизни Singleton создаются впервые запрошены (или когда `ConfigureServices` запускается при указании экземпляра существует) и затем каждый последующий запрос будет использовать тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="ce700-224">Singleton lifetime services are created the first time they're requested (or when `ConfigureServices` is run if you specify an instance there) and then every subsequent request will use the same instance.</span></span> <span data-ttu-id="ce700-225">Если приложению требуется одноэлементное поведение, что контейнер службы для управления временем существования службы рекомендуется вместо реализации шаблона разработки одноэлементный и самостоятельного управления временем жизни объекта в классе.</span><span class="sxs-lookup"><span data-stu-id="ce700-225">If your application requires singleton behavior, allowing the services container to manage the service's lifetime is recommended instead of implementing the singleton design pattern and managing your object's lifetime in the class yourself.</span></span>

<span data-ttu-id="ce700-226">Службы могут быть зарегистрированы с контейнером несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="ce700-226">Services can be registered with the container in several ways.</span></span> <span data-ttu-id="ce700-227">Мы уже видели, как зарегистрировать реализацию службы заданного типа, указав конкретный тип для использования.</span><span class="sxs-lookup"><span data-stu-id="ce700-227">We have already seen how to register a service implementation with a given type by specifying the concrete type to use.</span></span> <span data-ttu-id="ce700-228">Кроме того фабрику можно указать, который будет использоваться для создания экземпляра по требованию.</span><span class="sxs-lookup"><span data-stu-id="ce700-228">In addition, a factory can be specified, which will then be used to create the instance on demand.</span></span> <span data-ttu-id="ce700-229">Третий способ является непосредственно указать экземпляр типа для использования, в котором регистр контейнера никогда не будет пытаться создать экземпляр (и не удалит его экземпляра).</span><span class="sxs-lookup"><span data-stu-id="ce700-229">The third approach is to directly specify the instance of the type to use, in which case the container will never attempt to create an instance (nor will it dispose of the instance).</span></span>

<span data-ttu-id="ce700-230">Для демонстрации различия между указанными вариантами временем существования и регистрации, рассмотрим простой интерфейс, представляющий одну или несколько задач, как *операции* с уникальным идентификатором `OperationId`.</span><span class="sxs-lookup"><span data-stu-id="ce700-230">To demonstrate the difference between these lifetime and registration options, consider a simple interface that represents one or more tasks as an *operation* with a unique identifier, `OperationId`.</span></span> <span data-ttu-id="ce700-231">В зависимости от того, как мы настроить время жизни для этой службы контейнер будет предоставляют одинаковые или разные экземпляры службы для запроса класса.</span><span class="sxs-lookup"><span data-stu-id="ce700-231">Depending on how we configure the lifetime for this service, the container will provide either the same or different instances of the service to the requesting class.</span></span> <span data-ttu-id="ce700-232">Чтобы было ясно, какие время существования запрашивается, мы создадим одного типа на параметр lifetime:</span><span class="sxs-lookup"><span data-stu-id="ce700-232">To make it clear which lifetime is being requested, we will create one type per lifetime option:</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Interfaces/IOperation.cs?highlight=5-8)]

<span data-ttu-id="ce700-233">Мы реализуют эти интерфейсы, с помощью одного класса, `Operation`, которая принимает `Guid` в конструктор, или использует новый `Guid` Если не указан.</span><span class="sxs-lookup"><span data-stu-id="ce700-233">We implement these interfaces using a single class, `Operation`, that accepts a `Guid` in its constructor, or uses a new `Guid` if none is provided.</span></span>

<span data-ttu-id="ce700-234">Затем в `ConfigureServices`, каждый тип будет добавлен в контейнере согласно существования именованных:</span><span class="sxs-lookup"><span data-stu-id="ce700-234">Next, in `ConfigureServices`, each type is added to the container according to its named lifetime:</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Startup.cs?range=26-32)]

<span data-ttu-id="ce700-235">Обратите внимание, что `IOperationSingletonInstance` служба использует определенный экземпляр с известным Идентификатором `Guid.Empty` , он будет ясна, при использовании этого типа (его идентификатора Guid будет состоять из одних нулей).</span><span class="sxs-lookup"><span data-stu-id="ce700-235">Note that the `IOperationSingletonInstance` service is using a specific instance with a known ID of `Guid.Empty` so it will be clear when this type is in use (its Guid will be all zeroes).</span></span> <span data-ttu-id="ce700-236">Мы также зарегистрировать `OperationService` , зависит от каждого из других `Operation` типов, чтобы сделать его снимите внутри запроса ли эта служба получает тот же экземпляр контроллера или создать новую, для каждого типа операции.</span><span class="sxs-lookup"><span data-stu-id="ce700-236">We have also registered an `OperationService` that depends on each of the other `Operation` types, so that it will be clear within a request whether this service is getting the same instance as the controller, or a new one, for each operation type.</span></span> <span data-ttu-id="ce700-237">Эта служба не всего предоставляют его зависимости в виде свойств, чтобы их можно было отобразить в представлении.</span><span class="sxs-lookup"><span data-stu-id="ce700-237">All this service does is expose its dependencies as properties, so they can be displayed in the view.</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Services/OperationService.cs)]

<span data-ttu-id="ce700-238">Чтобы продемонстрировать времени жизни объектов внутри и между отдельные отдельных запросов в приложение, пример включает `OperationsController` , запрашивает каждого вида `IOperation` типа, а также `OperationService`.</span><span class="sxs-lookup"><span data-stu-id="ce700-238">To demonstrate the object lifetimes within and between separate individual requests to the application, the sample includes an `OperationsController` that requests each kind of `IOperation` type as well as an `OperationService`.</span></span> <span data-ttu-id="ce700-239">`Index` Действие отображает все контроллера и службы `OperationId` значения.</span><span class="sxs-lookup"><span data-stu-id="ce700-239">The `Index` action then displays all of the controller's and service's `OperationId` values.</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Controllers/OperationsController.cs)]

<span data-ttu-id="ce700-240">Теперь два отдельных запросов, выполненных для этого действия контроллера:</span><span class="sxs-lookup"><span data-stu-id="ce700-240">Now two separate requests are made to this controller action:</span></span>

![Представление операций в Microsoft Edge со значениями операции идентификатор (GUID) для временной области, одноэлементные и экземпляр контроллера операций и операции службы при первом запросе веб-приложения пример внедрения зависимостей.](dependency-injection/_static/lifetimes_request1.png)

![Операции просмотра со значениями код операции для второго запроса.](dependency-injection/_static/lifetimes_request2.png)

<span data-ttu-id="ce700-243">Обратите внимание, что из `OperationId` значения изменяются внутри запроса, а также между запросами.</span><span class="sxs-lookup"><span data-stu-id="ce700-243">Observe which of the `OperationId` values vary within a request, and between requests.</span></span>

* <span data-ttu-id="ce700-244">*Временные* объекты всегда различаются; для каждого контроллера и каждая служба предоставляется новый экземпляр.</span><span class="sxs-lookup"><span data-stu-id="ce700-244">*Transient* objects are always different; a new instance is provided to every controller and every service.</span></span>

* <span data-ttu-id="ce700-245">*Областью действия* объекты одинаковы в запросе, но отличается для различных запросов</span><span class="sxs-lookup"><span data-stu-id="ce700-245">*Scoped* objects are the same within a request, but different across different requests</span></span>

* <span data-ttu-id="ce700-246">*Одноэлементный* объекты одинаковы для всех объектов и каждого запроса (независимо от того, предоставляется ли экземпляр в `ConfigureServices`)</span><span class="sxs-lookup"><span data-stu-id="ce700-246">*Singleton* objects are the same for every object and every request (regardless of whether an instance is provided in `ConfigureServices`)</span></span>

## <a name="request-services"></a><span data-ttu-id="ce700-247">Запрос служб</span><span class="sxs-lookup"><span data-stu-id="ce700-247">Request Services</span></span>

<span data-ttu-id="ce700-248">Запрашивать службы, доступные в ASP.NET `HttpContext` , предоставляются через `RequestServices` коллекции.</span><span class="sxs-lookup"><span data-stu-id="ce700-248">The services available within an ASP.NET request from `HttpContext` are exposed through the `RequestServices` collection.</span></span>

![HttpContext запрос службы Intellisense контекстные диалогового окна о том, что службы запрос возвращает или задает IServiceProvider, предоставляющий доступ к контейнеру запроса службы.](dependency-injection/_static/request-services.png)

<span data-ttu-id="ce700-250">Запрос службы представляют собой службы настройки и запросов как часть приложения.</span><span class="sxs-lookup"><span data-stu-id="ce700-250">Request Services represent the services you configure and request as part of your application.</span></span> <span data-ttu-id="ce700-251">При объектов указать зависимости, они выполняются на типы, которые содержатся в `RequestServices`, а не `ApplicationServices`.</span><span class="sxs-lookup"><span data-stu-id="ce700-251">When your objects specify dependencies, these are satisfied by the types found in `RequestServices`, not `ApplicationServices`.</span></span>

<span data-ttu-id="ce700-252">Как правило не следует использовать эти свойства напрямую, предпочитая для запроса типов, требуемую через ваш класс конструктора классов, а окно платформа внедрить эти зависимости.</span><span class="sxs-lookup"><span data-stu-id="ce700-252">Generally, you shouldn't use these properties directly, preferring instead to request the types your classes you require via your class's constructor, and letting the framework inject these dependencies.</span></span> <span data-ttu-id="ce700-253">Это создает классы, которые более удобны для тестирования (см. [тестирования](../testing/index.md)) и более слабо связаны.</span><span class="sxs-lookup"><span data-stu-id="ce700-253">This yields classes that are easier to test (see [Testing](../testing/index.md)) and are more loosely coupled.</span></span>

> [!NOTE]
> <span data-ttu-id="ce700-254">Предпочтение запросы зависимости как параметры конструктора для доступа к `RequestServices` коллекции.</span><span class="sxs-lookup"><span data-stu-id="ce700-254">Prefer requesting dependencies as constructor parameters to accessing the `RequestServices` collection.</span></span>

## <a name="designing-your-services-for-dependency-injection"></a><span data-ttu-id="ce700-255">Разработка для внедрения зависимости служб</span><span class="sxs-lookup"><span data-stu-id="ce700-255">Designing Your Services For Dependency Injection</span></span>

<span data-ttu-id="ce700-256">Следует разрабатывать с помощью внедрения зависимости получить их участники совместной работы служб.</span><span class="sxs-lookup"><span data-stu-id="ce700-256">You should design your services to use dependency injection to get their collaborators.</span></span> <span data-ttu-id="ce700-257">Это означает, что не использовать вызовы статического метода, с отслеживанием состояния (что привести Запах код, известный как [статических напечатанными](http://deviq.com/static-cling/)) и прямой создание экземпляров зависимых классов внутри служб.</span><span class="sxs-lookup"><span data-stu-id="ce700-257">This means avoiding the use of stateful static method calls (which result in a code smell known as [static cling](http://deviq.com/static-cling/)) and the direct instantiation of dependent classes within your services.</span></span> <span data-ttu-id="ce700-258">Может помочь запомнить фразу [новые является связующего](https://ardalis.com/new-is-glue), при выборе, следует ли создать экземпляр типа или отправить запрос через внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ce700-258">It may help to remember the phrase, [New is Glue](https://ardalis.com/new-is-glue), when choosing whether to instantiate a type or to request it via dependency injection.</span></span> <span data-ttu-id="ce700-259">Следуя [СПЛОШНОЙ принципы из объектно-ориентированном проектировании](http://deviq.com/solid/), ваши классы естественным образом стремятся маленькое, хорошо организованную и легко протестированных.</span><span class="sxs-lookup"><span data-stu-id="ce700-259">By following the [SOLID Principles of Object Oriented Design](http://deviq.com/solid/), your classes will naturally tend to be small, well-factored, and easily tested.</span></span>

<span data-ttu-id="ce700-260">Что делать, если можно найти, что классы, обычно склонны к способом слишком много зависимостей, введенного?</span><span class="sxs-lookup"><span data-stu-id="ce700-260">What if you find that your classes tend to have way too many dependencies being injected?</span></span> <span data-ttu-id="ce700-261">Это обычно является признаком класс пытается делать слишком много что, вероятно, нарушил SRP - [персональной ответственности](http://deviq.com/single-responsibility-principle/).</span><span class="sxs-lookup"><span data-stu-id="ce700-261">This is generally a sign that your class is trying to do too much, and is probably violating SRP - the [Single Responsibility Principle](http://deviq.com/single-responsibility-principle/).</span></span> <span data-ttu-id="ce700-262">См. Если класс рефакторинга, переместив некоторые из его функции в новый класс.</span><span class="sxs-lookup"><span data-stu-id="ce700-262">See if you can refactor the class by moving some of its responsibilities into a new class.</span></span> <span data-ttu-id="ce700-263">Имейте в виду, что ваш `Controller` классы следует уделить особое внимание проблемы пользовательского интерфейса, поэтому бизнеса правил и данных access детали реализации должны храниться в классах, соответствующие этим [разделения проблем](http://deviq.com/separation-of-concerns/).</span><span class="sxs-lookup"><span data-stu-id="ce700-263">Keep in mind that your `Controller` classes should be focused on UI concerns, so business rules and data access implementation details should be kept in classes appropriate to these [separate concerns](http://deviq.com/separation-of-concerns/).</span></span>

<span data-ttu-id="ce700-264">В отношении доступа к данным в частности, можно ввести `DbContext` в контроллерах (при условии, что вы добавили EF в контейнере службы `ConfigureServices`).</span><span class="sxs-lookup"><span data-stu-id="ce700-264">With regards to data access specifically, you can inject the `DbContext` into your controllers (assuming you've added EF to the services container in `ConfigureServices`).</span></span> <span data-ttu-id="ce700-265">Некоторые разработчики предпочитают использовать интерфейс репозитория в базу данных вместо вводится `DbContext` напрямую.</span><span class="sxs-lookup"><span data-stu-id="ce700-265">Some developers prefer to use a repository interface to the database rather than injecting the `DbContext` directly.</span></span> <span data-ttu-id="ce700-266">С помощью интерфейса, предназначенный для инкапсуляции данных логики доступа в одном месте можно свести к минимуму число знаков, необходимо будет изменить при изменении базы данных.</span><span class="sxs-lookup"><span data-stu-id="ce700-266">Using an interface to encapsulate the data access logic in one place can minimize how many places you will have to change when your database changes.</span></span>

### <a name="disposing-of-services"></a><span data-ttu-id="ce700-267">Удаление служб</span><span class="sxs-lookup"><span data-stu-id="ce700-267">Disposing of services</span></span>

<span data-ttu-id="ce700-268">Контейнер будет вызвать `Dispose` для `IDisposable` типов, он создает.</span><span class="sxs-lookup"><span data-stu-id="ce700-268">The container will call `Dispose` for `IDisposable` types it creates.</span></span> <span data-ttu-id="ce700-269">Тем не менее при добавлении экземпляра к контейнеру самостоятельно, она не будет удален.</span><span class="sxs-lookup"><span data-stu-id="ce700-269">However, if you add an instance to the container yourself, it will not be disposed.</span></span>

<span data-ttu-id="ce700-270">Пример</span><span class="sxs-lookup"><span data-stu-id="ce700-270">Example:</span></span>

```csharp
// Services implement IDisposable:
public class Service1 : IDisposable {}
public class Service2 : IDisposable {}
public class Service3 : IDisposable {}

public interface ISomeService {}
public class SomeServiceImplementation : ISomeService, IDisposable {}


public void ConfigureServices(IServiceCollection services)
{
    // container will create the instance(s) of these types and will dispose them
    services.AddScoped<Service1>();
    services.AddSingleton<Service2>();
    services.AddSingleton<ISomeService>(sp => new SomeServiceImplementation());

    // container didn't create instance so it will NOT dispose it
    services.AddSingleton<Service3>(new Service3());
    services.AddSingleton(new Service3());
}
```

> [!NOTE]
> <span data-ttu-id="ce700-271">В версии 1.0, контейнер вызван dispose для *все* `IDisposable` объекты, включая те, он еще не создана.</span><span class="sxs-lookup"><span data-stu-id="ce700-271">In version 1.0, the container called dispose on *all* `IDisposable` objects, including those it didn't create.</span></span>

## <a name="replacing-the-default-services-container"></a><span data-ttu-id="ce700-272">Замена контейнер служб по умолчанию</span><span class="sxs-lookup"><span data-stu-id="ce700-272">Replacing the default services container</span></span>

<span data-ttu-id="ce700-273">Контейнер встроенных служб предназначен для обслуживания basic framework и большинство клиентские приложения, основанные на нем.</span><span class="sxs-lookup"><span data-stu-id="ce700-273">The built-in services container is meant to serve the basic needs of the framework and most consumer applications built on it.</span></span> <span data-ttu-id="ce700-274">Тем не менее разработчики могут заменять встроенного контейнера их предпочитаемыми контейнерами.</span><span class="sxs-lookup"><span data-stu-id="ce700-274">However, developers can replace the built-in container with their preferred container.</span></span> <span data-ttu-id="ce700-275">`ConfigureServices` Метод обычно возвращает `void`, но при изменении его подпись для возврата `IServiceProvider`, другой контейнер можно настроить и возвращается.</span><span class="sxs-lookup"><span data-stu-id="ce700-275">The `ConfigureServices` method typically returns `void`, but if its signature is changed to return `IServiceProvider`, a different container can be configured and returned.</span></span> <span data-ttu-id="ce700-276">Многие контейнеры IOC доступны для .NET.</span><span class="sxs-lookup"><span data-stu-id="ce700-276">There are many IOC containers available for .NET.</span></span> <span data-ttu-id="ce700-277">В этом примере [Autofac](https://autofac.org/) используется пакет.</span><span class="sxs-lookup"><span data-stu-id="ce700-277">In this example, the [Autofac](https://autofac.org/) package is used.</span></span>

<span data-ttu-id="ce700-278">Сначала установите пакеты соответствующего контейнера:</span><span class="sxs-lookup"><span data-stu-id="ce700-278">First, install the appropriate container package(s):</span></span>

* `Autofac`
* `Autofac.Extensions.DependencyInjection`

<span data-ttu-id="ce700-279">Настройте контейнер в `ConfigureServices` и возвращают `IServiceProvider`:</span><span class="sxs-lookup"><span data-stu-id="ce700-279">Next, configure the container in `ConfigureServices` and return an `IServiceProvider`:</span></span>

```csharp
public IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    // Add other framework services

    // Add Autofac
    var containerBuilder = new ContainerBuilder();
    containerBuilder.RegisterModule<DefaultModule>();
    containerBuilder.Populate(services);
    var container = containerBuilder.Build();
    return new AutofacServiceProvider(container);
}
```

> [!NOTE]
> <span data-ttu-id="ce700-280">При использовании сторонних DI контейнер, необходимо изменить `ConfigureServices` , чтобы он возвращал `IServiceProvider` вместо `void`.</span><span class="sxs-lookup"><span data-stu-id="ce700-280">When using a third-party DI container, you must change `ConfigureServices` so that it returns `IServiceProvider` instead of `void`.</span></span>

<span data-ttu-id="ce700-281">И наконец, настройте Autofac как обычно в `DefaultModule`:</span><span class="sxs-lookup"><span data-stu-id="ce700-281">Finally, configure Autofac as normal in `DefaultModule`:</span></span>

```csharp
public class DefaultModule : Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterType<CharacterRepository>().As<ICharacterRepository>();
    }
}
```

<span data-ttu-id="ce700-282">Во время выполнения Autofac будет использоваться для разрешения типов и внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ce700-282">At runtime, Autofac will be used to resolve types and inject dependencies.</span></span> <span data-ttu-id="ce700-283">[Дополнительные сведения об использовании Autofac и ASP.NET Core](http://docs.autofac.org/en/latest/integration/aspnetcore.html).</span><span class="sxs-lookup"><span data-stu-id="ce700-283">[Learn more about using Autofac and ASP.NET Core](http://docs.autofac.org/en/latest/integration/aspnetcore.html).</span></span>

### <a name="thread-safety"></a><span data-ttu-id="ce700-284">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="ce700-284">Thread safety</span></span>

<span data-ttu-id="ce700-285">Одноэлементные службы должны быть потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="ce700-285">Singleton services need to be thread safe.</span></span> <span data-ttu-id="ce700-286">Если служба singleton имеет зависимость от временных службы, временная служба может также потребоваться потокобезопасность, в зависимости от того, как он используется единственный экземпляр.</span><span class="sxs-lookup"><span data-stu-id="ce700-286">If a singleton service has a dependency on a transient service, the transient service may also need to be thread safe depending how it’s used by the singleton.</span></span>

## <a name="recommendations"></a><span data-ttu-id="ce700-287">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="ce700-287">Recommendations</span></span>

<span data-ttu-id="ce700-288">При работе с внедрения зависимостей, учитывайте следующие рекомендации:</span><span class="sxs-lookup"><span data-stu-id="ce700-288">When working with dependency injection, keep the following recommendations in mind:</span></span>

* <span data-ttu-id="ce700-289">DI — для объектов, имеющих сложных зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ce700-289">DI is for objects that have complex dependencies.</span></span> <span data-ttu-id="ce700-290">Контроллеры, служб, адаптеры и репозиториев иллюстрируют все объекты, которые могут быть добавлены DI.</span><span class="sxs-lookup"><span data-stu-id="ce700-290">Controllers, services, adapters, and repositories are all examples of objects that might be added to DI.</span></span>

* <span data-ttu-id="ce700-291">Не храните данные и конфигурации непосредственно в DI.</span><span class="sxs-lookup"><span data-stu-id="ce700-291">Avoid storing data and configuration directly in DI.</span></span> <span data-ttu-id="ce700-292">Например корзину пользователя обычно не следует добавлять в контейнер службы.</span><span class="sxs-lookup"><span data-stu-id="ce700-292">For example, a user's shopping cart shouldn't typically be added to the services container.</span></span> <span data-ttu-id="ce700-293">Следует использовать конфигурации [параметры шаблона](xref:fundamentals/configuration/options).</span><span class="sxs-lookup"><span data-stu-id="ce700-293">Configuration should use the [options pattern](xref:fundamentals/configuration/options).</span></span> <span data-ttu-id="ce700-294">Аналогичным образом можно Избегайте «данных владельца» объекты, которые существуют только для доступа к какой-либо другой объект.</span><span class="sxs-lookup"><span data-stu-id="ce700-294">Similarly, avoid "data holder" objects that only exist to allow access to some other object.</span></span> <span data-ttu-id="ce700-295">Лучше запроса фактический элемент понадобится DI, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="ce700-295">It's better to request the actual item needed via DI, if possible.</span></span>

* <span data-ttu-id="ce700-296">Избегайте доступа к службам.</span><span class="sxs-lookup"><span data-stu-id="ce700-296">Avoid static access to services.</span></span>

* <span data-ttu-id="ce700-297">Избегайте размещение службы в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="ce700-297">Avoid service location in your application code.</span></span>

* <span data-ttu-id="ce700-298">Избегайте доступа к `HttpContext`.</span><span class="sxs-lookup"><span data-stu-id="ce700-298">Avoid static access to `HttpContext`.</span></span>

> [!NOTE]
> <span data-ttu-id="ce700-299">Как и все наборы рекомендаций могут возникнуть ситуации, в которых требуется одно игнорируется.</span><span class="sxs-lookup"><span data-stu-id="ce700-299">Like all sets of recommendations, you may encounter situations where ignoring one is required.</span></span> <span data-ttu-id="ce700-300">Мы пришли к выводу исключения редко — главным образом специальные случаи, входящие в этой платформе.</span><span class="sxs-lookup"><span data-stu-id="ce700-300">We have found exceptions to be rare -- mostly very special cases within the framework itself.</span></span>

<span data-ttu-id="ce700-301">Помните, что является внедрения зависимостей *альтернативные* для шаблонов доступа к статическим или глобального объекта.</span><span class="sxs-lookup"><span data-stu-id="ce700-301">Remember, dependency injection is an *alternative* to static/global object access patterns.</span></span> <span data-ttu-id="ce700-302">Невозможно использовать преимущества DI Если перепутать с доступом статический объект.</span><span class="sxs-lookup"><span data-stu-id="ce700-302">You won't be able to realize the benefits of DI if you mix it with static object access.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ce700-303">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="ce700-303">Additional Resources</span></span>

* [<span data-ttu-id="ce700-304">Запуск приложения</span><span class="sxs-lookup"><span data-stu-id="ce700-304">Application Startup</span></span>](startup.md)

* [<span data-ttu-id="ce700-305">Тестирование</span><span class="sxs-lookup"><span data-stu-id="ce700-305">Testing</span></span>](../testing/index.md)

* [<span data-ttu-id="ce700-306">Написание кода очистки в ASP.NET Core с помощью внедрения зависимости (MSDN)</span><span class="sxs-lookup"><span data-stu-id="ce700-306">Writing Clean Code in ASP.NET Core with Dependency Injection (MSDN)</span></span>](https://msdn.microsoft.com/magazine/mt703433.aspx)

* [<span data-ttu-id="ce700-307">Управляемые контейнера при разработке приложения Prelude: Когда осуществляет контейнер принадлежать?</span><span class="sxs-lookup"><span data-stu-id="ce700-307">Container-Managed Application Design, Prelude: Where does the Container Belong?</span></span>](https://blogs.msdn.microsoft.com/nblumhardt/2008/12/26/container-managed-application-design-prelude-where-does-the-container-belong/)

* [<span data-ttu-id="ce700-308">Принцип явные зависимости</span><span class="sxs-lookup"><span data-stu-id="ce700-308">Explicit Dependencies Principle</span></span>](http://deviq.com/explicit-dependencies-principle/)

* <span data-ttu-id="ce700-309">[Контейнеры элементов управления и шаблон внедрения зависимостей инверсии](https://www.martinfowler.com/articles/injection.html) (Fowler)</span><span class="sxs-lookup"><span data-stu-id="ce700-309">[Inversion of Control Containers and the Dependency Injection Pattern](https://www.martinfowler.com/articles/injection.html) (Fowler)</span></span>
