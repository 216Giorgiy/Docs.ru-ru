---
title: "Внедрение зависимостей в ASP.NET Core"
author: ardalis
description: "Сведения о том, как ASP.NET Core реализует внедрение зависимостей и как его использовать."
manager: wpickett
ms.author: riande
ms.custom: H1Hack27Feb2017
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: fundamentals/dependency-injection
ms.openlocfilehash: 43c937ff9631be3edc1f95b3689650e4574abfbd
ms.sourcegitcommit: f2a11a89037471a77ad68a67533754b7bb8303e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/01/2018
---
# <a name="dependency-injection-in-aspnet-core"></a><span data-ttu-id="825f6-103">Внедрение зависимостей в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="825f6-103">Dependency injection in ASP.NET Core</span></span>

<a name="fundamentals-dependency-injection"></a>

<span data-ttu-id="825f6-104">Авторы: [Стив Смит](https://ardalis.com/) (Steve Smith) и [Скотт Эдди](https://scottaddie.com) (Scott Addie)</span><span class="sxs-lookup"><span data-stu-id="825f6-104">By [Steve Smith](https://ardalis.com/) and [Scott Addie](https://scottaddie.com)</span></span>

<span data-ttu-id="825f6-105">Среда ASP.NET Core разработана с нуля, чтобы обеспечить поддержку и использование внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="825f6-105">ASP.NET Core is designed from the ground up to support and leverage dependency injection.</span></span> <span data-ttu-id="825f6-106">Приложения ASP.NET Core могут использовать встроенные службы платформы, внедряя их в методы в классе Startup, кроме того, для внедрения можно настроить и службы приложений.</span><span class="sxs-lookup"><span data-stu-id="825f6-106">ASP.NET Core applications can leverage built-in framework services by having them injected into methods in the Startup class, and application services can be configured for injection as well.</span></span> <span data-ttu-id="825f6-107">Контейнер служб по умолчанию, предоставляемый ASP.NET Core, предлагает минимальный набор возможностей и не предназначен для замены других контейнеров.</span><span class="sxs-lookup"><span data-stu-id="825f6-107">The default services container provided by ASP.NET Core provides a minimal feature set and isn't intended to replace other containers.</span></span>

<span data-ttu-id="825f6-108">[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/dependency-injection/sample) ([как скачивать](xref:tutorials/index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="825f6-108">[View or download sample code](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/dependency-injection/sample) ([how to download](xref:tutorials/index#how-to-download-a-sample))</span></span>

## <a name="what-is-dependency-injection"></a><span data-ttu-id="825f6-109">Что такое внедрение зависимостей?</span><span class="sxs-lookup"><span data-stu-id="825f6-109">What is dependency injection?</span></span>

<span data-ttu-id="825f6-110">Внедрение зависимостей (DI) — это методика для обеспечения слабой связи между объектами и их участниками совместной работы или зависимостями.</span><span class="sxs-lookup"><span data-stu-id="825f6-110">Dependency injection (DI) is a technique for achieving loose coupling between objects and their collaborators, or dependencies.</span></span> <span data-ttu-id="825f6-111">Вместо того, чтобы напрямую создавать экземпляры участников совместной работы или использовать статические ссылки, объекты, необходимые классу для выполнения действий, предоставляются классу каким-либо образом.</span><span class="sxs-lookup"><span data-stu-id="825f6-111">Rather than directly instantiating collaborators, or using static references, the objects a class needs in order to perform its actions are provided to the class in some fashion.</span></span> <span data-ttu-id="825f6-112">Чаще всего классы объявляют зависимости через свой конструктор, позволяя им следовать [принципу явных зависимостей](http://deviq.com/explicit-dependencies-principle/).</span><span class="sxs-lookup"><span data-stu-id="825f6-112">Most often, classes will declare their dependencies via their constructor, allowing them to follow the [Explicit Dependencies Principle](http://deviq.com/explicit-dependencies-principle/).</span></span> <span data-ttu-id="825f6-113">Подобный подход называется "внедрением через конструктор".</span><span class="sxs-lookup"><span data-stu-id="825f6-113">This approach is known as "constructor injection".</span></span>

<span data-ttu-id="825f6-114">Когда классы создаются с учетом внедрения зависимостей, они слабее связаны, так как не имеют прямых и жестко заданных зависимостей от своих участников совместной работы.</span><span class="sxs-lookup"><span data-stu-id="825f6-114">When classes are designed with DI in mind, they're more loosely coupled because they don't have direct, hard-coded dependencies on their collaborators.</span></span> <span data-ttu-id="825f6-115">Это соответствует [принципу инверсии зависимостей](http://deviq.com/dependency-inversion-principle/), указывающему, что *"высокоуровневые модули не должны зависеть от низкоуровневых; оба этих типа должны зависеть от абстракций"*.</span><span class="sxs-lookup"><span data-stu-id="825f6-115">This follows the [Dependency Inversion Principle](http://deviq.com/dependency-inversion-principle/), which states that *"high level modules shouldn't depend on low level modules; both should depend on abstractions."*</span></span> <span data-ttu-id="825f6-116">Вместо ссылки на определенные реализации классы запрашивают абстракции (обычно `interfaces`), которые предоставляются им при создании класса.</span><span class="sxs-lookup"><span data-stu-id="825f6-116">Instead of referencing specific implementations, classes request abstractions (typically `interfaces`) which are provided to them when the class is constructed.</span></span> <span data-ttu-id="825f6-117">Извлечение зависимостей в интерфейсы и предоставление реализаций этих интерфейсов в качестве параметров также является примером [шаблона разработки стратегии](http://deviq.com/strategy-design-pattern/).</span><span class="sxs-lookup"><span data-stu-id="825f6-117">Extracting dependencies into interfaces and providing implementations of these interfaces as parameters is also an example of the [Strategy design pattern](http://deviq.com/strategy-design-pattern/).</span></span>

<span data-ttu-id="825f6-118">Когда система предназначена для использования внедрения зависимостей, то есть множество классов запрашивают зависимости через свой конструктор (или свойства), полезно иметь выделенный класс для создания этих классов с их связанными зависимостями.</span><span class="sxs-lookup"><span data-stu-id="825f6-118">When a system is designed to use DI, with many classes requesting their dependencies via their constructor (or properties), it's helpful to have a class dedicated to creating these classes with their associated dependencies.</span></span> <span data-ttu-id="825f6-119">Такие классы называются *контейнерами*, а если точнее, контейнерами [инверсии управления (IoC)](http://deviq.com/inversion-of-control/) или контейнерами внедрения зависимостей (DI).</span><span class="sxs-lookup"><span data-stu-id="825f6-119">These classes are referred to as *containers*, or more specifically, [Inversion of Control (IoC)](http://deviq.com/inversion-of-control/) containers or Dependency Injection (DI) containers.</span></span> <span data-ttu-id="825f6-120">Контейнер по существу является фабрикой и отвечает за предоставление экземпляров типов, запрашиваемых из него.</span><span class="sxs-lookup"><span data-stu-id="825f6-120">A container is essentially a factory that's responsible for providing instances of types that are requested from it.</span></span> <span data-ttu-id="825f6-121">Если заданный тип объявил, что имеет зависимости, а контейнер настроен для предоставления этих типов зависимостей, он создаст зависимости в рамках создания запрошенного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="825f6-121">If a given type has declared that it has dependencies, and the container has been configured to provide the dependency types, it will create the dependencies as part of creating the requested instance.</span></span> <span data-ttu-id="825f6-122">Таким образом, можно предоставить классам сложные графы зависимостей без потребности в создании жестко заданных объектов.</span><span class="sxs-lookup"><span data-stu-id="825f6-122">In this way, complex dependency graphs can be provided to classes without the need for any hard-coded object construction.</span></span> <span data-ttu-id="825f6-123">Кроме создания объектов с зависимостями, контейнеры обычно управляют временем жизни объектов в приложении.</span><span class="sxs-lookup"><span data-stu-id="825f6-123">In addition to creating objects with their dependencies, containers typically manage object lifetimes within the application.</span></span>

<span data-ttu-id="825f6-124">ASP.NET Core содержит простой встроенный контейнер (представленный интерфейсом `IServiceProvider`), поддерживающий внедрение через конструктор по умолчанию, а ASP.NET предоставляет посредством внедрения зависимостей определенные службы.</span><span class="sxs-lookup"><span data-stu-id="825f6-124">ASP.NET Core includes a simple built-in container (represented by the `IServiceProvider` interface) that supports constructor injection by default, and ASP.NET makes certain services available through DI.</span></span> <span data-ttu-id="825f6-125">Контейнер ASP.NET ссылается на управляемые им типы, как на *службы*.</span><span class="sxs-lookup"><span data-stu-id="825f6-125">ASP.NET's container refers to the types it manages as *services*.</span></span> <span data-ttu-id="825f6-126">В остальной части этой статьи *службами* будут обозначаться типы, которыми управляет контейнер инверсии управления ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="825f6-126">Throughout the rest of this article, *services* will refer to types that are managed by ASP.NET Core's IoC container.</span></span> <span data-ttu-id="825f6-127">Настроить службы встроенного контейнера можно в методе `ConfigureServices` в классе `Startup` вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="825f6-127">You configure the built-in container's services in the `ConfigureServices` method in your application's `Startup` class.</span></span>

> [!NOTE]
> <span data-ttu-id="825f6-128">Мартин Фаулер (Martin Fowler) написал обширную статью о [контейнерах инверсии управления и шаблоне внедрения зависимостей](https://www.martinfowler.com/articles/injection.html).</span><span class="sxs-lookup"><span data-stu-id="825f6-128">Martin Fowler has written an extensive article on [Inversion of Control Containers and the Dependency Injection Pattern](https://www.martinfowler.com/articles/injection.html).</span></span> <span data-ttu-id="825f6-129">Центр Microsoft Patterns and Practices также содержит хорошее описание [внедрения зависимостей](https://msdn.microsoft.com/library/hh323705.aspx).</span><span class="sxs-lookup"><span data-stu-id="825f6-129">Microsoft Patterns and Practices also has a great description of [Dependency Injection](https://msdn.microsoft.com/library/hh323705.aspx).</span></span>

> [!NOTE]
> <span data-ttu-id="825f6-130">Эта статья охватывает внедрение зависимостей применительно ко всем приложениям ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="825f6-130">This article covers Dependency Injection as it applies to all ASP.NET applications.</span></span> <span data-ttu-id="825f6-131">Внедрение зависимостей в контроллерах MVC рассматривается в статье [Внедрение зависимостей и контроллеры](../mvc/controllers/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="825f6-131">Dependency Injection within MVC controllers is covered in [Dependency Injection and Controllers](../mvc/controllers/dependency-injection.md).</span></span>

### <a name="constructor-injection-behavior"></a><span data-ttu-id="825f6-132">Поведение внедрения через конструктор</span><span class="sxs-lookup"><span data-stu-id="825f6-132">Constructor injection behavior</span></span>

<span data-ttu-id="825f6-133">Для внедрения через конструктор требуется, чтобы соответствующий конструктор был *открытым*.</span><span class="sxs-lookup"><span data-stu-id="825f6-133">Constructor injection requires that the constructor in question be *public*.</span></span> <span data-ttu-id="825f6-134">В противном случае приложение выдает исключение `InvalidOperationException`:</span><span class="sxs-lookup"><span data-stu-id="825f6-134">Otherwise, your app will throw an `InvalidOperationException`:</span></span>

> <span data-ttu-id="825f6-135">A suitable constructor for type "YourType" couldn't be located.</span><span class="sxs-lookup"><span data-stu-id="825f6-135">A suitable constructor for type 'YourType' couldn't be located.</span></span> <span data-ttu-id="825f6-136">Ensure the type is concrete and services are registered for all parameters of a public constructor. (Не удалось найти подходящий конструктор для типа "ваш_тип". Убедитесь, что тип является конкретным, а службы зарегистрированы для всех параметров открытого конструктора.)</span><span class="sxs-lookup"><span data-stu-id="825f6-136">Ensure the type is concrete and services are registered for all parameters of a public constructor.</span></span>


<span data-ttu-id="825f6-137">Для внедрения через конструктор необходимо, чтобы существовал всего один соответствующий конструктор.</span><span class="sxs-lookup"><span data-stu-id="825f6-137">Constructor injection requires that only one applicable constructor exist.</span></span> <span data-ttu-id="825f6-138">Перегрузки конструктора поддерживаются, но может существовать всего одна перегрузка, все аргументы которой могут быть обработаны с помощью внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="825f6-138">Constructor overloads are supported, but only one overload can exist whose arguments can all be fulfilled by dependency injection.</span></span> <span data-ttu-id="825f6-139">При наличии нескольких экземпляров приложение выдает исключение `InvalidOperationException`:</span><span class="sxs-lookup"><span data-stu-id="825f6-139">If more than one exists, your app will throw an `InvalidOperationException`:</span></span>

> <span data-ttu-id="825f6-140">Multiple constructors accepting all given argument types have been found in type "YourType".</span><span class="sxs-lookup"><span data-stu-id="825f6-140">Multiple constructors accepting all given argument types have been found in type 'YourType'.</span></span> <span data-ttu-id="825f6-141">There should only be one applicable constructor. (В типе "YourType" найдено несколько конструкторов, принимающих все заданные типы аргументов. Должен присутствовать всего один соответствующий конструктор.)</span><span class="sxs-lookup"><span data-stu-id="825f6-141">There should only be one applicable constructor.</span></span>

<span data-ttu-id="825f6-142">Конструкторы могут принимать аргументы, предоставленные не внедрением зависимостей, но они должны поддерживать значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="825f6-142">Constructors can accept arguments that are not provided by dependency injection, but these must support default values.</span></span> <span data-ttu-id="825f6-143">Пример:</span><span class="sxs-lookup"><span data-stu-id="825f6-143">For example:</span></span>

```csharp
// throws InvalidOperationException: Unable to resolve service for type 'System.String'...
public CharactersController(ICharacterRepository characterRepository, string title)
{
    _characterRepository = characterRepository;
    _title = title;
}

// runs without error
public CharactersController(ICharacterRepository characterRepository, string title = "Characters")
{
    _characterRepository = characterRepository;
    _title = title;
}
```

## <a name="using-framework-provided-services"></a><span data-ttu-id="825f6-144">Использование служб, предоставленных платформой</span><span class="sxs-lookup"><span data-stu-id="825f6-144">Using framework-provided services</span></span>

<span data-ttu-id="825f6-145">Метод `ConfigureServices` в классе `Startup` отвечает за определение служб, которые будет использовать приложение, включая такие возможности платформы, как Entity Framework Core и ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="825f6-145">The `ConfigureServices` method in the `Startup` class is responsible for defining the services the application will use, including platform features like Entity Framework Core and ASP.NET Core MVC.</span></span> <span data-ttu-id="825f6-146">Изначально `IServiceCollection`, предоставленный `ConfigureServices`, имеет следующие определенные службы (в зависимости от [настройки узла](xref:fundamentals/hosting)):</span><span class="sxs-lookup"><span data-stu-id="825f6-146">Initially, the `IServiceCollection` provided to `ConfigureServices` has the following services defined (depending on [how the host was configured](xref:fundamentals/hosting)):</span></span>

| <span data-ttu-id="825f6-147">Тип службы</span><span class="sxs-lookup"><span data-stu-id="825f6-147">Service Type</span></span> | <span data-ttu-id="825f6-148">Время существования</span><span class="sxs-lookup"><span data-stu-id="825f6-148">Lifetime</span></span> |
| ----- | ------- |
| [<span data-ttu-id="825f6-149">Microsoft.AspNetCore.Hosting.IHostingEnvironment</span><span class="sxs-lookup"><span data-stu-id="825f6-149">Microsoft.AspNetCore.Hosting.IHostingEnvironment</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.ihostingenvironment) | <span data-ttu-id="825f6-150">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-150">Singleton</span></span> |
| [<span data-ttu-id="825f6-151">Microsoft.Extensions.Logging.ILoggerFactory</span><span class="sxs-lookup"><span data-stu-id="825f6-151">Microsoft.Extensions.Logging.ILoggerFactory</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.logging.iloggerfactory) | <span data-ttu-id="825f6-152">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-152">Singleton</span></span> |
| [<span data-ttu-id="825f6-153">Microsoft.Extensions.Logging.ILogger&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="825f6-153">Microsoft.Extensions.Logging.ILogger&lt;T&gt;</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.logging.ilogger) | <span data-ttu-id="825f6-154">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-154">Singleton</span></span> |
| [<span data-ttu-id="825f6-155">Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</span><span class="sxs-lookup"><span data-stu-id="825f6-155">Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.builder.iapplicationbuilderfactory) | <span data-ttu-id="825f6-156">Временный</span><span class="sxs-lookup"><span data-stu-id="825f6-156">Transient</span></span> |
| [<span data-ttu-id="825f6-157">Microsoft.AspNetCore.Http.IHttpContextFactory</span><span class="sxs-lookup"><span data-stu-id="825f6-157">Microsoft.AspNetCore.Http.IHttpContextFactory</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.http.ihttpcontextfactory) | <span data-ttu-id="825f6-158">Временный</span><span class="sxs-lookup"><span data-stu-id="825f6-158">Transient</span></span> |
| [<span data-ttu-id="825f6-159">Microsoft.Extensions.Options.IOptions&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="825f6-159">Microsoft.Extensions.Options.IOptions&lt;T&gt;</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.options.ioptions-1) | <span data-ttu-id="825f6-160">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-160">Singleton</span></span> |
| [<span data-ttu-id="825f6-161">System.Diagnostics.DiagnosticSource</span><span class="sxs-lookup"><span data-stu-id="825f6-161">System.Diagnostics.DiagnosticSource</span></span>](https://docs.microsoft.com/dotnet/core/api/system.diagnostics.diagnosticsource) | <span data-ttu-id="825f6-162">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-162">Singleton</span></span> |
| [<span data-ttu-id="825f6-163">System.Diagnostics.DiagnosticListener</span><span class="sxs-lookup"><span data-stu-id="825f6-163">System.Diagnostics.DiagnosticListener</span></span>](https://docs.microsoft.com/dotnet/core/api/system.diagnostics.diagnosticlistener) | <span data-ttu-id="825f6-164">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-164">Singleton</span></span> |
| [<span data-ttu-id="825f6-165">Microsoft.AspNetCore.Hosting.IStartupFilter</span><span class="sxs-lookup"><span data-stu-id="825f6-165">Microsoft.AspNetCore.Hosting.IStartupFilter</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.istartupfilter) | <span data-ttu-id="825f6-166">Временный</span><span class="sxs-lookup"><span data-stu-id="825f6-166">Transient</span></span> |
| [<span data-ttu-id="825f6-167">Microsoft.Extensions.ObjectPool.ObjectPoolProvider</span><span class="sxs-lookup"><span data-stu-id="825f6-167">Microsoft.Extensions.ObjectPool.ObjectPoolProvider</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.objectpool.objectpoolprovider) | <span data-ttu-id="825f6-168">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-168">Singleton</span></span> |
| [<span data-ttu-id="825f6-169">Microsoft.Extensions.Options.IConfigureOptions&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="825f6-169">Microsoft.Extensions.Options.IConfigureOptions&lt;T&gt;</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.options.iconfigureoptions-1) | <span data-ttu-id="825f6-170">Временный</span><span class="sxs-lookup"><span data-stu-id="825f6-170">Transient</span></span> |
| [<span data-ttu-id="825f6-171">Microsoft.AspNetCore.Hosting.Server.IServer</span><span class="sxs-lookup"><span data-stu-id="825f6-171">Microsoft.AspNetCore.Hosting.Server.IServer</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.server.iserver) | <span data-ttu-id="825f6-172">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-172">Singleton</span></span> |
| [<span data-ttu-id="825f6-173">Microsoft.AspNetCore.Hosting.IStartup</span><span class="sxs-lookup"><span data-stu-id="825f6-173">Microsoft.AspNetCore.Hosting.IStartup</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.istartup) | <span data-ttu-id="825f6-174">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-174">Singleton</span></span> |
| [<span data-ttu-id="825f6-175">Microsoft.AspNetCore.Hosting.IApplicationLifetime</span><span class="sxs-lookup"><span data-stu-id="825f6-175">Microsoft.AspNetCore.Hosting.IApplicationLifetime</span></span>](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.hosting.iapplicationlifetime) | <span data-ttu-id="825f6-176">Одноэлементный</span><span class="sxs-lookup"><span data-stu-id="825f6-176">Singleton</span></span> |

<span data-ttu-id="825f6-177">Ниже приведен пример того, как добавить дополнительные службы в контейнер с помощью нескольких методов расширения, таких как `AddDbContext`, `AddIdentity` и `AddMvc`.</span><span class="sxs-lookup"><span data-stu-id="825f6-177">Below is an example of how to add additional services to the container using a number of extension methods like `AddDbContext`, `AddIdentity`, and `AddMvc`.</span></span>

[!code-csharp[Main](../common/samples/WebApplication1/Startup.cs?highlight=5-6,8-10,12&range=39-56)]

<span data-ttu-id="825f6-178">Предоставляемые ASP.NET функции и ПО промежуточного слоя, например MVC, соответствуют соглашению об использовании одного метода расширения Add*имя_службы* для регистрации всех служб, необходимых данному компоненту.</span><span class="sxs-lookup"><span data-stu-id="825f6-178">The features and middleware provided by ASP.NET, such as MVC, follow a convention of using a single Add*ServiceName* extension method to register all of the services required by that feature.</span></span>

>[!TIP]
> <span data-ttu-id="825f6-179">Вы можете запросить определенные предоставляемые платформой службы в методах `Startup` через их списки параметров. Дополнительные сведения см. в разделе [Запуск приложения](startup.md).</span><span class="sxs-lookup"><span data-stu-id="825f6-179">You can request certain framework-provided services within `Startup` methods through their parameter lists - see [Application Startup](startup.md) for more details.</span></span>

## <a name="registering-services"></a><span data-ttu-id="825f6-180">Регистрация служб</span><span class="sxs-lookup"><span data-stu-id="825f6-180">Registering services</span></span>

<span data-ttu-id="825f6-181">Вы можете регистрировать свои службы приложений описанным ниже образом.</span><span class="sxs-lookup"><span data-stu-id="825f6-181">You can register your own application services as follows.</span></span> <span data-ttu-id="825f6-182">Первый универсальный тип представляет тип (обычно это интерфейс), который будет запрашиваться из контейнера.</span><span class="sxs-lookup"><span data-stu-id="825f6-182">The first generic type represents the type (typically an interface) that will be requested from the container.</span></span> <span data-ttu-id="825f6-183">Второй универсальный тип представляет конкретный тип, экземпляр которого будет создаваться контейнером и использоваться для выполнения таких запросов.</span><span class="sxs-lookup"><span data-stu-id="825f6-183">The second generic type represents the concrete type that will be instantiated by the container and used to fulfill such requests.</span></span>

[!code-csharp[Main](../common/samples/WebApplication1/Startup.cs?range=53-54)]

> [!NOTE]
> <span data-ttu-id="825f6-184">Каждый метод расширения `services.Add<ServiceName>` добавляет (а потенциально и настраивает) службы.</span><span class="sxs-lookup"><span data-stu-id="825f6-184">Each `services.Add<ServiceName>` extension method adds (and potentially configures) services.</span></span> <span data-ttu-id="825f6-185">Например, `services.AddMvc()` добавляет службы, нужные MVC.</span><span class="sxs-lookup"><span data-stu-id="825f6-185">For example, `services.AddMvc()` adds the services MVC requires.</span></span> <span data-ttu-id="825f6-186">Рекомендуется следовать этому соглашению и поместить методы расширения в пространство имен `Microsoft.Extensions.DependencyInjection` для инкапсуляции группы регистраций служб.</span><span class="sxs-lookup"><span data-stu-id="825f6-186">It's recommended that you follow this convention, placing extension methods in the `Microsoft.Extensions.DependencyInjection` namespace, to encapsulate groups of service registrations.</span></span>

<span data-ttu-id="825f6-187">Метод `AddTransient` используется для сопоставления абстрактных типов с конкретными службами, экземпляры которых создаются отдельно для каждого объекта, который в них нуждается.</span><span class="sxs-lookup"><span data-stu-id="825f6-187">The `AddTransient` method is used to map abstract types to concrete services that are instantiated separately for every object that requires it.</span></span> <span data-ttu-id="825f6-188">Это называется *временем существования* службы, а соответствующие дополнительные параметры описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="825f6-188">This is known as the service's *lifetime*, and additional lifetime options are described below.</span></span> <span data-ttu-id="825f6-189">Важно выбирать подходящее время существования для каждой из регистрируемых служб.</span><span class="sxs-lookup"><span data-stu-id="825f6-189">It's important to choose an appropriate lifetime for each of the services you register.</span></span> <span data-ttu-id="825f6-190">Нужно ли предоставлять новый экземпляр службы каждому классу, который его запрашивает?</span><span class="sxs-lookup"><span data-stu-id="825f6-190">Should a new instance of the service be provided to each class that requests it?</span></span> <span data-ttu-id="825f6-191">Нужно ли использовать один экземпляр в рамках всего заданного веб-запроса?</span><span class="sxs-lookup"><span data-stu-id="825f6-191">Should one instance be used throughout a given web request?</span></span> <span data-ttu-id="825f6-192">Или нужно использовать один экземпляр в течение времени существования приложения?</span><span class="sxs-lookup"><span data-stu-id="825f6-192">Or should a single instance be used for the lifetime of the application?</span></span>

<span data-ttu-id="825f6-193">Пример для этой статьи содержит простой контроллер, который отображает имена символов и называется `CharactersController`.</span><span class="sxs-lookup"><span data-stu-id="825f6-193">In the sample for this article, there's a simple controller that displays character names, called `CharactersController`.</span></span> <span data-ttu-id="825f6-194">Его метод `Index` отображает текущий список символов, хранящихся в приложении, и инициализирует коллекцию с небольшим количеством символов, если такой список отсутствует.</span><span class="sxs-lookup"><span data-stu-id="825f6-194">Its `Index` method displays the current list of characters that have been stored in the application, and initializes the collection with a handful of characters if none exist.</span></span> <span data-ttu-id="825f6-195">Обратите внимание, что хотя это приложение использует Entity Framework Core и класс `ApplicationDbContext` для обеспечения сохраняемости, в контроллере об этом неизвестно.</span><span class="sxs-lookup"><span data-stu-id="825f6-195">Note that although this application uses Entity Framework Core and the `ApplicationDbContext` class for its persistence, none of that's apparent in the controller.</span></span> <span data-ttu-id="825f6-196">Вместо этого определенный механизм доступа к данным был абстрагирован за интерфейс `ICharacterRepository`, что соответствует [шаблону репозитория](http://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="825f6-196">Instead, the specific data access mechanism has been abstracted behind an interface, `ICharacterRepository`, which follows the [repository pattern](http://deviq.com/repository-pattern/).</span></span> <span data-ttu-id="825f6-197">Экземпляр `ICharacterRepository` запрашивается через конструктор и назначается частному полю, которое затем используется для доступа к символам по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="825f6-197">An instance of `ICharacterRepository` is requested via the constructor and assigned to a private field, which is then used to access characters as necessary.</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Controllers/CharactersController.cs?highlight=3,5,6,7,8,14,21-27&range=8-36)]

<span data-ttu-id="825f6-198">`ICharacterRepository` определяет два метода, которые нужны контроллеру для работы с экземплярами `Character`.</span><span class="sxs-lookup"><span data-stu-id="825f6-198">The `ICharacterRepository` defines the two methods the controller needs to work with `Character` instances.</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Interfaces/ICharacterRepository.cs?highlight=8,9)]

<span data-ttu-id="825f6-199">Этот интерфейс, в свою очередь, реализуется конкретным типом `CharacterRepository`, используемым во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="825f6-199">This interface is in turn implemented by a concrete type, `CharacterRepository`, that's used at runtime.</span></span>

> [!NOTE]
> <span data-ttu-id="825f6-200">Подход к использованию внедрения зависимостей с классом `CharacterRepository` является общей моделью, которую можно применять для всех служб приложений, а не только в репозиториях или классах доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="825f6-200">The way DI is used with the `CharacterRepository` class is a general model you can follow for all of your application services, not just in "repositories" or data access classes.</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Models/CharacterRepository.cs?highlight=9,11,12,13,14)]

<span data-ttu-id="825f6-201">Обратите внимание, что `CharacterRepository` запрашивает `ApplicationDbContext` в своем конструкторе.</span><span class="sxs-lookup"><span data-stu-id="825f6-201">Note that `CharacterRepository` requests an `ApplicationDbContext` in its constructor.</span></span> <span data-ttu-id="825f6-202">Внедрение зависимостей нередко используется по цепочке, когда каждая запрошенная зависимость запрашивает собственные зависимости.</span><span class="sxs-lookup"><span data-stu-id="825f6-202">It's not unusual for dependency injection to be used in a chained fashion like this, with each requested dependency in turn requesting its own dependencies.</span></span> <span data-ttu-id="825f6-203">Этот контейнер отвечает за разрешение всех зависимостей на графе и возврат полностью разрешенной службы.</span><span class="sxs-lookup"><span data-stu-id="825f6-203">The container is responsible for resolving all of the dependencies in the graph and returning the fully resolved service.</span></span>

> [!NOTE]
> <span data-ttu-id="825f6-204">Создание запрошенного объекта, всех необходимых ему объектов и всех объектов, необходимых этим объектам, иногда называют *графом объектов*.</span><span class="sxs-lookup"><span data-stu-id="825f6-204">Creating the requested object, and all of the objects it requires, and all of the objects those require, is sometimes referred to as an *object graph*.</span></span> <span data-ttu-id="825f6-205">Аналогичным образом, общий набор зависимостей, которые нужно разрешить, обычно называют *деревом зависимостей* или *графом зависимостей*.</span><span class="sxs-lookup"><span data-stu-id="825f6-205">Likewise, the collective set of dependencies that must be resolved is typically referred to as a *dependency tree* or *dependency graph*.</span></span>

<span data-ttu-id="825f6-206">В этом случае как `ICharacterRepository`, так и `ApplicationDbContext` нужно зарегистрировать в контейнере служб в `ConfigureServices` в `Startup`.</span><span class="sxs-lookup"><span data-stu-id="825f6-206">In this case, both `ICharacterRepository` and in turn `ApplicationDbContext` must be registered with the services container in `ConfigureServices` in `Startup`.</span></span> <span data-ttu-id="825f6-207">`ApplicationDbContext` настроен для вызова метода расширения `AddDbContext<T>`.</span><span class="sxs-lookup"><span data-stu-id="825f6-207">`ApplicationDbContext` is configured with the call to the extension method `AddDbContext<T>`.</span></span> <span data-ttu-id="825f6-208">Приведенный ниже пример кода демонстрирует регистрацию типа `CharacterRepository` .</span><span class="sxs-lookup"><span data-stu-id="825f6-208">The following code shows the registration of the `CharacterRepository` type.</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Startup.cs?highlight=3-5,11&range=16-32)]

<span data-ttu-id="825f6-209">Контексты Entity Framework нужно добавлять в контейнер служб с использованием времени существования `Scoped`.</span><span class="sxs-lookup"><span data-stu-id="825f6-209">Entity Framework contexts should be added to the services container using the `Scoped` lifetime.</span></span> <span data-ttu-id="825f6-210">Это выполняется автоматически, если вы используете вспомогательные методы, как показано выше.</span><span class="sxs-lookup"><span data-stu-id="825f6-210">This is taken care of automatically if you use the helper methods as shown above.</span></span> <span data-ttu-id="825f6-211">Репозитории, которые будут работать с Entity Framework, должны использовать то же время существования.</span><span class="sxs-lookup"><span data-stu-id="825f6-211">Repositories that will make use of Entity Framework should use the same lifetime.</span></span>

>[!WARNING]
> <span data-ttu-id="825f6-212">Главной опасностью, о которой следует помнить, является разрешение службы `Scoped` из singleton-класса.</span><span class="sxs-lookup"><span data-stu-id="825f6-212">The main danger to be wary of is resolving a `Scoped` service from a singleton.</span></span> <span data-ttu-id="825f6-213">В этом случае вполне вероятно, что служба будет иметь неверное состояние при обработке последующих запросов.</span><span class="sxs-lookup"><span data-stu-id="825f6-213">It's likely in such a case that the service will have incorrect state when processing subsequent requests.</span></span>

<span data-ttu-id="825f6-214">Службы, имеющие зависимости, должны зарегистрировать их в контейнере.</span><span class="sxs-lookup"><span data-stu-id="825f6-214">Services that have dependencies should register them in the container.</span></span> <span data-ttu-id="825f6-215">Если конструктору службы требуется примитив, например `string`, его можно внедрить с помощью [конфигурации](xref:fundamentals/configuration/index) и [шаблона параметров](xref:fundamentals/configuration/options).</span><span class="sxs-lookup"><span data-stu-id="825f6-215">If a service's constructor requires a primitive, such as a `string`, this can be injected by using [configuration](xref:fundamentals/configuration/index) and the [options pattern](xref:fundamentals/configuration/options).</span></span>

## <a name="service-lifetimes-and-registration-options"></a><span data-ttu-id="825f6-216">Время существования службы и параметры регистрации</span><span class="sxs-lookup"><span data-stu-id="825f6-216">Service lifetimes and registration options</span></span>

<span data-ttu-id="825f6-217">Для служб ASP.NET можно настроить следующие параметры времени существования:</span><span class="sxs-lookup"><span data-stu-id="825f6-217">ASP.NET services can be configured with the following lifetimes:</span></span>

<span data-ttu-id="825f6-218">**Временный**</span><span class="sxs-lookup"><span data-stu-id="825f6-218">**Transient**</span></span>

<span data-ttu-id="825f6-219">Временные службы времени существования создаются при каждом их запросе.</span><span class="sxs-lookup"><span data-stu-id="825f6-219">Transient lifetime services are created each time they're requested.</span></span> <span data-ttu-id="825f6-220">Это время существования лучше всего подходит для простых служб без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="825f6-220">This lifetime works best for lightweight, stateless services.</span></span>

<span data-ttu-id="825f6-221">**Ограниченный областью**</span><span class="sxs-lookup"><span data-stu-id="825f6-221">**Scoped**</span></span>

<span data-ttu-id="825f6-222">Службы времени существования с заданной областью создаются один раз для каждого запроса.</span><span class="sxs-lookup"><span data-stu-id="825f6-222">Scoped lifetime services are created once per request.</span></span>

<span data-ttu-id="825f6-223">**Одноэлементные**</span><span class="sxs-lookup"><span data-stu-id="825f6-223">**Singleton**</span></span>

<span data-ttu-id="825f6-224">Одноэлементные службы времени существования создаются при первом их запросе (или при запуске `ConfigureServices`, если вы указываете экземпляр там), после чего каждый последующий запрос использует тот же самый экземпляр.</span><span class="sxs-lookup"><span data-stu-id="825f6-224">Singleton lifetime services are created the first time they're requested (or when `ConfigureServices` is run if you specify an instance there) and then every subsequent request will use the same instance.</span></span> <span data-ttu-id="825f6-225">Если приложению требуется одноэлементное поведение, рекомендуется разрешить контейнеру служб управлять временем существования службы вместо того, чтобы реализовывать одноэлементный шаблон разработки и самостоятельно управлять временем существования объекта в классе.</span><span class="sxs-lookup"><span data-stu-id="825f6-225">If your application requires singleton behavior, allowing the services container to manage the service's lifetime is recommended instead of implementing the singleton design pattern and managing your object's lifetime in the class yourself.</span></span>

<span data-ttu-id="825f6-226">Службы можно регистрировать в контейнере несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="825f6-226">Services can be registered with the container in several ways.</span></span> <span data-ttu-id="825f6-227">Мы уже рассмотрели, как зарегистрировать реализацию службы заданного типа, указав используемый конкретный тип.</span><span class="sxs-lookup"><span data-stu-id="825f6-227">We have already seen how to register a service implementation with a given type by specifying the concrete type to use.</span></span> <span data-ttu-id="825f6-228">Кроме того, можно задать фабрику, которая затем будет использоваться для создания экземпляра по запросу.</span><span class="sxs-lookup"><span data-stu-id="825f6-228">In addition, a factory can be specified, which will then be used to create the instance on demand.</span></span> <span data-ttu-id="825f6-229">Третий способ заключается в том, чтобы напрямую указать используемый экземпляр типа. В этом случае контейнер никогда не будет пытаться создать экземпляр (и не будет удалять его).</span><span class="sxs-lookup"><span data-stu-id="825f6-229">The third approach is to directly specify the instance of the type to use, in which case the container will never attempt to create an instance (nor will it dispose of the instance).</span></span>

<span data-ttu-id="825f6-230">Чтобы продемонстрировать различия между указанными вариантами времени существования и регистрации, рассмотрим простой интерфейс, представляющий одну или несколько задач в виде *операции* с уникальным идентификатором `OperationId`.</span><span class="sxs-lookup"><span data-stu-id="825f6-230">To demonstrate the difference between these lifetime and registration options, consider a simple interface that represents one or more tasks as an *operation* with a unique identifier, `OperationId`.</span></span> <span data-ttu-id="825f6-231">В зависимости от того, как настроено время существования для этой службы, контейнер предоставляет запрашивающему классу одинаковые или разные экземпляры службы.</span><span class="sxs-lookup"><span data-stu-id="825f6-231">Depending on how we configure the lifetime for this service, the container will provide either the same or different instances of the service to the requesting class.</span></span> <span data-ttu-id="825f6-232">Чтобы уточнить, какое время существования запрашивается, мы создадим по одному типу на каждый вариант времени существования:</span><span class="sxs-lookup"><span data-stu-id="825f6-232">To make it clear which lifetime is being requested, we will create one type per lifetime option:</span></span>

[!code-csharp[Main](../fundamentals/dependency-injection/sample/DependencyInjectionSample/Interfaces/IOperation.cs?highlight=5-8)]

<span data-ttu-id="825f6-233">Мы реализуем эти интерфейсы с помощью одного класса — `Operation`, который принимает `Guid` в своем конструкторе или использует новый `Guid`, если он не указан.</span><span class="sxs-lookup"><span data-stu-id="825f6-233">We implement these interfaces using a single class, `Operation`, that accepts a `Guid` in its constructor, or uses a new `Guid` if none is provided.</span></span>

<span data-ttu-id="825f6-234">Затем в `ConfigureServices` каждый тип добавляется в контейнер согласно его времени существования:</span><span class="sxs-lookup"><span data-stu-id="825f6-234">Next, in `ConfigureServices`, each type is added to the container according to its named lifetime:</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Startup.cs?range=26-32)]

<span data-ttu-id="825f6-235">Обратите внимание, что служба `IOperationSingletonInstance` использует определенный экземпляр с известным идентификатором `Guid.Empty`, что позволяет четко определить, когда этот тип используется (его GUID будет состоять из одних нулей).</span><span class="sxs-lookup"><span data-stu-id="825f6-235">Note that the `IOperationSingletonInstance` service is using a specific instance with a known ID of `Guid.Empty` so it will be clear when this type is in use (its Guid will be all zeroes).</span></span> <span data-ttu-id="825f6-236">Мы также зарегистрировали `OperationService`, зависящий от каждого из других типов `Operation`, чтобы внутри запроса для каждого типа операции было очевидно, получает ли служба тот же или новый экземпляр контроллера.</span><span class="sxs-lookup"><span data-stu-id="825f6-236">We have also registered an `OperationService` that depends on each of the other `Operation` types, so that it will be clear within a request whether this service is getting the same instance as the controller, or a new one, for each operation type.</span></span> <span data-ttu-id="825f6-237">Эта служба лишь предоставляет свои зависимости в виде свойств, чтобы их можно было отобразить в представлении.</span><span class="sxs-lookup"><span data-stu-id="825f6-237">All this service does is expose its dependencies as properties, so they can be displayed in the view.</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Services/OperationService.cs)]

<span data-ttu-id="825f6-238">Чтобы продемонстрировать время существования объектов внутри отдельных запросов, направляемых в приложение, и между ними, пример включает `OperationsController`, который запрашивает каждый из типов `IOperation`, а также `OperationService`.</span><span class="sxs-lookup"><span data-stu-id="825f6-238">To demonstrate the object lifetimes within and between separate individual requests to the application, the sample includes an `OperationsController` that requests each kind of `IOperation` type as well as an `OperationService`.</span></span> <span data-ttu-id="825f6-239">Действие `Index` отображает все значения `OperationId` контроллера и службы.</span><span class="sxs-lookup"><span data-stu-id="825f6-239">The `Index` action then displays all of the controller's and service's `OperationId` values.</span></span>

[!code-csharp[Main](dependency-injection/sample/DependencyInjectionSample/Controllers/OperationsController.cs)]

<span data-ttu-id="825f6-240">Теперь для этого действия контроллера выполняются два отдельных запроса:</span><span class="sxs-lookup"><span data-stu-id="825f6-240">Now two separate requests are made to this controller action:</span></span>

![Представление операций для веб-приложения примера внедрения зависимостей, запущенного в Microsoft Edge, где отображаются значения идентификаторов (GUID) для временных, ограниченных по области, одноэлементных и относящихся к экземпляру операций контроллера и службы операций при первом запросе.](dependency-injection/_static/lifetimes_request1.png)

![Представление операций, показывающее идентификаторы операций для второго запроса.](dependency-injection/_static/lifetimes_request2.png)

<span data-ttu-id="825f6-243">Обратите внимание, какие значения `OperationId` изменяются внутри запроса, а также между запросами.</span><span class="sxs-lookup"><span data-stu-id="825f6-243">Observe which of the `OperationId` values vary within a request, and between requests.</span></span>

* <span data-ttu-id="825f6-244">*Временные* объекты всегда различаются — для каждого контроллера и каждой службы предоставляется новый экземпляр.</span><span class="sxs-lookup"><span data-stu-id="825f6-244">*Transient* objects are always different; a new instance is provided to every controller and every service.</span></span>

* <span data-ttu-id="825f6-245">*Ограниченные по области* объекты одинаковы в рамках запроса, но различаются для разных запросов.</span><span class="sxs-lookup"><span data-stu-id="825f6-245">*Scoped* objects are the same within a request, but different across different requests</span></span>

* <span data-ttu-id="825f6-246">*Одноэлементные* объекты одинаковы для всех объектов и запросов (независимо от того, предоставляется ли экземпляр в `ConfigureServices`).</span><span class="sxs-lookup"><span data-stu-id="825f6-246">*Singleton* objects are the same for every object and every request (regardless of whether an instance is provided in `ConfigureServices`)</span></span>

## <a name="request-services"></a><span data-ttu-id="825f6-247">Службы запросов</span><span class="sxs-lookup"><span data-stu-id="825f6-247">Request Services</span></span>

<span data-ttu-id="825f6-248">Службы, доступные в запросе ASP.NET из `HttpContext`, предоставляются посредством коллекции `RequestServices`.</span><span class="sxs-lookup"><span data-stu-id="825f6-248">The services available within an ASP.NET request from `HttpContext` are exposed through the `RequestServices` collection.</span></span>

![Контекстное диалоговое окно Intellisense для службы запросов HttpContext, сообщающее, что служба запросов возвращает или задает IServiceProvider, предоставляющий доступ к контейнеру службы для запроса.](dependency-injection/_static/request-services.png)

<span data-ttu-id="825f6-250">Службы запросов представляют службы, которые вы настраиваете и запрашиваете в рамках своего приложения.</span><span class="sxs-lookup"><span data-stu-id="825f6-250">Request Services represent the services you configure and request as part of your application.</span></span> <span data-ttu-id="825f6-251">Когда ваши объекты задают зависимости, они удовлетворяются за счет типов из `RequestServices`, а не `ApplicationServices`.</span><span class="sxs-lookup"><span data-stu-id="825f6-251">When your objects specify dependencies, these are satisfied by the types found in `RequestServices`, not `ApplicationServices`.</span></span>

<span data-ttu-id="825f6-252">Как правило, не следует использовать эти свойства напрямую, лучше запросить нужные вашим классам типы через конструктор класса и позволить платформе внедрить эти зависимости.</span><span class="sxs-lookup"><span data-stu-id="825f6-252">Generally, you shouldn't use these properties directly, preferring instead to request the types your classes you require via your class's constructor, and letting the framework inject these dependencies.</span></span> <span data-ttu-id="825f6-253">Полученные таким образом классы более удобны для тестирования (см. раздел [Тестирование](../testing/index.md)) и слабее связаны.</span><span class="sxs-lookup"><span data-stu-id="825f6-253">This yields classes that are easier to test (see [Testing](../testing/index.md)) and are more loosely coupled.</span></span>

> [!NOTE]
> <span data-ttu-id="825f6-254">Предпочтительнее запрашивать зависимости в качестве параметров конструктора, а не обращаться к коллекции `RequestServices`.</span><span class="sxs-lookup"><span data-stu-id="825f6-254">Prefer requesting dependencies as constructor parameters to accessing the `RequestServices` collection.</span></span>

## <a name="designing-services-for-dependency-injection"></a><span data-ttu-id="825f6-255">Разработка служб для внедрения зависимостей</span><span class="sxs-lookup"><span data-stu-id="825f6-255">Designing services for dependency injection</span></span>

<span data-ttu-id="825f6-256">Службы следует разрабатывать таким образом, чтобы они использовали внедрение зависимостей для получения своих участников совместной работы.</span><span class="sxs-lookup"><span data-stu-id="825f6-256">You should design your services to use dependency injection to get their collaborators.</span></span> <span data-ttu-id="825f6-257">Это означает отказ от использования вызовов статических методов с отслеживанием состояния (что приводит к проблемам с кодом, называемым [статическим слипанием](http://deviq.com/static-cling/)) и прямого создания экземпляров зависимых классов внутри служб.</span><span class="sxs-lookup"><span data-stu-id="825f6-257">This means avoiding the use of stateful static method calls (which result in a code smell known as [static cling](http://deviq.com/static-cling/)) and the direct instantiation of dependent classes within your services.</span></span> <span data-ttu-id="825f6-258">Принимая решение о том, следует ли создать экземпляр типа или запросить его через внедрение зависимостей, рекомендуется руководствоваться принципами, изложенными в статье о [связующем слове new](https://ardalis.com/new-is-glue).</span><span class="sxs-lookup"><span data-stu-id="825f6-258">It may help to remember the phrase, [New is Glue](https://ardalis.com/new-is-glue), when choosing whether to instantiate a type or to request it via dependency injection.</span></span> <span data-ttu-id="825f6-259">Соблюдение [принципов SOLID для объектно-ориентированного программирования](http://deviq.com/solid/) поможет сделать ваши классы небольшими, хорошо организованными и удобными в тестировании.</span><span class="sxs-lookup"><span data-stu-id="825f6-259">By following the [SOLID Principles of Object Oriented Design](http://deviq.com/solid/), your classes will naturally tend to be small, well-factored, and easily tested.</span></span>

<span data-ttu-id="825f6-260">Что делать, если классы склонны использовать слишком много внедряемых зависимостей?</span><span class="sxs-lookup"><span data-stu-id="825f6-260">What if you find that your classes tend to have way too many dependencies being injected?</span></span> <span data-ttu-id="825f6-261">Обычно это указывает на то, что класс пытается сделать слишком многое и, вероятно, нарушает [принцип единственной обязанности](http://deviq.com/single-responsibility-principle/).</span><span class="sxs-lookup"><span data-stu-id="825f6-261">This is generally a sign that your class is trying to do too much, and is probably violating SRP - the [Single Responsibility Principle](http://deviq.com/single-responsibility-principle/).</span></span> <span data-ttu-id="825f6-262">Определите, можно ли выполнить рефакторинг класса, переместив некоторые из его обязанностей в новый класс.</span><span class="sxs-lookup"><span data-stu-id="825f6-262">See if you can refactor the class by moving some of its responsibilities into a new class.</span></span> <span data-ttu-id="825f6-263">Помните, что ваши классы `Controller` должны быть посвящены аспектам пользовательского интерфейса, а за реализацию бизнес-правил и доступа к данным должны отвечать [отдельные](http://deviq.com/separation-of-concerns/) классы.</span><span class="sxs-lookup"><span data-stu-id="825f6-263">Keep in mind that your `Controller` classes should be focused on UI concerns, so business rules and data access implementation details should be kept in classes appropriate to these [separate concerns](http://deviq.com/separation-of-concerns/).</span></span>

<span data-ttu-id="825f6-264">Например, для доступа к данным можно внедрить `DbContext` в свои контроллеры (при условии, что вы добавили Entity Framework в контейнер служб в `ConfigureServices`).</span><span class="sxs-lookup"><span data-stu-id="825f6-264">With regards to data access specifically, you can inject the `DbContext` into your controllers (assuming you've added EF to the services container in `ConfigureServices`).</span></span> <span data-ttu-id="825f6-265">Некоторые разработчики предпочитают использовать интерфейс репозитория для базы данных, вместо того, чтобы внедрять `DbContext` напрямую.</span><span class="sxs-lookup"><span data-stu-id="825f6-265">Some developers prefer to use a repository interface to the database rather than injecting the `DbContext` directly.</span></span> <span data-ttu-id="825f6-266">Использование интерфейса для инкапсуляции логики доступа к данным в одном месте позволяет минимизировать число изменений, необходимых при изменении базы данных.</span><span class="sxs-lookup"><span data-stu-id="825f6-266">Using an interface to encapsulate the data access logic in one place can minimize how many places you will have to change when your database changes.</span></span>

### <a name="disposing-of-services"></a><span data-ttu-id="825f6-267">Удаление служб</span><span class="sxs-lookup"><span data-stu-id="825f6-267">Disposing of services</span></span>

<span data-ttu-id="825f6-268">Контейнер будет вызывать `Dispose` для создаваемых им типов `IDisposable`.</span><span class="sxs-lookup"><span data-stu-id="825f6-268">The container will call `Dispose` for `IDisposable` types it creates.</span></span> <span data-ttu-id="825f6-269">Но если вы самостоятельно добавите экземпляр в контейнер, он не будет удален.</span><span class="sxs-lookup"><span data-stu-id="825f6-269">However, if you add an instance to the container yourself, it will not be disposed.</span></span>

<span data-ttu-id="825f6-270">Пример</span><span class="sxs-lookup"><span data-stu-id="825f6-270">Example:</span></span>

```csharp
// Services implement IDisposable:
public class Service1 : IDisposable {}
public class Service2 : IDisposable {}
public class Service3 : IDisposable {}

public interface ISomeService {}
public class SomeServiceImplementation : ISomeService, IDisposable {}


public void ConfigureServices(IServiceCollection services)
{
    // container will create the instance(s) of these types and will dispose them
    services.AddScoped<Service1>();
    services.AddSingleton<Service2>();
    services.AddSingleton<ISomeService>(sp => new SomeServiceImplementation());

    // container didn't create instance so it will NOT dispose it
    services.AddSingleton<Service3>(new Service3());
    services.AddSingleton(new Service3());
}
```

> [!NOTE]
> <span data-ttu-id="825f6-271">В версии 1.0 контейнер вызывал удаление для *всех* объектов `IDisposable`, включая те, которые он не создавал.</span><span class="sxs-lookup"><span data-stu-id="825f6-271">In version 1.0, the container called dispose on *all* `IDisposable` objects, including those it didn't create.</span></span>

## <a name="replacing-the-default-services-container"></a><span data-ttu-id="825f6-272">Замена контейнера служб по умолчанию</span><span class="sxs-lookup"><span data-stu-id="825f6-272">Replacing the default services container</span></span>

<span data-ttu-id="825f6-273">Встроенный контейнер служб предназначен для удовлетворения базовых потребностей платформы и большинства основанных на ней клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="825f6-273">The built-in services container is meant to serve the basic needs of the framework and most consumer applications built on it.</span></span> <span data-ttu-id="825f6-274">Однако разработчики могут заменить его на предпочитаемый ими контейнер.</span><span class="sxs-lookup"><span data-stu-id="825f6-274">However, developers can replace the built-in container with their preferred container.</span></span> <span data-ttu-id="825f6-275">Метод `ConfigureServices` обычно возвращает `void`, но если его сигнатура изменена для возврата `IServiceProvider`, можно настроить и возвращать другой контейнер.</span><span class="sxs-lookup"><span data-stu-id="825f6-275">The `ConfigureServices` method typically returns `void`, but if its signature is changed to return `IServiceProvider`, a different container can be configured and returned.</span></span> <span data-ttu-id="825f6-276">Для платформы .NET доступно множество контейнеров инверсии управления.</span><span class="sxs-lookup"><span data-stu-id="825f6-276">There are many IOC containers available for .NET.</span></span> <span data-ttu-id="825f6-277">В этом примере используется пакет [Autofac](https://autofac.org/).</span><span class="sxs-lookup"><span data-stu-id="825f6-277">In this example, the [Autofac](https://autofac.org/) package is used.</span></span>

<span data-ttu-id="825f6-278">Сначала установите пакеты соответствующего контейнера:</span><span class="sxs-lookup"><span data-stu-id="825f6-278">First, install the appropriate container package(s):</span></span>

* `Autofac`
* `Autofac.Extensions.DependencyInjection`

<span data-ttu-id="825f6-279">Затем настройте контейнер в `ConfigureServices` и возвратите `IServiceProvider`:</span><span class="sxs-lookup"><span data-stu-id="825f6-279">Next, configure the container in `ConfigureServices` and return an `IServiceProvider`:</span></span>

```csharp
public IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    // Add other framework services

    // Add Autofac
    var containerBuilder = new ContainerBuilder();
    containerBuilder.RegisterModule<DefaultModule>();
    containerBuilder.Populate(services);
    var container = containerBuilder.Build();
    return new AutofacServiceProvider(container);
}
```

> [!NOTE]
> <span data-ttu-id="825f6-280">При использовании стороннего контейнера внедрения зависимостей нужно изменить `ConfigureServices`, чтобы он возвращал `IServiceProvider` вместо `void`.</span><span class="sxs-lookup"><span data-stu-id="825f6-280">When using a third-party DI container, you must change `ConfigureServices` so that it returns `IServiceProvider` instead of `void`.</span></span>

<span data-ttu-id="825f6-281">Наконец, настройте Autofac в `DefaultModule` обычным образом:</span><span class="sxs-lookup"><span data-stu-id="825f6-281">Finally, configure Autofac as normal in `DefaultModule`:</span></span>

```csharp
public class DefaultModule : Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterType<CharacterRepository>().As<ICharacterRepository>();
    }
}
```

<span data-ttu-id="825f6-282">Во время выполнения Autofac будет использоваться для разрешения типов и внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="825f6-282">At runtime, Autofac will be used to resolve types and inject dependencies.</span></span> <span data-ttu-id="825f6-283">[Дополнительные сведения об использовании Autofac и ASP.NET Core](http://docs.autofac.org/en/latest/integration/aspnetcore.html).</span><span class="sxs-lookup"><span data-stu-id="825f6-283">[Learn more about using Autofac and ASP.NET Core](http://docs.autofac.org/en/latest/integration/aspnetcore.html).</span></span>

### <a name="thread-safety"></a><span data-ttu-id="825f6-284">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="825f6-284">Thread safety</span></span>

<span data-ttu-id="825f6-285">Одноэлементные службы должны быть потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="825f6-285">Singleton services need to be thread safe.</span></span> <span data-ttu-id="825f6-286">Если одноэлементная служба имеет зависимость от временной службы, с учетом характера использования одноэлементной службой к этой временной службе также может предъявляться требование потокобезопасности.</span><span class="sxs-lookup"><span data-stu-id="825f6-286">If a singleton service has a dependency on a transient service, the transient service may also need to be thread safe depending how it's used by the singleton.</span></span>

## <a name="recommendations"></a><span data-ttu-id="825f6-287">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="825f6-287">Recommendations</span></span>

<span data-ttu-id="825f6-288">При работе с внедрением зависимостей соблюдайте следующие рекомендации:</span><span class="sxs-lookup"><span data-stu-id="825f6-288">When working with dependency injection, keep the following recommendations in mind:</span></span>

* <span data-ttu-id="825f6-289">Внедрение зависимостей предназначено для объектов, имеющих сложные зависимости.</span><span class="sxs-lookup"><span data-stu-id="825f6-289">DI is for objects that have complex dependencies.</span></span> <span data-ttu-id="825f6-290">Контроллеры, службы, адаптеры и репозитории являются примерами объектов, которые можно добавить в функцию внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="825f6-290">Controllers, services, adapters, and repositories are all examples of objects that might be added to DI.</span></span>

* <span data-ttu-id="825f6-291">Не храните данные и конфигурации непосредственно в функции внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="825f6-291">Avoid storing data and configuration directly in DI.</span></span> <span data-ttu-id="825f6-292">Например, в общем случае не следует добавлять корзину пользователя в контейнер служб.</span><span class="sxs-lookup"><span data-stu-id="825f6-292">For example, a user's shopping cart shouldn't typically be added to the services container.</span></span> <span data-ttu-id="825f6-293">Конфигурация должна использовать [шаблон параметров](xref:fundamentals/configuration/options).</span><span class="sxs-lookup"><span data-stu-id="825f6-293">Configuration should use the [options pattern](xref:fundamentals/configuration/options).</span></span> <span data-ttu-id="825f6-294">Аналогичным образом, избегайте объектов "хранения данных", которые служат лишь для доступа к некоторому другому объекту.</span><span class="sxs-lookup"><span data-stu-id="825f6-294">Similarly, avoid "data holder" objects that only exist to allow access to some other object.</span></span> <span data-ttu-id="825f6-295">По возможности лучше запросить фактический необходимый элемент через внедрение зависимостей.</span><span class="sxs-lookup"><span data-stu-id="825f6-295">It's better to request the actual item needed via DI, if possible.</span></span>

* <span data-ttu-id="825f6-296">Избегайте статического доступа к службам.</span><span class="sxs-lookup"><span data-stu-id="825f6-296">Avoid static access to services.</span></span>

* <span data-ttu-id="825f6-297">Избегайте обнаружения службы в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="825f6-297">Avoid service location in your application code.</span></span>

* <span data-ttu-id="825f6-298">Избегайте статического доступа к `HttpContext`.</span><span class="sxs-lookup"><span data-stu-id="825f6-298">Avoid static access to `HttpContext`.</span></span>

> [!NOTE]
> <span data-ttu-id="825f6-299">Как в случае с любыми наборами рекомендаций, могут возникнуть ситуации, когда нужно отступить от одного из правил.</span><span class="sxs-lookup"><span data-stu-id="825f6-299">Like all sets of recommendations, you may encounter situations where ignoring one is required.</span></span> <span data-ttu-id="825f6-300">Мы пришли к выводу, что подобные исключения довольно редки и нужны в особых случаях, главным образом внутри самой платформы.</span><span class="sxs-lookup"><span data-stu-id="825f6-300">We have found exceptions to be rare -- mostly very special cases within the framework itself.</span></span>

<span data-ttu-id="825f6-301">Помните, что внедрение зависимостей является *альтернативой* для шаблонов доступа к статическим или глобальным объектам.</span><span class="sxs-lookup"><span data-stu-id="825f6-301">Remember, dependency injection is an *alternative* to static/global object access patterns.</span></span> <span data-ttu-id="825f6-302">Вы не сможете воспользоваться преимуществами внедрения зависимостей, если будете сочетать его с доступом к статическим объектам.</span><span class="sxs-lookup"><span data-stu-id="825f6-302">You won't be able to realize the benefits of DI if you mix it with static object access.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="825f6-303">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="825f6-303">Additional resources</span></span>

* [<span data-ttu-id="825f6-304">Запуск приложения</span><span class="sxs-lookup"><span data-stu-id="825f6-304">Application Startup</span></span>](xref:fundamentals/startup)
* [<span data-ttu-id="825f6-305">Тестирование</span><span class="sxs-lookup"><span data-stu-id="825f6-305">Testing</span></span>](xref:testing/index)
* [<span data-ttu-id="825f6-306">Активация фабричного ПО промежуточного слоя</span><span class="sxs-lookup"><span data-stu-id="825f6-306">Factory-based middleware activation</span></span>](xref:fundamentals/middleware/extensibility)
* [<span data-ttu-id="825f6-307">Написание чистого кода в ASP.NET Core с внедрением зависимостей (MSDN)</span><span class="sxs-lookup"><span data-stu-id="825f6-307">Writing Clean Code in ASP.NET Core with Dependency Injection (MSDN)</span></span>](https://msdn.microsoft.com/magazine/mt703433.aspx)
* [<span data-ttu-id="825f6-308">Проектирование приложения на основе контейнеров. Вступление. К чему относится контейнер?</span><span class="sxs-lookup"><span data-stu-id="825f6-308">Container-Managed Application Design, Prelude: Where does the Container Belong?</span></span>](https://blogs.msdn.microsoft.com/nblumhardt/2008/12/26/container-managed-application-design-prelude-where-does-the-container-belong/)
* [<span data-ttu-id="825f6-309">Принцип явных зависимостей</span><span class="sxs-lookup"><span data-stu-id="825f6-309">Explicit Dependencies Principle</span></span>](http://deviq.com/explicit-dependencies-principle/)
* <span data-ttu-id="825f6-310">[Контейнеры инверсии управления и шаблон внедрения зависимостей](https://www.martinfowler.com/articles/injection.html) (Фаулер)</span><span class="sxs-lookup"><span data-stu-id="825f6-310">[Inversion of Control Containers and the Dependency Injection Pattern](https://www.martinfowler.com/articles/injection.html) (Fowler)</span></span>
