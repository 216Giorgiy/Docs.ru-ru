---
title: Поставщики файлов в ASP.NET Core
author: ardalis
description: Сведения о том, как ASP.NET Core абстрагирует доступ к файловой системе с помощью поставщиков файлов.
manager: wpickett
ms.author: riande
ms.date: 02/14/2017
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: fundamentals/file-providers
ms.openlocfilehash: cdbffdadd9616fe941809d67dc2c0bbd52149561
ms.sourcegitcommit: 7ac15eaae20b6d70e65f3650af050a7880115cbf
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/02/2018
ms.locfileid: "29724575"
---
# <a name="file-providers-in-aspnet-core"></a>Поставщики файлов в ASP.NET Core

Автор: [Стив Смит](https://ardalis.com/) (Steve Smith)

ASP.NET Core абстрагирует доступ к файловой системе с помощью поставщиков файлов.

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/file-providers/sample) ([как скачивать](xref:tutorials/index#how-to-download-a-sample))

## <a name="file-provider-abstractions"></a>Абстракции поставщиков файлов

Поставщики файлов представляют собой абстракцию над файловыми системами. Главным интерфейсом является `IFileProvider`. `IFileProvider` предоставляет методы для получения сведений о файле (`IFileInfo`), о каталоге (`IDirectoryContents`) и для настройки уведомлений об изменениях (с помощью `IChangeToken`).

`IFileInfo` предоставляет методы и свойства для отдельных файлов или каталогов. Он имеет два логических свойства `Exists` и `IsDirectory`, а также свойства, описывающие `Name`, `Length` (в байтах) и дату `LastModified` файла. Считывать данные из файла можно с помощью метода `CreateReadStream`.

## <a name="file-provider-implementations"></a>Реализации поставщиков файлов

Доступны три реализации `IFileProvider`: физическая, внедренная и составная. Физический поставщик используется для доступа к фактическим файлам системы. Внедренный поставщик используется для доступа к файлам, внедренным в сборки. Составной поставщик используется для предоставления комбинированного доступа к файлам и каталогам из одного или нескольких поставщиков.

### <a name="physicalfileprovider"></a>PhysicalFileProvider

`PhysicalFileProvider` предоставляет доступ к физической файловой системе. Он создает оболочку для типа `System.IO.File` (для физического поставщика), определяя областью всех путей каталог и его дочерние элементы. Эта область ограничивает доступ к определенному каталогу и его дочерним элементам, предотвращая доступ к файловой системе за своей границей. При создании экземпляра этого поставщика нужно указать путь к каталогу, который выступает в качестве базового пути для всех запросов, выполняемых для этого поставщика (а также ограничивает доступ за своими пределами). В приложении ASP.NET Core можно создать экземпляр поставщика `PhysicalFileProvider` напрямую или запросить `IFileProvider` в контроллере или конструкторе службы через [внедрение зависимостей](dependency-injection.md). Второй подход обычно дает более гибкое и пригодное для тестирования решение.

Приведенный ниже пример показывает, как создать `PhysicalFileProvider`.


```csharp
IFileProvider provider = new PhysicalFileProvider(applicationRoot);
IDirectoryContents contents = provider.GetDirectoryContents(""); // the applicationRoot contents
IFileInfo fileInfo = provider.GetFileInfo("wwwroot/js/site.js"); // a file under applicationRoot
```

Вы можете выполнять итерации по содержимому каталога или получить сведения о конкретном файле, предоставив вложенный путь.

Чтобы запросить поставщик из контроллера, укажите его в конструкторе контроллера и назначьте его локальному полю. Используйте локальный экземпляр из своих методов действий:

[!code-csharp[](file-providers/sample/src/FileProviderSample/Controllers/HomeController.cs?highlight=5,7,12&range=6-19)]

После этого создайте поставщик в классе `Startup` приложения:

[!code-csharp[](file-providers/sample/src/FileProviderSample/Startup.cs?highlight=35,40&range=1-43)]

В представлении *Index.cshtml* выполните итерации по предоставленному `IDirectoryContents`:

[!code-html[](file-providers/sample/src/FileProviderSample/Views/Home/Index.cshtml?highlight=2,7,9,11,15)]

Результат:

![Пример приложения поставщика файлов, перечисляющий физические файлы и папки](file-providers/_static/physical-directory-listing.png)

### <a name="embeddedfileprovider"></a>EmbeddedFileProvider

`EmbeddedFileProvider` используется для доступа к файлам, внедренным в сборки. В .NET Core для внедрения файлов в сборку используется элемент `<EmbeddedResource>` в файле *CSPROJ*:

[!code-json[](file-providers/sample/src/FileProviderSample/FileProviderSample.csproj?range=13-18)]

Вы можете использовать [стандартные маски](#globbing-patterns) при указании файлов для внедрения в сборку. Эти шаблоны можно использовать для сопоставления одного или нескольких файлов.

> [!NOTE]
> Маловероятно, что вам когда-либо потребуется фактически внедрять каждый JS-файл в проект в сборке; приведенный выше пример служит лишь для демонстрации.

При создании `EmbeddedFileProvider` передайте сборку, которую он считает своему конструктору.

```csharp
var embeddedProvider = new EmbeddedFileProvider(Assembly.GetEntryAssembly());
```

Приведенный выше фрагмент показывает создание `EmbeddedFileProvider` с доступом к выполняющейся сборке.

Изменение примера приложения для использования `EmbeddedFileProvider` приводит к следующему результату:

![Пример приложения поставщика файлов, перечисляющий внедренные файлы](file-providers/_static/embedded-directory-listing.png)

> [!NOTE]
> Внедренные ресурсы не предоставляют каталоги. Вместо этого путь к ресурсу (через пространство имен) внедряется в имя файла с помощью разделителей `.`.

> [!TIP]
> Конструктор `EmbeddedFileProvider` принимает необязательный параметр `baseNamespace`. Если задать его, область вызовов `GetDirectoryContents` будет ограничена ресурсами в указанном пространстве имен.

### <a name="compositefileprovider"></a>CompositeFileProvider

`CompositeFileProvider` объединяет экземпляры `IFileProvider`, предоставляя единый интерфейс для работы с файлами от нескольких поставщиков. При создании `CompositeFileProvider` вы передаете один или несколько экземпляров `IFileProvider` в его конструктор:

[!code-csharp[](file-providers/sample/src/FileProviderSample/Startup.cs?highlight=3&range=35-37)]

Изменение примера приложения для использования `CompositeFileProvider`, который включает в себя настроенные ранее физический и внедренный поставщики, дает следующий результат:

![Пример приложения поставщика файлов, перечисляющий как физические файлы и папки, так и внедренные файлы](file-providers/_static/composite-directory-listing.png)

## <a name="watching-for-changes"></a>Просмотр изменений

Метод `IFileProvider` `Watch` позволяет просматривать один или несколько файлов или каталогов на предмет изменений. Этот метод принимает строку пути, которая может использовать [стандартные маски](#globbing-patterns) для указания нескольких файлов и возвращает `IChangeToken`. Этот токен предоставляет свойство `HasChanged`, которое можно проверить, и метод `RegisterChangeCallback`, вызываемый при обнаружении изменений для указанной строки пути. Обратите внимание, что каждый токен изменения выполняет соответствующий обратный вызов только в ответ на отдельное изменение. Чтобы реализовать постоянное наблюдение, можно использовать `TaskCompletionSource`, как показано ниже, или повторно создавать экземпляры `IChangeToken` в ответ на изменения.

В рассматриваемом здесь примере консольное приложение настраивается для отображения сообщения при изменении текстового файла:

[!code-csharp[](file-providers/sample/src/WatchConsole/Program.cs?name=snippet1&highlight=1-2,16,19-20)]

Результат после нескольких сохранений файла:

![После запуска dotnet командное окно показывает мониторинг приложения на предмет изменений в файле quotes.txt и то, что этот файл был изменен пять раз.](file-providers/_static/watch-console.png)

> [!NOTE]
> Некоторые файловые системы, такие как контейнеры Docker и сетевые папки, не могут надежно отправлять уведомления об изменениях. Задайте для переменной среды `DOTNET_USE_POLLINGFILEWATCHER` значение `1` или `true`, чтобы опрашивать файловую систему на предмет изменений каждые 4 секунды.

## <a name="globbing-patterns"></a>Стандартные маски

Пути файловой системы используют шаблоны подстановочных знаков, которые называются *стандартными масками*. Эти простые шаблоны можно использовать для указания групп файлов. Поддерживаются два подстановочных знака — `*` и `**`.

**`*`**

   Совпадает со всем содержимым на текущем уровне папок, любым именем или расширением файла. Совпадения завершаются символами `/` и `.` в пути файла.

<strong><code>**</code></strong>

   Совпадает со всем содержимым на разных уровнях каталогов. Может использоваться для рекурсивного сопоставления множества файлов в иерархии каталогов.

### <a name="globbing-pattern-examples"></a>Примеры стандартных масок

**`directory/file.txt`**

   Соответствует конкретному файлу в заданном каталоге.

**<code>directory/*.txt</code>**

   Соответствует всем файлам с расширением `.txt` в заданном каталоге.

**`directory/*/bower.json`**

   Соответствует всем файлам `bower.json` в каталоге ровно на один уровень ниже каталога `directory`.

**<code>directory/&#42;&#42;/&#42;.txt</code>**

   Соответствует всем файлам с расширением `.txt`, находящимся ниже каталога `directory`.

## <a name="file-provider-usage-in-aspnet-core"></a>Использование поставщиков файлов в ASP.NET Core

Несколько частей ASP.NET Core используют поставщики файлов. `IHostingEnvironment` предоставляет корень содержимого приложения и корневой каталог веб-сайта в виде типов `IFileProvider`. ПО промежуточного слоя для статических файлов использует поставщики файлов для поиска статических файлов. Razor усложняет использование `IFileProvider` при поиске представлений. Функции публикации DotNet используют поставщики файлов и стандартные маски, чтобы указать, какие файлы нужно публиковать.

## <a name="recommendations-for-use-in-apps"></a>Рекомендации по использованию в приложениях

Если приложению ASP.NET Core требуется доступ к файловой системе, вы можете запросить экземпляр `IFileProvider` через внедрение зависимостей, а затем воспользоваться его методами для реализации доступа, как показано в этом примере. Это позволяет настроить поставщик один раз при запуске приложения и сокращает число типов реализации, для которых приложение создает экземпляры.
