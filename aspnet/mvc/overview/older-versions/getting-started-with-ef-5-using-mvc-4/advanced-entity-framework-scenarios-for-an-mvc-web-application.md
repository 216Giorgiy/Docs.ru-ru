---
uid: mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/advanced-entity-framework-scenarios-for-an-mvc-web-application
title: "Сложные сценарии, Entity Framework для веб-приложения MVC (10, 10) | Документы Microsoft"
author: tdykstra
description: "Contoso университета примера веб-приложения демонстрирует создание приложения ASP.NET MVC 4, с помощью Entity Framework 5 Code First и Visual Studio..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/30/2013
ms.topic: article
ms.assetid: 64906a1d-f734-41cf-9615-ee95f8740996
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/advanced-entity-framework-scenarios-for-an-mvc-web-application
msc.type: authoredcontent
ms.openlocfilehash: d58a745896b29317c1d1049e3bf1a5ec2e628820
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="advanced-entity-framework-scenarios-for-an-mvc-web-application-10-of-10"></a>Сценарии Framework дополнительные сущности для веб-приложения MVC (10, 10)
====================
По [Tom Dykstra](https://github.com/tdykstra)

[Загрузка завершенного проекта](http://code.msdn.microsoft.com/Getting-Started-with-dd0e2ed8)

> Contoso университета примера веб-приложения демонстрирует создание приложения ASP.NET MVC 4, с помощью Entity Framework 5 Code First и Visual Studio 2012. Сведения о учебника серии см [в первом учебнике ряда](creating-an-entity-framework-data-model-for-an-asp-net-mvc-application.md). Учебник рядов можно запустить с самого начала или [загрузить начальный проект для этой главы](building-the-ef5-mvc4-chapter-downloads.md) и начните здесь.
> 
> > [!NOTE] 
> > 
> > Если возникли проблемы, не удается устранить, [загрузить завершенного главе](building-the-ef5-mvc4-chapter-downloads.md) и попробуйте воспроизвести проблему. Обычно можно найти решение проблемы путем сравнения код для завершения кода. Некоторые распространенные ошибки и способы их устранения см. в разделе [ошибок и способы их устранения.](advanced-entity-framework-scenarios-for-an-mvc-web-application.md#errors)


В предыдущем учебнике реализован репозитория и единицы шаблонов рабочих элементов. Этот учебник содержит следующие разделы:

- Выполняет необработанные запросы SQL.
- Выполняет запросы отслеживания нет.
- Анализ запросов отправляются в базу данных.
- Работа с прокси-классы.
- Отключение автоматического обнаружения изменений.
- Отключение проверки при сохранении изменения.
- [Ошибки и способы](#errors)

Большинство этих разделов вы будете работать со страницами, которые уже созданы. Для использования необработанных SQL для проведения массовых обновлений вы создадите новую страницу, обновляет номер кредиты всех курсов в базе данных:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image1.png)

И использование запроса нет отслеживания вы добавите новая логика проверки страница отдела изменить:

![Department_Edit_page_with_duplicate_administrator_error_message](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image2.png)

## <a name="performing-raw-sql-queries"></a>Выполнение запросов Raw SQL

API первый Entity Framework кода включает методы, которые позволяют передавать команды SQL непосредственно к базе данных. Можно выбрать один из следующих параметров.

- Используйте `DbSet.SqlQuery` метод для запросов, возвращающих типы сущностей. Возвращаемые объекты должно относится к типу, ожидаемому `DbSet` объекта и они, автоматически отслеживаются контекстом контекст базы данных, если не отключить отслеживание. (См. в разделе `AsNoTracking` метод.)
- Используйте `Database.SqlQuery` метод для запросов, возвращающих типы, которые не являются сущностями. Возвращаемые данные не отслеживается контекст базы данных, даже при использовании этого метода на получение типов сущностей.
- Используйте [Database.ExecuteSqlCommand](https://msdn.microsoft.com/en-us/library/gg679456(v=vs.103).aspx) для команды без запроса.

Одним из преимуществ использования платформы Entity Framework является позволяет избежать прерывания кода слишком близко к конкретного метода хранения данных. Это делается путем создания SQL-запросов и команд, который избавляет от необходимости записывать их. Но существует исключительных сценариев, при необходимости выполнения конкретных запросов SQL, созданных вручную, и эти методы позволяют обрабатывать такие исключения.

Как всегда имеет значение true при выполнении команды SQL для веб-приложения, необходимо принять меры предосторожности, чтобы защитить сайт от атак путем внедрения кода SQL. Один из способов сделать это является использование параметризованных запросов, чтобы убедиться в том, что строки, отправленных веб-страницы не может интерпретироваться как команды SQL. В этом учебнике будет использоваться параметризованные запросы при интеграции ввод данных пользователем в запросе.

### <a name="calling-a-query-that-returns-entities"></a>Вызов запроса, которая возвращает сущности

Предположим, что нужно `GenericRepository` класса для предоставления дополнительной фильтрации и сортировки гибкость без необходимости создания производного класса с помощью дополнительных методов. Один из способов достижения это, можно добавить в метод, принимающий SQL-запроса. Вы можете указать любого типа, фильтрации и сортировки, вам необходимо на контроллере, например `Where` , зависящий от соединения или вложенном запросе предложения. В этом разделе вы увидите, как реализовать этот метод.

Создание `GetWithRawSql` метода, добавив следующий код в *GenericRepository.cs*:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample1.cs)]

В *CourseController.cs*, вызовите новый метод из `Details` метода, как показано в следующем примере:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample2.cs)]

В этом случае можно было бы использовать `GetByID` метода, но вы используете `GetWithRawSql` метод, чтобы убедиться, что `GetWithRawSQL` работает метод.

Запустите странице сведений, чтобы убедиться, что работа запросов select (выберите **курса** вкладку и затем **сведения** один курс).

![Course_Details_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image3.png)

### <a name="calling-a-query-that-returns-other-types-of-objects"></a>Вызов запроса, которая возвращает другие типы объектов

Ранее вы создали сетку статистики студента страницу о программе показано число учеников для каждой даты регистрации. Код, который делает это в *HomeController.cs* использует LINQ:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample3.cs)]

Предположим, что необходимо написать код, который получает эти данные непосредственно в SQL, а не с помощью LINQ. Чтобы сделать, необходимо запустить запрос, который возвращает нечто, отличное от объектов сущностей, означающее, что необходимо использовать `Database.SqlQuery` метода.

В *HomeController.cs*, замените оператор LINQ в `About` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample4.cs)]

Запустите страницу About. Он отображает те же данные, которые раньше.

![About_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image4.png)

### <a name="calling-an-update-query"></a>Вызов запроса Update

Предположим, что администраторы университета Contoso требуется возможность выполнения массовых изменений в базе данных, например изменение количества кредиты для каждого курса. Если университета имеет большое количество курсов, было бы неэффективно, извлекать их все как сущности и измените их по отдельности. В этом разделе будет реализован веб-страницы, которая позволяет пользователю указать коэффициент, используемый для изменения номера кредиты для всех курсов и вносятся изменения, выполнив SQL `UPDATE` инструкции. Веб-страница будет выглядеть как на следующем рисунке:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image5.png)

В предыдущем учебнике используется универсальный репозитория для чтения и обновления `Course` сущностей в `Course` контроллера. Для этой операции массового обновления необходимо создать новый репозиторий метод, который не находится в хранилище универсальный. Чтобы сделать это, вы создадите выделенную `CourseRepository` класс, производный от `GenericRepository` класса.

В *DAL* папке создайте *CourseRepository.cs* и замените существующий код следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample5.cs)]

В *UnitOfWork.cs*, изменить `Course` тип репозитория из `GenericRepository<Course>` для`CourseRepository:`

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample6.cs)]

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample7.cs)]

В *CourseContoller.cs*, добавьте `UpdateCourseCredits` метод:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample8.cs)]

Этот метод будет использоваться для обоих `HttpGet` и `HttpPost`. Когда `HttpGet` `UpdateCourseCredits` выполняется метод `multiplier` переменной будет иметь значение null и представления отображаются пустые текстовые поля и кнопки "Отправить", как показано на предыдущем рисунке.

При **обновление** кнопки и `HttpPost` выполняется метод `multiplier` будет иметь значение, введенное в текстовом поле. Затем код вызывает репозитории `UpdateCourseCredits` метод, который возвращает число обработанных строк, и это значение хранится в `ViewBag` объекта. Если представление получает количество задействованных строк в `ViewBag` объекта, он отображает этот номер вместо текстового поля и отправить кнопки, как показано на следующем рисунке:

![Update_Course_Credits_rows_affected_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image6.png)

Создание представления в *Views\Course* папку отзывы о курсе обновления страницы:

![Add_View_dialog_box_for_Update_Course_Credits](https://asp.net/media/2578203/Windows-Live-Writer_Advanced-Entity-Framework-Scenarios-for-_CEF8_Add_View_dialog_box_for_Update_Course_Credits.png)

В *Views\Course\UpdateCourseCredits.cshtml*, замените код шаблона в следующий код:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample9.cshtml)]

Запустите `UpdateCourseCredits` метод, выбрав **курсы** вкладку, затем добавляется «/ UpdateCourseCredits» в конец URL-адрес в адресной строке браузера (например: `http://localhost:50205/Course/UpdateCourseCredits`). Введите число в текстовом поле:

![Update_Course_Credits_initial_page_with_2_entered](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image7.png)

Нажмите кнопку **Обновить**. Количество строк, затронутых просмотреть:

![Update_Course_Credits_rows_affected_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image8.png)

Нажмите кнопку **списка** для просмотра списка курсов с измененный номер кредиты.

![Courses_Index_page_showing_revised_credits](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image9.png)

Дополнительные сведения о необработанных запросов SQL см. в разделе [необработанные запросы SQL](https://blogs.msdn.com/b/adonet/archive/2011/02/04/using-dbcontext-in-ef-feature-ctp5-part-10-raw-sql-queries.aspx) блоге группы разработчиков платформы Entity Framework.

## <a name="no-tracking-queries"></a>Нет отслеживания запросов

Если контекст базы данных получает строки базы данных и создает объекты сущности, представляющие их, по умолчанию он хранит информацию о ли сущностей в памяти синхронизированы с папкой базы данных. Данные в памяти действует как кэш и используется, если вы обновили сущность. Это кэширование необязательно, часто в веб-приложение, так как контекста экземпляров обычно кратковременных (новый один создается и удаляется для каждого запроса), а в контексте, осуществляющий чтение сущности обычно удаляется, прежде чем снова используется этой сущности.

Можно указать, отслеживает ли контекст объектов сущностей для запроса с помощью `AsNoTracking` метод. Ниже приведены типичные сценарии, в которых может потребоваться сделать:

- Запрос извлекает таких больших объемов данных, отключение трассировка может заметно повысить производительность.
- Необходимо присоединить сущности, чтобы обновить его, но ранее полученные той же сущности для другой цели. Поскольку сущность уже отслеживается контекстом базы данных, не удается присоединить сущности, который требуется изменить. Один из способов предотвратить возникновение этой ситуации является использование `AsNoTracking` параметр с приведенный выше запрос.

В этом разделе необходимо реализовать бизнес-логику, иллюстрирующий второго из этих сценариев. В частности будет применять бизнес-правило, говорит, что инструктор не может быть администратором более одного отдела.

В *DepartmentController.cs*, добавьте новый метод, который можно вызвать из `Edit` и `Create` методы, чтобы не двух отделов должны иметь ту же администратора:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample10.cs)]

Добавьте код в `try` блока `HttpPost` `Edit` метод для вызова этого нового метода, если нет ошибок проверки. `try` Блок теперь выглядит как в следующем примере:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample11.cs?highlight=9-12)]

Запустите страница отдела изменение и попробуйте сделать администратор отдела инструктора, который уже является администратор другое подразделение. Ожидаемый отображается сообщение:

![Department_Edit_page_with_duplicate_administrator_error_message](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image10.png)

Теперь запустите еще раз страница отдела изменение и это изменение времени **бюджета** суммы. При нажатии кнопки **Сохранить**, появится страница ошибки:

![Department_Edit_page_with_object_state_manager_error_message](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image11.png)

Ошибка сообщение об исключении: "`An object with the same key already exists in the ObjectStateManager. The ObjectStateManager cannot track multiple objects with the same key.`" это произошло из-за следующая последовательность событий:

- `Edit` Вызовы метода `ValidateOneAdministratorAssignmentPerInstructor` метод, который получает все подразделения, имеющих Kim Abercrombie как администратор сети. В результате отделе английского языка для чтения. Так как это подразделение редактируемого, ошибка не возникает. В результате этой операцией чтения Однако сущность department английского языка, считанное из базы данных теперь отслеживается контекст базы данных.
- `Edit` Метод пытается задать `Modified` флаг в английском языке отдел сущность создана системой связывателя модели MVC, но это не удается, так как контекст уже отслеживает сущность для английского языка отдела.

Для предотвращения контекст отслеживания сущности отдела в памяти, полученные запросом проверки является одно из решений этой проблемы. Нет не недостаток таким образом, так как не будет обновляться этой сущности или считывании его в виде, получают преимущества от его кэширования в памяти.

В *DepartmentController.cs*в `ValidateOneAdministratorAssignmentPerInstructor` метода, укажите не отслеживания, как показано в следующем:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample12.cs?highlight=4)]

Повторите попытку изменить **бюджета** объем отдел. Это время операция выполнена успешно, и сайт возвращает должным образом на страницу индекса отделов, отображается значение пересмотренного бюджета.

## <a name="examining-queries-sent-to-the-database"></a>Изучение запросы, отправляемые в базу данных

Иногда бывает полезно иметь возможность просматривать фактические запросы SQL, которые отправляются в базу данных. Для этого вы можете изучить переменной запроса в отладчике или вызывать запроса `ToString` метод. Чтобы протестировать эту возможность, будет рассмотрим простой запрос и проверьте, что происходит на него при добавлении параметров таких eager загрузки, фильтрации и сортировки.

В *контроллеров или CourseController*, замените `Index` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample13.cs?highlight=3)]

Теперь задать точку останова в *GenericRepository.cs* на `return query.ToList();` и `return orderBy(query).ToList();` инструкции `Get` метод. Запустите проект в режиме отладки и выберите страницу индекса курса. Когда код достигает точки останова, изучите `query` переменной. Появится запрос, отправленных на SQL Server. Это простой `Select` инструкции:

[!code-json[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample14.json)]

![](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image12.png)

Запросы могут выполняться слишком много времени для отображения в окнах отладки в Visual Studio. Чтобы просмотреть весь запрос, можно скопировать значения переменной и вставьте его в текстовый редактор:

![Copy_value_of_variable_in_debug_mode](https://asp.net/media/2578239/Windows-Live-Writer_Advanced-Entity-Framework-Scenarios-for-_CEF8_Copy_value_of_variable_in_debug_mode_0902a2b1-b799-47a6-9b4b-f266c79d83c1.png)

Теперь добавим раскрывающегося списка на страницу индекса курс, чтобы пользователи могут выполнять фильтрацию определенного отдела. Нужно отсортировать курсов по названию, и потребуется указать упреждающую для `Department` свойства навигации. В *CourseController.cs*, замените `Index` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample15.cs)]

Метод получает выбранное значение из раскрывающегося списка в `SelectedDepartment` параметра. Если ничего не выделено, этот параметр будет иметь значение null.

Объект `SelectList` передается коллекция, содержащая все отделы в представление для раскрывающегося списка. Параметры, передаваемые `SelectList` конструктор указать значение имени поля, имя текстового поля и выбранного элемента.

Для `Get` метод `Course` репозитория, код задает критерий фильтра, порядок сортировки и загрузка для eager `Department` свойства навигации. Возвращает критерий фильтра всегда `true` Если ничего не выбрано в раскрывающемся списке (то есть `SelectedDepartment` имеет значение null).

В *Views\Course\Index.cshtml*, непосредственно перед открытием `table` , добавьте следующий код для создания раскрывающегося списка и кнопка отправки:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample16.cshtml)]

С точки останова по-прежнему в `GenericRepository` выполнения страницы индекса курса класса. Продолжайте первых двух раз, что код не достигнет точки останова, чтобы отобразить страницу в браузере. Выберите подразделение из раскрывающегося списка и нажмите кнопку **фильтра**:

![Course_Index_page_with_department_selected](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image13.png)

Это время первой точки останова будет запроса отделов для раскрывающегося списка. Пропустить и просмотреть `query` переменной очередном код достигает точки останова, чтобы узнать, какие `Course` запроса теперь имеет следующий вид. Вы увидите примерно следующим образом:

[!code-json[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample17.json)]

Вы увидите, что запрос теперь является `JOIN` запрос, который загружает `Department` вместе с данными `Course` данных и что он включает `WHERE` предложения.

<a id="proxyclasses"></a>

## <a name="working-with-proxy-classes"></a>Работа с прокси-классы

Когда платформа Entity Framework создает экземпляры сущности (например, при выполнении запроса), они часто будут созданы как экземпляры динамически создаваемых производного типа, который действует как прокси для сущности. Этот прокси-сервер переопределяет некоторые виртуальные свойства сущности, которую необходимо вставить обработчики для выполнения действий, автоматически при доступе к этому свойству. Например этот механизм используется для поддержки отложенной загрузки связей.

В большинстве случаев не требуется учитывать такое использование учетных записей-посредников, однако существуют исключения:

- В некоторых сценариях может потребоваться запретить Entity Framework создавать экземпляры прокси-сервера. Например сериализация экземпляров отличных от прокси-сервера может быть более эффективным, чем сериализации экземпляров прокси-сервера.
- При создании экземпляра класса сущностей с помощью `new` оператора, можно не получить экземпляр прокси-сервера. Это означает, что вы не получаете функциональные возможности, например отложенную загрузку и автоматическое отслеживание изменений. Как правило, это хорошо; обычно не требуется отложенную загрузку, поскольку вы создаете новую сущность, которая не находится в базе данных и обычно не требуется отслеживания изменений, если явным образом пометить сущности как `Added`. Тем не менее, если вам нужен отложенную загрузку и требуется отслеживание изменений, можно создать экземпляры этой сущности с прокси-серверов с помощью `Create` метод `DbSet` класса.
- Можно получить фактический тип сущности из прокси-типа. Можно использовать `GetObjectType` метод `ObjectContext` класса, чтобы получить фактический тип сущности экземпляра типа прокси-сервера.

Дополнительные сведения см. в разделе [работа с прокси-серверы](https://blogs.msdn.com/b/adonet/archive/2011/02/02/using-dbcontext-in-ef-feature-ctp5-part-8-working-with-proxies.aspx) блоге группы разработчиков платформы Entity Framework.

## <a name="disabling-automatic-detection-of-changes"></a>Отключение автоматического обнаружения изменений

Платформа Entity Framework определяет изменении сущности (и поэтому обновления, которые необходимо передать в базу данных), путем сравнения значений текущей сущности с исходными значениями. Исходные значения хранятся в том случае, когда сущность была запросы или присоединенного. Ниже перечислены некоторые методы, которые вызывают изменение автоматического обнаружения.

- `DbSet.Find`
- `DbSet.Local`
- `DbSet.Remove`
- `DbSet.Add`
- `DbSet.Attach`
- `DbContext.SaveChanges`
- `DbContext.GetValidationErrors`
- `DbContext.Entry`
- `DbChangeTracker.Entries`

Если вы отслеживаете большого числа сущностей и вызовите один из этих методов много раз в цикле, может появиться значительное повышение производительности, временно отключив автоматическое изменение отслеживания с помощью [AutoDetectChangesEnabled](https://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.dbcontextconfiguration.autodetectchangesenabled(VS.103).aspx) свойство. Дополнительные сведения см. в разделе [автоматическое обнаружение изменений](https://blogs.msdn.com/b/adonet/archive/2011/02/06/using-dbcontext-in-ef-feature-ctp5-part-12-automatically-detecting-changes.aspx).

## <a name="disabling-validation-when-saving-changes"></a>Отключение проверки при сохранении изменения

При вызове `SaveChanges` метода по умолчанию платформа Entity Framework проверяет данные в все свойства сущности все измененные перед обновлением базы данных. Если вы обновили большого числа сущностей и вы уже проверены данные, эта работа не требуется и может сделать процесс сохранения изменений требуется меньше времени, временно отключив проверки. Можно сделать при помощи этого [ValidateOnSaveEnabled](https://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.dbcontextconfiguration.validateonsaveenabled(VS.103).aspx) свойство. Дополнительные сведения см. в разделе [проверки](https://blogs.msdn.com/b/adonet/archive/2010/12/15/ef-feature-ctp5-validation.aspx).

## <a name="summary"></a>Сводка

На этом завершается, серию учебники по использованию платформы Entity Framework в приложении ASP.NET MVC. Ссылки на другие ресурсы Entity Framework можно найти в [Карта содержимого для доступа к данным ASP.NET](../../../../whitepapers/aspnet-data-access-content-map.md).

Дополнительные сведения о развертывании веб-приложения после его построения см. в разделе [Карта содержимого развертывания ASP.NET](https://msdn.microsoft.com/en-us/library/bb386521.aspx) в библиотеке MSDN.

Сведения о других разделов, связанных с MVC, таких как проверка подлинности и авторизации, в разделе [MVC рекомендуется использовать ресурсы](../../getting-started/recommended-resources-for-mvc.md).

<a id="acknowledgments"></a>

## <a name="acknowledgments"></a>Подтверждения

- Tom Dykstra написал исходной версии этого учебника и имеет старший программирования записи на веб-платформу Майкрософт и средств разработчиков содержимого.
- [Рик Андерсон](https://blogs.msdn.com/b/rickandy/) (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT)), выпущенной этого учебника и не большую часть работы, для EF 5 и MVC 4. Рик имеет старший программный модуль записи для Microsoft Azure и MVC.
- [Роуэном Миллер](http://www.romiller.com) и другими членами команды Entity Framework вспомогательная с проверками кода и помогли многих проблемах отладки со миграций, возникших во время мы обновляли учебника EF 5.

## <a name="vb"></a>VB

Когда учебника изначально был создан, мы предоставляем версии C# и VB завершения загрузки проекта. Это обновление предоставляет проект C# загружаемые для каждой главы сделать проще начать работать в любом из серии, но из-за ограничения времени и других приоритетов, мы не выполнено, для Visual Basic. При построении проекта Visual Basic, с помощью этих учебников и возможно, захотят данным совместного использования с другими пользователями, сообщите нам об этом.

<a id="errors"></a>

## <a name="errors-and-workarounds"></a>Ошибки и способы их устранения

### <a name="cannot-createshadow-copy"></a>Не удается создать теневую копию

Сообщение об ошибке:

*Не удается создать теневую копию «DotNetOpenAuth.OpenId», так как он уже существует.*

Решение:

Подождите несколько секунд и обновите страницу.

### <a name="update-database-not-recognized"></a>Update-Database не распознан

Сообщение об ошибке:

*Термин «Update-Database» не распознан как имя командлета, функции, файла скрипта или действующей программы. Проверьте правильность написания имени, а если включен путь, проверьте правильность пути и повторите попытку.* (Из  *`Update-Database`*  в PMC.)

Решение:

Выйдите из Visual Studio. Откройте проект и повторите попытку.

### <a name="validation-failed"></a>Сбой проверки

Сообщение об ошибке:

*Не удалось проверить одну или несколько сущностей. См. Дополнительные сведения о свойстве «EntityValidationErrors».* (От  *`Update-Database`*  в PMC.)

Решение:

Одной из причин этой ошибки является ошибки проверки при `Seed` метода. В разделе [заполнения и отладка Entity Framework (EF) БД](https://blogs.msdn.com/b/rickandy/archive/2013/02/12/seeding-and-debugging-entity-framework-ef-dbs.aspx) советы по отладке `Seed` метод.

### <a name="http-50019-error"></a>HTTP 500.19 ошибки

Сообщение об ошибке:

*Ошибка HTTP 500.19 — Внутренняя ошибка сервера запрошенную страницу невозможен из-за неверной конфигурации данных для страницы.*

Решение:

Эта ошибка может возникнуть в том из с несколькими копиями решение, каждый из них используют тот же номер порта. Обычно эти проблемы можно устранить, выход из всех экземпляров Visual Studio, а затем перезапуск на работу с вашего проекта. Если это не поможет, попробуйте изменить номер порта. Щелкните правой кнопкой мыши файл проекта и выберите пункт Свойства. Выберите **Web** вкладку и измените номер порта в **URL-адрес проекта** текстовое поле.

### <a name="error-locating-sql-server-instance"></a>Ошибка поиску экземпляра SQL Server

Сообщение об ошибке:

*Связанные с сетью или с определенным экземпляром ошибка при установлении соединения с SQL Server. Сервер не найден или недоступен. Убедитесь, что имя экземпляра указано правильно и что SQL Server настроен для удаленных подключений. (поставщик: сетевые интерфейсы SQL, ошибка: 26: ошибка поиске указанного сервера/экземпляра)*

Решение:

Проверьте строку подключения. Если удаленные базы данных вручную, измените имя базы данных в строке построения.

>[!div class="step-by-step"]
[Назад](implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application.md)
[Вперед](building-the-ef5-mvc4-chapter-downloads.md)
