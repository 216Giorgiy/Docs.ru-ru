---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Предотвращение XSRF/CSRF в ASP.NET MVC и веб-страницы | Документы Microsoft
author: Rick-Anderson
description: Подделки межсайтовых запросов (также известный как XSRF или CSRF) — это атака, для приложений веб сервере, при котором вредоносный веб-узел может влиять на проводятся...
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6cf30daa7ed966b11405cec715c5bc803b567249
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/10/2018
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="4dc76-103">Предотвращение XSRF/CSRF в ASP.NET MVC и веб-страницы</span><span class="sxs-lookup"><span data-stu-id="4dc76-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="4dc76-104">по [Рик Андерсон](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="4dc76-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="4dc76-105">Запрос межсайтовой подделки (также известный как XSRF или CSRF) — это атака, для приложений веб сервере, при котором вредоносных веб-сайта могут повлиять на взаимодействие между браузером клиента и веб-сайта, которым доверяет этот браузер.</span><span class="sxs-lookup"><span data-stu-id="4dc76-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="4dc76-106">Такие атаки становится возможным, так как веб-браузеры будет отправлять маркеры проверки подлинности автоматически при каждом запросе к веб-сайту.</span><span class="sxs-lookup"><span data-stu-id="4dc76-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="4dc76-107">Типичный пример — файл cookie проверки подлинности, например ASP. Билет проверки подлинности форм в NET.</span><span class="sxs-lookup"><span data-stu-id="4dc76-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="4dc76-108">Тем не менее веб-сайтов, которые с помощью любого механизма проверки подлинности (например, проверку подлинности Windows, Basic и т. д.) могут быть нацелены подобных атак.</span><span class="sxs-lookup"><span data-stu-id="4dc76-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="4dc76-109">Атака XSRF отличается от фишинга.</span><span class="sxs-lookup"><span data-stu-id="4dc76-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="4dc76-110">Фишинг-атаках требуют взаимодействия из выбран в качестве жертвы.</span><span class="sxs-lookup"><span data-stu-id="4dc76-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="4dc76-111">При атаке с фишинг вредоносный веб-узел будет имитировать целевого веб-сайта и жертвы верьте обеспечить конфиденциальную информацию злоумышленнику.</span><span class="sxs-lookup"><span data-stu-id="4dc76-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="4dc76-112">При атаке XSRF обычно имеется без участия необходимые из выбран в качестве жертвы.</span><span class="sxs-lookup"><span data-stu-id="4dc76-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="4dc76-113">Вместо этого он полагается на браузера, автоматически отправляя все соответствующие файлы cookie в веб-узлу.</span><span class="sxs-lookup"><span data-stu-id="4dc76-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="4dc76-114">Дополнительные сведения см. в разделе [откройте проект безопасности веб-приложения](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="4dc76-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="4dc76-115">Составляющие атака</span><span class="sxs-lookup"><span data-stu-id="4dc76-115">Anatomy of an attack</span></span>

<span data-ttu-id="4dc76-116">Для ознакомления с XSRF атаки, рассмотрите возможность пользователя, который хочет работать некоторые транзакции банковских операциях.</span><span class="sxs-lookup"><span data-stu-id="4dc76-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="4dc76-117">Этот пользователь посещает в первую очередь WoodgroveBank.com и журналов, после чего заголовок ответа будет содержать ее файла cookie проверки подлинности:</span><span class="sxs-lookup"><span data-stu-id="4dc76-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="4dc76-118">Так как файл cookie проверки подлинности файла cookie сеанса, он будет автоматически удалено браузером при завершении процесса браузера.</span><span class="sxs-lookup"><span data-stu-id="4dc76-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="4dc76-119">Однако до этого времени браузер автоматически включит куки-файл для каждого запроса WoodgroveBank.com. Пользователю для передачи 1000 долларов на другую учетную запись, поэтому она заполнения формы на сайте банковских операций, а браузер отправляет запрос к серверу:</span><span class="sxs-lookup"><span data-stu-id="4dc76-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="4dc76-120">Так как эта операция является побочным эффектом (запускает транзакцию денежных), на сайте банковских операций выбрала запрос HTTP POST, чтобы выполнить эту операцию.</span><span class="sxs-lookup"><span data-stu-id="4dc76-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="4dc76-121">Сервер считывает токена проверки подлинности из запроса, ищет номер учетной записи текущего пользователя, проверяет, существует достаточно средств и затем запускает транзакцию в целевой учетной записью.</span><span class="sxs-lookup"><span data-stu-id="4dc76-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="4dc76-122">Ей сети банковских завершения, пользователь выходит из сайта банковских операций и посещает другие расположения в Интернете.</span><span class="sxs-lookup"><span data-stu-id="4dc76-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="4dc76-123">Один из этих сайтов — fabrikam.com — включает следующую разметку страницы, внедренный в &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="4dc76-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="4dc76-124">В результате чего браузер для выполнения данного запроса:</span><span class="sxs-lookup"><span data-stu-id="4dc76-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="4dc76-125">Он применяет тот факт, что пользователь по-прежнему может быть маркер аутентификации для целевого веб-сайта, и она использует небольшой фрагмент кода JavaScript в браузер, чтобы автоматически сделать HTTP POST на целевой сайт.</span><span class="sxs-lookup"><span data-stu-id="4dc76-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="4dc76-126">Если маркер проверки подлинности по-прежнему допустим, на сайте банковских операций инициирует передачу 250 долл. США в учетную запись по выбору злоумышленника.</span><span class="sxs-lookup"><span data-stu-id="4dc76-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="4dc76-127">Неэффективной исправлений</span><span class="sxs-lookup"><span data-stu-id="4dc76-127">Ineffective mitigations</span></span>

<span data-ttu-id="4dc76-128">Это интересно отметить, что в приведенном выше сценарии тем, что WoodgroveBank.com осуществлялся через SSL и имеет файл cookie проверки подлинности SSL-только слишком мал для предотвратить атаки.</span><span class="sxs-lookup"><span data-stu-id="4dc76-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="4dc76-129">Злоумышленник имеет возможность указать [схема URI](http://en.wikipedia.org/wiki/URI_scheme) (https) в нее &lt;формы&gt; элемент и браузер продолжает отправлять неистекшим сроком действия файлов cookie на целевой сайт, при условии, что файлы cookie являются согласуется с URI Схема намеченной цели.</span><span class="sxs-lookup"><span data-stu-id="4dc76-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="4dc76-130">Можно утверждать, что пользователь просто не посетите ненадежных веб-сайтов, как посещения только для доверенных сайтов позволяет сети остаются в безопасном.</span><span class="sxs-lookup"><span data-stu-id="4dc76-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="4dc76-131">Есть некоторые истины это, но к сожалению это требование не всегда практично.</span><span class="sxs-lookup"><span data-stu-id="4dc76-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="4dc76-132">Возможно пользователя» доверяет» на сайте местных новостей ConsolidatedMessenger.</span><span class="sxs-lookup"><span data-stu-id="4dc76-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="4dc76-133">ConsolidatedMessenger.com и переходит к посещение, вместо этого сайта, но этот узел имеет уязвимость XSS, что позволяет злоумышленнику вставку фрагмент кода, запущенного на fabrikam.com.</span><span class="sxs-lookup"><span data-stu-id="4dc76-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="4dc76-134">Убедитесь, что входящие запросы имеют [заголовок Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) ссылки на домен.</span><span class="sxs-lookup"><span data-stu-id="4dc76-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="4dc76-135">Это остановит запросов, случайно переданных из домена сторонних разработчиков.</span><span class="sxs-lookup"><span data-stu-id="4dc76-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="4dc76-136">Тем не менее некоторые пользователи отключите заголовок Referer браузера по соображениям конфиденциальности и злоумышленники иногда может подделать заголовок, если выбран в качестве жертвы имеет определенные небезопасных установлено программное обеспечение.</span><span class="sxs-lookup"><span data-stu-id="4dc76-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="4dc76-137">Проверка [заголовок Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) не считается безопасным способом, предотвращая XSRF-атак.</span><span class="sxs-lookup"><span data-stu-id="4dc76-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="4dc76-138">Возможные способы устранения Web XSRF стека времени выполнения</span><span class="sxs-lookup"><span data-stu-id="4dc76-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="4dc76-139">Среда выполнения ASP.NET Web стека используется вариант [синхронизатор шаблона токена](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) для защиты от XSRF-атак.</span><span class="sxs-lookup"><span data-stu-id="4dc76-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="4dc76-140">Общая форма синхронизатор шаблона токена — что два маркера anti-XSRF отправляются на сервер с каждой HTTP POST (помимо токена проверки подлинности): один токен как файл cookie, а другой — как значение формы.</span><span class="sxs-lookup"><span data-stu-id="4dc76-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="4dc76-141">Значения маркера, создаваемые средой выполнения ASP.NET не детерминированным или с предсказуемой злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="4dc76-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="4dc76-142">При отправке токенов сервера позволит запроса только в том случае, если оба маркера пройти проверку сравнения.</span><span class="sxs-lookup"><span data-stu-id="4dc76-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="4dc76-143">Запрос проверки XSRF *токена сеанса* сохраняется как файл cookie HTTP и в настоящее время содержит следующие сведения в его полезные данные:</span><span class="sxs-lookup"><span data-stu-id="4dc76-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="4dc76-144">Маркер безопасности, состоящий из произвольного 128-разрядный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="4dc76-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="4dc76-145">На следующем рисунке показана отображается с помощью средств разработчика Internet Explorer F12 маркер сеанса проверки XSRF запроса: (Примечание это текущая реализация, тема, даже может меняться.)</span><span class="sxs-lookup"><span data-stu-id="4dc76-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="4dc76-146">*Маркер поля* хранится в виде `<input type="hidden" />` и содержит следующие сведения в его полезные данные:</span><span class="sxs-lookup"><span data-stu-id="4dc76-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="4dc76-147">Имя пользователя вошедшего в систему пользователя (если проверка подлинности).</span><span class="sxs-lookup"><span data-stu-id="4dc76-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="4dc76-148">Любые дополнительные данные, предоставляемые [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="4dc76-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="4dc76-149">Полезные данные маркеров защиты от XSRF шифруются и подписываются, поэтому имя пользователя не отображается при использовании средств для проверки токенов.</span><span class="sxs-lookup"><span data-stu-id="4dc76-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="4dc76-150">При веб-приложение предназначен для ASP.NET 4.0, службы шифрования предоставляются [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) подпрограммы.</span><span class="sxs-lookup"><span data-stu-id="4dc76-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="4dc76-151">При веб-приложение предназначен для ASP.NET 4.5 или более поздней версии, криптографических служб, предоставляемых [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) подпрограмму, которая предлагает более высокую производительность, расширяемости и безопасности.</span><span class="sxs-lookup"><span data-stu-id="4dc76-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="4dc76-152">Узнать о следующей записи в блогах Дополнительные сведения:</span><span class="sxs-lookup"><span data-stu-id="4dc76-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="4dc76-153">Усовершенствования шифрования в ASP.NET 4.5, pt. 1</span><span class="sxs-lookup"><span data-stu-id="4dc76-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="4dc76-154">Усовершенствования шифрования в ASP.NET 4.5, pt. 2</span><span class="sxs-lookup"><span data-stu-id="4dc76-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="4dc76-155">Усовершенствования шифрования в ASP.NET 4.5, pt. 3</span><span class="sxs-lookup"><span data-stu-id="4dc76-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="4dc76-156">Создание токенов</span><span class="sxs-lookup"><span data-stu-id="4dc76-156">Generating the tokens</span></span>

<span data-ttu-id="4dc76-157">Для создания маркеров защиты от XSRF следует вызвать [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) метод из представления MVC или @AntiForgery.GetHtml() на странице Razor.</span><span class="sxs-lookup"><span data-stu-id="4dc76-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="4dc76-158">Среда выполнения будет затем выполните следующие действия:</span><span class="sxs-lookup"><span data-stu-id="4dc76-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="4dc76-159">Если текущий HTTP-запрос уже содержит маркера anti-XSRF сеанса (файл cookie защиты от XSRF \_ \_RequestVerificationToken), маркер безопасности извлекается из него.</span><span class="sxs-lookup"><span data-stu-id="4dc76-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="4dc76-160">Если HTTP-запроса не содержит маркера anti-XSRF сеанса или произошел сбой извлечения маркера безопасности, будет создан новый маркер случайных anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="4dc76-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="4dc76-161">Маркера anti-XSRF поля генерируется с использованием маркера безопасности в предыдущем шаге (1) и удостоверения текущего вошедшего в систему пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="4dc76-162">(Дополнительные сведения об определении удостоверение пользователя см. в разделе **[сценариев с специальную поддержку](#_Scenarios_with_special)** разделе ниже.) Кроме того Если [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) будет настроена, среда выполнения будет вызывать его [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) метод и включать в токен поля возвращаемой строки.</span><span class="sxs-lookup"><span data-stu-id="4dc76-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="4dc76-163">(См. **[конфигурации и расширяемость](#_Configuration_and_extensibility)** Дополнительные сведения.)</span><span class="sxs-lookup"><span data-stu-id="4dc76-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="4dc76-164">Если нового маркера anti-XSRF, созданный на шаге (1), новый маркер для него будет создана и будет добавляться в коллекцию файлов cookie HTTP-исходящих.</span><span class="sxs-lookup"><span data-stu-id="4dc76-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="4dc76-165">Токен поля из пункта (2) будет вставлено в `<input type="hidden" />` элемент и эта разметка HTML будут возвращаемое значение `Html.AntiForgeryToken()` или `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="4dc76-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="4dc76-166">Проверку маркеров</span><span class="sxs-lookup"><span data-stu-id="4dc76-166">Validating the tokens</span></span>

<span data-ttu-id="4dc76-167">Для проверки входящих маркеров защиты от XSRF, включает разработчик [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) атрибут на ее действие MVC, контроллера или она вызывает `@AntiForgery.Validate()` из своей страницей Razor.</span><span class="sxs-lookup"><span data-stu-id="4dc76-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="4dc76-168">Среда выполнения будет выполнять следующие действия:</span><span class="sxs-lookup"><span data-stu-id="4dc76-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="4dc76-169">Входящий токен сеанса и токен поля доступны для чтения и маркера anti-XSRF извлекается из каждого.</span><span class="sxs-lookup"><span data-stu-id="4dc76-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="4dc76-170">Маркеры защиты от XSRF должны быть одинаковыми на каждом шаге (2) в процедуре создания.</span><span class="sxs-lookup"><span data-stu-id="4dc76-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="4dc76-171">Если текущий пользователь прошел проверку подлинности, ее имя пользователя сравнивается с именем пользователя, хранящихся в токен поля.</span><span class="sxs-lookup"><span data-stu-id="4dc76-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="4dc76-172">Имена пользователей должны совпадать.</span><span class="sxs-lookup"><span data-stu-id="4dc76-172">The usernames must match.</span></span>
3. <span data-ttu-id="4dc76-173">Если [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) настроена, среда выполнения вызывает его *ValidateAdditionalData* метод.</span><span class="sxs-lookup"><span data-stu-id="4dc76-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="4dc76-174">Метод должен возвращать логическое значение, которое *true*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="4dc76-175">Если проверка прошла успешно, запрос разрешается.</span><span class="sxs-lookup"><span data-stu-id="4dc76-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="4dc76-176">Если проверка завершается неудачно, платформа будет вызывать *HttpAntiForgeryException*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="4dc76-177">Условия сбоя</span><span class="sxs-lookup"><span data-stu-id="4dc76-177">Failure conditions</span></span>

<span data-ttu-id="4dc76-178">Начиная с версии 2 среда ASP.NET Web стека выполнения, все *HttpAntiForgeryException* , возникающее во время проверки будет содержать подробные сведения о том, что пошло не так.</span><span class="sxs-lookup"><span data-stu-id="4dc76-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="4dc76-179">Условия, определенные на текущий момент сбоя:</span><span class="sxs-lookup"><span data-stu-id="4dc76-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="4dc76-180">Маркер сеанса или маркера формы не присутствует в запросе.</span><span class="sxs-lookup"><span data-stu-id="4dc76-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="4dc76-181">Маркер сеанса или маркера формы не может быть прочитан.</span><span class="sxs-lookup"><span data-stu-id="4dc76-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="4dc76-182">Наиболее вероятной причиной является несовпадение версий среды выполнения ASP.NET Web стека или фермы с балансированием где &lt;machineKey&gt; элемента в файле Web.config отличается между компьютерами.</span><span class="sxs-lookup"><span data-stu-id="4dc76-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="4dc76-183">Можно использовать такое средство, как Fiddler принудительно это исключение, подделки либо маркера anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="4dc76-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="4dc76-184">Маркер сеанса и токен поля были перепутаны.</span><span class="sxs-lookup"><span data-stu-id="4dc76-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="4dc76-185">Маркер сеанса и токен поля содержат токены несоответствия безопасности.</span><span class="sxs-lookup"><span data-stu-id="4dc76-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="4dc76-186">Имя пользователя, внедренные в маркер поля не соответствует текущего вошедшего в систему пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="4dc76-187">*[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* возвращаемое значение метода *false*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="4dc76-188">Средства защиты от XSRF также может выполнять дополнительную проверку во время создания токенов или проверки и ошибок во время проверки может привести к созданию исключений.</span><span class="sxs-lookup"><span data-stu-id="4dc76-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="4dc76-189">. В разделе [WIF и ACS или на основе утверждений проверки подлинности](#_WIF_ACS) и **[конфигурации и расширяемость](#_Configuration_and_extensibility)** разделы для получения дополнительной информации.</span><span class="sxs-lookup"><span data-stu-id="4dc76-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="4dc76-190">Сценарии с специальную поддержку</span><span class="sxs-lookup"><span data-stu-id="4dc76-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="4dc76-191">Анонимная проверка подлинности</span><span class="sxs-lookup"><span data-stu-id="4dc76-191">Anonymous authentication</span></span>

<span data-ttu-id="4dc76-192">Система защиты от XSRF содержит специальную поддержку для анонимных пользователей, где «anonymous» определяется как пользователь где *IIdentity.IsAuthenticated* возвращает *false*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="4dc76-193">Сценарии включают в себя предоставление защиты от XSRF на страницу входа (до проверки подлинности пользователя) и пользовательских схем проверки подлинности где приложение использует механизм, отличный от *IIdentity* для идентификации пользователей.</span><span class="sxs-lookup"><span data-stu-id="4dc76-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="4dc76-194">Для поддержки следующих сценариев, помните, что маркеры сеанса и поле присоединены токеном безопасности, который является 128-разрядным формируется случайным образом непрозрачным идентификатором.</span><span class="sxs-lookup"><span data-stu-id="4dc76-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="4dc76-195">Маркер безопасности используется для отслеживания сеанса отдельного пользователя, как она перешла сайта, поэтому фактически служит анонимного идентификатора.</span><span class="sxs-lookup"><span data-stu-id="4dc76-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="4dc76-196">Вместо имени пользователя для описанных выше процедур создания и проверки используется пустая строка.</span><span class="sxs-lookup"><span data-stu-id="4dc76-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="4dc76-197">WIF и ACS или на основе утверждений проверка подлинности</span><span class="sxs-lookup"><span data-stu-id="4dc76-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="4dc76-198">Как правило *IIdentity* классы, встроенный в .NET Framework имеют свойства, *IIdentity.Name* достаточно для уникальной идентификации конкретного пользователя в пределах конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="4dc76-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="4dc76-199">Например *FormsIdentity.Name* возвращает имя пользователя, который хранится в базе данных членства (которое должно быть уникальным для всех приложений, в зависимости от этой базы данных), *WindowsIdentity.Name* возвращает доменном удостоверение пользователя и т. д.</span><span class="sxs-lookup"><span data-stu-id="4dc76-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="4dc76-200">Эти системы обеспечивают не только проверка подлинности; они также *идентификации* пользователям приложения.</span><span class="sxs-lookup"><span data-stu-id="4dc76-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="4dc76-201">Проверка подлинности на основе утверждений, с другой стороны, не требует обязательного идентификации конкретного пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="4dc76-202">Вместо этого *ClaimsPrincipal* и *ClaimsIdentity* типы связаны с набором *утверждения* экземпляров, где отдельных утверждений может быть «is 18 + лет» или» является администратором» для других действий.</span><span class="sxs-lookup"><span data-stu-id="4dc76-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="4dc76-203">Поскольку пользователь не обязательно определена, среда выполнения не может использовать *ClaimsIdentity.Name* свойство как уникальный идентификатор для данного пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="4dc76-204">Команда замеченных примеров, где *ClaimsIdentity.Name* возвращает *null*, возвращает имя понятного имени (отображение) или в противном случае возвращает строку, которая не подходит для использования в качестве уникального идентификатора для пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="4dc76-205">Многие из развертываний, которые используют проверку подлинности на основе утверждений используется [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) в частности.</span><span class="sxs-lookup"><span data-stu-id="4dc76-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="4dc76-206">ACS позволяет разработчикам настраивать отдельные *Поставщики удостоверений* (такие как ADFS, поставщик учетной записи Майкрософт поставщиков OpenID, например Yahoo!, т. д.), и Поставщики удостоверений, которые возвращают *имя идентификаторы*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="4dc76-207">Эти идентификаторы имя может содержать личные сведения (PII) как адрес электронной почты, или может быть анонимен как частным личным идентификатором (PPID).</span><span class="sxs-lookup"><span data-stu-id="4dc76-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="4dc76-208">Независимо от того, кортеж (поставщика удостоверений, идентификатора имени) достаточно служит в качестве маркера соответствующие отслеживания для конкретного пользователя во время она поиск по сайту, так что среда выполнения ASP.NET Web стека можно использовать кортеж вместо имени пользователя при создании и проверки маркеров защиты от XSRF поля.</span><span class="sxs-lookup"><span data-stu-id="4dc76-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="4dc76-209">Определенный URI для поставщика удостоверений и идентификатор имени:</span><span class="sxs-lookup"><span data-stu-id="4dc76-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="4dc76-210">(см. в этом [ACS doc страницы](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) Дополнительные сведения.)</span><span class="sxs-lookup"><span data-stu-id="4dc76-210">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="4dc76-211">При создании или проверке токена, среда выполнения ASP.NET Web стека во время выполнения попытается привязки к типам:</span><span class="sxs-lookup"><span data-stu-id="4dc76-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="4dc76-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (Для WIF SDK.)</span><span class="sxs-lookup"><span data-stu-id="4dc76-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="4dc76-213">`System.Security.Claims.ClaimsIdentity` (Для .NET Framework 4.5).</span><span class="sxs-lookup"><span data-stu-id="4dc76-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="4dc76-214">Если такие существуют и в том случае, если текущий пользователь *IIIIdentity* реализует или подклассы один из этих типов, будет использовать средство защиты от XSRF (поставщика удостоверений, идентификатора имени) кортежа вместо имени пользователя, при создании и Проверка токены.</span><span class="sxs-lookup"><span data-stu-id="4dc76-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="4dc76-215">Если присутствует нет таких кортежей, запрос будет завершаться ошибкой, описывают разработчику для настройки системы защиты от XSRF для понимания механизм конкретной проверки подлинности на основе утверждений используется.</span><span class="sxs-lookup"><span data-stu-id="4dc76-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="4dc76-216">В разделе **[конфигурации и расширяемость](#_Configuration_and_extensibility)** Дополнительные сведения.</span><span class="sxs-lookup"><span data-stu-id="4dc76-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="4dc76-217">OAuth или OpenID проверки подлинности</span><span class="sxs-lookup"><span data-stu-id="4dc76-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="4dc76-218">Наконец средство защиты от XSRF имеет специальную поддержку для приложений, которые используют проверку подлинности OAuth или OpenID.</span><span class="sxs-lookup"><span data-stu-id="4dc76-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="4dc76-219">Эта поддержка основана на эвристический: если текущий *IIdentity.Name* начинается с http:// или https://, а затем будет выполнено сравнение имени пользователя с помощью компаратор порядковый номер, а не функцию сравнения по умолчанию OrdinalIgnoreCase.</span><span class="sxs-lookup"><span data-stu-id="4dc76-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="4dc76-220">Конфигурации и расширяемость</span><span class="sxs-lookup"><span data-stu-id="4dc76-220">Configuration and extensibility</span></span>

<span data-ttu-id="4dc76-221">В некоторых случаях разработчикам может потребоваться строгий контроль над созданием anti-XSRF и поведения проверки.</span><span class="sxs-lookup"><span data-stu-id="4dc76-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="4dc76-222">Например может быть нежелательно MVC и веб-страницы помощников по умолчанию автоматически добавить файлы cookie HTTP в ответ и разработчик может потребоваться сохранить токены в другом месте.</span><span class="sxs-lookup"><span data-stu-id="4dc76-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="4dc76-223">Существует два API, чтобы это:</span><span class="sxs-lookup"><span data-stu-id="4dc76-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="4dc76-224">*GetTokens* метод принимает в качестве входного существующего XSRF запрос проверки сеанса маркера (который может иметь значение null) и выводит как выходные нового маркера сеанса проверки XSRF запроса и маркер поля.</span><span class="sxs-lookup"><span data-stu-id="4dc76-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="4dc76-225">Токены являются просто непрозрачные строки без оформления; *formToken* значение для экземпляра не будет переноситься в &lt;ввода&gt; тег.</span><span class="sxs-lookup"><span data-stu-id="4dc76-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="4dc76-226">*NewCookieToken* значение может иметь значение null; в этом случае то *oldCookieToken* значение все еще действителен, и требуется задать не cookie нового отклика.</span><span class="sxs-lookup"><span data-stu-id="4dc76-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="4dc76-227">Код, вызывающий *GetTokens* отвечает за сохранение все файлы cookie, необходимые ответа или создания любой необходимой разметки; *GetTokens* сам метод не может изменить ответа в качестве побочного эффекта.</span><span class="sxs-lookup"><span data-stu-id="4dc76-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="4dc76-228">*Проверки* метод принимает входящий сеанс, а поле маркеры и выполняет логику проверки в упомянутой выше над ними.</span><span class="sxs-lookup"><span data-stu-id="4dc76-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="4dc76-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="4dc76-229">AntiForgeryConfig</span></span>

<span data-ttu-id="4dc76-230">Разработчик может настроить систему защиты от XSRF из приложения\_запуска.</span><span class="sxs-lookup"><span data-stu-id="4dc76-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="4dc76-231">Конфигурация — программный.</span><span class="sxs-lookup"><span data-stu-id="4dc76-231">Configuration is programmatic.</span></span> <span data-ttu-id="4dc76-232">Свойства статических *AntiForgeryConfig* тип описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="4dc76-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="4dc76-233">Большинство пользователей, используя утверждения может потребоваться задать свойство UniqueClaimTypeIdentifier.</span><span class="sxs-lookup"><span data-stu-id="4dc76-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="4dc76-234">**Свойство**</span><span class="sxs-lookup"><span data-stu-id="4dc76-234">**Property**</span></span> | <span data-ttu-id="4dc76-235">**Описание**</span><span class="sxs-lookup"><span data-stu-id="4dc76-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="4dc76-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="4dc76-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="4dc76-237">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , предоставляющий дополнительные данные во время создания токенов и потребует дополнительных данных во время проверки токена.</span><span class="sxs-lookup"><span data-stu-id="4dc76-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="4dc76-238">Значение по умолчанию — *null*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-238">The default value is *null*.</span></span> <span data-ttu-id="4dc76-239">Дополнительные сведения см. в разделе [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) раздела.</span><span class="sxs-lookup"><span data-stu-id="4dc76-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="4dc76-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="4dc76-240">**CookieName**</span></span> | <span data-ttu-id="4dc76-241">Строка, представляющая имя файла cookie HTTP, который используется для хранения маркера anti-XSRF сеанса.</span><span class="sxs-lookup"><span data-stu-id="4dc76-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="4dc76-242">Если это значение не задано, имя будет автоматически сформировано, основываясь на развернутой виртуальный путь приложения.</span><span class="sxs-lookup"><span data-stu-id="4dc76-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="4dc76-243">Значение по умолчанию — *null*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-243">The default value is *null*.</span></span> |
| <span data-ttu-id="4dc76-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="4dc76-244">**RequireSsl**</span></span> | <span data-ttu-id="4dc76-245">Значение типа Boolean, который определяет, требуются ли маркеров защиты от XSRF для отправки через канал SSL-защитой.</span><span class="sxs-lookup"><span data-stu-id="4dc76-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="4dc76-246">Если это значение равно *true*, все файлы cookie, автоматически создается будет установлен флаг «безопасность», и интерфейсы API защиты от XSRF вызывает исключение при вызове из внутри запроса, не отправляется через SSL.</span><span class="sxs-lookup"><span data-stu-id="4dc76-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="4dc76-247">Значение по умолчанию — *false*.</span><span class="sxs-lookup"><span data-stu-id="4dc76-247">The default value is *false*.</span></span> |
| <span data-ttu-id="4dc76-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="4dc76-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="4dc76-249">Значение типа Boolean, который определяет, следует ли система защиты от XSRF отключить поддержку удостоверений, основанных на утверждениях.</span><span class="sxs-lookup"><span data-stu-id="4dc76-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="4dc76-250">Если это значение равно *true*, система предполагается, что *IIdentity.Name* подходит для использования в качестве идентификатора уникального пользователя и не будет пытаться особой *IClaimsIdentity*или *ClClaimsIdentity* как описано в [WIF и ACS или на основе утверждений проверка подлинности](#_WIF_ACS) раздела.</span><span class="sxs-lookup"><span data-stu-id="4dc76-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="4dc76-251">Значение по умолчанию — `false`.</span><span class="sxs-lookup"><span data-stu-id="4dc76-251">The default value is `false`.</span></span> |
| <span data-ttu-id="4dc76-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="4dc76-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="4dc76-253">Строка, указывающая, какие утверждения введите подходит для использования в качестве идентификатора уникального пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="4dc76-254">Если это значение равно набор и текущий *IIdentity* на базе утверждений, система попытается извлечь утверждения типа определяется *UniqueClaimTypeIdentifier*, и соответствующее значение будет использоваться вместо пользователя при создании токен поля.</span><span class="sxs-lookup"><span data-stu-id="4dc76-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="4dc76-255">Если тип утверждения не найден, система отклонит запрос.</span><span class="sxs-lookup"><span data-stu-id="4dc76-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="4dc76-256">Значение по умолчанию — *null*, указывающая, что система должна использовать (поставщика удостоверений, идентификатора имени) кортежа, как описано выше вместо пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="4dc76-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="4dc76-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="4dc76-258">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* типа позволяет разработчикам расширять поведение системы защиты от XSRF с циклической обработки дополнительных данных в каждом маркере.</span><span class="sxs-lookup"><span data-stu-id="4dc76-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="4dc76-259">*GetAdditionalData* при каждом вызове метода создается маркер поля, и возвращаемое значение внедряется в созданный токен.</span><span class="sxs-lookup"><span data-stu-id="4dc76-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="4dc76-260">Разработчик может вернуть отметку времени, nonce или любое другое значение, которое она хочет из этого метода.</span><span class="sxs-lookup"><span data-stu-id="4dc76-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="4dc76-261">Аналогичным образом *ValidateAdditionalData* метод вызывается каждый раз проверяется токен поля, и строка «дополнительные данные», внедренные в маркер передается в метод.</span><span class="sxs-lookup"><span data-stu-id="4dc76-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="4dc76-262">Процедуры проверки может реализовать тайм-аут (путем проверки текущее время от времени, которое было сохранено при создании токена), nonce проверка подпрограммы или любой другой требуемого логику.</span><span class="sxs-lookup"><span data-stu-id="4dc76-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="4dc76-263">Проектные решения и вопросы безопасности</span><span class="sxs-lookup"><span data-stu-id="4dc76-263">Design decisions and security considerations</span></span>

<span data-ttu-id="4dc76-264">Маркер безопасности, который связывает токенов сеанса и поля требуется технически только при попытке защитить анонимные или не прошедшие проверку подлинности пользователей от XSRF-атак.</span><span class="sxs-lookup"><span data-stu-id="4dc76-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="4dc76-265">При проверке подлинности пользователя, маркер проверки подлинности самого (которые можно отправить в форме куки-файла) можно использовать в качестве одной половины синхронизатор токен пары.</span><span class="sxs-lookup"><span data-stu-id="4dc76-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="4dc76-266">Тем не менее существует допустимое сценариев для защиты страницы входа в систему выполнен щелчок непроверенных пользователей и защиты от XSRF логику его проще всегда создается и проверки маркера безопасности, даже для прошедших проверку пользователей.</span><span class="sxs-lookup"><span data-stu-id="4dc76-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="4dc76-267">Он также предоставляет некоторую дополнительную защиту в случае, если токен поля будет скомпрометирован злоумышленником, как установка или угадывания маркера сеанса будет другая проблема преодолеть злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="4dc76-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="4dc76-268">Разработчикам следует проявлять осторожность, когда несколько приложений размещаются в одном домене.</span><span class="sxs-lookup"><span data-stu-id="4dc76-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="4dc76-269">Например несмотря на то что *example1.cloudapp.net* и *example2.cloudapp.net* находятся на разных узлах есть неявные доверительные отношения между все узлы на  *\*. cloudapp.net* домена.</span><span class="sxs-lookup"><span data-stu-id="4dc76-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="4dc76-270">Неявные отношения доверия между [позволяет узлам потенциально небезопасных влияет на файлы cookie друг друга](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (политики одного источника, которые управляют запросы AJAX неприменимы обязательно для файлов cookie HTTP).</span><span class="sxs-lookup"><span data-stu-id="4dc76-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="4dc76-271">Среда выполнения ASP.NET Web стека предоставляет некоторые устранение рисков тем, что имя пользователя, внедряется в токен поля, таким образом, даже если вредоносный поддомен возможность перезаписывать маркер сеанса его не удалось создать маркер допустимого поля для пользователя.</span><span class="sxs-lookup"><span data-stu-id="4dc76-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="4dc76-272">Тем не менее при размещении в такой среде подпрограммы встроенной защиты от XSRF по-прежнему не может защитить от захвата сеанса или имя входа XSRF.</span><span class="sxs-lookup"><span data-stu-id="4dc76-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="4dc76-273">Процедуры защиты от XSRF в настоящее время не защиту от [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="4dc76-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="4dc76-274">Приложения, которые нужно защитить себя от clickjacking может легко сделать, отправляя X-Frame-Options: заголовок SAMEORIGIN с каждым ответом.</span><span class="sxs-lookup"><span data-stu-id="4dc76-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="4dc76-275">Этот заголовок поддерживает все последние версии обозревателей.</span><span class="sxs-lookup"><span data-stu-id="4dc76-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="4dc76-276">Дополнительные сведения см. в разделе [IE блог](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [блоге SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), и [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="4dc76-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="4dc76-277">Среда выполнения ASP.NET Web стека может в некоторых будущих выпусков убедитесь MVC и вспомогательные методы защиты от XSRF веб-страницы автоматически устанавливается этот заголовок, чтобы приложения автоматически защищены от этой атаки.</span><span class="sxs-lookup"><span data-stu-id="4dc76-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="4dc76-278">Веб-разработчикам следует продолжить убедитесь, что является уязвимым для атак с XSS им сайта.</span><span class="sxs-lookup"><span data-stu-id="4dc76-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="4dc76-279">Предупреждения атак с XSS являются очень мощными и успешной атаке также будет нарушена эффективных средств защиты среды выполнения ASP.NET Web стека от XSRF-атак.</span><span class="sxs-lookup"><span data-stu-id="4dc76-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="4dc76-280">Подтверждение</span><span class="sxs-lookup"><span data-stu-id="4dc76-280">Acknowledgment</span></span>

<span data-ttu-id="4dc76-281">[@LeviBroderick](https://twitter.com/LeviBroderick), записавшей большую часть кода, безопасность ASP.NET большая часть этих сведений.</span><span class="sxs-lookup"><span data-stu-id="4dc76-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
