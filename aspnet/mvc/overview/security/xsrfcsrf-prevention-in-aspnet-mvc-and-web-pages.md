---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Предотвращение XSRF/CSRF в ASP.NET MVC и веб-страницы | Документы Microsoft
author: Rick-Anderson
description: Подделки межсайтовых запросов (также известный как XSRF или CSRF) — это атака, для приложений веб сервере, при котором вредоносный веб-узел может влиять на проводятся...
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6cf30daa7ed966b11405cec715c5bc803b567249
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/10/2018
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a>Предотвращение XSRF/CSRF в ASP.NET MVC и веб-страницы
====================
по [Рик Андерсон](https://github.com/Rick-Anderson)

> Запрос межсайтовой подделки (также известный как XSRF или CSRF) — это атака, для приложений веб сервере, при котором вредоносных веб-сайта могут повлиять на взаимодействие между браузером клиента и веб-сайта, которым доверяет этот браузер. Такие атаки становится возможным, так как веб-браузеры будет отправлять маркеры проверки подлинности автоматически при каждом запросе к веб-сайту. Типичный пример — файл cookie проверки подлинности, например ASP. Билет проверки подлинности форм в NET. Тем не менее веб-сайтов, которые с помощью любого механизма проверки подлинности (например, проверку подлинности Windows, Basic и т. д.) могут быть нацелены подобных атак.
> 
> Атака XSRF отличается от фишинга. Фишинг-атаках требуют взаимодействия из выбран в качестве жертвы. При атаке с фишинг вредоносный веб-узел будет имитировать целевого веб-сайта и жертвы верьте обеспечить конфиденциальную информацию злоумышленнику. При атаке XSRF обычно имеется без участия необходимые из выбран в качестве жертвы. Вместо этого он полагается на браузера, автоматически отправляя все соответствующие файлы cookie в веб-узлу.
> 
> Дополнительные сведения см. в разделе [откройте проект безопасности веб-приложения](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).


## <a name="anatomy-of-an-attack"></a>Составляющие атака

Для ознакомления с XSRF атаки, рассмотрите возможность пользователя, который хочет работать некоторые транзакции банковских операциях. Этот пользователь посещает в первую очередь WoodgroveBank.com и журналов, после чего заголовок ответа будет содержать ее файла cookie проверки подлинности:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

Так как файл cookie проверки подлинности файла cookie сеанса, он будет автоматически удалено браузером при завершении процесса браузера. Однако до этого времени браузер автоматически включит куки-файл для каждого запроса WoodgroveBank.com. Пользователю для передачи 1000 долларов на другую учетную запись, поэтому она заполнения формы на сайте банковских операций, а браузер отправляет запрос к серверу:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

Так как эта операция является побочным эффектом (запускает транзакцию денежных), на сайте банковских операций выбрала запрос HTTP POST, чтобы выполнить эту операцию. Сервер считывает токена проверки подлинности из запроса, ищет номер учетной записи текущего пользователя, проверяет, существует достаточно средств и затем запускает транзакцию в целевой учетной записью.

Ей сети банковских завершения, пользователь выходит из сайта банковских операций и посещает другие расположения в Интернете. Один из этих сайтов — fabrikam.com — включает следующую разметку страницы, внедренный в &lt;iframe&gt;:

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

В результате чего браузер для выполнения данного запроса:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

Он применяет тот факт, что пользователь по-прежнему может быть маркер аутентификации для целевого веб-сайта, и она использует небольшой фрагмент кода JavaScript в браузер, чтобы автоматически сделать HTTP POST на целевой сайт. Если маркер проверки подлинности по-прежнему допустим, на сайте банковских операций инициирует передачу 250 долл. США в учетную запись по выбору злоумышленника.

### <a name="ineffective-mitigations"></a>Неэффективной исправлений

Это интересно отметить, что в приведенном выше сценарии тем, что WoodgroveBank.com осуществлялся через SSL и имеет файл cookie проверки подлинности SSL-только слишком мал для предотвратить атаки. Злоумышленник имеет возможность указать [схема URI](http://en.wikipedia.org/wiki/URI_scheme) (https) в нее &lt;формы&gt; элемент и браузер продолжает отправлять неистекшим сроком действия файлов cookie на целевой сайт, при условии, что файлы cookie являются согласуется с URI Схема намеченной цели.

Можно утверждать, что пользователь просто не посетите ненадежных веб-сайтов, как посещения только для доверенных сайтов позволяет сети остаются в безопасном. Есть некоторые истины это, но к сожалению это требование не всегда практично. Возможно пользователя» доверяет» на сайте местных новостей ConsolidatedMessenger. ConsolidatedMessenger.com и переходит к посещение, вместо этого сайта, но этот узел имеет уязвимость XSS, что позволяет злоумышленнику вставку фрагмент кода, запущенного на fabrikam.com.

Убедитесь, что входящие запросы имеют [заголовок Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) ссылки на домен. Это остановит запросов, случайно переданных из домена сторонних разработчиков. Тем не менее некоторые пользователи отключите заголовок Referer браузера по соображениям конфиденциальности и злоумышленники иногда может подделать заголовок, если выбран в качестве жертвы имеет определенные небезопасных установлено программное обеспечение. Проверка [заголовок Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) не считается безопасным способом, предотвращая XSRF-атак.

## <a name="web-stack-runtime-xsrf-mitigations"></a>Возможные способы устранения Web XSRF стека времени выполнения

Среда выполнения ASP.NET Web стека используется вариант [синхронизатор шаблона токена](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) для защиты от XSRF-атак. Общая форма синхронизатор шаблона токена — что два маркера anti-XSRF отправляются на сервер с каждой HTTP POST (помимо токена проверки подлинности): один токен как файл cookie, а другой — как значение формы. Значения маркера, создаваемые средой выполнения ASP.NET не детерминированным или с предсказуемой злоумышленником. При отправке токенов сервера позволит запроса только в том случае, если оба маркера пройти проверку сравнения.

Запрос проверки XSRF *токена сеанса* сохраняется как файл cookie HTTP и в настоящее время содержит следующие сведения в его полезные данные:

- Маркер безопасности, состоящий из произвольного 128-разрядный идентификатор.   
 На следующем рисунке показана отображается с помощью средств разработчика Internet Explorer F12 маркер сеанса проверки XSRF запроса: (Примечание это текущая реализация, тема, даже может меняться.)

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

*Маркер поля* хранится в виде `<input type="hidden" />` и содержит следующие сведения в его полезные данные:

- Имя пользователя вошедшего в систему пользователя (если проверка подлинности).
- Любые дополнительные данные, предоставляемые [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).

Полезные данные маркеров защиты от XSRF шифруются и подписываются, поэтому имя пользователя не отображается при использовании средств для проверки токенов. При веб-приложение предназначен для ASP.NET 4.0, службы шифрования предоставляются [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) подпрограммы. При веб-приложение предназначен для ASP.NET 4.5 или более поздней версии, криптографических служб, предоставляемых [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) подпрограмму, которая предлагает более высокую производительность, расширяемости и безопасности. Узнать о следующей записи в блогах Дополнительные сведения:

- [Усовершенствования шифрования в ASP.NET 4.5, pt. 1](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [Усовершенствования шифрования в ASP.NET 4.5, pt. 2](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [Усовершенствования шифрования в ASP.NET 4.5, pt. 3](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a>Создание токенов

Для создания маркеров защиты от XSRF следует вызвать [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) метод из представления MVC или @AntiForgery.GetHtml() на странице Razor. Среда выполнения будет затем выполните следующие действия:

1. Если текущий HTTP-запрос уже содержит маркера anti-XSRF сеанса (файл cookie защиты от XSRF \_ \_RequestVerificationToken), маркер безопасности извлекается из него. Если HTTP-запроса не содержит маркера anti-XSRF сеанса или произошел сбой извлечения маркера безопасности, будет создан новый маркер случайных anti-XSRF.
2. Маркера anti-XSRF поля генерируется с использованием маркера безопасности в предыдущем шаге (1) и удостоверения текущего вошедшего в систему пользователя. (Дополнительные сведения об определении удостоверение пользователя см. в разделе **[сценариев с специальную поддержку](#_Scenarios_with_special)** разделе ниже.) Кроме того Если [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) будет настроена, среда выполнения будет вызывать его [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) метод и включать в токен поля возвращаемой строки. (См. **[конфигурации и расширяемость](#_Configuration_and_extensibility)** Дополнительные сведения.)
3. Если нового маркера anti-XSRF, созданный на шаге (1), новый маркер для него будет создана и будет добавляться в коллекцию файлов cookie HTTP-исходящих. Токен поля из пункта (2) будет вставлено в `<input type="hidden" />` элемент и эта разметка HTML будут возвращаемое значение `Html.AntiForgeryToken()` или `AntiForgery.GetHtml()`.

## <a name="validating-the-tokens"></a>Проверку маркеров

Для проверки входящих маркеров защиты от XSRF, включает разработчик [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) атрибут на ее действие MVC, контроллера или она вызывает `@AntiForgery.Validate()` из своей страницей Razor. Среда выполнения будет выполнять следующие действия:

1. Входящий токен сеанса и токен поля доступны для чтения и маркера anti-XSRF извлекается из каждого. Маркеры защиты от XSRF должны быть одинаковыми на каждом шаге (2) в процедуре создания.
2. Если текущий пользователь прошел проверку подлинности, ее имя пользователя сравнивается с именем пользователя, хранящихся в токен поля. Имена пользователей должны совпадать.
3. Если [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) настроена, среда выполнения вызывает его *ValidateAdditionalData* метод. Метод должен возвращать логическое значение, которое *true*.

Если проверка прошла успешно, запрос разрешается. Если проверка завершается неудачно, платформа будет вызывать *HttpAntiForgeryException*.

## <a name="failure-conditions"></a>Условия сбоя

Начиная с версии 2 среда ASP.NET Web стека выполнения, все *HttpAntiForgeryException* , возникающее во время проверки будет содержать подробные сведения о том, что пошло не так. Условия, определенные на текущий момент сбоя:

- Маркер сеанса или маркера формы не присутствует в запросе.
- Маркер сеанса или маркера формы не может быть прочитан. Наиболее вероятной причиной является несовпадение версий среды выполнения ASP.NET Web стека или фермы с балансированием где &lt;machineKey&gt; элемента в файле Web.config отличается между компьютерами. Можно использовать такое средство, как Fiddler принудительно это исключение, подделки либо маркера anti-XSRF.
- Маркер сеанса и токен поля были перепутаны.
- Маркер сеанса и токен поля содержат токены несоответствия безопасности.
- Имя пользователя, внедренные в маркер поля не соответствует текущего вошедшего в систему пользователя.
- *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* возвращаемое значение метода *false*.

Средства защиты от XSRF также может выполнять дополнительную проверку во время создания токенов или проверки и ошибок во время проверки может привести к созданию исключений. . В разделе [WIF и ACS или на основе утверждений проверки подлинности](#_WIF_ACS) и **[конфигурации и расширяемость](#_Configuration_and_extensibility)** разделы для получения дополнительной информации.

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a>Сценарии с специальную поддержку

### <a name="anonymous-authentication"></a>Анонимная проверка подлинности

Система защиты от XSRF содержит специальную поддержку для анонимных пользователей, где «anonymous» определяется как пользователь где *IIdentity.IsAuthenticated* возвращает *false*. Сценарии включают в себя предоставление защиты от XSRF на страницу входа (до проверки подлинности пользователя) и пользовательских схем проверки подлинности где приложение использует механизм, отличный от *IIdentity* для идентификации пользователей.

Для поддержки следующих сценариев, помните, что маркеры сеанса и поле присоединены токеном безопасности, который является 128-разрядным формируется случайным образом непрозрачным идентификатором. Маркер безопасности используется для отслеживания сеанса отдельного пользователя, как она перешла сайта, поэтому фактически служит анонимного идентификатора. Вместо имени пользователя для описанных выше процедур создания и проверки используется пустая строка.

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a>WIF и ACS или на основе утверждений проверка подлинности

Как правило *IIdentity* классы, встроенный в .NET Framework имеют свойства, *IIdentity.Name* достаточно для уникальной идентификации конкретного пользователя в пределах конкретного приложения. Например *FormsIdentity.Name* возвращает имя пользователя, который хранится в базе данных членства (которое должно быть уникальным для всех приложений, в зависимости от этой базы данных), *WindowsIdentity.Name* возвращает доменном удостоверение пользователя и т. д. Эти системы обеспечивают не только проверка подлинности; они также *идентификации* пользователям приложения.

Проверка подлинности на основе утверждений, с другой стороны, не требует обязательного идентификации конкретного пользователя. Вместо этого *ClaimsPrincipal* и *ClaimsIdentity* типы связаны с набором *утверждения* экземпляров, где отдельных утверждений может быть «is 18 + лет» или» является администратором» для других действий. Поскольку пользователь не обязательно определена, среда выполнения не может использовать *ClaimsIdentity.Name* свойство как уникальный идентификатор для данного пользователя. Команда замеченных примеров, где *ClaimsIdentity.Name* возвращает *null*, возвращает имя понятного имени (отображение) или в противном случае возвращает строку, которая не подходит для использования в качестве уникального идентификатора для пользователя.

Многие из развертываний, которые используют проверку подлинности на основе утверждений используется [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) в частности. ACS позволяет разработчикам настраивать отдельные *Поставщики удостоверений* (такие как ADFS, поставщик учетной записи Майкрософт поставщиков OpenID, например Yahoo!, т. д.), и Поставщики удостоверений, которые возвращают *имя идентификаторы*. Эти идентификаторы имя может содержать личные сведения (PII) как адрес электронной почты, или может быть анонимен как частным личным идентификатором (PPID). Независимо от того, кортеж (поставщика удостоверений, идентификатора имени) достаточно служит в качестве маркера соответствующие отслеживания для конкретного пользователя во время она поиск по сайту, так что среда выполнения ASP.NET Web стека можно использовать кортеж вместо имени пользователя при создании и проверки маркеров защиты от XSRF поля. Определенный URI для поставщика удостоверений и идентификатор имени:

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

(см. в этом [ACS doc страницы](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) Дополнительные сведения.)

При создании или проверке токена, среда выполнения ASP.NET Web стека во время выполнения попытается привязки к типам:

- `Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (Для WIF SDK.)
- `System.Security.Claims.ClaimsIdentity` (Для .NET Framework 4.5).

Если такие существуют и в том случае, если текущий пользователь *IIIIdentity* реализует или подклассы один из этих типов, будет использовать средство защиты от XSRF (поставщика удостоверений, идентификатора имени) кортежа вместо имени пользователя, при создании и Проверка токены. Если присутствует нет таких кортежей, запрос будет завершаться ошибкой, описывают разработчику для настройки системы защиты от XSRF для понимания механизм конкретной проверки подлинности на основе утверждений используется. В разделе **[конфигурации и расширяемость](#_Configuration_and_extensibility)** Дополнительные сведения.

### <a name="oauth--openid-authentication"></a>OAuth или OpenID проверки подлинности

Наконец средство защиты от XSRF имеет специальную поддержку для приложений, которые используют проверку подлинности OAuth или OpenID. Эта поддержка основана на эвристический: если текущий *IIdentity.Name* начинается с http:// или https://, а затем будет выполнено сравнение имени пользователя с помощью компаратор порядковый номер, а не функцию сравнения по умолчанию OrdinalIgnoreCase.

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a>Конфигурации и расширяемость

В некоторых случаях разработчикам может потребоваться строгий контроль над созданием anti-XSRF и поведения проверки. Например может быть нежелательно MVC и веб-страницы помощников по умолчанию автоматически добавить файлы cookie HTTP в ответ и разработчик может потребоваться сохранить токены в другом месте. Существует два API, чтобы это:

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

*GetTokens* метод принимает в качестве входного существующего XSRF запрос проверки сеанса маркера (который может иметь значение null) и выводит как выходные нового маркера сеанса проверки XSRF запроса и маркер поля. Токены являются просто непрозрачные строки без оформления; *formToken* значение для экземпляра не будет переноситься в &lt;ввода&gt; тег. *NewCookieToken* значение может иметь значение null; в этом случае то *oldCookieToken* значение все еще действителен, и требуется задать не cookie нового отклика. Код, вызывающий *GetTokens* отвечает за сохранение все файлы cookie, необходимые ответа или создания любой необходимой разметки; *GetTokens* сам метод не может изменить ответа в качестве побочного эффекта. *Проверки* метод принимает входящий сеанс, а поле маркеры и выполняет логику проверки в упомянутой выше над ними.

### <a name="antiforgeryconfig"></a>AntiForgeryConfig

Разработчик может настроить систему защиты от XSRF из приложения\_запуска. Конфигурация — программный. Свойства статических *AntiForgeryConfig* тип описаны ниже. Большинство пользователей, используя утверждения может потребоваться задать свойство UniqueClaimTypeIdentifier.

| **Свойство** | **Описание** |
| --- | --- |
| **AdditionalDataProvider** | [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , предоставляющий дополнительные данные во время создания токенов и потребует дополнительных данных во время проверки токена. Значение по умолчанию — *null*. Дополнительные сведения см. в разделе [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) раздела. |
| **CookieName** | Строка, представляющая имя файла cookie HTTP, который используется для хранения маркера anti-XSRF сеанса. Если это значение не задано, имя будет автоматически сформировано, основываясь на развернутой виртуальный путь приложения. Значение по умолчанию — *null*. |
| **RequireSsl** | Значение типа Boolean, который определяет, требуются ли маркеров защиты от XSRF для отправки через канал SSL-защитой. Если это значение равно *true*, все файлы cookie, автоматически создается будет установлен флаг «безопасность», и интерфейсы API защиты от XSRF вызывает исключение при вызове из внутри запроса, не отправляется через SSL. Значение по умолчанию — *false*. |
| **SuppressIdentityHeuristicChecks** | Значение типа Boolean, который определяет, следует ли система защиты от XSRF отключить поддержку удостоверений, основанных на утверждениях. Если это значение равно *true*, система предполагается, что *IIdentity.Name* подходит для использования в качестве идентификатора уникального пользователя и не будет пытаться особой *IClaimsIdentity*или *ClClaimsIdentity* как описано в [WIF и ACS или на основе утверждений проверка подлинности](#_WIF_ACS) раздела. Значение по умолчанию — `false`. |
| **UniqueClaimTypeIdentifier** | Строка, указывающая, какие утверждения введите подходит для использования в качестве идентификатора уникального пользователя. Если это значение равно набор и текущий *IIdentity* на базе утверждений, система попытается извлечь утверждения типа определяется *UniqueClaimTypeIdentifier*, и соответствующее значение будет использоваться вместо пользователя при создании токен поля. Если тип утверждения не найден, система отклонит запрос. Значение по умолчанию — *null*, указывающая, что система должна использовать (поставщика удостоверений, идентификатора имени) кортежа, как описано выше вместо пользователя. |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a>IAntiForgeryAdditionalDataProvider

*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* типа позволяет разработчикам расширять поведение системы защиты от XSRF с циклической обработки дополнительных данных в каждом маркере. *GetAdditionalData* при каждом вызове метода создается маркер поля, и возвращаемое значение внедряется в созданный токен. Разработчик может вернуть отметку времени, nonce или любое другое значение, которое она хочет из этого метода.

Аналогичным образом *ValidateAdditionalData* метод вызывается каждый раз проверяется токен поля, и строка «дополнительные данные», внедренные в маркер передается в метод. Процедуры проверки может реализовать тайм-аут (путем проверки текущее время от времени, которое было сохранено при создании токена), nonce проверка подпрограммы или любой другой требуемого логику.

## <a name="design-decisions-and-security-considerations"></a>Проектные решения и вопросы безопасности

Маркер безопасности, который связывает токенов сеанса и поля требуется технически только при попытке защитить анонимные или не прошедшие проверку подлинности пользователей от XSRF-атак. При проверке подлинности пользователя, маркер проверки подлинности самого (которые можно отправить в форме куки-файла) можно использовать в качестве одной половины синхронизатор токен пары. Тем не менее существует допустимое сценариев для защиты страницы входа в систему выполнен щелчок непроверенных пользователей и защиты от XSRF логику его проще всегда создается и проверки маркера безопасности, даже для прошедших проверку пользователей. Он также предоставляет некоторую дополнительную защиту в случае, если токен поля будет скомпрометирован злоумышленником, как установка или угадывания маркера сеанса будет другая проблема преодолеть злоумышленником.

Разработчикам следует проявлять осторожность, когда несколько приложений размещаются в одном домене. Например несмотря на то что *example1.cloudapp.net* и *example2.cloudapp.net* находятся на разных узлах есть неявные доверительные отношения между все узлы на  *\*. cloudapp.net* домена. Неявные отношения доверия между [позволяет узлам потенциально небезопасных влияет на файлы cookie друг друга](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (политики одного источника, которые управляют запросы AJAX неприменимы обязательно для файлов cookie HTTP). Среда выполнения ASP.NET Web стека предоставляет некоторые устранение рисков тем, что имя пользователя, внедряется в токен поля, таким образом, даже если вредоносный поддомен возможность перезаписывать маркер сеанса его не удалось создать маркер допустимого поля для пользователя. Тем не менее при размещении в такой среде подпрограммы встроенной защиты от XSRF по-прежнему не может защитить от захвата сеанса или имя входа XSRF.

Процедуры защиты от XSRF в настоящее время не защиту от [clickjacking](https://www.owasp.org/index.php/Clickjacking). Приложения, которые нужно защитить себя от clickjacking может легко сделать, отправляя X-Frame-Options: заголовок SAMEORIGIN с каждым ответом. Этот заголовок поддерживает все последние версии обозревателей. Дополнительные сведения см. в разделе [IE блог](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [блоге SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), и [OWASP](https://www.owasp.org/index.php/Clickjacking). Среда выполнения ASP.NET Web стека может в некоторых будущих выпусков убедитесь MVC и вспомогательные методы защиты от XSRF веб-страницы автоматически устанавливается этот заголовок, чтобы приложения автоматически защищены от этой атаки.

Веб-разработчикам следует продолжить убедитесь, что является уязвимым для атак с XSS им сайта. Предупреждения атак с XSS являются очень мощными и успешной атаке также будет нарушена эффективных средств защиты среды выполнения ASP.NET Web стека от XSRF-атак.

## <a name="acknowledgment"></a>Подтверждение

[@LeviBroderick](https://twitter.com/LeviBroderick), записавшей большую часть кода, безопасность ASP.NET большая часть этих сведений.
