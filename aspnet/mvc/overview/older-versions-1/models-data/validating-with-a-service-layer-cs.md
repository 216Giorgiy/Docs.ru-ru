---
uid: mvc/overview/older-versions-1/models-data/validating-with-a-service-layer-cs
title: "Проверка с помощью на уровне службы (C#) | Документы Microsoft"
author: StephenWalther
description: "Узнайте, как переместить логику проверки из действия контроллера и в слой отдельной службе. В этом учебнике объясняется Стивен Вальтер как вы..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/02/2009
ms.topic: article
ms.assetid: 4eabc535-b8a1-43f5-bb99-cfeb86db0fca
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/models-data/validating-with-a-service-layer-cs
msc.type: authoredcontent
ms.openlocfilehash: f36301aef4377c6c00cb4fc33dbc5c57b1c426a9
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="validating-with-a-service-layer-c"></a>Проверка с помощью на уровне службы (C#)
====================
по [Стивен Вальтер](https://github.com/StephenWalther)

> Узнайте, как переместить логику проверки из действия контроллера и в слой отдельной службе. В этом учебнике Стивен Вальтер объясняется, как обеспечить острым Разделение областей ответственности изоляция на уровне службы из вашего уровня контроллера.


Целью данного учебника является описание один из способов проверки в приложении ASP.NET MVC. В этом учебнике вы узнаете, как переместить логику проверки из контроллеров и отправляются на уровне отдельных службы.

## <a name="separating-concerns"></a>Отделение проблемы

При создании приложения ASP.NET MVC, логику базы данных не следует помещать внутри действия контроллера. Смешивание логику базы данных и контроллера усложняет приложение для поддержания со временем. Рекомендуется поместить все логики базы данных на уровне отдельных репозитория.

Например список 1 содержит простой репозиторий с именем ProductRepository. Репозиторий продукта содержит все код доступа к данным для приложения. Список также включает интерфейс IProductRepository, который реализует хранилище продукта.

**1 — Models\ProductRepository.cs со списком**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample1.cs)]

Контроллер в списке 2 использует уровня репозитория Index() и Create() действий. Обратите внимание, что данный контроллер не содержит логику базы данных. Создание уровня хранилища позволяет поддерживать четкое разделение областей ответственности. Контроллеры отвечают за логику управления потоком приложения и репозитория отвечает за логики доступа к данным.

**Листинг 2 - Controllers\ProductController.cs**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample2.cs)]

## <a name="creating-a-service-layer"></a>Создание уровня службы

Таким образом приложения потока управления располагается в контроллере и принадлежит логики доступа к данным в репозитории. В этом случае, где размещен свою логику проверки? Первый вариант — разместить логику проверки в *уровень службы*.

На уровне службы представляет собой дополнительный уровень в приложении ASP.NET MVC, который является посредником связи между контроллером и уровня репозитория. Уровень службы содержит бизнес-логики. В частности он содержит логику проверки.

Например уровень службы продукта в списке 3 имеет метод CreateProduct(). Метод CreateProduct() вызывает метод ValidateProduct(), чтобы проверить новый продукт перед передачей продукта в репозитории продукта.

**Листинг 3 - Models\ProductService.cs**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample3.cs)]

Контроллер продукта был обновлен в листинге 4 для использования вместо уровня репозитория уровня службы. Обсуждения слоя контроллера до уровня службы. Уровень служб обращается к уровня репозитория. Каждый уровень имеет отдельный ответственности.

**Листинг 4 - Controllers\ProductController.cs**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample4.cs)]

Обратите внимание, что службы продукта создается в конструктор контроллера продукта. При создании службы продукта в словарь состояния модели передается в службу. Обновления продукта состояние модели используется для передачи сообщений об ошибках проверки на контроллер.

## <a name="decoupling-the-service-layer"></a>Отделение уровень службы

Изолировать контроллера и слои службы в одном — произошел сбой. Контроллер и слои службы взаимодействуют через состояние модели. Другими словами уровень службы имеет зависимость от определенной функции платформы ASP.NET MVC.

Мы хотим изолировать уровень службы из наших максимально уровня контроллера. В теории мы должны иметь возможность использовать уровень службы с любым типом приложения, а не только приложение ASP.NET MVC. Например в дальнейшем может потребоваться для построения переднего плана для нашего приложения WPF. Мы должны найти состояние модели способ удалить зависимость от ASP.NET MVC из наших уровня службы.

В листинге 5 уровня службы, была обновлена, чтобы он больше не использует состояние модели. Вместо этого он использует любой класс, реализующий интерфейс IValidationDictionary.

**Список 5 - Models\ProductService.cs (связано)**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample5.cs)]

Интерфейс IValidationDictionary определен в 6 со списком. Этот простой интерфейс имеет один метод и одного свойства.

**Перечисление 6 - Models\IValidationDictionary.cs**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample6.cs)]

Класс в список 7, с именем класса ModelStateWrapper, реализующий интерфейс IValidationDictionary. Можно создать экземпляр класса ModelStateWrapper, передав конструктору словарь состояния модели.

**Листинг 7 - Models\ModelStateWrapper.cs**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample7.cs)]

Наконец обновленный контроллер в листинг 8 использует ModelStateWrapper при создании уровня службы в конструкторе.

**8 - Controllers\ProductController.cs со списком**

[!code-csharp[Main](validating-with-a-service-layer-cs/samples/sample8.cs)]

С помощью IValidationDictionary интерфейс и класс ModelStateWrapper позволяет полностью изолировать уровень нашей службы из наших уровня контроллера. Уровень службы больше не зависит от состояния модели. Можно передать любой класс, реализующий интерфейс IValidationDictionary до уровня службы. Например приложение WPF может реализовывать интерфейс IValidationDictionary с класс простой коллекции.

## <a name="summary"></a>Сводка

Целью данного учебника было обсудить один из подходов к проверке в приложении ASP.NET MVC. В этом учебнике вы узнали, как перемещение всех логики проверки из контроллеров и отправляются на уровне отдельных службы. Вы также узнали, как изоляция на уровне службы из вашего уровня контроллера, создав класс ModelStateWrapper.

>[!div class="step-by-step"]
[Назад](validating-with-the-idataerrorinfo-interface-cs.md)
[Вперед](validation-with-the-data-annotation-validators-cs.md)
