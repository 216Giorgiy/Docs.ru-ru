---
uid: mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
title: "Используйте ViewData и реализуйте ViewModel классы | Документы Microsoft"
author: microsoft
description: "Шаг 6 показано, как включить поддержка более полных форм изменение сценариев, а также рассматриваются два подхода, которые могут использоваться для передачи данных из контроллеры с представлениями:..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2010
ms.topic: article
ms.assetid: 5755ec4c-60f1-4057-9ec0-3a5de3a20e23
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
msc.type: authoredcontent
ms.openlocfilehash: 36b9e87cc24f74f7f2cc592afb5102709b598f74
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="use-viewdata-and-implement-viewmodel-classes"></a>Используйте ViewData и реализуйте ViewModel классы
====================
по [Microsoft](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это бесплатная шага 6 [учебника «Обновление NerdDinner» приложения](introducing-the-nerddinner-tutorial.md) , обходов сквозной как построить небольшой, но завершается веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 6 показано, как включить поддержка более полных форм изменение сценариев, а также рассматриваются два подхода, которые могут использоваться для передачи данных из контроллеры с представлениями: ViewData и ViewModel.
> 
> При использовании ASP.NET MVC 3, которому рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-6-viewdata-and-viewmodel"></a>Обновление NerdDinner шаг 6: ViewData и ViewModel

Мы внесли рассматривается несколько сценариев post формы и описано, как реализовать создания, обновления и удаления (CRUD) поддержки. Теперь мы предпринять дальнейшие реализацию DinnersController и обеспечить поддержку редактирования сценариев более полных форм. При этом мы обсудим двух подходов, которые можно использовать для передачи данных из контроллеры с представлениями: ViewData и ViewModel.

### <a name="passing-data-from-controllers-to-view-templates"></a>Передача данных из контроллеров шаблонов представлений

Одна из определяющие характеристики шаблона MVC — strict «Разделение областей ответственности» он помогает обеспечивать между различными компонентами приложения. Модели, контроллеры и представления каждой иметь хорошо определенные роли и обязанности и они взаимодействовать между собой явно определенными способами. Это помогает повысить уровень тестирования и повторное использование кода.

Если класс контроллера решит для отрисовки HTML-ответе клиенту, он отвечает явным образом передать Просмотр шаблона, все данные, необходимые для визуализации в ответ. Просмотр шаблонов никогда не будет выполнять любые данные извлечения или приложение логики — и вместо этого следует ограничить их можно иметь только код отрисовки, основано на модели и данные, передаваемые его контроллером.

В данный момент данные модели, передаваемым по нашей DinnersController класс для наших шаблонов представлений является простой и последовательных — список объектов Dinner в случае Index() и один Dinner объекта в случае Details(), Edit(), Create() и Delete(). Как добавить дополнительные возможности пользовательского интерфейса приложения, часто будет необходимо передать не только эти данные для визуализации HTML ответы в наших шаблонов представлений. Например может потребоваться изменение поля «Страна» в наших редактирования и создание представления не текстовое поле HTML в dropdownlist. Вместо того чтобы жестко раскрывающемся списке названия стран в шаблоне представления необходимо создать его из списка поддерживаемых странах, мы заполнять в динамическом режиме. Нам понадобится для передачи объекта Dinner *и* список поддерживаемых странах из наших контроллера для наших шаблонов представлений.

Давайте рассмотрим мы это можно сделать двумя способами.

### <a name="using-the-viewdata-dictionary"></a>Используя словарь ViewData

Базовый класс контроллера предоставляет свойство словаря «ViewData», который может использоваться для передачи дополнительных данных элементов из контроллеры с представлениями.

Например для поддержки сценариев, где мы хотим изменить текстовое поле «Страна» в нашем представления изменения сборщику текстовое поле HTML в dropdownlist можно обновить метод действия нашей Edit() для передачи (в дополнение к объект Dinner) SelectList объект, который можно использовать в качестве m одели dropdownlist странах.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample1.cs)]

Конструктор выше SelectList принимает список округов, для заполнения downlist drop с, а также текущее выбранное значение.

Затем можно изменить шаблон представления нашей Edit.aspx использование вспомогательного метода Html.DropDownList() вместо Html.TextBox() вспомогательный метод, который мы использовали ранее:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample2.aspx)]

Вспомогательный метод Html.DropDownList() выше принимает два параметра. Первый аргумент — имя HTML-элемента формы для вывода. Второе — мы переданных через словарь ViewData модели «SelectList». Мы используем C# ключевое слово «as» для приведения типа в словаре как SelectList.

А теперь когда мы запускаем нашей доступа к приложениям и */Dinners/Edit/1* URL-адрес в наш обозреватель мы увидим, наши изменения пользовательского интерфейса был обновлен для отображения dropdownlist стран вместо текстового поля:

![](use-viewdata-and-implement-viewmodel-classes/_static/image1.png)

Поскольку мы также отображают шаблон редактирования представление из метода изменить HTTP POST (в сценарии при возникновении ошибок), мы имеет смысл убедитесь, что мы также обновить этот метод, чтобы добавить SelectList ViewData при подготовке к просмотру Просмотр шаблона в сценариях, ошибка:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample3.cs)]

А теперь поддерживает DropDownList в нашем сценарии DinnersController редактирования.

### <a name="using-a-viewmodel-pattern"></a>С помощью шаблона ViewModel

Такой подход словарь ViewData имеет преимущество довольно быстро и легко реализовать. Некоторые разработчики не нравится словарей на основе строки, с помощью менее, поскольку опечаток может привести к ошибкам, которые не будут перехватываться во время компиляции. Нетипизированные словарь ViewData также требуется с помощью оператора «как» или приведение при использовании строго типизированным языком такими как C# в шаблоне представления.

Альтернативный подход, который можно использовать понимается часто обозначается как шаблон «ViewModel». При использовании этого шаблона создается строго типизированные классы, оптимизированных для сценариев определенных представлений, который предоставляют свойства для динамического значения или содержимого, необходимые для наших шаблонов представлений. Наши классы контроллера можно заполнить и передать нашей Просмотр шаблона для использования этих классов, оптимизированными для представления. Это позволяет безопасность типа, проверка во время компиляции и intellisense редактора внутри шаблонов представлений.

Например, чтобы разрешить форм dinner редактирования сценариев, можно создать «DinnerFormViewModel» класса как ниже, обладает двумя свойствами строго типизированных: объект Dinner и SelectList модели, необходимые для заполнения dropdownlist страны:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample4.cs)]

Мы обновите метод действия нашей Edit() создание DinnerFormViewModel, с помощью Dinner объекта, к которому получен от нашем репозитории и затем передавать его нашей Просмотр шаблона:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample5.cs)]

Мы будем то нашей Просмотр шаблона, что он ожидает «DinnerFormViewModel» вместо «Dinner» объекта, изменив атрибут «inherits» в верхней части страницы edit.aspx обновления следующим образом:

[!code-cshtml[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample6.cshtml)]

После этого, intellisense свойство «Модель» в нашем Просмотр шаблона будут обновлены в соответствии с моделью объектов типа DinnerFormViewModel, мы передаем:

![](use-viewdata-and-implement-viewmodel-classes/_static/image2.png)

![](use-viewdata-and-implement-viewmodel-classes/_static/image3.png)

Затем можно обновлять наши Просмотр кода для работы от его. Обратите внимание ниже как мы не меняют имена элементов ввода мы создаем (элементы формы будет по-прежнему называться «Title», «Страна») —, но мы обновляем HTML вспомогательные методы для получения значений, с помощью класса DinnerFormViewModel:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample7.aspx)]

Также мы обновим наши метода post редактирования при подготовке к просмотру ошибок с помощью класса DinnerFormViewModel:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample8.cs)]

Мы также можно обновить наши методы действий Create() для повторного использования точно таким же *DinnerFormViewModel* класса для включения стран DropDownList в тех также. Ниже приведен реализация HTTP-GET.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample9.cs)]

Ниже приведен реализацию метода создания HTTP POST.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample10.cs)]

И изменить и создать экранам поддерживают раскрывающихся списках для выбора страны.

### <a name="custom-shaped-viewmodel-classes"></a>Custom образный ViewModel классы

В приведенном выше сценарии нами класса DinnerFormViewModel напрямую предоставляет объект модели Dinner как свойства, включая вспомогательные свойство модели SelectList. Этот подход хорошо работает для сценариев, где пользовательского интерфейса HTML, необходимо создать в нашем Просмотр шаблона соответствует относительно тесно нашей объектами модели домена.

Для сценариев, где это не так, можно использовать только один параметр является создание класс ViewModel были сформированы настраиваемый которого объектной модели более оптимизированы для использования с представление — и которого может выглядеть совершенно отличаются от объекта модели домена. Например потенциально подвергает разные имена свойств и свойства статистических выражений, собранных из нескольких объектов модели.

Custom образный ViewModel классы могут быть используется и для передачи данных из контроллеров представления для отображения, а также для обработки данных формы, отправляемая метод действия контроллера. В этом сценарии более поздней версии может потребоваться метод действия обновления объекта ViewModel данными отправки формы, а затем использовать ViewModel экземпляр для сопоставления или извлечении объекта модели домена.

Были сформированы пользовательские классы ViewModel может предоставить большую гибкость и немного исследовать каждый раз, когда поиска в коде отрисовки в шаблоны представления или формы учета код внутри начиная слишком усложнять методов действия. Часто это является признаком, модели домена не соответствуют полностью при создании пользовательского интерфейса, и что промежуточный класс ViewModel форму пользовательского может помочь.

### <a name="next-step"></a>Следующий шаг

Теперь взглянем на как можно использовать частичными репликами и главных страниц для повторного использования и совместное использование пользовательского интерфейса в приложении.

>[!div class="step-by-step"]
[Назад](provide-crud-create-read-update-delete-data-form-entry-support.md)
[Вперед](re-use-ui-using-master-pages-and-partials.md)
