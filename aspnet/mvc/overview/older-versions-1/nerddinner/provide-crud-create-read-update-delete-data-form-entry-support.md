---
uid: mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
title: Укажите CRUD (Создание, чтение, обновление и удаление) данных образуют запись поддержки | Документы Microsoft
author: microsoft
description: Шаг 5 показано, как выполнить включение поддержки для редактирования, создание и удаление ужинов с ним также нами класса DinnersController.
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2010
ms.topic: article
ms.assetid: bbb976e5-6150-4283-a374-c22fbafe29f5
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
msc.type: authoredcontent
ms.openlocfilehash: bd906282db5c620476966ffbe09cecb5ade66ee4
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30876752"
---
<a name="provide-crud-create-read-update-delete-data-form-entry-support"></a>Укажите CRUD (Создание, чтение, обновление и удаление) данных образуют запись поддержки
====================
по [Microsoft](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 5 бесплатных [учебника «Обновление NerdDinner» приложения](introducing-the-nerddinner-tutorial.md) , обходов сквозной как построить небольшой, но завершается веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 5 показано, как выполнить включение поддержки для редактирования, создание и удаление ужинов с ним также нами класса DinnersController.
> 
> При использовании ASP.NET MVC 3, которому рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-5-create-update-delete-form-scenarios"></a>Обновление NerdDinner шаг 5: Создание, обновление и удаление сценарии формы

Мы появились контроллеры и представления и описаны способы его использования для реализации более сведения о вхождении возможности для ужинов на сайте. Следующим шагом будет предпринимать никаких дополнительных нами класса DinnersController и обеспечить поддержку редактирования, создание и удаление ужинов с ним также.

### <a name="urls-handled-by-dinnerscontroller"></a>URL-адресов, обрабатываемых DinnersController

Ранее мы добавили методы действий в DinnersController, реализована поддержка двух URL-адресов: */Dinners* и */Dinners/подробности / [id]*.

| **URL** | **VERB** | **Назначение** |
| --- | --- | --- |
| */Dinners/* | GET | Отобразить список предстоящих ужинов в HTML. |
| */Dinners/Details/[id]* | GET | Отображение сведений о конкретных обед. |

Теперь добавим методы действий для реализации трех дополнительных URL-адресов: <em>/Dinners/Edit / [id], / ужинов/Create,</em>и<em>/Dinners/Delete / [id]</em>. Эти URL-адреса будет включить поддержку редактирования существующих ужинов, создание новых ужинов и удаление ужинов.

Поддерживаются взаимодействия команду HTTP GET и HTTP POST с эти новые URL-адреса. Запросы HTTP GET в URL-адресов будет отображаться исходное представление HTML данные (заполняется данными компании Dinner в случае «edit» формы, пустую форму, в случае с «Создание» и экран подтверждения удаления в случае «удалить»). HTTP-запросы POST для этих URL-адресов будет сохранение, обновление и удаление данных компании Dinner в нашем DinnerRepository (и из нее в базу данных).

| **URL** | **VERB** | **Назначение** |
| --- | --- | --- |
| */Dinners/Edit/[id]* | GET | Отображение заполняются данными компании Dinner формы для редактирования HTML. |
| ПОМЕСТИТЬ | Сохраните изменения формы для конкретной компании Dinner в базу данных. |
| */Dinners/Create* | GET | Отображение пустой HTML-формы, пользователи могут определять новые ужинов. |
| ПОМЕСТИТЬ | Создайте новый Dinner и сохраните его в базе данных. |
| */Dinners/Delete/[id]* | GET | Запрашивать удаление экран подтверждения. |
| ПОМЕСТИТЬ | Удаляет указанный dinner из базы данных. |

### <a name="edit-support"></a>Изменения поддержки

Начнем с реализации сценария «edit».

#### <a name="the-http-get-edit-action-method"></a>Метод HTTP-GET изменение действия

Мы начнем путем реализации HTTP «GET» поведение нашей редактирования метода действия. Этот метод будет вызываться при */Dinners/Edit / [id]* запрошенный URL-адрес. Наше решение будет выглядеть как:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample1.cs)]

Приведенный выше код использует DinnerRepository для извлечения объекта обед. Затем он отображает шаблон представления с помощью объекта Dinner. Поскольку мы еще не передается явно имя шаблона для *View()* вспомогательный метод, он использует путь по умолчанию на основе соглашения о разрешить просмотр шаблона: /Views/Dinners/Edit.aspx.

Теперь создадим этого шаблона представления. Мы сделаем это, щелкнув правой кнопкой мыши внутри метода редактирования и выбрав из контекстного меню команду «Добавить представление»:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image1.png)

В диалоговом окне «Добавление представления» здесь мы указываем мы производится передача объекта Dinner нашей представление шаблон в качестве своей модели и выбрать шаблон «Изменить» auto-формирования шаблонов:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image2.png)

При нажатии кнопки «Добавить», Visual Studio добавит новый файл шаблона «Edit.aspx» представление нам в каталоге «\Views\Dinners». Он также будет открыт новый шаблон представления «Edit.aspx» внутри редактора кода — заполняется начальной «Изменить» формирования шаблонов реализации как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image3.png)

Давайте внести некоторые изменения, чтобы по умолчанию «изменить» формирования шаблонов создается и обновить представление шаблона редактирования содержимого страницы (которая удаляет несколько свойств, которые мы не хотим предоставлять):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample2.aspx)]

Когда мы запускаем приложения и запроса *«/ ужинов/Edit/1»* URL-адрес, мы увидим со следующей страницы:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image4.png)

HTML-разметка, созданных нашей представление выглядит как ниже. Это стандартный код HTML — с &lt;формы&gt; элемент, который выполняет операцию HTTP POST */Dinners/Edit/1* URL-адрес при «Сохранить» &lt;тип входных данных = «отправить» /&gt; нажатия кнопки. HTML &lt;тип входных данных = «text» или&gt; элемент был выходные данные для каждого свойства, редактируемые:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image5.png)

#### <a name="htmlbeginform-and-htmltextbox-html-helper-methods"></a>Html.BeginForm() и Html.TextBox() Html вспомогательные методы

Наш шаблон представления «Edit.aspx» использует несколько методов «Вспомогательный метод Html»: Html.ValidationSummary(), Html.BeginForm(), Html.TextBox() и Html.ValidationMessage(). Помимо создания HTML-разметка для нас эти вспомогательные методы предоставляют обработка встроенных ошибок и проверка поддержки.

##### <a name="htmlbeginform-helper-method"></a>Вспомогательный метод Html.BeginForm()

Вспомогательный метод Html.BeginForm() является какие выходные данные HTML &lt;формы&gt; элемент в разметку. В нашем Edit.aspx Просмотр шаблона вы заметите, что применяется оператор «using» при использовании этого метода C#. Указывает, открывающей фигурной скобки в начало &lt;формы&gt; содержимого и закрывающую фигурную скобку является то, что указывает на конец &lt;/form&gt; элемента:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample3.cs)]

Кроме того Если оператор «using» подход искусственных для сценария следующим образом, можно использовать сочетание Html.BeginForm() и Html.EndForm() (что делает то же самое):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample4.aspx)]

Вызов Html.BeginForm() без параметров приведет к его выходных элементов формы, выполняющий запрос HTTP POST на URL-адрес текущего запроса. Т. е. Почему наши представления изменения приводит к возникновению ошибки *&lt;действия формы = «/ ужинов/Edit-1» метода = «post»&gt;* элемента. Мы может также передается явно параметров Html.BeginForm() чтобы учесть различные URL-адреса.

##### <a name="htmltextbox-helper-method"></a>Вспомогательный метод Html.TextBox()

Наш Edit.aspx представление использует вспомогательный метод Html.TextBox() для вывода &lt;тип входных данных = «text» или&gt; элементов:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample5.aspx)]

Описанный выше метод Html.TextBox() принимает один параметр — используется для указания имен и идентификаторов атрибутов из &lt;тип входных данных = «text» или&gt; выходные данные, а также свойство модели для заполнения значения текстового поля из элемента. Например, объект Dinner Мы передали представления изменения имеет значение «Title» свойства «Фьючерсов .NET» и поэтому наши метод Html.TextBox("Title") вызовов выходные данные: *&lt;входа с идентификатором = «Title» имя = «Title» тип = значение «text» = «Фьючерсов .NET» или&gt;*.

Кроме того можно использовать первый параметр Html.TextBox() для задания имени и идентификатора элемента и явным образом передать в значение, используемое в качестве второго параметра:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample6.aspx)]

Часто нам потребуется выполнить настраиваемое форматирование на значение, которое представляет выходные данные. Статический метод String.Format() встроены в .NET полезно в следующих случаях. Наш Edit.aspx Просмотр шаблона использует это для форматирования значения EventDate (с типом DateTime), чтобы он не показывает секунд, время:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample7.aspx)]

Третий параметр Html.TextBox() также можно использовать для вывода дополнительных атрибутов HTML. Фрагмент кода ниже показано, как для подготовки к просмотру дополнительный объем = «30» атрибута и класс = атрибут «mycssclass» на &lt;тип входных данных = «text» или&gt; элемент. Обратите внимание на то, как мы экранирование имя атрибута класса с помощью «@" character because "класса» является зарезервированным словом в C#:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample8.aspx)]

#### <a name="implementing-the-http-post-edit-action-method"></a>Реализация метода действия редактирования HTTP POST

Теперь у нас есть HTTP-GET версии наших изменить действие метода реализации. Когда пользователь запрашивает */Dinners/Edit/1* URL-адрес, они получают HTML-страницы следующим образом:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image6.png)

Нажатие кнопки «Сохранить» вызывает отправку формы */Dinners/Edit/1* URL-адрес, и отправляет HTML &lt;ввода&gt; форме значения, с помощью команды HTTP POST. Теперь рассмотрим процедуру внедрения поведение HTTP POST метода действия нашей редактирования — которой обрабатывающий сохранение компании Dinner.

Для начала рассмотрим путем добавления перегруженного метода действия «Изменить» для наших DinnersController, имеющего атрибут «AcceptVerbs» на нем, показывающее, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample9.cs)]

При применении атрибута [AcceptVerbs] действие перегруженные методы, ASP.NET MVC автоматически обрабатывает диспетчеризации запросы для соответствующего метода действия в зависимости от входящего HTTP-команду. Запросы HTTP POST <em>/Dinners/Edit / [id]</em> URL-адреса будет отправлена выше редактирования метода при всех остальных HTTP-команд запросов <em>/Dinners/Edit / [id]</em>URL-адреса переходит первый метод редактирования мы реализовали (которые были не имеет атрибута [AcceptVerbs]).

| **Раздел стороны: Почему отличить через HTTP-команды?** |
| --- |
| Вы можете задать вопрос — Почему мы, с помощью одного URL-адрес и запоминающихся его поведение через HTTP-команду? Почему нельзя иметь две разные URL-адреса для обработки, загрузки и сохранения изменений редактирования? Например: /Dinners/Edit / [id] для отображения исходной формы и /Dinners/Save / [id] для обработки формы post, чтобы сохранить его? С публикации две разные URL-адреса недостатком является то, что в случаях, где мы отправкой /Dinners/Save/2, а затем нужно отобразить HTML-формы из-за ошибок ввода, конечному пользователю будет образоваться ужинов/Save/2 URL-адрес в адресной строке браузера (так как это было URL-адрес формы учитывается). Если конечному пользователю закладки здесь redisplayed Избранное их браузера или копирование и вставка URL-адрес и отправляет его другому пользователю, будет заканчиваться сохранение URL-адрес, не будут работать в будущем (с момента этого URL-адреса зависит от значения отправки). Предоставляя один URL-адрес (например: /Dinners/Edit/[id]) и запоминающихся его обработки командой HTTP, можно безопасно для конечных пользователей к bookmark страницы правки и/или отправить другим пользователям URL-адрес. |

#### <a name="retrieving-form-post-values"></a>Получение значения отправки формы

Существует множество способов можно обратиться к учтена параметров формы в нашем метода HTTP POST «Изменить». Один простой подход является просто использовать свойство Request в базовом классе контроллера для доступа к коллекции форм и непосредственно получить переданные значения:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample10.cs)]

Описанный подход немного verbose, особенно в том случае, когда мы добавляем логику обработки ошибок.

Удачное решение для этого сценария заключается в возможности использования встроенной *UpdateModel()* вспомогательный метод в базовом классе контроллера. Она поддерживает обновление свойств объекта, который передается с помощью входящих параметров формы. Он использует отражение для определения имен свойств в объекте и затем автоматически преобразует и присваивает значения их на основе входных значений, указанным клиентом.

Метод UpdateModel() можно использовать для упрощения нашей HTTP POST изменение действия с помощью следующего кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample11.cs)]

Теперь мы посетите */Dinners/Edit/1* URL-адрес и измените название нашей компании Dinner:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image7.png)

При нажатии кнопки «Сохранить», мы действия для наших действие изменения формы post и обновленные значения будут сохранены в базе данных. Мы затем будут перенаправляться в URL-адрес сведений для компании Dinner (который будет отображаться только что сохраненные значения):

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image8.png)

#### <a name="handling-edit-errors"></a>Обработка ошибок редактирования

Прекрасная нашей текущей реализации works HTTP POST — за исключением случаев, когда есть ошибки.

Когда пользователь создает ошибку, редактирование формы, нам нужно убедитесь, что форма отобразится сообщение подробное сообщение об ошибке, которая поможет им по ее устранению. Сюда входят случаи, где пользователь отправляет неверные входные данные (например: строка имеет неправильный формат даты), как также ситуации, когда формат ввода является допустимым, но есть нарушение бизнес-правил. При возникновении ошибок, что входные данные пользователя, изначально введены так, чтобы не приходилось вручную повторного заполнения их изменения необходимо сохранять значения формы. Этот процесс необходимо повторить любое число раз до успешного завершения формы.

ASP.NET MVC включает ряд встроенных функций с низким приоритетом, упрощает обработку ошибок и повторно отобразить форму. Для просмотра этих функций в давайте обновить нашей изменить метод действия с помощью следующего кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample12.cs)]

Приведенный выше код аналогичен нашей предыдущей реализации — за исключением того, мы теперь упаковки обработка ошибок блок try/catch вокруг своей работы. При возникновении исключения при вызове UpdateModel() или если мы попробуйте и сохранить DinnerRepository (который будет вызывать исключение, если компания Dinner объект, который мы пытаемся сохранить недопустима из-за нарушение правила в нашей модели), наш блок catch ошибки обработки будет выполнение. В ней мы цикла любые нарушения правил, которые существуют в объекте компании Dinner и добавить их в объект ModelState (который мы обсудим в ближайшее время). Затем мы снова отобразить представление.

Чтобы увидеть его работа запустим приложение снова, изменить Dinner и измените его на пустым заголовком EventDate «BOGUS», используют номер телефона UK со значением страны США. Когда мы нажмите кнопку «Сохранить» наш HTTP POST изменить метод нельзя будет сохранить компании Dinner (из-за ошибок) и будет повторного отображения формы:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image9.png)

Наше приложение имеет опыт довольно ошибки. Текстовые элементы с недопустимые входные данные, выделены красным цветом, а сообщения об ошибках проверки отображаются для конечного пользователя о них. Форма также сохраняет входных данных, первоначально введенное пользователем —, чтобы не приходилось пополнения ничего.

Как это сделать вы можете спросить, это происходило? Как текстовые поля заголовка, EventDate и ContactPhone сами Выделение красным цветом и знать для вывода значений первоначально введенное пользователем? И, как сообщения об ошибках отображаются в верхней части списка? Хорошо то, что это случается не магическая - вместо этого было так, как мы использовали некоторые встроенные функции ASP.NET MVC, упрощает проверку входных данных и ошибки сценарии обработки.

#### <a name="understanding-modelstate-and-the-validation-html-helper-methods"></a>Основные сведения о ModelState и методы проверки вспомогательный метод HTML

Классы контроллера имеют набор свойств «ModelState», который предоставляет возможность указать, что имеются ошибки с помощью объекта модели, передаваемые в представление. Ошибка записи в коллекции ModelState идентифицировать имя свойства модели с проблемой (например: «Title», «EventDate» или «ContactPhone») и разрешить сообщение об ошибке понятную указание (например: «Требуется заголовок»).

*UpdateModel()* вспомогательный метод автоматически заполняет коллекцию ModelState при обнаружении ошибки при попытке присвоения значений формы свойства объекта модели. Например свойство EventDate нашей компании Dinner объекта относится к типу DateTime. Когда метод UpdateModel() не удалось назначить строковое значение «BOGUS» в сценарии выше, метод UpdateModel() добавить запись в коллекцию ModelState, указывающее, ошибка назначения возникла с этим свойством.

Разработчики также можно написать код, чтобы явным образом добавить Ошибка записи в коллекцию ModelState, как это делается ниже в нашем «catch» Ошибка обработки блок, который заполнение коллекции ModelState с записями в зависимости от активных нарушение правил в Компания Dinner объект:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample13.cs)]

#### <a name="html-helper-integration-with-modelstate"></a>Вспомогательный метод HTML интеграция с ModelState

Вспомогательные методы HTML - как Html.TextBox() - Проверьте коллекцию ModelState при отрисовке выходных данных. При наличии ошибки элемента, их отрисовки, введенное пользователем значение и ошибка класс CSS.

Например в нашем режиме «Изменить» мы используем Html.TextBox() вспомогательный метод для отображения EventDate объекта нашей компании Dinner:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample14.aspx)]

При визуализации представления в случае ошибки, метод Html.TextBox() проверка коллекции ModelState для просмотра, если бы все ошибки, связанные со свойством «EventDate» объекта нашей компании Dinner. Если обнаружено, что произошла ошибка его к просмотру отправленного пользователя входного значения («BOGUS») и добавлен класс css, ошибка &lt;тип входных данных = «текстовое поле» /&gt; разметки, оно создано:

[!code-html[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample15.html)]

Можно настроить внешний вид ошибки класс css для поиска, тем не менее необходимо. Класс CSS ошибки по умолчанию — «входные данные проверки ошибка» — определяется в *\content\site.css* таблицы стилей и выглядит, аналогичные показанным ниже:

[!code-css[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample16.css)]

Это правило CSS является причину нашей Недопустимый входной выделять элементы, как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image10.png)

##### <a name="htmlvalidationmessage-helper-method"></a>Вспомогательный метод Html.ValidationMessage()

Вспомогательный метод Html.ValidationMessage() можно использовать для вывода ModelState сообщение, связанное со свойством конкретной модели:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample17.aspx)]

Этот код выводит:  *&lt;span класса = «ошибка поле проверки»&gt; недопустимое значение «BOGUS» &lt; /span&gt;*

Вспомогательный метод Html.ValidationMessage() также поддерживает второй параметр, который позволяет разработчикам переопределять текстовое сообщение об ошибке, отображается:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample18.aspx)]

Этот код выводит:  <em>&lt;класс span = «error поля проверки»&gt;\*&lt;/span&gt;</em>вместо текста ошибки по умолчанию, если ошибка отсутствует Свойство EventDate.

##### <a name="htmlvalidationsummary-helper-method"></a>Вспомогательный метод Html.ValidationSummary()

Вспомогательный метод Html.ValidationSummary() можно использовать для отображения сводное сообщение об ошибке, сопровождается &lt;ul&gt;&lt;li /&gt;&lt;/ul&gt; перечень всех подробных сообщений об ошибках в ModelState коллекции:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image11.png)

Вспомогательный метод Html.ValidationSummary() принимает параметр необязательная строка — определяющий сводное сообщение об ошибке для отображения над списком подробных сообщений об ошибках:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample19.aspx)]

При необходимости можно использовать CSS для переопределения выглядит как список ошибок.

#### <a name="using-a-addruleviolations-helper-method"></a>С помощью AddRuleViolations вспомогательный метод

Реализацию начальной изменить HTTP POST используется оператор foreach его блока catch цикла нарушения правил объекта компании Dinner и добавить их в коллекцию ModelState контроллера:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample20.cs)]

Можно сделать этот код немного более понятную путем добавления «ControllerHelpers» обновление NerdDinner проект и использовать метод расширения «AddRuleViolations» внутри него, добавляет вспомогательный метод в класс ASP.NET MVC ModelStateDictionary. Этот метод расширения можно инкапсулировать логику, необходимую для заполнения ModelStateDictionary со списком ошибок RuleViolation:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample21.cs)]

Затем можно обновлять нашей метод действия HTTP POST Edit использовать этот метод расширения для заполнения коллекции ModelState нашей компании Dinner нарушения правил.

#### <a name="complete-edit-action-method-implementations"></a>Завершить редактирование реализации метода действия

В следующем примере кода реализованы все контроллера логику, необходимую для данного сценария изменения:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample22.cs)]

Что хорошо изменить реализацию, имеет нами класса контроллера ни нашей Просмотр шаблона знания о специальные проверочные или бизнес-правила, установленному нашей модели компании Dinner. Мы можно добавить дополнительные правила для нашей модели в будущем и не требуется вносить изменения кода в нашем контроллер или представление для них для поддержки. Это предоставляет возможность легко развить наших требований приложения в будущем с минимальным изменений кода.

### <a name="create-support"></a>Создание поддержки

Мы после реализации поведения класса DinnersController «Edit». Теперь перейдем к реализации поддержки «Создать» на его — это позволяет пользователям добавлять новые ужинов.

#### <a name="the-http-get-create-action-method"></a>Метод действия создания HTTP-GET

Для начала нужно реализовать поведение «GET» HTTP из наших создания метода действия. Этот метод будет вызван, когда кто-то посещает */ужинов/Create* URL-адрес. Наше решение выглядит следующим образом.

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample23.cs)]

Приведенный выше код создает новый объект Dinner и присваивает его свойство EventDate, чтобы быть недели в будущем. Он выполняет визуализацию представления, основанный на новый объект обед. Поскольку мы еще не передается явно имя для *View()* вспомогательный метод, он использует путь по умолчанию на основе соглашения о разрешить просмотр шаблона: /Views/Dinners/Create.aspx.

Теперь создадим этого шаблона представления. Это можно сделать, щелкнув правой кнопкой мыши внутри метода действия Create и выбрав из контекстного меню команду «Добавить представление». В диалоговом окне «Добавление представления» здесь мы указываем мы производится передача объекта Dinner шаблон представления и выбрать шаблон «Создать» auto-формирования шаблонов:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image12.png)

При нажатии кнопки «Добавить», Visual Studio сохраните новое представление «Create.aspx» на основе формирования шаблонов в каталоге «\Views\Dinners» и откройте его в Интегрированной среде разработки:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image13.png)

Давайте внести некоторые изменения в файл по умолчанию «создание» формирования шаблонов, созданный для нас и измените его вверх, как должен выглядеть ниже:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample24.aspx)]

А теперь когда мы запускаем нашей доступа к приложениям и *«/ ужинов/создать»* URL-адрес в браузере, будет заполняться пользовательского интерфейса, такие как ниже от наших реализации создать действие:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image14.png)

#### <a name="implementing-the-http-post-create-action-method"></a>Реализация HTTP POST для создания метода действия

У нас есть версия HTTP-GET реализован метод действия нашей Create. Когда пользователь нажимает кнопку «Сохранить», он выполняет формы post для */ужинов/Create* URL-адрес, и отправляет HTML &lt;ввода&gt; форме значения, с помощью команды HTTP POST.

Теперь рассмотрим процедуру внедрения поведение HTTP POST нашей создания метода действия. Для начала рассмотрим путем добавления перегруженного метода действия «Создать» для наших DinnersController, имеющего атрибут «AcceptVerbs» на нем, показывающее, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample25.cs)]

Существуют различные способы, можно обратиться к отправленной формы параметры в рамках нашей метода HTTP-POST включена «Создать».

Можно создать объект Dinner, а затем использовать *UpdateModel()* вспомогательный метод (как мы сделали с действие изменения) требуется заполнить значения из отправленной формы. Мы может затем добавить его в нашем DinnerRepository сохранения в базе данных и перенаправит пользователя на наши действия сведений для отображения в следующем примере кода с помощью только что созданный компании Dinner:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample26.cs)]

Кроме того можно использовать подход наличия наш метод действия Create() принимают в качестве параметра метода объект компании Dinner. ASP.NET MVC будет затем автоматически создать экземпляр объекта Dinner нам, заполнить его свойства с помощью входных данных формы и передать методу наши действия:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample27.cs)]

Описанный выше метод наши действия проверяет, компании Dinner объект был успешно заполнен значения отправки формы, обращаясь к свойству ModelState.IsValid. Возвращает значение false, если входной проблемы преобразования (например: строка «BOGUS» для свойства EventDate), и повторно Если возникли проблемы наш метод действия отображает форму.

Если входные значения являются допустимыми, метод действия пытается добавить и сохранить новый Dinner DinnerRepository. Он включает эту работу внутри блока try/catch и повторно отображает форму, в случае нарушения правил бизнеса (которые вызовет метод dinnerRepository.Save() для вызова исключения).

Чтобы просмотреть это поведение в действии обработки ошибок, можно запросить */ужинов/Create* URL-адрес и заполните сведения о новых обед. Неверные входные данные или значения, вызовет создание формы для повторно с ошибками, выделены как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image15.png)

Обратите внимание на то, как точное же проверки и бизнес-правила, что наши форме редактирования соблюдает нашей Создание формы. Это потому, что наши проверки и бизнес-правилами были определены в модели, а не удалось внедрить в рамках пользовательского интерфейса или контроллера приложения. Это означает, что мы можно позже изменить/развивать нашей проверки или бизнес-правила в одном поместите и их применяются ко всему нашего приложения. Нам не нужно изменить любой код, либо в нашем измените или создавать методы действий автоматически соблюдать все новые правила или изменения в существующие.

Когда мы исправьте входные значения и нажмите кнопку «Сохранить» еще раз, будет выполнен нашей дополнение к DinnerRepository и новый Dinner будут добавлены в базу данных. Чтобы мы затем перенаправляется */Dinners/подробности / [id]* URL-адрес — где мы предоставят подробные сведения о только что созданный Dinner:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image16.png)

### <a name="delete-support"></a>Удаление поддержки

Теперь добавим поддержку «Удалить» для наших DinnersController.

#### <a name="the-http-get-delete-action-method"></a>Метод действия Delete HTTP-GET

Для начала рассмотрим, реализовав поведение наш метод действия delete HTTP GET. Этот метод будет вызван при посещении */Dinners/Delete / [id]* URL-адрес. Ниже приводится реализация:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample28.cs)]

Метод действия пытается получить Dinner для удаления. Если компании Dinner существует Визуализирует представление на основе Dinner объекта. Если объект не существует (или уже был удален) он возвращает представление, которое отображает «NotFound» Просмотр шаблона, созданную ранее для наших метода действия «Подробности».

Можно создать шаблон представления «Удалить», щелкните правой кнопкой мыши в метод действия Delete и выбрав из контекстного меню команду «Добавить представление». В диалоговом окне «Добавление представления» здесь мы указываем мы производится передача объекта Dinner нашей представление шаблон в качестве своей модели и выберите для создания пустого шаблона:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image17.png)

При нажатии кнопки «Добавить», Visual Studio добавит новый файл шаблона «Delete.aspx» представление нам в каталог «\Views\Dinners». Мы добавим некоторые HTML и код шаблона для реализации экран подтверждения удаления, аналогичные показанным ниже:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample29.aspx)]

Приведенный выше код отображает название компании Dinner удаляемых и выходы &lt;формы&gt; элемент, который выполняет запрос POST /Dinners/Delete / [id] URL-адрес, если конечный пользователь нажимает кнопку «Удалить» в ней.

Когда мы запускаем нашей доступа к приложениям и *«/ ужинов/Delete / [id]»* URL-адрес допустимым Dinner объекта он отображает пользовательский Интерфейс, аналогичные показанным ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image18.png)

| **Раздел стороны: Почему делается POST?** |
| --- |
| Вы можете задать вопрос — Почему мы исчезают через трудозатраты на создание &lt;формы&gt; в нашем экран подтверждения удаления? Почему просто не использовать стандартные гиперссылки для связывания метода действия, выполняющий операции фактического удаления? Так как нам нужно соблюдать осторожность, чтобы защититься от программ-обходчиков и поисковых систем обнаружения URL-адреса и случайно вызывают данных должны удаляться при их по ссылкам. HTTP-GET на основе URL-адреса считаются «безопасным», для них доступ/сканирования, и они должны следовать HTTP-POST из них не. Рекомендуется убедитесь, что вы всегда помещать разрушительных или операции изменения данных за запросы HTTP POST. |

#### <a name="implementing-the-http-post-delete-action-method"></a>Реализация метода действия Delete HTTP POST

Теперь у нас есть версия HTTP-GET наш метод действия Delete реализован которого отображается экран подтверждения удаления. Когда пользователь нажимает кнопку «Удалить», он будет выполнять формы post для */Dinners/Dinner / [id]* URL-адрес.

Теперь рассмотрим процедуру внедрения HTTP «POST» поведение метод действия delete, используя приведенный ниже код:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample30.cs)]

Версия HTTP POST наш метод действия Delete пытается получить удаляемого объекта dinner. Если не удается найти (так как он уже удален) он отображает нашей шаблона «NotFound». При обнаружении компании Dinner удаляется из DinnerRepository. Затем он отображает шаблон «Удалено».

Для реализации шаблона «Удалено» мы щелкните правой кнопкой мыши в методе действия и Выбор контекстного меню «Добавить представление». Мы имя нашей представление «Удалено» и быть пустого шаблона (и не принимают в качестве модели строго типизированный объект). Затем мы добавим некоторые HTML-содержимого на него:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample31.aspx)]

И теперь когда мы запускаем нашей доступа к приложениям и *«/ ужинов/Delete / [id]»* URL-адрес допустимым Dinner подтверждение удаления объекта, он будет отображать нашей компании Dinner экрана как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image19.png)

При нажатии кнопки «Удалить» выполняется операция HTTP POST для */Dinners/Delete / [id]* URL-адрес, который удалит компании Dinner из наших базы данных и отобразить наш «Удалено» Просмотр шаблона:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image20.png)

### <a name="model-binding-security"></a>Безопасность привязки модели

Мы обсуждали два разных способа использования встроенных функций привязки модели ASP.NET MVC. Сначала с помощью метода UpdateModel() для обновления свойств на основе существующего объекта модели, а второй с помощью ASP.NET MVC поддержки для передачи объектов модели в как параметры метода действия. Оба этих метода — очень мощная и очень полезным.

Эти возможности также предлагает очень ответственности. Важно всегда быть излишняя о безопасности при получении вводимых пользователем, и это также имеет значение true, если привязки объектов к ввод формы. Следует соблюдать осторожность, чтобы всегда HTML-кодирование любой значений, введенных пользователем, чтобы избежать атак путем внедрения кода HTML и JavaScript и будьте внимательны атак путем внедрения кода SQL (Примечание: мы используем для нашего приложения, автоматически кодирует параметры, чтобы предотвратить эти LINQ to SQL типы атак). Никогда не следует полагаться на клиентскую проверку только и всегда использовать проверку на стороне сервера для защиты от хакеров, попытка отправить вам поддельное значения.

Один элемент дополнительную безопасность, убедитесь, что вы думаете о при использовании функции привязки ASP.NET MVC — это область объектов, на которые выполняется привязка. В частности вы хотите убедитесь, что вы понимаете последствия для безопасности свойств, которые позволяет привязать и убедитесь, что допускается только те свойства, которые действительно должно быть обновляемым обновляемого конечным пользователем.

По умолчанию метод UpdateModel() попытается обновить все свойства в объекте модели, которые соответствуют значения входящих параметров формы. Аналогичным образом могут иметь объекты также передаются как параметры метода действия по умолчанию, все свои свойства задаются в меню параметров формы.

#### <a name="locking-down-binding-on-a-per-usage-basis"></a>Блокировка привязки на основе в зависимости от использования

Вы блокируете политику привязки на основе в зависимости от использования, предоставляя явные» включают список» свойств, которые могут быть обновлены. Это можно сделать, передав параметр дополнительной строки массива методу UpdateModel() как ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample32.cs)]

Объекты передаются как параметры метода действия также поддерживает атрибут [привязки], позволяющий» включают список» из допускается указывать как ниже свойства:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample33.cs)]

#### <a name="locking-down-binding-on-a-type-basis"></a>Блокировка привязки на основе типа

Можно также зафиксировать правила привязки на уровне отдельных типов. Это позволяет определить правила привязки один раз и затем их применять во всех сценариях (включая сценарии параметра метод UpdateModel и действия) на все контроллеры и методы действий.

Вы можете настроить правила для типа привязки, путем добавления атрибута [привязки] на тип, или путем его регистрации в файле Global.asax приложения (Это удобно в сценариях, где вы не владеете тип). Затем можно использовать атрибут привязки Include и Exclude свойства, определяющие свойства, которые можно привязать для определенного класса или интерфейса.

Используется этот метод для класса Dinner в приложении обновление NerdDinner и добавить атрибут [привязки] к нему, который ограничивает список привязываемые свойства следующим:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample34.cs)]

Обратите внимание, что это не предоставляет коллекцию ответов на приглашение для обработки через привязку, и мы, позволяя задать через привязку свойства DinnerID или HostedBy. По соображениям безопасности мы будем вместо этого работает только с этих определенных свойств, с помощью кода в наши методы действий.

### <a name="crud-wrap-up"></a>Подведение итогов CRUD

ASP.NET MVC включает ряд встроенных функций, помогающие в реализации формы учета сценариев. Мы использовали различные эти функции для поддержки пользовательского интерфейса CRUD над нашей DinnerRepository.

Мы используем ориентированной модели для реализации нашего приложения. Это означает, что наши проверки и бизнес-правила, логика, определенного в нашей модели слоя —, а не внутри наших контроллеров или представления. Наш класс контроллера ни наших шаблонов представлений знания бизнес-правил, которые применяются в классе модели нашей компании Dinner.

Это останется чистой архитектуру приложения и упростить тестирование. Можно добавить дополнительные бизнес-правила в нашей модели слоев в будущем и *не нужно вносить любые изменения кода* нашей контроллер или представление для них будут поддерживаться. Это будет предоставить нам большую гибкость для развития и измените приложения в будущем.

Наш DinnersController теперь включает Dinner вхождений подробности, а также создание, изменение и удаление поддержки. Ниже можно найти полный код для класса:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample35.cs)]

### <a name="next-step"></a>Следующий шаг

Теперь у нас есть реализовать в нашем классе DinnersController поддержку CRUD (Создание, чтение, обновление и удаление).

Теперь взглянем на как можно использовать классы ViewData и ViewModel для включения более широких пользовательского интерфейса на нашем форм.

> [!div class="step-by-step"]
> [Назад](use-controllers-and-views-to-implement-a-listingdetails-ui.md)
> [Вперед](use-viewdata-and-implement-viewmodel-classes.md)
