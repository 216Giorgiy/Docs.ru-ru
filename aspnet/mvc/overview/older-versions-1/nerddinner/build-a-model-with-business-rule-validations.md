---
uid: mvc/overview/older-versions-1/nerddinner/build-a-model-with-business-rule-validations
title: Построить модель с бизнес-правило проверок | Документы Microsoft
author: microsoft
description: Шаг 3 показано, как создать модель, что мы можно использовать для обоих запросов и обновления базы данных для нашего приложения обновление NerdDinner.
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2010
ms.topic: article
ms.assetid: 0bc191b2-4311-479a-a83a-7f1b1c32e6fe
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/build-a-model-with-business-rule-validations
msc.type: authoredcontent
ms.openlocfilehash: c5a482474fd2f41836f70952306ada5cd9136455
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30874945"
---
<a name="build-a-model-with-business-rule-validations"></a>Построить модель с бизнес-правило проверок
====================
по [Microsoft](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это бесплатная шага 3 [учебника «Обновление NerdDinner» приложения](introducing-the-nerddinner-tutorial.md) , обходов сквозной как построить небольшой, но завершается веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 3 показано, как создать модель, что мы можно использовать для обоих запросов и обновления базы данных для нашего приложения обновление NerdDinner.
> 
> При использовании ASP.NET MVC 3, которому рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-3-building-the-model"></a>Обновление NerdDinner шаг 3: Построение модели

В платформу model-view-controller термин «модель» относится к объектам, которые представляют собой данные приложения, а также соответствующие доменную логику, которое интегрируется с его проверки и бизнес-правил. Модели — во многом «основу» приложения на основе MVC и как мы рассмотрим позже существенно дисков его поведение.

Платформа ASP.NET MVC поддерживает использование любой технологии доступа к данным, и разработчики могут выбирать из множества разнообразные параметры данных .NET для реализации их моделей, в том числе: LINQ для сущности, LINQ to SQL, NHibernate, LLBLGen Pro, SubSonic, WilsonORM или просто необработанные ADO. Объекты DataReader NET или наборов данных.

В нашем приложении обновление NerdDinner мы будем использовать LINQ to SQL для создания простой модели, достаточно близко соответствует нашей структуры базы данных, а также добавляет некоторые пользовательские логику и бизнес-правила проверки. Затем будет реализуются репозитория класс, помогающий абстрактный немедленно реализация сохраняемости данных от остальной части приложения, а также позволяет нам легко модульного тестирования.

### <a name="linq-to-sql"></a>LINQ to SQL

LINQ to SQL является ORM (реляционный модуль сопоставления объектов), который поставляется в составе .NET 3.5.

LINQ to SQL обеспечивает простой способ сопоставить классы .NET, который мы можно разрабатывать код для таблицы базы данных. В нашем приложении обновление NerdDinner мы будем использовать для сопоставления в базе данных для классов Dinner и RSVP таблицы ужинов и RSVP. Столбцы таблицы ужинов и RSVP будет соответствовать свойствам классы Dinner и RSVP. Каждый объект Dinner и RSVP будет представлять отдельную строку внутри ужинов или RSVP таблиц в базе данных.

LINQ to SQL позволяет избежать необходимости вручную создавать инструкции SQL для извлечения и обновления Dinner и RSVP объектов базы данных. Вместо этого мы определим классы Dinner и RSVP, как они сопоставляются/из базы данных и связи между ними. LINQ to SQL будет затем принимает следить за соответствующую логику выполнения SQL для использования во время выполнения, когда мы взаимодействовать и использовать их создания.

Поддержка языка LINQ в C# и VB можно использовать для написания выражений запросов, которые получают Dinner и RSVP объекты из базы данных. Это сводит к минимуму объем данных кода для написания, и позволяет создавать приложения, действительно очистить.

### <a name="adding-linq-to-sql-classes-to-our-project"></a>Добавление классов LINQ to SQL в свой проект

Мы будем начинается путем щелчка правой кнопкой мыши папку «Моделей» в данном проекте и выберите **Add -&gt;новый элемент** команды меню:

![](build-a-model-with-business-rule-validations/_static/image1.png)

Откроется диалоговое окно «Добавление нового элемента». Мы фильтрация по категории «Данные» и выберите шаблон «LINQ to SQL Classes» в ней:

![](build-a-model-with-business-rule-validations/_static/image2.png)

Мы имя элемента «Обновление NerdDinner» и нажмите кнопку «Добавить». Visual Studio будет добавить файл NerdDinner.dbml нашей \Models в каталоге, а затем откройте LINQ to SQL реляционный конструктор объектов:

![](build-a-model-with-business-rule-validations/_static/image3.png)

### <a name="creating-data-model-classes-with-linq-to-sql"></a>Создание классов модели данных с помощью LINQ to SQL

LINQ to SQL позволяет быстро создать классы модели данных из существующей схемы базы данных. Задача это мы будем открыть обновление NerdDinner базу данных в обозревателе серверов и выберите таблицы, мы хотим модели в ней:

![](build-a-model-with-business-rule-validations/_static/image4.png)

Затем можно перетащить таблицы на LINQ в область конструктора SQL. Когда мы делаем это LINQ to SQL автоматически создаст Dinner и RSVP классы, с помощью схемы таблиц (со свойствами класса, которые сопоставляются со столбцами таблицы базы данных):

![](build-a-model-with-business-rule-validations/_static/image5.png)

По умолчанию LINQ to SQL конструктор автоматически» форму множественного «имена таблиц и столбцов при создании классов на основе схемы базы данных. Например: в таблице «Ужинов» в приведенном выше примере привело к созданию класса «Dinner». Этот класс именования позволяет согласовать наши модели с соглашения об именовании .NET, и обычно найти, наличие конструктора исправления это удобный вверх (особенно при добавлении большое количество таблиц). Если вам не нравится имя класса или свойство, которое создает конструктор, хотя всегда можно переопределить и измените его на любое нужное имя. Это можно сделать, изменив свойства сущности или имя в строке конструктора или путем изменения его через сетки свойств.

По умолчанию LINQ to SQL конструктор также проверяет связи первичного и внешнего ключа из таблиц, а также на их основе автоматически создает по умолчанию «отношение ассоциации» между классами другой модели, созданные им. Например, когда мы перетащить ужины и RSVP таблиц на LINQ to SQL конструктор связь "один ко многим" между двумя было выведено исходя из того, что таблица RSVP имела внешнего ключа к таблице ужинов (обозначается стрелкой в конструктор).

![](build-a-model-with-business-rule-validations/_static/image6.png)

Связь выше приведет к LINQ SQL добавляемый RSVP класс, который разработчики могут использовать для доступа к компании Dinner, связанный с данной RSVP строго типизированное свойство «Dinner». Это также вызовет класс Dinner имеет свойство коллекции «RSVPs», дает разработчикам возможность получать и обновлять RSVP объекты, связанные с определенной Dinner.

Ниже можно видеть пример intellisense в Visual Studio, когда мы создать объект RSVP и добавить его в коллекцию ответов на приглашение компании Dinner. Обратите внимание на то, как LINQ to SQL автоматически добавляется коллекции «Ответов на приглашение» в объекте Dinner:

![](build-a-model-with-business-rule-validations/_static/image7.png)

Путем добавления объекта RSVP коллекцию ответов на приглашение компании Dinner мы указываем LINQ to SQL, чтобы связать отношение внешнего ключа между компании Dinner и RSVP строки в базе данных:

![](build-a-model-with-business-rule-validations/_static/image8.png)

Если вас не устраивает, как конструктор моделируется или связь таблицы с именем, его можно переопределить. Просто щелкните стрелку связи в конструкторе и доступ к его свойства с помощью сетки свойств, чтобы переименовать, удалить или изменить его. В нашем приложении обновление NerdDinner, правила сопоставления по умолчанию подходят для создаваемых классов модели данных и можно просто использовать поведение по умолчанию.

### <a name="nerddinnerdatacontext-class"></a>Класс NerdDinnerDataContext

Visual Studio автоматически создает классы .NET, представляющие моделей и связей базы данных, определенный с помощью LINQ to SQL конструктора. LINQ to SQL DataContext класса также создается для каждого файла LINQ to SQL конструктора добавляется в решение. Так как мы назвали нашей LINQ to SQL элемента класса «Обновление NerdDinner», класс DataContext, созданный будет вызываться «NerdDinnerDataContext». Этот класс NerdDinnerDataContext является основным способом прикрепления мы будет взаимодействовать с базой данных.

Наш NerdDinnerDataContext класс предоставляет два свойства - «Ужинов» и «RSVPs -», представляющие двух таблиц, которые мы моделировать внутри базы данных. C# можно использовать для записи запросов LINQ для этих свойств запроса и получения Dinner и RSVP объекты из базы данных.

Следующий код демонстрирует создание экземпляра объекта NerdDinnerDataContext и выполняют запросы LINQ к его для получения последовательности ужинов, возникающие в будущем. Visual Studio предоставляет технологией intellisense при написании запроса LINQ, и являются строго типизированными объектами, возвращаемыми его, а также поддерживают технологию intellisense.

![](build-a-model-with-business-rule-validations/_static/image9.png)

Помимо выдачи нами для запроса объектов Dinner и RSVP, NerdDinnerDataContext также автоматически отслеживает любые изменения, которые мы предоставляем впоследствии Dinner и RSVP объекты, которые нам получить через него. Эту функциональность можно использовать легко сохранить изменения в базе данных — без необходимости написания кода обновления явной SQL.

Например в следующем примере кода показано, как использовать LINQ-запрос для извлечения объекта Dinner из базы данных, обновления двух свойств Dinner и сохранить изменения в базе данных:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample1.cs)]

В коде выше объекта NerdDinnerDataContext автоматически отслеживаться изменения свойств в объект Dinner мы полученный от его. Когда мы вызвал метод «SubmitChanges()», он выполнит соответствующие «UPDATE» инструкции SQL в базу данных, чтобы сохранить обновленные значения обратно.

### <a name="creating-a-dinnerrepository-class"></a>Создание класса DinnerRepository

Для небольших приложений иногда бывает нормально контроллеры непосредственная работа с LINQ to SQL DataContext класса и внедрить запросов LINQ в контроллеров. Как приложения получают большего размера, хотя такой подход становится громоздким, в обслуживании и тестировании. Это также может привести к нам дублирование те же запросы LINQ в нескольких местах.

Один из подходов, можно сделать удобнее для обслуживания и тестирования приложения является использование шаблона «хранилище». Класс репозитория позволяет инкапсулировать запроса данных и логику сохраняемости и краткие описания немедленно детали реализации, сохранения данных из приложения. Помимо внесения очистки кода приложения, использование шаблона репозитория можно упростить в дальнейшем изменить реализациями хранилищ данных и может помочь применения модульного тестирования приложения без необходимости реальной базы данных.

В нашем приложении обновление NerdDinner мы определим класс DinnerRepository с ниже подписи:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample2.cs)]

*Примечание: Далее в этой главе мы будет извлечь интерфейс IDinnerRepository от этого класса и включить внедрение зависимостей с ним на нашем контроллеров. Начинается с менее, мы собираемся начать простой и просто будет работать непосредственно с классом DinnerRepository.*

Для реализации этого класса, мы правой кнопкой мыши папку нашей «Моделей» и выберите **Add -&gt;новый элемент** команду меню. В диалоговом окне «Добавление нового элемента» мы выберите шаблон «Класс» и присвойте файлу имя «DinnerRepository.cs»:

![](build-a-model-with-business-rule-validations/_static/image10.png)

Затем мы можно реализовать нашего DinnerRespository класса, используя приведенный ниже код.

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample3.cs)]

### <a name="retrieving-updating-inserting-and-deleting-using-the-dinnerrepository-class"></a>Извлечение, обновление, вставка и удаление с помощью класса DinnerRepository

Теперь, когда мы создавали нами класса DinnerRepository, давайте рассмотрим несколько примеров кода, которые демонстрируют общие задачи, которые мы можем с ней:

#### <a name="querying-examples"></a>Примеры запросов

В следующем примере кода получает один обед с использованием значения DinnerID:


[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample4.cs)]

Приведенный ниже код извлекает все предстоящих ужинов и циклы над ними:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample5.cs)]

#### <a name="insert-and-update-examples"></a>INSERT и Update примеры

В следующем примере кода показано, как добавить два новых ужинов. Дополнений и изменений в репозитории не зафиксированы в базе данных, пока не будет вызван метод «Save()» на нем. LINQ to SQL автоматически переносит все изменения в транзакции базы данных — так, чтобы все изменения произойти или ни одна из них при сохранении в нашем репозитории:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample6.cs)]

Приведенный ниже код извлекает существующий объект Dinner и изменяет ее два свойства. Изменения фиксируются в базе данных при вызове метода «Метод Save()» на нашем репозитории:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample7.cs)]

В следующем примере кода извлекается dinner и добавляет Подтверждать. Это делается с помощью коллекции ответов на приглашение компании Dinner объекта, LINQ to SQL создать нам (поскольку связь первичный ключ/внешний ключ между ними в базе данных). Это изменение сохраняется в базе данных как новой строки RSVP при вызове метода «Save()» в репозитории:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample8.cs)]

#### <a name="delete-example"></a>Пример удаления

Приведенный ниже код извлекает объект, существующий Dinner, а затем помечает его удаления. При вызове метода «Save()» в репозитории фиксируется удаления в базе данных:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample9.cs)]

### <a name="integrating-validation-and-business-rule-logic-with-model-classes"></a>Интеграция проверки и логику бизнес-правила с помощью классов модели

Интеграция проверки и бизнес-правила, что логика является ключевой частью любого приложения, которое работает с данными.

#### <a name="schema-validation"></a>Проверка схемы

Если классы модели определяются с помощью LINQ to SQL конструктор, типы данных свойств в классы модели данных соответствуют типы данных в таблицу базы данных. Например: Если столбец «EventDate» в таблице ужинов «datetime», класс модели данных, созданные в LINQ to SQL будет иметь тип «DateTime» (это встроенный тип данных .NET). Это означает, что вы получите ошибки компиляции, если он будет вызывать ошибку автоматически при попытке выполнить неявное преобразование недопустимого строкового типа к ней во время выполнения при попытке присвоить целое число или логическое значение из кода.

LINQ to SQL будет автоматически обрабатывает значения экранирования SQL при использовании строк — что помогает защититься от атак путем внедрения кода SQL при его использовании.

#### <a name="validation-and-business-rule-logic"></a>Проверка и логику бизнес-правила

Проверка схемы полезны в качестве первого шага, но достаточно редко. Большинство реальных сценариев необходима возможность указать более подробная логику проверки, которая может охватывать несколько свойств, выполните код и часто имеет сведений о состоянии модели (например: он создается/обновления/удален, или состояние специфические для домена как «архивированный»). Существует множество различных шаблонов и платформ, которые можно использовать для определения и применения правил проверки к классам модели, и существует несколько на основе платформы .NET, которые можно использовать, чтобы помочь в этом. Можно использовать практически любой из них в приложениях ASP.NET MVC.

В целях нашего приложения обновление NerdDinner мы будем использовать шаблон относительно простой и последовательных где мы предоставляем IsValid свойство и метод GetRuleViolations() на объект модели нашей компании Dinner. Свойство IsValid возвращает значение true или false в зависимости от того, было ли все допустимые проверки и бизнес-правила. Метод GetRuleViolations() возвращает список ошибок правило.

Мы будет реализован IsValid и GetRuleViolations() для нашей компании Dinner модели путем добавления «разделяемый класс» в свой проект. Разделяемые классы можно использовать дополнительные методы, свойства и события для классов, обслуживается конструктор VS (например, класс Dinner, сформированные LINQ to SQL конструктора) и помогает избежать средство из фактической нашим кодом. Мы добавьте новый разделяемый класс в свой проект, щелкнув папку \Models и затем выберите команду меню «Добавить новый элемент». Затем мы можно Выбор шаблона «Класс» в диалоговом окне «Добавление нового элемента» и назовите его Dinner.cs.

![](build-a-model-with-business-rule-validations/_static/image11.png)

Нажмите кнопку «Добавить» добавить файл Dinner.cs в свой проект и откройте его в Интегрированной среде разработки. Мы затем можно реализовать применения базовых правилам framework, используя ниже кода:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample10.cs)]

Сказать о приведенный выше код:

- Класс Dinner предшествовало ключевое слово «частичное» — это означает код, содержащиеся в нем будет в сочетании с классом, который создается и сохраняется в LINQ to SQL конструктор и компилируются в один класс.
- Класс RuleViolation — это вспомогательный класс, который будет добавлен к проекту, который позволяет нам для предоставления подробной информации о нарушении правил.
- Метод Dinner.GetRuleViolations() вызывает нашей проверки и бизнес-правила для вычисления (мы будем реализовывать их вскоре). Затем возвращается обратно последовательность RuleViolation объектов, предоставляющих дополнительные сведения об ошибках правило.
- Свойство Dinner.IsValid предоставляет удобные вспомогательные свойство, определяющее, имеет ли объект Dinner любой active RuleViolations. Он может проверяться заранее разработчиком, с помощью объекта Dinner в любое время (и не вызывает исключение).
- Разделяемый метод Dinner.OnValidate() является обработчик, который предоставляет LINQ to SQL, позволяющий получать уведомления каждый раз, когда объект Dinner собирается сохраняются в базе данных. Реализацию OnValidate() выше обеспечивает компании Dinner не RuleViolations перед сохранением. Если он находится в недопустимом состоянии он выдает исключение, которое приведет к LINQ to SQL, транзакция будет прервана.

Такой подход предоставляет простой платформу, мы можно интегрировать проверки и бизнес-правила в. Теперь добавим ниже правила в данном методе GetRuleViolations():

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample11.cs)]

Для возвращения последовательности любой RuleViolations мы используем компонент «yield return» C#. Первый шести правило проверки выше просто принудительно, что свойства строки на нашей компании Dinner не может быть неопределенным или пустым. Правило последнего более интересным, и вызывает вспомогательный метод PhoneValidator.IsValidNumber(), можно добавить в свой проект, чтобы убедиться, что ContactPhone число формат соответствует компании Dinner по стране.

Можно использовать. NET поддержки регулярных выражений для реализации проверки поддержка по телефону. Ниже приведена простая реализация PhoneValidator, можно добавить в свой проект, позволяющую добавить проверки шаблон регулярного выражения конкретной страны:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample12.cs)]

#### <a name="handling-validation-and-business-logic-violations"></a>Обработка проверки и бизнес логики нарушений

Мы добавили приведенный выше проверки и бизнес-правило код, каждый раз, когда мы пытаемся создать или обновить Dinner, наши правила логики проверки оценивается и применяется.

Разработчики могут писать код как ниже для заранее определить допустимость объекта Dinner и получения списка все нарушения в его без вызова исключения:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample13.cs)]

При попытке сохранить Dinner в недопустимом состоянии, если нужно вызвать метод Save() на DinnerRepository будет порождено исключение. Это происходит, поскольку LINQ to SQL автоматически вызывает нашей Dinner.OnValidate() разделяемого метода, прежде чем он сохраняет изменения компании Dinner и был добавлен код, чтобы Dinner.OnValidate() вызывает исключение, если существует нарушения правил в компании Dinner. Можно перехватить это исключение и оперативно получать список нарушений Устранение:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample14.cs)]

Поскольку наш проверки и бизнес-правила реализованы в нашей модели слоев, а не в пределах уровня пользовательского интерфейса, они будет применяться и используемого во всех сценариях, в приложении. Мы можно позже изменить или добавить бизнес-правил и весь код, что работает с объектами нашей компании Dinner соблюдать их.

Наличие легко изменить бизнес-правила в одном месте, без необходимости изменения ripple через приложения и логика пользовательского интерфейса является признаком хорошо написанное приложение и выигрыша, который MVC framework помогает стимулировать.

### <a name="next-step"></a>Следующий шаг

Теперь имеется модель, можно использовать для запроса и обновления в базе данных.

Теперь добавим некоторые контроллеры и представления в проект, который можно использовать для построения пользовательского интерфейса HTML взаимодействие вокруг нее.

> [!div class="step-by-step"]
> [Назад](create-a-database.md)
> [Вперед](use-controllers-and-views-to-implement-a-listingdetails-ui.md)
