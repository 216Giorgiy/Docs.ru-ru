---
uid: mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
title: Разбиение по страницам данных, эффективно реализовать | Документы Microsoft
author: microsoft
description: Шаг 8 показано, как добавить поддержку разбиения по страницам нашей /Dinners URL-адрес, чтобы вместо отображения ужинов сразу несколько тысяч, мы будет отображаться только 10 предстоящих ужинов на...
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2010
ms.topic: article
ms.assetid: adea836d-dbc2-4005-94ea-53aef09e9e34
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
msc.type: authoredcontent
ms.openlocfilehash: 0188e21438820adf2adbe05b047fdb772540e1a0
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30873252"
---
<a name="implement-efficient-data-paging"></a>Разбиение по страницам для реализации эффективного данных
====================
по [Microsoft](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это бесплатная шагу 8 [учебника «Обновление NerdDinner» приложения](introducing-the-nerddinner-tutorial.md) , обходов сквозной как построить небольшой, но завершается веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 8 показано, как добавить поддержку разбиения по страницам нашей /Dinners URL-адрес, чтобы вместо отображения ужинов сразу несколько тысяч, мы только раз - 10 предстоящих ужинов отображаются и разрешить конечным пользователям страницы назад и вперед по всему списку понятным образом оптимизации поисковой системы.
> 
> При использовании ASP.NET MVC 3, которому рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-8-paging-support"></a>Обновление NerdDinner шаг 8: Поддержка разбиения на страницы

При успешном выполнении наш сайт будет тысячи предстоящих ужинов. Мы должны убедиться, масштабируется для обработки всех этих ужинов нашем пользовательском Интерфейсе и позволяет пользователям просматривать их. Чтобы включить эту возможность, мы добавим поддержку разбиения по страницам нашей */Dinners* URL-адрес так, чтобы вместо отображение тысячи ужинов на один раз, мы будем только отображения 10 предстоящих ужинов одновременно - и разрешить конечным пользователям страницы назад и вперед по весь список в SEO понятным способом.

### <a name="index-action-method-recap"></a>Метод повторение INDEX() действия

Метод действия Index() в нашем классе DinnersController в данный момент выглядит как ниже:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample1.cs)]

При запросе к */Dinners* URL-адрес, он получает список всех предстоящих ужинов и выводит список всех из них:

![](implement-efficient-data-paging/_static/image1.png)

### <a name="understanding-iquerablelttgt"></a>Основные сведения о IQuerable&lt;T&gt;

*IQueryable&lt;T&gt;*  — это интерфейс, был введен в составе .NET 3.5 с помощью LINQ. Он поддерживает мощные «отложенного выполнения» сценарии, которые мы могут воспользоваться преимуществами для реализации поддержки разбиения на страницы.

В нашем DinnerRepository возвращаете IQueryable&lt;Dinner&gt; последовательности из наших FindUpcomingDinners() метода:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample2.cs)]

IQueryable&lt;Dinner&gt; объект, возвращаемый в данном методе FindUpcomingDinners() инкапсулирует запрос для получения объектов Dinner из наших базы данных с помощью LINQ to SQL. Главное не будет выполняться запрос к базе данных, пока выполняется попытка доступа или итерацию по данным в запросе или пока нужно вызвать метод ToList() на нем. Кода, вызов метода нашей FindUpcomingDinners() при необходимости можно выбрать для добавления «связанные» операции и фильтров к IQueryable&lt;Dinner&gt; объекта перед выполнением запроса. LINQ to SQL может затем выполнить объединенного запроса к базе данных, при запросе данных.

Для реализации логики постраничного просмотра можно изменить метод действия Index() наших DinnersController, что позволит применять дополнительные операторы «Skip» и «Выполнить» к возвращаемой IQueryable&lt;Dinner&gt; последовательности до вызова ToList() для него:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample3.cs)]

Приведенный выше код пропускает первые 10 предстоящих ужинов в базе данных и затем возвращает ужинов 20. LINQ to SQL является достаточно широкими возможностями для создания оптимизированного SQL-запрос, выполняющий это пропуск логику в базе данных SQL, а не в веб сервера. Это означает, что даже если у нас есть миллионы предстоящих ужинов в базе данных, только 10, которые требуется извлекается как часть этого запроса (сделав его эффективное и масштабируемое).

### <a name="adding-a-page-value-to-the-url"></a>Добавление значения «страница» в URL-адрес

Вместо жестко запрограммированного определенный диапазон страниц, потребуется URL-адреса для включения параметра «страница», который определяет какие Dinner диапазона, запрашивающего пользователя.

#### <a name="using-a-querystring-value"></a>Использование значения строки запроса

В следующем примере кода показано, как можно обновить метод действия нашей Index() поддерживают параметр строки запроса и включение URL-адреса, например */Dinners? страницы = 2*:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample4.cs)]

Описанный выше метод Index() действие имеет параметр с именем «страница». Параметр объявлен как неотрицательного целого (это какие int? указывает). Это означает, что */Dinners? страницы = 2* URL-адрес вызовет значение «2», передается как значение параметра. */Dinners* URL-адрес (без указания значения строки запроса) вызовет значение null должны быть переданы.

Мы умножения значения страницы по размеру страницы (в данном случае 10 строк) чтобы определить, сколько ужинов для пропуска. Мы используем [C#» оператором слияния с null» (?) ](https://weblogs.asp.net/scottgu/archive/2007/09/20/the-new-c-null-coalescing-operator-and-using-it-with-linq.aspx) это полезно при работе с типами, допускающие значение NULL. Приведенный выше код назначает страницы значение 0, если страница параметр имеет значение null.

#### <a name="using-embedded-url-values"></a>С помощью значений внедренных URL-адресов

Вместо использования значение строки запроса будет внедрять параметра страницы в фактический URL-адрес самого. Например: */Dinners/Page/2* или */ужинов/2*. ASP.NET MVC включает мощный модуль маршрутизации URL-адрес, упрощающий для поддержки сценариев следующим образом.

Можно зарегистрировать пользовательские правила маршрутизации, сопоставленные с любой входящий URL-адрес или URL-адрес формат для любого класса или действие метода контроллера нужным нам. Все, что нам нужно задача — это открыть файл Global.asax в данном проекте:

![](implement-efficient-data-paging/_static/image2.png)

А затем зарегистрировать новое правило сопоставления с помощью вспомогательного метода MapRoute() как первый вызов маршрутов. MapRoute() ниже:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample5.cs)]

Выше мы регистрации новое правило маршрутизации с именем «UpcomingDinners». Мы, указывающее, он имеет следующий формат URL-адрес» ужинов/страница / {страницы}», где {page} стало значение параметра внедрен в URL-адрес. Третий параметр метода MapRoute() указывает, что мы следует сопоставить URL-адресов, соответствующих этот формат, чтобы метод действия Index() DinnersController класса.

Можно использовать точное Index() код, который мы имели до с нашем сценарии Querystring — за исключением того, теперь наши параметр «страница» будет получен из URL-адрес и не в строке запроса:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample6.cs)]

Затем теперь мы запустите приложение и введите в */Dinners* мы увидим первые 10 предстоящих ужинов:

![](implement-efficient-data-paging/_static/image3.png)

И при вводе в */Dinners/Page/1* мы рассмотрим следующую страницу ужинов:

![](implement-efficient-data-paging/_static/image4.png)

### <a name="adding-page-navigation-ui"></a>Добавление навигацию по страницам пользовательского интерфейса

Для реализации «Далее» и «раньше» навигации пользовательского интерфейса в нашей Просмотр шаблона, чтобы пользователи могли легко пропустить данные компании Dinner будет последним этапом процесса в нашем сценарии разбиения на страницы.

Чтобы правильно реализовать это, мы необходимо знать общее число ужинов в базе данных, также как много страниц данных в результате. Затем необходимо вычислить, является ли значение текущей запрошенной «страница» в начале или конце данных также скрытие и Отображение «предыдущей» и «далее» пользовательского интерфейса соответствующим образом. Мы может реализовывать эту логику в рамках нашей Index() метода действия. В качестве альтернативы можно добавить вспомогательный класс в свой проект, который инкапсулирует эту логику повторно удобным образом.

Ниже приведен простой «PaginatedList» вспомогательный класс, который является производным от списка&lt;T&gt; класс коллекции встроены в .NET Framework. Он реализует класс многократно используемые коллекции, который может использоваться для разбиения по страницам, любая последовательность данных IQueryable. В нашем приложении обновление NerdDinner у нас будет работы над IQueryable&lt;Dinner&gt; результаты, но его может легко использоваться против IQueryable&lt;продукта&gt; или IQueryable&lt;клиента&gt;результатов в других сценариях приложений:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample7.cs)]

Обратите внимание выше как вычисляется, а затем предоставляет свойства, например «PageIndex», «PageSize», «TotalCount» и «TotalPages». Он также предоставляет две вспомогательные свойства «HasPreviousPage» и «HasNextPage», который определяет, является ли страницы данных в коллекции в начале или конце исходной последовательности. Приведенный выше код вызовет двух запросов SQL для выполнения - первый для получения количества общее число объектов компании Dinner (это не возвращает объекты — вместо этого он выполняет инструкцию «ВЫБЕРИТЕ СЧЕТЧИК», которая возвращает целое число), а вторая — для получения строк из данные, необходимые в базе данных для текущей страницы данных.

Затем можно обновлять наши DinnersController.Index() вспомогательный метод для создания PaginatedList&lt;Dinner&gt; из наших DinnerRepository.FindUpcomingDinners() привести и передайте его в нашем Просмотр шаблона:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample8.cs)]

Затем можно изменить шаблон представления \Views\Dinners\Index.aspx наследование от ViewPage&lt;NerdDinner.Helpers.PaginatedList&lt;Dinner&gt; &gt; вместо ViewPage&lt;IEnumerable&lt;Dinner&gt;&gt;, а затем добавьте следующий код в нижнюю часть наших шаблон представления для отображения или скрытия перехода вперед и назад пользовательского интерфейса:

[!code-aspx[Main](implement-efficient-data-paging/samples/sample9.aspx)]

Обратите внимание, выше как мы используем Html.RouteLink() вспомогательный метод для создания нашей гиперссылок. Этот метод аналогичен Html.ActionLink() вспомогательный метод, который мы использовали ранее. Различие заключается в, создания URL-адрес с помощью маршрутизации правила, мы настраиваем в наш файл Global.asax «UpcomingDinners». Это гарантирует, что мы создания URL-адресов для наших Index() метод действия, который имеет формат: */Dinners/страницы / {page}* — там, где значение {page}, является переменной, мы предоставляем выше зависимости от текущей PageIndex.

Теперь при запуске приложения еще раз я приведу 10 ужинов одновременно в нашем браузера:

![](implement-efficient-data-paging/_static/image5.png)

У нас также есть &lt; &lt; &lt; и &gt; &gt; &gt; навигации пользовательского интерфейса в нижней части страницы, позволяющий пропустить вперед и вперед по наши данные с помощью поиска обработчик URL-адресов доступны:

![](implement-efficient-data-paging/_static/image6.png)

| **Раздел стороны: Основные сведения о последствиях IQueryable&lt;T&gt;** |
| --- |
| IQueryable&lt;T&gt; является очень мощная функция, позволяющая ряд интересных отложенное выполнение сценариев (как разбиение на страницы и композиции на основе запросов). Как все широкими возможностями, вы должны быть внимательно отнестись к ее использование и убедитесь, что ее использовать. Это важно понять, что возврат IQueryable&lt;T&gt; вызывающий код для добавления на методы связанных операторов на него и поэтому участвовать в выполнении запроса ultimate позволяет результатов из репозитория. Если предоставить вызывающий код, эта возможность не требуется, то следует вернуть обратно IList&lt;T&gt; или IEnumerable&lt;T&gt; результаты - которых содержатся результаты запроса, так как уже выполняется. Для сценариев разбиения на страницы это потребует Принудительная отправка логики разбиения на страницы фактические данные в репозиторий вызываемого метода. В этом сценарии может обновить метод поиска нашей FindUpcomingDinners() должен иметь сигнатуру, что либо возвращены PaginatedList: PaginatedList&lt; Dinner&gt; FindUpcomingDinners (int pageIndex, int pageSize) {} или возврата обратно IList &lt;Dinner&gt;и использовать для получения общего количества ужинов «totalCount» out param: IList&lt;Dinner&gt; FindUpcomingDinners (int pageIndex, int pageSize, out int totalCount) {} |

### <a name="next-step"></a>Следующий шаг

Теперь взглянем на как можно добавить поддержку проверки подлинности и авторизации для нашего приложения.

> [!div class="step-by-step"]
> [Назад](re-use-ui-using-master-pages-and-partials.md)
> [Вперед](secure-applications-using-authentication-and-authorization.md)
