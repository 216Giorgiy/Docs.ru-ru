---
uid: mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-cs
title: "Итерация &#6; — использование управляемой тестами разработки (C#) | Документы Microsoft"
author: microsoft
description: "В итерации этого шестой мы добавим новые функциональные возможности наше приложение, сначала написание модульных тестов и писать код для модульных тестов. В этой итерации..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2009
ms.topic: article
ms.assetid: 013c3c26-7dc3-41d1-8064-f233c86008b5
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-cs
msc.type: authoredcontent
ms.openlocfilehash: 85426a7d4024b779848c3ffd05f2ab306152000c
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="iteration-6--use-test-driven-development-c"></a>Итерация &#6; — использование управляемой тестами разработки (C#)
====================
по [Microsoft](https://github.com/microsoft)

[Загрузить исходный код](iteration-6-use-test-driven-development-cs/_static/contactmanager_6_cs1.zip)

> В итерации этого шестой мы добавим новые функциональные возможности наше приложение, сначала написание модульных тестов и писать код для модульных тестов. В этой итерации добавим групп контактов.


## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>Создание приложения ASP.NET MVC управления контактами (C#)
  

В этой серии учебники мы создаем всего приложения управления контактами от начала и завершения. Приложение диспетчера контактов позволяет хранить контактные данные - имена, номера телефонов и адресов электронной почты — список людей.

Мы постройте приложение в нескольких итерациях. С каждой итерацией постепенно мы улучшить приложение. Это несколько итераций предназначена для того, чтобы позволяют понять причину для каждого изменения.

- Итерации #1 - создать приложение. В первой итерации мы создадим диспетчера контактов простейшим способом невозможно. Добавлена поддержка для основных операций базы данных: создание, чтение, обновление и удаление (CRUD).

- Итерации #2 — сделать приложение поиска работы с низким приоритетом. В этой итерации нам улучшить внешний вид приложения, изменив значение по умолчанию главной страницы представления ASP.NET MVC и каскадные таблицы стилей.

- Итерации #3 - Добавление проверки формы. В третьем проходе добавим проверки базовой формы. Мы запретить отправки формы, не завершая обязательные поля. Мы также для проверки адреса электронной почты и номера телефонов.

- Итерации #4 - сделать приложение слабо. В этой третьей итерации мы воспользоваться преимуществами нескольких шаблонов разработки программного обеспечения, чтобы упростить обслуживание и изменить приложение диспетчера контактов. Например мы выполнили рефакторинг наше приложение, чтобы использовать шаблон репозитория и шаблон внедрения зависимостей.

- Итерации #5 - Создание модульных тестов. В пятой итерации сделан нашего приложения проще в обслуживании и изменить, добавив модульных тестов. Мы макета наших классов модели данных и создания модульных тестов для наших контроллеров и логику проверки.

- Итерация &#6; — с помощью управляемой тестами разработки. В итерации этого шестой мы добавим новые функциональные возможности наше приложение, сначала написание модульных тестов и писать код для модульных тестов. В этой итерации добавим групп контактов.

- Итерации #7. Добавление функциональности Ajax. В седьмой итерации мы повысить скорость реагирования и производительности приложения, добавляя поддержку Ajax.

## <a name="this-iteration"></a>Этой итерации

В предыдущих итерациях приложение диспетчера контактов мы создали модульные тесты для обеспечения средство подстраховки наш код. Чтобы сделать код более устойчивым, чтобы изменить был мотивация для создания модульных тестов. С помощью модульных тестов на месте мы счастью изменения наш код и немедленно узнаете ли мы нарушили существующие функциональные возможности.

В этой итерации мы используем модульных тестов для абсолютно другой цели. В этой итерации, мы используем модульных тестов в рамках принципы разработки приложений, которые вызывается *управляемой тестами разработки*. Если вы на практике разработки через тестирование, сначала создать тесты и затем написать код для выполнения тестов.

Точнее, при числе управляемой тестами разработки, состоит из трех шагов, которые выполняются при создании кода (красный или зеленый/рефакторинг):

1. Написать модульный тест, происходит сбой (красный)
2. Написать код, который передает модульного теста (зеленый)
3. Выполнить рефакторинг кода (оптимизации)

Во-первых можно написать модульный тест. Модульный тест необходимо выражать ваше намерение для как предполагается, что код поведение. При создании модульного теста в модульный тест должен завершиться ошибкой. Тест должен завершиться ошибкой, так как код приложения, который будет проходить тест еще не записаны.

После этого достаточно код пишется в порядке для модульного теста для передачи. Цель заключается в написании кода образом laziest, sloppiest и быстрым невозможно. Не следует тратить время думать об архитектуре приложения. Вместо этого следует уделить внимание запись минимальный объем кода, необходимого для удовлетворения намерение выражается модульного теста.

Наконец после написания кода достаточно можно шаг назад и рассмотрим общую архитектуру приложения. На этом шаге вы переписать (рефакторинга) код, используя преимущества разработки программного обеспечения, шаблоны — например шаблон репозитория--таким образом, более простого в сопровождении кода. Код на этом шаге fearlessly можно переписать так, как код, связанная с модульными тестами.

Существует много преимуществ, возникающие в результате упражнений управляемой тестами разработки. Во-первых, управляемой тестами разработки заставляет сосредоточиться на код, который фактически необходимо записать. Поскольку постоянно выделена просто написание кода, недостаточно для передачи конкретного теста, не смогут велика в weeds и записи больших объемов кода, никогда не будет использоваться.

Во-вторых методологии разработки «сначала test» приходится писать код с точки зрения использования кода. Другими словами при числе управляемой тестами разработки, постоянно пишется тестов с точки зрения пользователя. Таким образом управляемой тестами разработки может привести к API-интерфейсы более понятным и более понятным.

Наконец управляемой тестами разработки принудительно создать модульные тесты как часть обычного процесса создания приложения. По мере приближения срока выполнения проекта тестирования обычно является первое, что идет окна. При числе управляемой тестами разработки, с другой стороны, вы, скорее всего, быть действенных о написании модульных тестов, поскольку управляемой тестами разработки делает модульные тесты центра в процесс построения приложения.

> [!NOTE] 
> 
> Дополнительные сведения об управляемой тестами разработки я рекомендуется прочитать книги Майкла Физерса **эффективная работа со старым кодом**.


В этой итерации мы добавим новую функцию наше приложение диспетчера контактов. Мы добавили поддержку для группы контактов. Можно использовать группы контакт Организация контактов по категориям, например бизнеса и Friend.

Мы добавим эти новые командлеты для нашего приложения, выполнив процесс разработки через тестирование. Мы записываем нашей модульных тестов сначала, и мы записываем все наш код для этих тестов.

## <a name="what-gets-tested"></a>Что возвращает тестирования

Как уже говорилось в предыдущих итерациях, обычно не создавать модульные тесты для логики доступа к данным или просмотра логику. Вы не хотите t создавать модульные тесты для логики доступа к данным, так как доступ к базе данных является относительно медленным операции. Вы не хотите t создавать модульные тесты для представления логики, так как доступ к представлению требуется для настройки веб-сервера, который является относительно медленным операцией. T не старее написать модульный тест, если тест может выполняться снова и снова очень быстро

Поскольку управляемой тестами разработки определяется модульные тесты, мы изначально уделить внимание написанию контроллера и бизнес-логики. Мы не касается базы данных или представления. Мы выиграл t изменения базы данных или создания нашей представлений до окончания этого учебника. Мы начнем с что можно протестировать.

## <a name="creating-user-stories"></a>Создание пользовательских описаний функциональности

При числе управляемой тестами разработки, сначала всегда Написание теста. Немедленно, это вызывает вопрос: как решить, какой тест писать сначала? Чтобы ответить на этот вопрос, следует писать набор [ **описаний функциональности пользователей**](http://en.wikipedia.org/wiki/User_stories).

Описания функциональности пользователя является очень краткое описание требования к программному обеспечению (обычно одно предложение). Он должен быть нетехнических описание требование записи с точки зрения пользователя.

Здесь s набора пользовательских описаний функциональности, описывающие функции, необходимые для новых функциональных возможностей обратитесь к группе:

1. Пользователь может просматривать список групп контактов.
2. Пользователь может создавать новые группы контактов.
3. Пользователь может удалить существующую группу контактов.
4. Пользователь может выбрать группу контактов, при создании нового контакта.
5. Пользователь может выбрать группу контактов, при редактировании существующего контакта.
6. Список групп контактов отображается в представлении индекса.
7. Когда пользователь щелкает группу контактов, отображается список совпадающих контактов.

Обратите внимание, что этот список описаний функциональности пользователей вполне понятно клиентом. Нет Техническая реализация не указываются.

Хотя в процессе построения приложения, набора пользовательских историй может стать проще и удобнее. Описания функциональности пользователя может разбить на несколько описаний функциональности (требования). Например можно решить, что создания новой группы контактов привлечь проверки. Отправка группу контактов без имени должен возвращать ошибку проверки.

После создания списка описаний функциональности пользователей, все готово для записи первый модульный тест. Мы начнем с создания модульного теста для просмотра списка групп контактов.

## <a name="listing-contact-groups"></a>Список групп контактов

Наш первый описания функциональности пользователя является, пользователь должен иметь права для просмотра списка групп контактов. Нам нужно express этой истории с тестом.

Создать новый модульный тест, щелкнув правой кнопкой мыши папку Controllers в проекте ContactManager.Tests выбора **Add, новый тест**и выбрав **модульного теста** шаблона (см. рис. 1). Имя нового модульного тестирования GroupControllerTest.cs и нажмите кнопку **ОК** кнопки.


[![Добавление GroupControllerTest модульного теста](iteration-6-use-test-driven-development-cs/_static/image1.jpg)](iteration-6-use-test-driven-development-cs/_static/image1.png)

**На рисунке 01**: Добавление модульного теста GroupControllerTest ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image2.png))


Наш первый модульный тест содержится в листинге 1. В этом тесте проверяется, что метод Index() контроллера группы возвращает набор групп. Тест проверяет, что коллекция группы возвращается в представлении данных.

**Листинг 1 - Controllers\GroupControllerTest.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample1.cs)]

При вводе кода сначала в список 1 в Visual Studio вы сможете получить массу красной волнистой линией. Классы GroupController или группа не создана.

На этом этапе мы можем даже построения t нашего приложения, поэтому мы можем t выполнение наш первый модульный тест. Хороший s. Считается непройденного теста. Таким образом мы теперь имеет разрешения на запуск написания кода приложения. Нам необходимо написать код, достаточно для выполнения в нашем тесте.

Класс контроллера группы в списке 2 содержит допустимый минимум кода, необходимого для передачи модульного теста. Действие Index() возвращает статически закодированного список групп (группы класс определен в списке 3).

**Листинг 2 - Controllers\GroupController.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample2.cs)]

**Листинг 3 - Models\Group.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample3.cs)]

После добавить классы GroupController и группа проектов, наш первый модульный тест завершается успешно (см. рис. 2). Мы выполнили минимальные необходимые действия, чтобы пройти проверку. Пора отметить.


[![Выполнена успешно!](iteration-6-use-test-driven-development-cs/_static/image2.jpg)](iteration-6-use-test-driven-development-cs/_static/image3.png)

**На рисунке 02**: успех! () [Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image4.png))


## <a name="creating-contact-groups"></a>Создание групп контактов

Теперь можно продолжать второй описанием функциональности пользователя. Необходимо иметь возможность создавать новые группы контактов. Нам нужно express ее с тестом.

Тест в листинге 4 проверяет, что вызов Create(), метод с новой группой добавляет группу в список групп, возвращенный методом Index(). Другими словами Если создать новую группу, я должно быть возможность получить новую группу из списка групп, возвращенный методом Index().

**Листинг 4 - Controllers\GroupControllerTest.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample4.cs)]

Тест в листинге 4 вызывает группы контроллера метод Create() с нового контакта группы. Затем тест проверяет, что вызов контроллера группы Index() метод возвращает новую группу в представлении данных.

Изменения группы контроллер в листинге 5 содержит минимальный набор изменений, необходимых для передачи нового теста.

**Список 5 - Controllers\GroupController.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample5.cs)]

## <a name="the-group-controller-in-listing-5-has-a-new-create-action-this-action-adds-a-group-to-a-collection-of-groups-notice-that-the-index-action-has-been-modified-to-return-the-contents-of-the-collection-of-groups"></a>Контроллер группы в листинге 5 содержит действие новых Create(). Это действие добавляет группу в коллекцию групп. Обратите внимание, действие Index() был изменен для возврата содержимого коллекции групп.

Опять же мы выполнили bare минимальный объем работ, необходимый для передачи модульного теста. После мы внести эти изменения к контроллеру группу, все наши модульные тесты пройдены.

## <a name="adding-validation"></a>Добавление проверки

Это требование не было явно указано в описания функциональности пользователя. Тем не менее это целесообразно потребовать имя группы. В противном случае Организация контактов в группы не будет очень полезным.

Перечисление 6 содержит новый тест, обозначающим ее. Этот тест проверяет, что попытка создать группу без указания имени результатов в сообщение об ошибке проверки в состоянии модели.

**Перечисление 6 - Controllers\GroupControllerTest.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample6.cs)]

Для удовлетворения этого теста, необходимо добавить свойство имени в нашем группу (см. Листинг 7). Кроме того нам нужно добавить небольшая логику проверки в нашей группы контроллер s Create() действие (см. список 8).

**Листинг 7 - Models\Group.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample7.cs)]

**8 - Controllers\GroupController.cs со списком**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample8.cs)]

Обратите внимание, что группа контроллера Create() действие логику проверки и базы данных. В настоящее время базы данных, используемое контроллером группа состоит из не более чем коллекции в памяти.

## <a name="time-to-refactor"></a>Время для оптимизации кода

На третьем шаге красный, зеленый и рефакторинг входит рефакторинга. На этом этапе необходимо отойти от нашего кода и рассмотрите, как мы можем выполнить рефакторинг нашего приложения для повышения его разработки. На этапе рефакторинга выполняется этап, когда мы считаем, что жесткие о лучший способ реализации принципы разработки программного обеспечения и шаблоны.

Можно свободно изменить наш код каким-либо образом, мы решили улучшить конструкцию кода. У нас есть средство подстраховки модульных тестов, которые нам предотвратить прерывание существующие функциональные возможности.

В данный момент, нашей группы контроллер является карточки с точки зрения Хорошая архитектура программного обеспечения. Контроллер группа содержит запутанную карточки проверки и код доступа к данным. Чтобы не нарушать персональной ответственности, нам необходимо разделить эти проблемы на различных классов.

Наш рефакторингу класс контроллера группы содержится в Листинг 9. Контроллер был изменен для использования ContactManager уровня службы. Это же уровень служб, мы используем с контроллером контакта.

Перечисление 10 содержит новые методы, добавляется на слой ContactManager службы для поддержки проверки, форматирование и создание групп. Интерфейс IContactManagerService был обновлен для включения новых методов.

Перечисление 11 содержит новый класс FakeContactManagerRepository, который реализует интерфейс IContactManagerRepository. В отличие от класса EntityContactManagerRepository, который также реализует интерфейс IContactManagerRepository наш класс FakeContactManagerRepository не взаимодействуют с базой данных. Класс FakeContactManagerRepository использует находящуюся в памяти коллекцию как прокси для базы данных. Мы будем использовать этот класс в нашем модульные тесты как слой имитацией хранилища.

**Листинг 9 - Controllers\GroupController.cs.**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample9.cs)]

**Перечисление 10 - Controllers\ContactManagerService.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample10.cs)]

**Перечисление 11 - Controllers\FakeContactManagerRepository.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample11.cs)]

Изменение IContactManagerRepository, интерфейс требует использования для реализации методов CreateGroup() и ListGroups() в классе EntityContactManagerRepository. Laziest и наиболее быстрый способ сделать это — добавление заглушки методов, которые выглядят следующим образом:   

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample12.cs)]


Наконец эти изменения в структуре приложения требуют нам внести некоторые изменения в наших модульных тестов. Теперь нам нужно использовать FakeContactManagerRepository при выполнении модульных тестов. Обновленный класс GroupControllerTest содержится листинг 12.

**Пример 12 - Controllers\GroupControllerTest.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample13.cs)]

После мы убедитесь, что все эти изменения, опять же, все наши модульные тесты пройдены. Мы завершили весь цикл красный, зеленый и рефакторинг. Мы применили первый две пользовательские истории. Теперь у нас есть поддержка модульных тестов для требований, представленных в описания функциональности пользователей. Реализация оставшуюся часть описаний функциональности пользователей включает в себя повторять этот же цикл красный, зеленый и рефакторинг.

## <a name="modifying-our-database"></a>Изменения в базе данных

К сожалению несмотря на то, что мы выполнены все требования, выраженный с нашей модульных тестов, нашей работе не выполняется. Мы все еще требуется изменить базе данных.

Необходимо создать новую таблицу базы данных группы. Выполните следующие действия.

1. В окне обозревателя решений щелкните правой кнопкой мыши папку «таблицы» и выберите пункт меню в **добавить новую таблицу**.
2. Введите два столбца, описанные ниже, в конструкторе таблиц.
3. Пометьте столбец идентификатора как первичный ключ и столбце идентификаторов.
4. Сохраните новую таблицу с именем группы, щелкнув значок дискеты.

<a id="0.11_table01"></a>


| **Имя столбца** | **Тип данных** | **Разрешить значения NULL** |
| --- | --- | --- |
| Идентификатор | int | False |
| Имя | nvarchar(50) | False |


Затем нужно удалить все данные из таблицы Contacts (в противном случае мы выиграл t можно создавать связи между таблицами контакты и группы). Выполните следующие действия.

1. Щелкните правой кнопкой мыши таблицу Contacts и выбрать пункт меню **Показать таблицу данных**.
2. Удалите все строки.

Теперь нам нужны для определения связи между таблицей базы данных групп и существующая таблица базы данных контактов. Выполните следующие действия.

1. Дважды щелкните в таблице контактов в окне обозревателя серверов, чтобы открыть конструктор таблиц.
2. Добавьте новый столбец целочисленного типа к таблице Contacts, с именем GroupId.
3. Нажмите кнопку связь, чтобы открыть диалоговое окно связи по внешнему ключу (см. рис. 3).
4. Нажмите кнопку Добавить.
5. Нажмите кнопку с многоточием рядом с кнопку спецификация столбцы и таблицы.
6. В диалоговом окне таблиц и столбцов выберите группы, как идентификатор в качестве столбца первичного ключа и таблицу первичного ключа. Указать контакты в качестве GroupId как столбец внешнего ключа таблицы внешнего ключа (см. рис. 4). Нажмите кнопку "ОК".
7. В разделе **спецификация INSERT и UPDATE**, выберите значение **Cascade** для **удалить правило**.
8. Нажмите кнопку "Закрыть", чтобы закрыть диалоговое окно связи по внешнему ключу.
9. Нажмите кнопку Сохранить, чтобы сохранить изменения в таблице Contacts.


[![Создание связи таблицы базы данных](iteration-6-use-test-driven-development-cs/_static/image3.jpg)](iteration-6-use-test-driven-development-cs/_static/image5.png)

**На рисунке 03**: Создание связи таблицы базы данных ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image6.png))


[![Задание связей между таблицами](iteration-6-use-test-driven-development-cs/_static/image4.jpg)](iteration-6-use-test-driven-development-cs/_static/image7.png)

**На рисунке 04**: указание связи между таблицами ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image8.png))


### <a name="updating-our-data-model"></a>Обновление модели данных

Теперь нам нужны для обновления модели данных для представления новой таблицы базы данных. Выполните следующие действия.

1. Дважды щелкните файл ContactManagerModel.edmx в папку Models, чтобы открыть конструктор сущностей.
2. Щелкните правой кнопкой мыши область конструктора и выберите пункт меню в **обновление модели из базы данных**.
3. В мастере обновления выберите группы таблицы и нажмите кнопку Готово кнопку (см. рис. 5).
4. Щелкните правой кнопкой мыши сущность группы и выберите пункт меню в **переименование**. Измените имя *группы* сущность *группы* (единственного числа).
5. Щелкните правой кнопкой мыши свойство навигации группы, которое отображается в нижней части сущности Contact. Измените имя *группы* свойство навигации для *группы* (единственного числа).


[![Обновление модели Entity Framework из базы данных](iteration-6-use-test-driven-development-cs/_static/image5.jpg)](iteration-6-use-test-driven-development-cs/_static/image9.png)

**На рисунке 05**: обновление модели из базы данных Entity Framework ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image10.png))


После выполнения этих шагов модель данных будет представлять контакты и группы таблиц. Конструктор сущностей должны показывать обе сущности (см. рис. 6).


[![Отображение группы и обратитесь в службу конструктора сущностей](iteration-6-use-test-driven-development-cs/_static/image6.jpg)](iteration-6-use-test-driven-development-cs/_static/image11.png)

**На рисунке 06**: Entity Designer отображения группы и обратитесь в службу ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image12.png))


### <a name="creating-our-repository-classes"></a>Создание классов нашей репозитория

Далее необходимо реализовать класс нашей репозитория. В течение этой итерации мы добавили новые методы в интерфейсе IContactManagerRepository при написании кода для удовлетворения наших модульных тестов. Окончательная версия интерфейса IContactManagerRepository содержится в 14 со списком.

**Перечисление 14 - Models\IContactManagerRepository.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample14.cs)]

Мы не использовали t фактически реализации любого из методов, относящиеся к работе с группами, обратитесь в службу. В настоящее время EntityContactManagerRepository класс имеет методы-заглушки для каждого из методов группы контактов, перечисленных в интерфейсе IContactManagerRepository. Например метод ListGroups() в данный момент выглядит следующим образом:

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample15.cs)]

Методы-заглушки позволит нам скомпилировать нашего приложения и модульные тесты. Однако теперь пора фактически реализуют эти методы. Окончательная версия класса EntityContactManagerRepository содержится в Листинг 13.

**Листинг 13 - Models\EntityContactManagerRepository.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample16.cs)]

### <a name="creating-the-views"></a>Создание представления

Приложение ASP.NET MVC, при использовании механизма представления ASP.NET по умолчанию. Таким образом пункт не создавать представления в ответ на определенный модульного теста. Тем не менее, так как приложение будет бесполезен без представлений, мы можем t завершить эту итерацию без создания и изменения представления, содержащиеся в приложение диспетчера контактов.

Необходимо создать следующие новые представления для управления группами, обратитесь в службу (см. рис. 7):

- Views\Group\Index.aspx - отображает список групп контактов
- Views\Group\Delete.aspx - форма отображает подтверждение для удаления группы контактов


[![Индекс группы представления](iteration-6-use-test-driven-development-cs/_static/image7.jpg)](iteration-6-use-test-driven-development-cs/_static/image13.png)

**Рисунок 07**: индекс, представляющий группу представление ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image14.png))


Нам нужно изменить следующие существующие представления, таким образом, чтобы они включали групп контактов:

- Views\Home\Create.aspx
- Views\Home\Edit.aspx
- Views\Home\Index.aspx

Для проверки измененного представления приложения Visual Studio, в этом учебнике приводится. Например на рис. 8 показана представление Index контакта.


[![Представление указателя контактов](iteration-6-use-test-driven-development-cs/_static/image8.jpg)](iteration-6-use-test-driven-development-cs/_static/image15.png)

**Рисунок 08**: представление Index контакт ([Просмотр полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image16.png))


## <a name="summary"></a>Сводка

В этой итерации мы добавили новые функциональные возможности в наше приложение диспетчера контактов, следуя методологии разработки через тестирование разработки приложения. Мы начали с помощью набора пользовательских описаний функциональности. Мы создали набор модульных тестов, соответствующий требованиям выражается описаний функциональности пользователей. Наконец мы написали код, достаточно для удовлетворения требований, представленных в модульные тесты.

По окончании мы написание кода, недостаточно для удовлетворения требований, представленных в модульные тесты, мы обновили наш базы данных и представления. Мы Добавление новой группы таблицы в базе данных, а также изменили нашей модели данных Entity Framework. Мы также создавать и изменять набор представлений.

В следующей итерации--последней итерации — мы перепишите нашего приложения, чтобы воспользоваться преимуществами Ajax. Используя преимущества Ajax, здесь мы повысить скорость реагирования и производительность приложения диспетчера контактов.

>[!div class="step-by-step"]
[Назад](iteration-5-create-unit-tests-cs.md)
[Вперед](iteration-7-add-ajax-functionality-cs.md)
