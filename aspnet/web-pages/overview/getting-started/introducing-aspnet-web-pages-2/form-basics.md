---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
title: Введение в ASP.NET Web Pages — основы HTML-формы | Документы Microsoft
author: tfitzmac
description: Этот учебник показывает основные сведения о том, как создать форму ввода и как обрабатывать введенные пользователем данные, при использовании веб-страниц ASP.NET (Razor). И теперь, которые...
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/28/2015
ms.topic: article
ms.assetid: 81ed82bf-b940-44f1-b94a-555d0cb7cc98
ms.technology: dotnet-webpages
ms.prod: .net-framework
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
msc.type: authoredcontent
ms.openlocfilehash: 6f44f74774c2fa6338524987779e15f3940d1830
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30898925"
---
<a name="introducing-aspnet-web-pages---html-form-basics"></a>Общие сведения о веб-страницах ASP.NET — основы HTML-формы
====================
по [Tom FitzMacken](https://github.com/tfitzmac)

> Этот учебник показывает основные сведения о том, как создать форму ввода и как обрабатывать введенные пользователем данные, при использовании веб-страниц ASP.NET (Razor). И теперь, когда у вас есть базы данных, чтобы позволить пользователям находить определенные фильмы в базе данных используйте свои навыки формы. Предполагается, что завершена ряда через [Общие сведения для отображения данных с помощью веб-страниц ASP.NET](/aspnet/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/displaying-data).
> 
> Что вы узнаете следующее.
> 
> - Как создать форму с помощью стандартных элементов HTML.
> - Как выполнить чтение пользователь ввода данных в форме.
> - Предоставляет способ создания SQL-запроса, выборочно получает данные с помощью поиска терминов, пользователь.
> - Как с полями, на странице «запомнить» ввод пользователя.
>   
> 
> Обсуждаются функции и технологии:
> 
> - Объект `Request`.
> - SQL `Where` предложения.


## <a name="what-youll-build"></a>Что мы создадим

В предыдущем учебнике создана база данных, добавить данные к нему, а затем используйте `WebGrid` вспомогательный метод для отображения данных. В этом учебнике вы добавите поле поиска позволяет находить фильмы из определенного жанра или которого заголовок содержит любые word ввода. (Например, вы сможете найти все фильмы которого жанре — «Действие» или которого заголовок содержит «Харри» или «Adventure.»)

После завершения работы с учебником, вы получите страницы, похожее на следующее.

![Страница фильмов с поиском жанр и Title](form-basics/_static/image1.png)

Листинг часть страницы является такой же, как последний Учебник &mdash; сетки. Отличие может быть, что в сетке отображаются только фильмы производился поиск.

## <a name="about-html-forms"></a>О HTML-формы

(Если у вас есть опыт создания HTML-форм и разницу между `GET` и `POST`, этот раздел можно пропустить.)

Содержит элементы пользовательского ввода форма &mdash; текстовые поля, кнопки, переключатели, флажки, раскрывающиеся списки и т. д. Пользователи заполнить эти элементы управления или сделайте выбор и отправить форму, путем нажатия кнопки.

В этом примере показана базовый синтаксис формы HTML.

[!code-html[Main](form-basics/samples/sample1.html)]

При запуске этой разметки на странице создает простой формы, который выглядит как на этом рисунке:

![Базовая форма HTML как готовый для просмотра в браузере](form-basics/_static/image2.png)

`<form>` Элемент заключает HTML-элементов, которые требуется отправить. (Является простой ошибки, чтобы добавить элементы на страницу, но затем забывают поместить их в `<form>` элемент. В этом случае ничего не отправляется.) `method` Атрибут предписывает браузеру том, как отправить данные, введенные пользователем. Это значение `post` при выполнении обновления на сервере или к `get` если только что выборка данных с сервера.

<a id="GET,_POST,_and_HTTP_Verb_Safety"></a>

> [!TIP] 
> 
> **GET, POST и HTTP-команду, безопасность**
> 
> HTTP-протокола, браузеры и серверы используют для обмена данными, его основные операции чрезвычайно проста. Браузеры используют только несколько команд для выполнения запросов к серверам. При написании кода для веб-сайта, необходимо понимать эти команды и браузером и сервером их использовании. Использующимся наиболее часто используемых команд указаны следующие:
> 
> - `GET`. Эта команда обозревателем для выборки нечто с сервера. Например, при вводе URL-адрес в адресную строку браузера браузер выполняет `GET` операцию запроса страницы. Если страница содержит графики, браузер выполняет дополнительные `GET` операции для получения изображений. Если `GET` операция имеет для передачи данных на сервер, эти сведения передаются как часть URL-адреса в строке запроса.
> - `POST`. Браузер отправляет `POST` запроса для отправки данных будут добавлены или изменены на сервере. Например `POST` команда используется для создания записей в базе данных или изменение существующих. В большинстве случаев, заполните форму при нажатии кнопки "Отправить", обозреватель выполняет `POST` операцию. В `POST` операции, данные, передаваемые на сервер находится в основной области страницы.
> 
> Это важное различие между эти команды `GET` операции не должен изменять что-либо на сервере — или поместить его в виде немного более абстрактное `GET` операция не приведет к смене состояния на сервере. Можно выполнить `GET` операцию на те же ресурсы столько раз, сколько угодно, а не изменять эти ресурсы. (A `GET` операция часто называется «безопасность», или использовать технический термин, является *идемпотентными*.) В отличие от этого, конечно `POST` запросить изменения, что-нибудь на сервере каждый раз при выполнении операции.
> 
> Два примера будет проиллюстрировать это различие. При выполнении поиска с использованием механизма, например Bing или Google, заполните форму, которая состоит из одного текстового поля и затем нажмите кнопку поиска. Браузер выполняет `GET` операции со значением, введенным в поле, переданная как часть URL-адрес. С помощью `GET` операцию для этого типа формы подходит, так как операции поиска не изменяется все ресурсы на сервере, он просто извлекает сведения.
> 
> Теперь рассмотрим процесс упорядочения, что-либо сети. Введите сведения о заказе и нажмите кнопку "Отправить". Эта операция будет `POST` запрос, поскольку операция приведет к изменению на сервере, например записи нового заказа, изменения в данные учетной записи и может быть других изменений. В отличие от `GET` операции, не может повторяться в `POST` запроса — Если вы выполнили, каждый раз повторно запрос, создается новый заказ на сервере. (В таких случаях веб-сайтов часто предупредит не нажимать кнопку отправки более одного раза или отключит кнопки "Отправить", чтобы не отправку формы случайно.)
> 
> В этом учебнике будет использоваться `GET` операции и `POST` операции для работы с HTML-формы. Мы объясним, в том, почему каждого варианта команды, используемой содержится правильный.
> 
> (Дополнительные сведения о HTTP-команд, см. в разделе [определений методов](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) статье на сайте консорциума W3C.)


Большинство элементов ввода пользователя находятся HTML `<input>` элементов. Они выглядят `<input type="type" name="name">,` где *тип* указывает тип элемента управления вводом пользователя, необходимо. Эти элементы являются наиболее частых из них:

- Текстовое поле: `<input type="text">`
- Флажок: `<input type="check">`
- Переключатель: `<input type="radio">`
- кнопки: `<input type="button">`
- Кнопка отправки: `<input type="submit">`

Можно также использовать `<textarea>` элемент для создания многострочного текстового поля и `<select>` элемент для создания раскрывающегося списка или прокручиваемого списка. (Дополнительные сведения о HTML элементах form, см. в разделе [HTML-формы и ввода](http://www.w3schools.com/html/html_forms.asp) на сайте W3Schools.)

`name` Атрибут очень важен, так как оно получение значение элемента в более поздней версии, как вы увидите в ближайшее время.

Особый интерес представляет, разработчик, выполняемых с входные данные пользователя. Отсутствует встроенный поведение связанную с этими элементами. Вместо этого необходимо получить значения, которые пользователь ввести или выбрать и с ними. Это будет рассмотрен в этом учебнике.

> [!TIP] 
> 
> **HTML5 и формами ввода**
> 
> Как правило, HTML находится в состоянии перехода и последнюю версию (HTML5) включает поддержку интуитивно способы, которыми пользователи будут вводить данные. Например в HTML5, (разработчик страницы) можно настроить страницы, необходимо, чтобы пользователь мог ввести дату. Затем, браузер может автоматически отображать календаре, а не требуют от пользователя ввести дату вручную. Тем не менее новые HTML5 и еще не поддерживается во всех браузерах.
> 
> Веб-страницы ASP.NET поддерживает входных данных при условии, что обозреватель пользователя делает HTML5. Для получения представления о новых атрибутов для `<input>` в HTML5, см. в разделе [HTML &lt;ввода&gt; атрибут типа](http://www.w3schools.com/html/html_form_input_types.asp) на сайте W3Schools.


## <a name="creating-the-form"></a>Создание формы

В WebMatrix в **файлы** рабочей области, откройте *Movies.cshtml* страницы.

После закрывающей `</h1>` тега и перед открытием `<div>` тег `grid.GetHtml` call, добавьте следующую разметку:

[!code-html[Main](form-basics/samples/sample2.html)]

Эта разметка создает форму, которая содержит текстовое поле с именем `searchGenre` и кнопку submit. Текст поле и отправьте кнопка заключаются в `<form>` элемент которого `method` атрибута задано значение `get`. (Следует помнить, что если не включить в текстовое поле, а кнопка внутри отправки `<form>` элемент, при нажатии кнопки ничего не будет отправлено.) Вы используете `GET` команда здесь так, как вы создаете формы, не вносит изменения на сервере — только в результате поиска. (В предыдущем учебнике используется `post` метод, который является, как отправить изменения на сервер. Вы увидите, в следующем уроке еще раз.)

Запустите страницу. Несмотря на то, что любое поведение формы еще не определен, вы увидите, как оно выглядит:

![Страница фильмов с поле поиска для жанр](form-basics/_static/image3.png)

Введите значение в текстовое поле, например «Комедия». Нажмите кнопку **жанр поиска**.

Запишите URL-адрес страницы. Так как задать `<form>` элемента `method` атрибут `get`, введенное значение теперь является частью строки запроса в URL-адрес, следующим образом:

`http://localhost:45661/Movies.cshtml?searchGenre=Comedy`

## <a name="reading-form-values"></a>Считывание значений формы

Страница уже содержит код, который получает данные базы данных и отображение результатов в виде сетки. Теперь необходимо добавить некоторый код, который считывает значение текстового поля, чтобы можно было запустить SQL-запрос, включающий условие поиска.

Поскольку значение формы метод `get`, можно считывать значение, введенное в текстовое поле, с помощью кода следующим образом:

`var searchTerm = Request.QueryString["searchGenre"];`

`Request.QueryString` Объекта ( `QueryString` свойство `Request` объекта) включает в себя значения элементов, которые были отправлены в рамках `GET` операции. `Request.QueryString` Свойство содержит *коллекции* (список) значений, переданных в форме. Для получения всех индивидуальных значений, укажите имя нужного элемента. Вот почему необходимо иметь `name` атрибут `<input>` элемент (`searchTerm`), создающего текстового поля. (Дополнительные сведения о `Request` см. в разделе [боковой панели](#BKMK_TheRequestObject) более поздней версии.)

Это довольно простой, считывается значение текстового поля. Однако если пользователь ничего не введено вообще в текстовом поле, но щелчке **поиска** в любом случае, можно пропустить, щелкните, так как нет элементов для поиска.

Ниже приведен пример, в котором показано, как реализовать эти условия. (Не нужно добавить этот код еще предстоит выполнить, чуть позже.)

[!code-csharp[Main](form-basics/samples/sample3.cs)]

Разбивает теста таким образом:

- Получить значение `Request.QueryString["searchGenre"]`, а именно, введенный в значение `<input>` элемента с именем `searchGenre`.
- Узнайте, пуст ли с помощью `IsEmpty` метод. Этот метод является стандартным способом, чтобы определить, содержит ли что-то (например, элемент form) значение. Но, необходима только в том случае, если он имеет *не* пуст, поэтому...
- Добавить `!` оператор перед `IsEmpty` тестирования. ( `!` Оператор означает логическое не).

На английском, вся `if` условие преобразуется в следующее: *Если формы searchGenre элемент не является пустым, затем...*

Этот блок задает рабочей области для создания запроса, использующего поисковому запросу. Вы сможете сделать, в следующем разделе.

<a id="BKMK_TheRequestObject"></a>

> [!TIP] 
> 
> **Объект запроса**
> 
> `Request` Объект содержит всю информацию, браузер отправляет в приложение при страницы запрошенный или отправки. Этот объект включает все сведения, предоставленные пользователем, как значения текстового поля или файл для передачи. Она также включает все виды Дополнительные сведения, например файлы cookie, значения в строке запроса URL-адрес (если таковые имеются), путь к файлу страницы, на котором выполняется тип браузера, которое пользователь использует список языков, заданных в браузере и многое другое.
> 
> `Request` Объект *коллекции* (список) значений. Получить отдельные значения из коллекции, указав его имя:
> 
> `var someValue = Request["name"];`
> 
> `Request` Объект фактически предоставляет несколько подмножеств. Пример:
> 
> - `Request.Form` Предоставляет значения из элементов в указанной `<form>` элемент, если запрос является `POST` запроса.
> - `Request.QueryString` предоставляет только значения в строке запроса URL-адрес. (В URL-адрес: `http://mysite/myapp/page?searchGenre=action&page=2`, `?searchGenre=action&page=2` раздел URL-адрес является строка запроса.)
> - `Request.Cookies` Коллекция предоставляет доступ к файлам cookie, отправленных браузер.
> 
> Чтобы получить значение, которое известно в отправленной формы, можно использовать `Request["name"]`. Кроме того, можно использовать более конкретные версии `Request.Form["name"]` (для `POST` запросов) или `Request.QueryString["name"]` (для `GET` запросов). Конечно *имя* имя элемента.
> 
> Имя элемента, который вы хотите получить должно быть уникальным в пределах коллекции, которую вы используете. Вот почему `Request` объект предоставляет подмножества, например `Request.Form` и `Request.QueryString`. Предположим, что страница содержит элемент формы с именем `userName` и *также* содержащее куки-файл с именем `userName`. Если вы получаете `Request["userName"]`, он является неоднозначным, нужно ли значение формы или куки-файл. Тем не менее если вы получаете `Request.Form["userName"]` или `Request.Cookie["userName"]`, вы поступили явно значение, которое нужно получить.
> 
> Рекомендуется указать точно и использовать подмножество `Request` , вас интересует, как `Request.Form` или `Request.QueryString`. Для простых страниц, которые вы создаете в этом учебнике он, скорее всего, не менять действительно. Тем не менее, при создании более сложных страниц, с помощью явного версии `Request.Form` или `Request.QueryString` поможет вам избежать проблем, которые могут возникнуть, когда страница содержит формы (или несколько форм), файлы cookie, значения строки запроса и т. д.


## <a name="creating-a-query-by-using-a-search-term"></a>Создание запроса с помощью условия поиска

Теперь, когда вы знаете, как получить условия поиска, введенного пользователем, можно создать запрос, который его использует. Помните, что для получения всех элементов фильма из базы данных, вы используете запрос SQL, который выглядит как эта инструкция:

`SELECT * FROM Movies`

Чтобы получить только определенные фильмы, необходимо использовать запрос, включающий `Where` предложения. Это предложение позволяет задавать условия, на котором строки возвращаются запросом. Ниже приведен пример:

`SELECT * FROM Movies WHERE Genre = 'Action'`

Стандартный формат имеет `WHERE column = value`. Можно использовать различные операторы, кроме только что `=`, таких как `>` (больше), `<` (меньше), `<>` (не равно), `<=` (меньше или равно), т. д., в зависимости от того, что вы ищете.

В случае, если вам интересно, инструкции SQL не учитывается регистр &mdash; `SELECT` совпадает со значением `Select` (или даже `select`). Тем не менее, люди часто выгоду ключевые слова в инструкции SQL, таких как `SELECT` и `WHERE`, чтобы сделать его более удобным для чтения.

### <a name="passing-the-search-term-as-a-parameter"></a>Передача в качестве параметра условия поиска

Поиск конкретного жанр достаточно просто (`WHERE Genre = 'Action'`), но вы хотите иметь возможность искать любые жанра, вводимых пользователем. Чтобы сделать это, создаваемых в SQL-запрос, который включает заполнитель для значения для поиска. Будет выглядеть, как эта команда:

`SELECT * FROM Movies WHERE Genre = @0`

Является прототипом `@` символ за которыми следует ноль. Как можно догадаться, запрос может содержать несколько заполнители и будет называться `@0`, `@1`, `@2`и т. д.

Настройка запроса и фактически передает значение, используйте код, аналогичный следующему:

[!code-sql[Main](form-basics/samples/sample4.sql)]

Это тот же том, что вы уже сделали для отображения данных в сетке. Единственными отличиями являются:

- Запрос содержит заполнитель (`WHERE Genre = @0"`).
- Запрос помещается в переменную (`selectCommand`), прежде чем вы передали запрос непосредственно в `db.Query` метод.
- При вызове `db.Query` метода, передаче запроса и значение, используемое для заполнителя. (Если запрос содержит несколько заполнителей, следует передавать их все как отдельные значения для метода.)

Если поместить эти элементы друг с другом, отобразится следующий код:

[!code-csharp[Main](form-basics/samples/sample5.cs)]

> [!NOTE] 
> 
> **Важно!** С помощью заполнителей (таких как `@0`) для передачи значений в команды SQL является *крайне важно* для обеспечения безопасности. Он отображается, с заполнителями для данных переменной, способ является единственным способом, следует создавать команды SQL.
> 
> Никогда не создания инструкции SQL путем объединения (объединения) литеральный текст и значения, которые можно получить от пользователя. Объединения вводимых пользователем данных в одну инструкцию SQL открывает веб-сайт в *атак путем внедрения кода SQL* когда злоумышленник отправляет значения на страницу, взломать базы данных. (Дополнительные статьи о [атаки SQL Injection](https://msdn.microsoft.com/library/ms161953.aspx) веб-сайте MSDN.)


## <a name="updating-the-movies-page-with-search-code"></a>Обновление страницы фильмов с кодом поиска

Теперь можно обновить код в *Movies.cshtml* файла. Чтобы начать, замените код в блоке кода в верхней части страницы следующим кодом:

[!code-csharp[Main](form-basics/samples/sample6.cs)]

Различие состоит в том, что вы помещаете запроса в `selectCommand` переменной, передаваемой в `db.Query` позже. Помещение инструкции SQL в переменную можно изменить оператор, который является то, что вы выполните для выполнения поиска.

Кроме того, вы удалили эти две строки, в которых вы сможете вернуться к более поздней версии:

[!code-csharp[Main](form-basics/samples/sample7.cs)]

Выполните запрос еще не требуется (то есть вызывать `db.Query`) и не нужно инициализировать `WebGrid` вспомогательный еще один. Вам предстоит выполнить эти действия, после вы разобрались, как инструкцию SQL должен выполняться.

После этого перезаписанного блока можно добавить новый логику для обработки поиска. Полный код будет выглядеть следующим образом. Обновите код на странице, чтобы он соответствовал в этом примере:

[!code-cshtml[Main](form-basics/samples/sample8.cshtml)]

Страницы теперь выглядит следующим образом. Каждый раз при запуске страницы код открывает базу данных и `selectCommand` переменной присваивается инструкции SQL, которая возвращает все записи из `Movies` таблицы. Этот код инициализирует также `searchTerm` переменной.

Тем не менее если текущий запрос включает значение для `searchGenre` элемент, в коде устанавливается `selectCommand` к другому запросу, а именно на ту, которая включает в себя `Where` предложение для поиска жанра. Кроме того, задается `searchTerm` независимо от был передан для поля поиска (это может быть nothing).

Независимо от того, какие SQL инструкция находится в `selectCommand`, затем код вызывает `db.Query` для выполнения запроса, передавая ему независимо от возможности `searchTerm`. Если никакая `searchTerm`, не имеет значения, так как в этом случае нет параметра для передачи значения для `selectCommand` несмотря на это.

Наконец, этот код инициализирует `WebGrid` вспомогательный с помощью результатов запроса, так же, как раньше.

Можно видеть, что путем помещения инструкции SQL и условие поиска в переменные, добавленные гибкость кода. Как вы увидите далее в этом учебнике, можно использовать этот базовой платформой и добавлять логику для различных типов поиска.

## <a name="testing-the-search-by-genre-feature"></a>Тестирование возможность поиска по жанру

В WebMatrix, выполните *Movies.cshtml* страницы. Вы увидите страницу с текстовым полем для жанра.

Введите жанра, вы ввели по одной записи теста, а затем нажмите кнопку **поиска**. На этом этапе отобразится список фильмы, которые соответствуют этого жанра:

![Страница фильмы, со списком после поиска жанр «Comedies»](form-basics/_static/image4.png)

Введите другой жанр и повторить поиск. Попробуйте ввести его, используя все и строчные буквы, чтобы вы увидите, что поиск выполняется без учета регистра.

## <a name="remembering-what-the-user-entered"></a>«Запоминание» пользователь ввел

Вы могли заметить, после ввода жанра и щелчке **поиска жанр**, можно было увидеть список для этого жанра. Тем не менее, текстового поля поиска был пустым &mdash; иными словами, он не запоминать был введен.

Важно понять, почему это происходит. При отправке страницы браузер отправляет запрос на веб-сервер. Когда ASP.NET получает запрос, создает совершенно новый экземпляр страницы, выполняет код в нем и выводит страницу в браузере. Фактически, страницы не знает, что только вы работали с предыдущей версии самого себя. Все знает, что он получил запрос существовавшей некоторые данные формы в нем.

При каждом запросе страницы &mdash; в первый раз или отправив его &mdash; для получения новой страницы. Веб-сервер имеет недостаточно памяти последнего запроса. Ни один не ASP.NET, и ни один браузер. Только подключения между этими экземплярами отдельные страницы имеет все данные, передаваемые между ними. Например, при передаче страницы к новому экземпляру страницы можно получить данные формы, которое было отправлено с ранней версии экземпляра. (Другой способ передачи данных между страницами — использовать файлы cookie).

Формальные способ описания этой ситуации — сказать, что веб-страницы находятся *без сохранения состояния*. Веб-серверов и сами страницы и элементы на странице не поддерживать все сведения о состоянии предыдущей страницы. Веб-сайте был разработан таким образом, так как поддержание состояния для отдельных запросов может быстро исчерпать ресурсы веб-серверов, которые часто обработки тысяч, может быть даже сотни тысяч запросов в секунду.

Поэтому поэтому текстовое поле было пустым. После отправки страницы ASP.NET создается новый экземпляр страницы и запустил кода и разметки. Произошла ничего не в этом коде, которые сообщили ASP.NET, чтобы поместить значение в текстовое поле. Поэтому ASP.NET не выполнять никаких действий и текстовое поле прорисован без значения в нем.

Нет фактически простой способ обойти эту проблему. Жанра, введенный в текстовое поле *—* доступна в коде &mdash; в `Request.QueryString["searchGenre"]`.

Обновить разметки для текстового поля, чтобы `value` атрибут получает свое значение из `searchTerm`, как в этом примере:

[!code-html[Main](form-basics/samples/sample9.html?highlight=1)]

На этой странице вы могли также задать `value` атрибут `searchTerm` переменной, так как эта переменная содержит также жанр введено. Однако с помощью `Request` объекта, чтобы зафиксировать `value` атрибута, как показано ниже приведен стандартный способ выполнения этой задачи. (При условии, что требуется даже этого &mdash; в некоторых ситуациях может потребоваться отображать страницу *без* значения в полях. Все зависит происходящем вместе с приложением.)

> [!NOTE]
> «Неизвестен» значение текстового поля, используемый для паролей. Было бы брешь в системе безопасности для заполнения поля пароля с помощью кода.


Снова запустить страницу введите жанра, а щелкните **жанр поиска**. Это время не только вы увидите результаты поиска, но текстовое поле запоминает введенное время последнего:

![Страница, показывающая, что текстовое поле «запомнить» предыдущей записи](form-basics/_static/image5.png)

## <a name="searching-for-any-word-in-the-title"></a>Поиск любых слов в заголовке

Теперь можно выполнять поиск любого жанра, но можно также выполнить поиск по названию. Трудно получить заголовок совершенно верно при поиске, поэтому вместо этого можно искать слово, которое появляется в любом месте внутри заголовка. Чтобы сделать это в SQL, используйте `LIKE` операторы и синтаксис, следующим образом:

`SELECT * FROM Movies WHERE Title LIKE '%adventure%'`

Эта команда возвращает все фильмы, названия которых содержат «adventure». При использовании `LIKE` оператор, включать символ-шаблон `%` как часть условия поиска. Поиск `LIKE 'adventure%'` означает «'adventure'». (Технически означает «Строка adventure следует ничего.») Аналогичным образом, условие поиска `LIKE '%adventure'` означает «все, за которым следует строка 'adventure'», являющееся другим способом, чтобы сказать «заканчивая 'adventure'».

Условие поиска `LIKE '%adventure%'` таким образом означает «с «adventure' в любом месте названия.» (Технически «все в заголовке, следуют 'adventure', следует ничего.»)

Внутри `<form>` элемента, добавьте следующую разметку прямо под закрывающей `</div>` тег для поиска жанр (непосредственно перед закрывающим тегом `</form>` элемент):

[!code-html[Main](form-basics/samples/sample10.html)]

Код для обработки данного поиска аналогичен кода для поиска жанра, за исключением того, что необходимо собрать `LIKE` поиска. Добавьте в блок кода в верхней части страницы, это `if` сразу после блока `if` блок для поиска жанра:

[!code-csharp[Main](form-basics/samples/sample11.cs)]

Этот код использует ту же логику, вы видели ранее, за исключением того, что при поиске используются `LIKE` оператор и помещает кода «`%`» до и после поисковому запросу.

Обратите внимание на то, каким образом было легко добавить другой поиск на страницу. Все, что было нужно было:

- Создание `if` блок, проверяется ли поле поиска соответствующего имел значение.
- Задать `selectCommand` переменной новой инструкции SQL.
- Задать `searchTerm` переменной значение для передачи в запрос.

Вот блок полный код, который содержит новый логику для поиска.

[!code-cshtml[Main](form-basics/samples/sample12.cshtml)]

Ниже приведена сводка делает этот код:

- Переменные `searchTerm` и `selectCommand` инициализируются вверху. Вы собираетесь установить эти параметры для соответствующих поисковому запросу (если таковые имеются) и соответствующей командой SQL, основанных на действия пользователя на странице. Поиск по умолчанию является простой регистр получения всех фильмов из базы данных.
- В тестах для `searchGenre` и `searchTitle`, в коде устанавливается `searchTerm` значение будет выполнять поиск. Эти блоки кода также задать `selectCommand` на соответствующую команду SQL для поиска.
- `db.Query` Метод вызывается только один раз, используя любой команды SQL в `selectedCommand` и значение `searchTerm`. Если условие поиска не задано (не жанр и нет заголовка word), значение `searchTerm` является пустой строкой. Однако это не имеет значения, так как в этом случае запрос не требует параметра.

## <a name="testing-the-title-search-feature"></a>Тестирование функцию поиска заголовка

Теперь можно проверить страницы завершения поиска. Запустите *Movies.cshtml*.

Введите жанра и нажмите кнопку **жанр поиска**. В сетке отображаются фильмы из этого жанра, как и перед.

Введите слово заголовок и нажмите кнопку **заголовок поиска**. В сетке отображаются фильмы, к которым это слово в заголовке.

![После поиска «в заголовке страницы фильмов](form-basics/_static/image6.png)

Не указывайте оба поля и нажмите любую кнопку. В сетке отображаются все фильмов.

## <a name="combining-the-queries"></a>Объединение запросов

Можно заметить, что критерии поиска, который можно выполнить являются взаимоисключающими. Не удается найти заголовок и жанр одновременно, даже если оба поля поиска значений в них. Например нельзя выполнять поиск для всех действий фильмов, заголовок которого содержит «Adventure». (Как страницы кодируется теперь при вводе значения для жанр и title, поиск заголовка получает приоритет). Чтобы создать поиск, который объединяет условия, пришлось бы создать SQL-запроса, который имеет следующий синтаксис:

`SELECT * FROM Movies WHERE Genre = @0 AND Title LIKE @1`

И необходимо выполнить запрос с помощью инструкции следующим образом (Грубо говоря):

`var selectedData = db.Query(selectCommand, searchGenre, searchTitle);`

Создание логики для многих вариантов условия поиска можно получить несколько участвующих как можно видеть. Таким образом мы будем остановиться на этом.

## <a name="coming-up-next"></a>В ближайшее время

В следующем уроке вы создадите страницы, использующей формы, чтобы пользователи могли добавлять фильмы в базу данных.

## <a name="complete-listing-for-movie-page-updated-with-search"></a>Полный пример для страницы фильма (обновляются с использованием поиска)

[!code-cshtml[Main](form-basics/samples/sample13.cshtml)]

## <a name="additional-resources"></a>Дополнительные ресурсы

- [Введение в программирование веб-ASP.NET с использованием синтаксиса Razor](https://go.microsoft.com/fwlink/?LinkID=202890)
- [Предложение WHERE SQL](http://www.w3schools.com/sql/sql_where.asp) на сайте W3Schools
- [Метод определения](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) статье на сайте W3C

> [!div class="step-by-step"]
> [Назад](displaying-data.md)
> [Вперед](entering-data.md)
