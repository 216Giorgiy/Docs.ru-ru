---
uid: web-api/overview/web-api-routing-and-actions/routing-and-action-selection
title: "Маршрутизация и выбор действий в ASP.NET Web API | Документы Microsoft"
author: MikeWasson
description: 
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2012
ms.topic: article
ms.assetid: bcf2d223-cb7f-411e-be05-f43e96a14015
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/routing-and-action-selection
msc.type: authoredcontent
ms.openlocfilehash: 997582263bd48590b74434ee0ffc6be928fa1e08
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="routing-and-action-selection-in-aspnet-web-api"></a>Маршрутизация и выбор действий в веб-API ASP.NET
====================
по [Mike Wasson](https://github.com/MikeWasson)

В этой статье описывается, как веб-API ASP.NET маршрутизирует запрос HTTP для определенного действия на контроллере.

> [!NOTE]
> Высокоуровневый обзор маршрутизации см. в разделе [маршрутизации в ASP.NET Web API](routing-in-aspnet-web-api.md).


В этой статье рассматриваются сведения процесса маршрутизации. Если необходимо создать проект веб-API и найти том, что некоторые запросы не получить направлено должным образом, надеемся Эта статья поможет.

Маршрутизация имеет три основных этапа:

1. Сопоставления URI для шаблона маршрута.
2. При выборе контроллера.
3. Выберите действие.

Некоторые части процесса можно заменить собственные пользовательские поведения. В этой статье описывается поведение по умолчанию. В конце я Обратите внимание, везде, где можно настроить поведение.

## <a name="route-templates"></a>Шаблоны маршрута

Шаблон маршрута выглядит аналогично пути URI, но может иметь значения заполнителя, указав фигурные скобки:

[!code-csharp[Main](routing-and-action-selection/samples/sample1.ps1)]

При создании маршрута можно предоставить значения по умолчанию для некоторых или всех заполнителей:

[!code-csharp[Main](routing-and-action-selection/samples/sample2.cs)]

Можно также ввести ограничения, которые ограничивают как сегмент URI можно сопоставить заполнитель:

[!code-csharp[Main](routing-and-action-selection/samples/sample3.js)]

Платформа ищет совпадение сегментов в пути URI к шаблону. Литералы в шаблоне должны точно совпадать. Заполнитель совпадает с любым значением, если не указать ограничения. Платформа не соответствует другие части URI, таких как имя узла или параметры запроса. Платформа выбирает первый маршрут в таблице маршрутов, который соответствует URI.

Существует два специальных заполнителей: «{controller}» и «{action}».

- «{controller}» предоставляет имя контроллера.
- «{action}» содержит имя действия. В веб-API обычных соглашений — пропустить «{action}».

### <a name="defaults"></a>расписания

При указании значения по умолчанию маршрута будет соответствовать URI, который не удалось обнаружить эти сегменты. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample4.cs)]

URI "`http://localhost/api/products`" будет соответствовать этому маршруту. Сегмент {«категория»} назначается значение по умолчанию «все».

### <a name="route-dictionary"></a>Словарь маршрута

Если платформа находит соответствие для URI, он создает словарь, содержащий значение для каждого заполнителя. Ключи являются именами заполнителей, не включая фигурные скобки. Значения берутся из пути URI или значения по умолчанию. Словарь хранится в **IHttpRouteData** объекта.

На этом этапе сопоставление маршрутов специальной «{controller}» и «{action}» заполнители, обрабатываются так же, как другие заполнители. Просто они хранятся в словаре с другими значениями.

Значение по умолчанию имеют специальное значение **RouteParameter.Optional**. Если заполнитель возвращает это значение, значение не добавляется в словарь маршрута. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample5.cs)]

Словарь маршрута для пути URI «api и продукты» будет содержать следующее:

- контроллер: «продукты»
- Категория: «все»

«Api/продукты/toys/123» Однако словарь маршрута будет содержать:

- контроллер: «продукты»
- Категория: «toys»
- Идентификатор: «123»

Значения по умолчанию можно также включить значение, которое не отображается в любом месте в шаблоне маршрута. Если этот маршрут соответствует, это значение хранится в словаре. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample6.cs)]

Если пути URI «корневой/api/8», словарь будет содержать два значения:

- контроллер: «заказчики»
- Идентификатор: «8»

## <a name="selecting-a-controller"></a>При выборе контроллера

Выбор контроллера обрабатывается **IHttpControllerSelector.SelectController** метод. Этот метод принимает **HttpRequestMessage** экземпляр и возвращает **HttpControllerDescriptor**. Реализация по умолчанию обеспечивается **DefaultHttpControllerSelector** класса. Этот класс будет использоваться алгоритм прост:

1. Искать в словарь маршрута для ключа «controller».
2. Использовано значение для этого ключа и добавить строку «Controller», чтобы получить имя типа контроллера.
3. Ищите контроллер веб-API с таким именем типа.

Например если маршрут словарь содержит пару ключ значение «controller» = «продукты», «ProductsController» имеет тип контроллера. Если отсутствует соответствующий тип или несколько соответствий, платформа возвращает ошибку для клиента.

На шаге 3 **DefaultHttpControllerSelector** использует **IHttpControllerTypeResolver** интерфейс для получения списка типов контроллера веб-API. Реализация по умолчанию **IHttpControllerTypeResolver** возвращает все открытые классы, реализующие (a) **IHttpController**, (б) являются не абстрактный и (c) иметь имя, которое заканчивается на «Controller».

## <a name="action-selection"></a>Выбор действия

После выбора контроллера, платформа выбирает действие, вызвав **IHttpActionSelector.SelectAction** метод. Этот метод принимает **HttpControllerContext** и возвращает **HttpActionDescriptor**.

Реализация по умолчанию обеспечивается **ApiControllerActionSelector** класса. Чтобы выбрать действие, он выполняет поиск следующих:

- Метод HTTP запроса.
- Заполнитель «{action}» в шаблон маршрута, если он имеется.
- Параметры действий в контроллере.

Перед рассмотрением алгоритм выбора, мы должны понять следующее о действиях контроллера.

**Какие именно методы на контроллере, считаются «действия»?** При выборе действия, платформа считывает только открытые методы экземпляра на контроллере. Кроме того, он исключает [«специальным именем»](https://msdn.microsoft.com/library/system.reflection.methodbase.isspecialname) методы (конструкторы, события, перегрузки операторов и т. д.) и методы, унаследованные от **ApiController** класса.

**Методы HTTP.** Платформа выбирает только действий, которые соответствуют метод HTTP запроса определяется следующим образом:

1. Можно указать метод HTTP с атрибутом: **AcceptVerbs**, **HttpDelete**, **HttpGet**, **HttpHead**,  **HttpOptions**, **HttpPatch**, **HttpPost**, или **HttpPut**.
2. В противном случае если имя метода контроллера начинается с «Get», «Post», «Put», «Delete», «Заголовок», «Параметры» или «Исправление», затем по соглашению действие поддерживает, HTTP-метод.
3. Если ни один из перечисленных выше поддерживает метод POST.

**Привязки параметров.** Привязки параметра состоит в том, как веб-API создает значения для параметра. Вот правило по умолчанию для привязки параметра.

- Простые типы, взяты из URI.
- Сложные типы, взяты из текста запроса.

Простые типы включают все [простые типы .NET Framework](https://msdn.microsoft.com/library/system.type.isprimitive), плюс **DateTime**, **десятичное**, **Guid**, **строки** , и **TimeSpan**. Для каждого действия не более одного параметра может считывать текст запроса.

> [!NOTE]
> Это можно переопределить правила привязки по умолчанию. В разделе [привязки параметра WebAPI за кулисами](https://blogs.msdn.com/b/jmstall/archive/2012/05/11/webapi-parameter-binding-under-the-hood.aspx).


С помощью данного цвета фона Вот алгоритм выбора действия.

1. Создайте список всех действий в контроллере, соответствующий метод HTTP-запроса.
2. Если словарь маршрута есть запись «действия», удалите действия, имя которого не соответствует это значение.
3. Повторите для сопоставления параметров действия на URI следующим образом: 

    1. Для каждого действия получите список параметров, которые простого типа, где привязка получает параметр из URI. Исключите необязательные параметры.
    2. В этом списке попробуйте найти совпадения для каждого параметра, словарь маршрута или в строке запроса URI. Совпадения не зависят от регистра и не зависят от порядка параметров.
    3. Выберите действие, где каждый параметр в списке имеет соответствие в URI.
    4. Если более одного действия не отвечает этим критериям, выберите один с большинство параметров соответствия.
4. Игнорировать действия с **[NonAction]** атрибута.

Шаг #3 — вероятно, наиболее путаницу. Основная идея заключается в том, что его значение можно получить параметр из URI, в тексте запроса или из пользовательской привязки. Для параметров, полученные из URI мы хотим убедиться, что URI фактически содержит значение для этого параметра в пути (через словарь маршрута) или в строке запроса.

Например рассмотрим следующее действие:

[!code-csharp[Main](routing-and-action-selection/samples/sample7.cs)]

*Идентификатор* привязка параметра к URI. Таким образом это действие может соответствовать только URI, который содержит значение «идентификатор», или в строке запроса словарь маршрута.

Необязательные параметры представляют собой исключение, так как они не являются обязательными. Для необязательного параметра является работоспособным, если привязка не удалось получить значение из URI.

Исключением являются сложные типы по другой причине. Сложный тип может быть привязан только к URI посредством пользовательской привязки. Однако в этом случае платформа не может заранее знать, будет ли параметр привязан определенный URI. Чтобы узнать, его потребуется вызвать привязки. Алгоритм выбора предназначена для выбора действия из статических описания, перед вызовом любых привязок. Таким образом сложные типы, исключаются из алгоритм сопоставления.

После выбора действия вызываются все привязки параметров.

Сводка:

- Действие должно соответствовать метод HTTP запроса.
- Имя действия должна совпадать с записью «действие» в словарь маршрута, при его наличии.
- Для каждого параметра действия Если параметр берется из URI, затем имя параметра необходимо найти в словарь маршрута или в строке запроса URI. (Исключаются необязательные параметры и параметры со сложными типами).
- Пытаются найти наибольшее число параметров. Оптимальная может быть метод без параметров.

## <a name="extended-example"></a>Подробный пример

Маршруты:

[!code-csharp[Main](routing-and-action-selection/samples/sample8.cs)]

Контроллер:

[!code-csharp[Main](routing-and-action-selection/samples/sample9.cs)]

HTTP-запроса:

[!code-console[Main](routing-and-action-selection/samples/sample10.cmd)]

### <a name="route-matching"></a>Маршрутизации в компоненте

URI, совпадает с именем «DefaultApi» маршрут. Словарь маршрута содержит следующие записи:

- контроллер: «продукты»
- Идентификатор: «1»

Словарь маршрута не содержит параметров строки запроса, «версия» и «подробности», но они по-прежнему будут учитываться во время выбора действия.

### <a name="controller-selection"></a>Выбор контроллера

Из записи «controller» в словарь маршрута, является тип контроллера `ProductsController`.

### <a name="action-selection"></a>Выбор действия

HTTP-запрос — это запрос GET. Действия контроллера, поддерживающих GET являются `GetAll`, `GetById`, и `FindProductsByName`. Словарь маршрута не содержит запись для «действия», поэтому нам не нужен для сопоставления имени действия.

Затем выполняется попытка сопоставить имена параметров для действий, просмотрев операции GET.

| Действие | Параметры соответствия |
| --- | --- |
| `GetAll` | Нет |
| `GetById` | «Идентификатор» |
| `FindProductsByName` | «Имя» |

Обратите внимание, что *версии* параметр `GetById` не учитываются, поскольку он является необязательным параметром.

`GetAll` Элементарно соответствующий метод. `GetById` Также соответствует метод, так как «id» содержит словарь маршрута. `FindProductsByName` Метод не совпадает.

`GetById` Побеждает метод, так как он соответствует один параметр и без параметров для `GetAll`. Метод вызывается со следующими значениями параметров:

- *id* = 1
- *версия* = 1.5

Обратите внимание, что даже если *версии* не использовался в алгоритм выбора, значение параметра берется из строки запроса URI.

## <a name="extension-points"></a>Точки расширения

Веб-API предоставляет точки расширения для некоторых частей процесса маршрутизации.

| Интерфейс | Описание: |
| --- | --- |
| **IHttpControllerSelector** | Выбирает контроллер. |
| **IHttpControllerTypeResolver** | Получает список типов контроллеров. **DefaultHttpControllerSelector** выбирает тип контроллера из этого списка. |
| **IAssembliesResolver** | Возвращает список сборок, проект. **IHttpControllerTypeResolver** интерфейс использует этот список, чтобы найти типы контроллера. |
| **IHttpControllerActivator** | Создает новый экземпляр контроллера. |
| **IHttpActionSelector** | Выбирает действие. |
| **IHttpActionInvoker** | Вызывает действие. |

Чтобы предоставить собственную реализацию для любого из этих интерфейсов, используйте **службы** коллекции на **HttpConfiguration** объекта:

[!code-csharp[Main](routing-and-action-selection/samples/sample11.cs)]
