---
uid: web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2
title: "Атрибут маршрутизации в ASP.NET Web API 2 | Документы Microsoft"
author: MikeWasson
description: 
ms.author: aspnetcontent
manager: wpickett
ms.date: 01/20/2014
ms.topic: article
ms.assetid: 979d6c9f-0129-4e5b-ae56-4507b281b86d
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2
msc.type: authoredcontent
ms.openlocfilehash: 173add73a150d3e13ae243d6548463da912dadee
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="attribute-routing-in-aspnet-web-api-2"></a>Атрибут маршрутизации в ASP.NET Web API 2
====================
по [Mike Wasson](https://github.com/MikeWasson)

*Маршрутизация* как веб-API соответствует URI-адрес действия. Веб-API 2 поддерживает новый тип маршрутизации, вызывается *маршрутизацией атрибутов*. Как следует из имен, атрибут маршрутизации использует атрибуты для определения маршрутов. Атрибут маршрутизации предоставляет больший контроль над URL-адреса в веб-API. Например можно легко создать URI, которые описывают иерархии ресурсов.

Ранее стиль маршрутизации, вызывается на основе соглашений маршрутизации, по-прежнему полностью поддерживается. На самом деле можно сочетать оба способа, в том же проекте.

В этом разделе показано, как включить маршрутизацию атрибута и описывает различные параметры для атрибута маршрутизации. End-to-end учебник, в котором используется атрибут маршрутизация, см. [создать REST API с маршрутизацией атрибутов в веб-API 2](create-a-rest-api-with-attribute-routing.md).


## <a name="prerequisites"></a>Предварительные требования

[Visual Studio 2017 г](https://www.visualstudio.com/vs/) Community, Professional или Enterprise Edition

Можно также установить необходимые пакеты с помощью диспетчера пакетов NuGet. Из **средства** в Visual Studio, выберите пункт меню **диспетчер пакетов библиотеки**, а затем выберите **консоль диспетчера пакетов**. В окне консоли диспетчера пакетов введите следующую команду:

`Install-Package Microsoft.AspNet.WebApi.WebHost`

<a id="why"></a>
## <a name="why-attribute-routing"></a>Почему атрибута маршрутизации?

В первом выпуске используется веб-API *соглашению* маршрутизации. В типа маршрутизации определить один или несколько шаблонов маршрута, которые по сути являются параметризованные строки. Платформа получает запрос, сопоставляет URI с шаблоном маршрута. (Дополнительные сведения о маршрутизации на основе соглашения см. в разделе [маршрутизации в ASP.NET Web API](routing-in-aspnet-web-api.md).

Одно из преимуществ маршрутизации на основе соглашений — шаблоны определены в одном месте, что правила маршрутизации применяется последовательно на всех контроллерах. К сожалению маршрутизация на основе соглашения о становится трудно поддерживать определенные шаблоны URI, которые являются общими в API RESTful. Например, часто содержат ресурсы дочерние ресурсы: клиенты имеют заказы, фильмы имеют субъекты, книг у авторов и т. д. Логично, для создания URI, которые отражают таких отношений:

`/customers/1/orders`

Такой тип URI сложно создать с помощью маршрутизации на основе соглашения. Несмотря на то, что это можно сделать, результаты не масштабируются также в том случае, если у вас есть много контроллеров или типы ресурсов.

При маршрутизации атрибута является тривиальным, чтобы определить маршрут для данного URI. Просто добавьте атрибут к действию контроллера:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample1.cs)]

Ниже приведены некоторые шаблоны, которые атрибута маршрутизации позволяет легко.

**Управление версиями API**

В этом примере «/ api/v1/продуктов» будет перенаправляться в другой контроллер, чем «/ v2/api/продуктов».

`/api/v1/products`  
`/api/v2/products`

**Перегруженные сегментов URI-адреса**

В этом примере «1» является номер заказа, но «ожидание» сопоставляемый с коллекцией.

`/orders/1`  
`/orders/pending`

**Несколькими типами параметров**

В этом примере «1» является номер заказа, но дата «2013-06/16".

`/orders/1`  
`/orders/2013/06/16`

<a id="enable"></a>
## <a name="enabling-attribute-routing"></a>Включение атрибута маршрутизации

Чтобы включить атрибут маршрутизации, вызовите **MapHttpAttributeRoutes** во время настройки. Этот метод расширения определен в **System.Web.Http.HttpConfigurationExtensions** класса.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample2.cs)]

Атрибут маршрутизации может сочетаться с [соглашению](routing-in-aspnet-web-api.md) маршрутизации. Определение маршрутов на основе соглашений, вызовите **MapHttpRoute** метод.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample3.cs)]

Дополнительные сведения о настройке веб-API см. в разделе [Настройка ASP.NET Web API 2](../advanced/configuring-aspnet-web-api.md).

<a id="config"></a>
### <a name="note-migrating-from-web-api-1"></a>Примечание: Переход с веб-API 1

Перед веб-API 2 шаблоны проектов веб-API создан следующий код:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample4.cs)]

Если включен атрибут маршрутизации, этот код вызовет исключение. При обновлении существующего проекта веб-API, чтобы использовать атрибут маршрутизации, необходимо обязательно обновить код конфигурации следующее:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample5.cs?highlight=4)]

> [!NOTE]
> Дополнительные сведения см. в разделе [Настройка веб-API с размещением ASP.NET](../advanced/configuring-aspnet-web-api.md#webhost).


<a id="add-routes"></a>
## <a name="adding-route-attributes"></a>Добавление атрибутов маршрута

Ниже приведен пример маршрута, определенного с помощью атрибута:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample6.cs)]

Строка &quot;клиентов / {customerId} / упорядочивает&quot; шаблон URI для маршрута. Веб-API предпринимается попытка сопоставить URI запроса в шаблон. В этом примере «заказчики» и «orders» являются литерала сегментов и «{customerId}» является параметром-переменной. Следующие URI будет соответствовать этому шаблону:

- `http://localhost/customers/1/orders`
- `http://localhost/customers/bob/orders`
- `http://localhost/customers/1234-5678/orders`

Вы можете ограничить соответствия с помощью [ограничения](#constraints), описанных далее в этом разделе.

Обратите внимание, что &quot;{customerId}&quot; параметры в шаблоне маршрута совпадает с именем *customerId* параметра в методе. Когда веб-API вызывает действия контроллера, он пытается выполнить привязку параметров маршрута. Например, если URL-адрес является `http://example.com/customers/1/orders`, веб-API пытается привязать значение «1» *customerId* параметр в действие.

Шаблон URI может иметь несколько параметров.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample7.cs)]

Методы контроллера, которые имеют атрибут маршрута используйте маршрутизации на основе соглашения. Таким образом, можно сочетать оба типа маршрутизации в том же проекте.

## <a name="http-methods"></a>Методы HTTP

Веб-API также выбирает действия на основе метода HTTP запроса (GET, POST, и т. д.). По умолчанию веб-API ищет совпадение без учета регистра с начала имени метода контроллера. Например, метод контроллера с именем `PutCustomers` соответствует запрос HTTP PUT.

Это соглашение можно переопределить посредством декорирования метод с любым следующие атрибуты:

- **[HttpDelete]**
- **[HttpGet]**
- **[HttpHead]**
- **[HttpOptions]**
- **[HttpPatch]**
- **[HttpPost]**
- **[HttpPut]**

Следующий пример сопоставляет CreateBook метод HTTP-запросы POST.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample8.cs)]

Для всех других методов HTTP, включая стандартным методы используйте **AcceptVerbs** атрибут, который принимает список методов HTTP.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample9.cs)]

<a id="prefixes"></a>
## <a name="route-prefixes"></a>Префиксов маршрутов

Часто маршруты в контроллере, начинающихся с тем же префиксом. Пример:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample10.cs)]

Можно задать Общий префикс для всей контроллера с помощью **[RoutePrefix]** атрибута:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample11.cs)]

Используйте атрибут method тильды (~) для переопределения префикс маршрута:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample12.cs)]

Префикс маршрута может включать параметры:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample13.cs)]

<a id="constraints"></a>
## <a name="route-constraints"></a>Ограничения маршрута

Ограничения маршрута позволяют ограничить сопоставления параметров в шаблоне маршрута. Общий синтаксис &quot;{параметр: ограничение}&quot;. Пример:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample14.cs)]

Здесь первый маршрут выбирается только если &quot;идентификатор&quot; сегмент URI должно быть целым числом. В противном случае будет выбран второй маршрут.

В следующей таблице перечислены ограничения, которые поддерживаются.

| Ограничение | Описание: | Пример |
| --- | --- | --- |
| Альфа-канал | Соответствует прописные или строчные буквы латинского алфавита (a-z, A-Z) | {x:alpha} |
| bool | Соответствует логическое значение. | {x: bool} |
| datetime | Соответствует **DateTime** значение. | {x:datetime} |
| decimal | Совпадает с десятичным значением. | {x:decimal} |
| double | Совпадает с 64-разрядное значение с плавающей запятой. | {x:double} |
| float | Совпадает с 32-разрядное значение с плавающей запятой. | {x: float} |
| guid | Совпадает со значением GUID. | {x:guid} |
| int | Совпадает со значением 32-разрядное целое число. | {x: int} |
| длина | Соответствует строке, указанной длины или в указанном диапазоне длин. | {x: length(6)} {x: length(1,20)} |
| long | Совпадает со значением 64-разрядное целое число. | {x: long} |
| max | Совпадает со значением максимальное целое число. | {x: max(10)} |
| MaxLength | Соответствует строке с максимальной длиной. | {x: maxlength(10)} |
| min | Соответствует целое минимальное значение. | {x: min(10)} |
| minLength | Со строкой с минимальной длиной. | {x: minlength(10)} |
| range | Соответствует целым числом в диапазоне значений. | {x: range(10,50)} |
| regex | Соответствует регулярному выражению. | {x:regex(^\d{3}-\d{3}-\d{4}$)} |

Обратите внимание на то что некоторые ограничения, такие как &quot;min&quot;, принимают аргументы в круглые скобки. Можно применить несколько ограничений для параметров, разделенных точкой с запятой.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample15.cs)]

### <a name="custom-route-constraints"></a>Ограничения пользовательских маршрута

Можно создать настраиваемый маршрут ограничения, реализовав **IHttpRouteConstraint** интерфейса. Например следующее ограничение ограничивает ненулевое целочисленное значение параметра.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample16.cs)]

Ниже показано, как зарегистрировать ограничение:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample17.cs)]

Теперь можно применить ограничение в свои маршруты:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample18.cs)]

Также можно заменить весь **DefaultInlineConstraintResolver** класса путем реализации **IInlineConstraintResolver** интерфейса. Это заменит все встроенные ограничения, если реализация **IInlineConstraintResolver** добавит их специально.

<a id="optional"></a>
## <a name="optional-uri-parameters-and-default-values"></a>Необязательный URI параметры и значения по умолчанию

Параметр URI можно сделать необязательным путем добавления вопросительный знак параметра маршрута. Если параметр маршрута является необязательным, необходимо определить значения по умолчанию для параметра метода.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample19.cs)]

В этом примере `/api/books/locale/1033` и `/api/books/locale` возвращать тот же ресурс.

Кроме того можно указать значение по умолчанию в шаблоне маршрута, следующим образом:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample20.cs)]

Это аналогично предыдущему примеру, но есть незначительные различия поведения, когда применяется значение по умолчанию.

- В первом примере («{lcid?}») значение по умолчанию 1033 назначается непосредственно в параметр метода, параметр будет иметь точное значение.
- Во втором примере («{lcid = 1033}»), значение по умолчанию «1033» проходит через процесс привязки модели. Связыватель модели по умолчанию преобразует «1033» в числовое значение 1033. Тем не менее можно подключить настраиваемый связыватель модели, что может сделать нечто иное.

(В большинстве случаев при отсутствии связыватели моделей, настраиваемые в ваш конвейер две формы будет эквивалентное.)

<a id="route-names"></a>
## <a name="route-names"></a>Имена маршрутов

В веб-API каждый имеет имя. Имена маршрутов полезны для создания ссылок, так что можно включить ссылку в HTTP-ответа.

Чтобы указать имя маршрута, задайте **имя** атрибута. Следующий пример показывает, как задать имя маршрута, а также как использовать имя маршрута, при создании ссылки.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample21.cs)]

<a id="order"></a>
## <a name="route-order"></a>Порядок маршрута

Когда платформа предпринимается попытка сопоставить URI с маршрутом, она оценивает маршруты в определенном порядке. Чтобы указать порядок, задайте **RouteOrder** маршрут атрибута. Более низкие значения вычисляются первыми. Значение порядка по умолчанию равно нулю.

Вот, как определяется общего упорядочения.

1. Сравнение **RouteOrder** маршрут атрибута.
2. Рассмотрим каждый сегмент URI в шаблоне маршрута. Для каждого сегмента заказов следующим образом: 

    1. Литерал сегментов.
    2. Параметры маршрута с ограничениями.
    3. Параметры маршрута без ограничений.
    4. Сегменты с подстановочными знаками параметр с ограничениями.
    5. Сегменты с подстановочными знаками параметр без ограничений.
3. В случае одинаковых значений, маршруты, упорядоченные по сравнения строк по порядковому номеру без учета регистра ([OrdinalIgnoreCase](https://msdn.microsoft.com/library/system.stringcomparer.ordinalignorecase.aspx)) шаблона маршрута.

Пример. Предположим, что определение следующего контроллера:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample22.cs)]

Эти маршруты содержат, упорядочены следующим образом.

1. заказы подробности
2. заказы / {id}
3. orders/{customerName}
4. заказы / {\*date}
5. заказы / ожидание

Обратите внимание, что «подробности» является сегментом литерала находится перед «{id}», но «ожидается» отображается последнее, так как **RouteOrder** свойства является 1. (Предполагается, что ни один клиент именуются «подробности» или «Ожидание». В целом Старайтесь избегать неоднозначных маршрутов. В этом примере лучше шаблон маршрута для `GetByCustomer` — «клиентов / {customerName}»)
