---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: Глобальные обработки ошибок в ASP.NET Web API 2 | Документы Microsoft
author: davidmatson
description: ''
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/03/2014
ms.topic: article
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: c593c56ba3d0ee8ebf6dc425408d2c3b91c83f93
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
ms.locfileid: "28042590"
---
<a name="global-error-handling-in-aspnet-web-api-2"></a>Глобальные обработки ошибок в ASP.NET Web API 2
====================
по [Matson Дэвид](https://github.com/davidmatson), [Рик Андерсон](https://github.com/Rick-Anderson)

Сегодня никак не просто в веб-API, чтобы вести журнал или глобально обработки ошибок. Некоторые необработанные исключения, которые могут быть обработаны посредством [фильтры исключений](exception-handling.md), но существует ряд вариантов, которые не удается обработать фильтры исключений. Пример:

1. Исключения, созданные из конструкторов контроллера.
2. Исключения, созданные из обработчиков сообщений.
3. Исключения, возникшие во время маршрутизации.
4. Исключения, возникшие во время сериализации содержимого ответа.

Корпорация Майкрософт стремится предоставить простой и согласованный способ журнала и обработки (если это возможно) эти исключения. 

Существует два основных варианта обработки исключений, можно отправить ответ с ошибкой и журнала исключение — случай, где все мы можем сделать. Например в последнем случае, если исключение создается середине потоковой передачи содержимого ответа. в этом случае уже слишком поздно для отправки нового сообщения ответа, так как код состояния, заголовки и Частичное содержимое уже прошли по каналу связи, поэтому мы просто отменить соединение. Несмотря на то, что исключение не обработано для создания нового сообщения ответа, по-прежнему поддерживает регистрации исключения. В случаях, когда обнаруживается ошибка мы можем вернуться ответа на соответствующее сообщение об ошибке, как показано в следующем примере:

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a>Существующие параметры

В дополнение к [фильтры исключений](exception-handling.md), [обработчиков сообщений](../advanced/http-message-handlers.md) современных для просмотра всех ответов уровня 500, но обработкой этих ответов является сложным, как они отсутствуют контекста изначальную ошибку. Обработчики сообщений также имеют некоторые те же ограничения, как фильтры исключений в отношении обращения, которые они могут обрабатывать. Тогда как веб-API инфраструктура трассировки, который фиксирует ошибки инфраструктура трассировки для целей диагностики и не планирование и подходит для выполнения в рабочих средах. Глобальные обработки исключений и ведение журнала должно быть служб, которые можно выполнять в процессе производства и следует подключать существующие решения для мониторинга (например, [ELMAH](https://code.google.com/p/elmah/) ).

### <a name="solution-overview"></a>Обзор решения

 Мы предоставляем две новых службы ресурсом [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) и IExceptionHandler для журнала и обработки необработанных исключений. Схожий с два важных отличия используются следующие службы:

1. Мы поддерживаем регистрации несколько средств ведения журнала исключений, но только один обработчик исключений.
2. Средства ведения журнала исключений всегда вызываться, даже если мы вы собираетесь отменить подключение. Обработчики исключений только получить вызывается, когда мы по-прежнему сможет выбрать какие ответное сообщение для отправки.

Обе службы предоставляют доступ к контексту исключения, содержащий важные сведения из точки, в которой обнаружено исключение, особенно [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), возникает исключение и источник исключения (см. ниже).

### <a name="design-principles"></a>Принципы разработки

1. **Отсутствуют критические изменения** так как эта функция добавляется в дополнительного номера версии, то, важное ограничение, влияющие на решения будет существовать отсутствуют критические изменения, либо для ввода контракты для поведения. Это ограничение исключить некоторые очистки, которые мы бы хотели были выполнены с точки зрения существующих блоков catch, включение исключения в 500 ответов. Этот дополнительный Очистка, то, что мы рассмотреть для последующих основного выпуска. Если это важно для Пожалуйста голосовать на его в параметре [отзывы пользователей веб-API ASP.NET](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).
2. **Обеспечение согласованности с веб-API создает** конвейер фильтра веб-API — это отличный способ обрабатывает вопросы, связанные с перекрестными гибкость применения логики в действиях конкретного контроллера или глобальной области видимости. Фильтры, включая фильтры исключений, всегда имеют контексты действия и контроллера, даже в том случае, если зарегистрирован в глобальной области видимости. Существует контракт имеет смысл для фильтров, что означает, что фильтры исключений, даже с глобальной областью из них, не подходит для обработки случаев, например для исключения из обработчиков сообщений, где контекст не действий или контроллера некоторых исключений. Если мы хотим использовать гибкие области, обеспечиваемая фильтры для обработки исключений, мы по-прежнему должны фильтры исключений. Но если необходимо обрабатывать исключение вне контекста контроллера, также необходимо отдельные конструкции для обработки ошибок полной глобальные (что-нибудь без контроллера контекст и действие ограничений контекста).

### <a name="when-to-use"></a>Когда использовать

- Средства ведения журнала исключений являются решением для просмотра всех необработанного исключения перехватываются веб-API.
- Обработчики исключений являются решением для настройки всех возможных реакций на необработанные исключения перехватываются веб-API.
- Фильтры исключений являются простым решением для обработки подмножества необработанных исключений, связанных с определенной действий или контроллера.

### <a name="service-details"></a>Сведения о службе

 Интерфейсы службы ведения журнала и обработчик исключений являются простой асинхронные методы, принимающие соответствующих контекстов: 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 Мы также предоставляют базовые классы для этих интерфейсов. Переопределения методов core (синхронизации или асинхронный) — все, что требуется для входа или обработки на рекомендуемую раз. Для ведения журнала, `ExceptionLogger` базового класса убедитесь, что метод ведения журнала core только вызывается один раз для каждого исключения (даже если впоследствии распространяет дальнейшую по стеку вызовов и перехватывается снова). `ExceptionHandler` Базового класса вызывает основной метод обработки только для исключения в верхней части стека вызовов, игнорируется для прежних версий вложенные блоки catch. (Упрощенными вариантами эти базовые классы находятся в приложении ниже). Оба `IExceptionLogger` и `IExceptionHandler` получать сведения об исключении через `ExceptionContext`.

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

Когда платформа вызывает средство ведения журнала исключений или обработчик исключений, будет всегда предоставлять `Exception` и `Request`. За исключением модульного тестирования, она даст также всегда `RequestContext`. Он редко предоставляет `ControllerContext` и `ActionContext` (только при вызове из блока catch для фильтров исключений). Очень редко дают `Response`(только в определенных случаях IIS при середине при записи ответа). Обратите внимание, что, так как некоторые из этих свойств могут быть `null` возлагается потребителя для проверки `null` перед получением доступа к членам класса exception.`CatchBlock` Строка, указывающее, какой блок catch видели исключение. Ниже приведены строки блока catch.

- Сервер HTTP (метод SendAsync)
- HttpControllerDispatcher (метод SendAsync)
- HttpBatchHandler (метод SendAsync)
- IExceptionFilter (обработка элемента ApiController конвейера фильтра исключения в ExecuteAsync)
- Узел OWIN:

    - HttpMessageHandlerAdapter.BufferResponseContentAsync (для буферизации выходных данных)
    - HttpMessageHandlerAdapter.CopyResponseContentAsync (для потоковой передачи выходных данных)
- Веб-узел:

    - HttpControllerHandler.WriteBufferedResponseContentAsync (для буферизации выходных данных)
    - HttpControllerHandler.WriteStreamedResponseContentAsync (для потоковой передачи выходных данных)
    - HttpControllerHandler.WriteErrorResponseContentAsync (для сбоев в восстановление после ошибок в режиме буферизации выходных данных)

Список строк блок catch также доступна через статические свойства. (Строки блока catch ядра находятся в статических ExceptionCatchBlocks; остаток будет отображаться в один статический класс каждого OWIN и веб-узла).`IsTopLevelCatchBlock` полезно для следующих рекомендуемый шаблон обработки исключений, только в верхней части стека вызовов. Вместо того чтобы включать 500 ответов везде, где происходит блок catch вложенные исключения, обработчик исключений можно позволить исключения распространение, пока они хотят увидеть узлом.

В дополнение к `ExceptionContext`, средство ведения журнала получает еще один фрагмент данных посредством полной `ExceptionLoggerContext`:

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

Второе свойство `CanBeHandled`, позволяет средство ведения журнала для идентификации исключение, которое не может быть обработан. Когда подключение прерывается и не нового ответного сообщения могут отправляться, средства ведения журнала будет вызван, но будет обработчик ***не*** вызвать, и средства ведения журнала можно определить этот сценарий из этого свойства.

В дополнительных для `ExceptionContext`, обработчик получает еще одно свойство, его можно задать полной `ExceptionHandlerContext` для обработки исключения:

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

Обработчик исключений указывает, что она обработала исключение, задав `Result` свойство результат действия (например, [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [ StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), или пользовательским результатом). Если `Result` свойство имеет значение null, исключение остается необработанным и исходное исключение будет создано повторно.

Для исключений в верхней части стека вызовов мы воспользовались дополнительный шаг, чтобы убедиться, что ответ подходит для вызова API. Если исключение распространяется до узла, вызывающий объект увидите желтый экрана смерти или других узлах, предоставляемый ответа, как правило, HTML и обычно не соответствующий ответ ошибки API. В этих случаях начинается результат, отличных от null, и только в том случае, если она явно задает пользовательский обработчик исключений обратно в `null` (необрабатываемым) исключение распространяется на узле. Установка `Result` для `null` в таких случаях может оказаться полезным для двух сценариев:

1. OWIN размещен веб-API с пользовательское исключение, обработка по промежуточного слоя, зарегистрированные перед/вне веб-API.
2. Локальная отладка через браузер, где желтый экрана смерти фактически полезные ответа для необработанных исключений.

Для средств ведения журнала исключений и обработчики исключений мы ничего не делают для восстановления, если средство ведения журнала или сам обработчик вызывает исключение. (Кроме позволить исключению публикации, то оставьте отзыв в нижней части этой страницы, если у вас более удачным подходом.) Контракт для средств ведения журнала исключений и обработчики является то, что они не разрешают исключения распространяется до их вызывающие объекты; в противном случае исключение будет просто распространить, часто вплоть до узла, что приводит к ошибке HTML (например, ASP. NET желтый экран), отправляемых клиенту (который обычно не является предпочтительным для API вызывающим объектам, которые ожидают JSON или XML).

## <a name="examples"></a>Примеры

### <a name="tracing-exception-logger"></a>Трассировка ведения журнала исключений

Ведения журнала исключений отправить данные об исключении настроенные источники трассировки (в том числе в окне вывода отладки в Visual Studio).

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a>Обработчик исключений сообщения пользовательских ошибок

Следующие ниже формирует ответ настраиваемых ошибок для клиентов, включая адрес электронной почты для обращения в службу поддержки.

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a>Регистрация фильтры исключений

Если используется шаблон проекта «ASP.NET MVC 4 веб-приложения» для создания проекта, поместите код конфигурации веб-API в `WebApiConfig` класса в *приложения или за_пустить* папки:

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a>Приложение: Сведения о базовом классе

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
