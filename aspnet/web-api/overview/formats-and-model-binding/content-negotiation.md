---
uid: web-api/overview/formats-and-model-binding/content-negotiation
title: Согласование в веб-API ASP.NET содержимого | Документы Microsoft
author: MikeWasson
description: Описывает, как веб-API ASP.NET реализует согласования содержимого HTTP.
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/20/2012
ms.topic: article
ms.assetid: 0dd51b30-bf5a-419f-a1b7-2817ccca3c7d
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/formats-and-model-binding/content-negotiation
msc.type: authoredcontent
ms.openlocfilehash: ca373af6754e82889dc100b63f73b76aaa4e4f27
ms.sourcegitcommit: 6784510cfb589308c3875ccb5113eb31031766b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2018
ms.locfileid: "26507023"
---
<a name="content-negotiation-in-aspnet-web-api"></a>Согласование содержимого в веб-API ASP.NET
====================
по [Mike Wasson](https://github.com/MikeWasson)

В этой статье описывается, как веб-API ASP.NET реализует согласования содержимого.

Спецификации протокола HTTP (RFC 2616) определяет согласование содержимого, как «процесс выбора наилучшим представлением для указанного ответа при наличии нескольких представлений.» Эти заголовки запроса являются основным механизмом для согласования содержимого в HTTP:

- **Примите:** типов мультимедиа, которые допустимые для ответа, такие как «application/json», «application/xml», или тип пользовательского носитель, такой как &quot;application/vnd.example+xml&quot;
- **Accept-Charset:** какие наборы символов допустимы, например UTF-8 или ISO 8859-1.
- **Приемлемой кодировкой:** допустимы какие кодировки содержимого, таких как gzip.
- **Принять язык:** естественный язык, такие как «en-us».

Сервер можно также просмотреть другие составные части HTTP-запроса. Например если запрос содержит заголовок X-Requested-With, указывающее, AJAX-запросом, сервер может по умолчанию JSON Если отсутствует заголовок Accept.

В этой статье мы рассмотрим, как веб-API использует заголовки Accept и Accept-Charset. (В настоящее время не поддерживается встроенная Accept-Encoding или Accept-Language.)

## <a name="serialization"></a>Сериализация

Если контроллер веб-API возвращает ресурсов как тип CLR, конвейер сериализует возвращаемое значение и записывает его в тексте ответа HTTP.

Например рассмотрим следующее действие контроллера:

[!code-csharp[Main](content-negotiation/samples/sample1.cs)]

Клиент может передавать этого HTTP-запроса:

[!code-console[Main](content-negotiation/samples/sample2.cmd)]

В результате сервер может отправить:

[!code-console[Main](content-negotiation/samples/sample3.cmd)]

В этом примере клиент запросил JSON, Javascript или «все» (\*/\*). Сервер в ответ получен представление JSON `Product` объекта. Обратите внимание, что имеет значение заголовка Content-Type в ответе &quot;приложение/json&quot;.

Контроллер может также возвращать **HttpResponseMessage** объекта. Чтобы указать объект среды CLR, текст ответа, вызовите **CreateResponse** метода расширения:

[!code-csharp[Main](content-negotiation/samples/sample4.cs)]

Данный параметр предоставляет больший контроль над сведения об ответе. Можно задать код состояния, добавление заголовков HTTP и так далее.

Объект, который сериализует ресурс называется *форматирования мультимедиа*. Модули форматирования мультимедиа являются производными от **MediaTypeFormatter** класса. Веб-API предоставляет модули форматирования мультимедиа для XML и JSON, и можно создать пользовательские модули форматирования для поддержки других типов носителей. Сведения о написании пользовательский модуль форматирования см. в разделе [модули форматирования мультимедиа](media-formatters.md).

## <a name="how-content-negotiation-works"></a>Работает как содержимого согласования

Во-первых, конвейер получает **IContentNegotiator** из **HttpConfiguration** объекта. Он также возвращает список модулей форматирования мультимедиа из **HttpConfiguration.Formatters** коллекции.

Затем вызывает конвейер **IContentNegotiatior.Negotiate**, передавая:

- Тип объекта для сериализации
- Коллекция модулей форматирования мультимедиа
- HTTP-запроса

**Negotiate** метод возвращает два блока данных:

- Форматер, используя
- Тип носителя для ответа

Если модуль форматирования не найден, **Negotiate** возвращает **null**и ошибка клиента получении HTTP 406 (неприемлемо).

В следующем коде показано, как контроллер можно напрямую вызвать согласование содержимого:

[!code-csharp[Main](content-negotiation/samples/sample5.cs)]

Этот код является эквивалентом на то, что делает конвейера автоматически.

## <a name="default-content-negotiator"></a>Согласователь содержимого по умолчанию

**DefaultContentNegotiator** класс предоставляет реализацию по умолчанию **IContentNegotiator**. Он использует нескольких критериев для выбора модуля форматирования.

Во-первых модуль форматирования должен иметь возможность сериализовать тип. Это подтверждается вызов **MediaTypeFormatter.CanWriteType**.

Затем согласователь содержимого просматривает каждого модуля форматирования и вычисляет степень его соответствия HTTP-запроса. Для оценки соответствия, согласователь содержимого проверяет два действия в модуль форматирования:

- **SupportedMediaTypes** коллекции, которая содержит список типов носителей, поддерживаемых. Согласователь содержимого предпринимается попытка сопоставить этот список для заголовка Accept запроса. Обратите внимание, что заголовок Accept может содержать диапазонов. Например, «text/plain» совпадение для текста или\* или \* / \*.
- **MediaTypeMappings** коллекции, которая содержит список **MediaTypeMapping** объектов. **MediaTypeMapping** класс предоставляет универсальный способ для сопоставления с типами мультимедиа HTTP-запросов. Например он сопоставляется заголовок HTTP для определенного типа носителя.

Если используется несколько совпадает, совпадение с наивысшим wins коэффициент качества. Пример:

[!code-console[Main](content-negotiation/samples/sample6.cmd)]

В этом примере приложение/json имеет коэффициент подразумеваемых качества, 1.0, поэтому он предпочтительнее, чем приложения и xml.

Если соответствий не найдено, согласователь содержимого пытается сопоставить с типом мультимедиа тела запроса, если таковые имеются. Например если запрос содержит данные JSON, модуль форматирования JSON выглядит согласователь содержимого.

Если по-прежнему не найдено совпадений, согласователь содержимого просто выбирает первый модуль форматирования, который может сериализовать тип.

## <a name="selecting-a-character-encoding"></a>При выборе кодировки символов

После выбора модуля форматирования согласователь содержимого выбирает лучшую кодировку символов, просмотрев **SupportedEncodings** свойства форматирования и сопоставление его в запросе заголовок Accept-Charset (если таковые имеются).
