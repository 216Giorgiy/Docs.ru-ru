---
uid: web-api/overview/odata-support-in-aspnet-web-api/odata-security-guidance
title: "Рекомендации по безопасности для ASP.NET Web API 2 OData | Документы Microsoft"
author: MikeWasson
description: 
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/06/2013
ms.topic: article
ms.assetid: b91e6424-1544-4747-bd0b-d1f8418c9653
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/odata-support-in-aspnet-web-api/odata-security-guidance
msc.type: authoredcontent
ms.openlocfilehash: 799e2a0c742b545acf3b5cd27531d734aa7def80
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="security-guidance-for-aspnet-web-api-2-odata"></a>Рекомендации по безопасности для ASP.NET Web API 2 OData
====================
по [Mike Wasson](https://github.com/MikeWasson)

В этом разделе описываются некоторые проблемы безопасности, которые следует учитывать при предоставлении набора данных через OData.

## <a name="edm-security"></a>Модель EDM безопасности

Семантики запросов основаны на модели EDM (модель EDM), не базовых типов модели. Можно исключить свойство из модели EDM, и он не будет видимым в запрос. Например предположим, что модель включает в себя тип со свойством заработной платы сотрудника. Может потребоваться исключить это свойство из модели EDM, чтобы скрыть его от клиентов.

Существует два способа исключает свойство из модели EDM. Можно задать **[IgnoreDataMember]** атрибут свойства в класс модели:

[!code-csharp[Main](odata-security-guidance/samples/sample1.cs)]

Можно также удалить свойство из модели EDM программными средствами.

[!code-csharp[Main](odata-security-guidance/samples/sample2.cs)]

## <a name="query-security"></a>Запрос безопасности

Вредоносного или упрощенного клиента можно создать запрос, который занимает очень много времени для выполнения. В худшем случае это может нарушить доступ к службе.

**[Queryable]** атрибут является фильтр действий, который выполняет синтаксический анализ, проверяет и применяет запрос. Фильтр преобразует параметры запроса в выражении LINQ. Если контроллер OData возвращает **IQueryable** типа, **IQueryable** LINQ поставщик преобразует выражение LINQ в запрос. Таким образом производительность зависит от поставщика LINQ, который можно использовать и определенными характеристиками схемы набора данных или базы данных.

Дополнительные сведения об использовании параметров запроса OData в веб-API ASP.NET см. в разделе [поддержки параметров запроса OData](supporting-odata-query-options.md).

Если известно, что все клиенты доверия (например, в корпоративной среде) или небольшой набор данных, производительность запросов может оказаться проблемой. В противном случае рассмотрите следующие рекомендации.

- Тестирование службы с различных запросов и профиля базы данных.
- Включите сервер разбиение на страницы предотвратить возвращение большого количества данных в одном запросе. Дополнительные сведения см. в разделе [Server-Driven подкачки](supporting-odata-query-options.md#server-paging). 

    [!code-csharp[Main](odata-security-guidance/samples/sample3.cs)]
- Требуется $filter и $orderby? Для некоторых приложений может разрешить клиент разбиения по страницам, используя $top и $skip, но отключите другие параметры запроса. 

    [!code-csharp[Main](odata-security-guidance/samples/sample4.cs)]
- Рекомендуется ограничить $orderby к свойствам в кластеризованном индексе. Сортировка больших объемов данных в кластеризованном индексе происходит слишком медленно. 

    [!code-csharp[Main](odata-security-guidance/samples/sample5.cs)]
- Количество узлов максимальное: **MaxNodeCount** свойство **[Queryable]** задает максимальное число узлов, которые разрешены в синтаксического дерева $filter. Значение по умолчанию — 100, но вы можете задать более низкое значение, так как большое количество узлов может быть медленным для компиляции. Это особенно верно, если вы используете LINQ to Objects (т. е. запросов LINQ к коллекции в памяти, без использования промежуточного поставщика LINQ). 

    [!code-csharp[Main](odata-security-guidance/samples/sample6.cs)]
- Рекомендуется отключить функции any() и all(), как это может быть медленным. 

    [!code-csharp[Main](odata-security-guidance/samples/sample7.cs)]
- Если любые свойства строки содержат больших строк & #8212for пример, описание продукта или запись в блоге & #8212consider отключение строковые функции. 

    [!code-csharp[Main](odata-security-guidance/samples/sample8.cs)]
- Рассмотрите возможность запрета, фильтрация по свойствам навигации. Фильтрация по свойствам навигации может привести к соединению, которое может быть медленным, в зависимости от схемы базы данных. В следующем коде показано запроса проверяющий элемент управления, не позволяющая фильтрация по свойствам навигации. Дополнительные сведения о запросе проверяющие элементы управления см. в разделе [проверки запроса](supporting-odata-query-options.md#query-validation). 

    [!code-csharp[Main](odata-security-guidance/samples/sample9.cs)]
- Рекомендуется ограничить запросов $filter записывая проверяющий элемент управления, настроенную для базы данных. Например рассмотрим следующие два запроса: 

    - Все фильмы с субъектами, чья фамилия начинается с «А».
    - Все фильмы, выпущенные в 1994 г.

    Если субъекты индексированных фильмы, первый запрос может потребоваться ядра СУБД, чтобы просмотреть весь список фильмов. В то время как второй запрос может быть приемлемым, если предполагается, что фильмы индексируются по году выпуска.

    В следующем коде показано проверяющий элемент управления позволяет фильтровать свойства «ReleaseYear» и «Title», но не других свойств.

    [!code-csharp[Main](odata-security-guidance/samples/sample10.cs)]
- В общем случае рекомендуется какие функции $filter. Если клиентам не требуется полный выразительность $filter, можно ограничить допустимых функций.
