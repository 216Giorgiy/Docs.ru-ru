---
uid: web-api/overview/security/individual-accounts-in-web-api
title: "Защита веб-API с отдельным учетным записям и локального имени входа в ASP.NET Web API 2.2 | Документы Microsoft"
author: MikeWasson
description: "В этом разделе показано, как защитить веб-API, с помощью OAuth2 для проверки подлинности базы данных членства. Версии программного обеспечения, используемые в учебник Visual Studio 201..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 10/15/2014
ms.topic: article
ms.assetid: 92c84846-f0ea-4b5e-94b6-5004874eb060
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/security/individual-accounts-in-web-api
msc.type: authoredcontent
ms.openlocfilehash: 8207df79c1e915b33a0ba095d917a6dc69550173
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="secure-a-web-api-with-individual-accounts-and-local-login-in-aspnet-web-api-22"></a>Защита веб-API с отдельным учетным записям и локального имени входа в ASP.NET Web API 2.2
====================
по [Mike Wasson](https://github.com/MikeWasson)

[Загрузить пример приложения](https://github.com/MikeWasson/LocalAccountsApp)

> В этом разделе показано, как защитить веб-API, с помощью OAuth2 для проверки подлинности базы данных членства.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемая в этом учебнике
> 
> 
> - [Visual Studio 2013 с обновлением 3](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - [Веб-API 2.2](../releases/whats-new-in-aspnet-web-api-22.md)
> - [ASP.NET Identity 2.1](../../../identity/index.md)


В Visual Studio 2013 шаблон проекта веб-API предоставляет три способа проверки подлинности:

- **Индивидуальные учетные записи.** Приложение использует база данных членства.
- **Учетные записи в организации.** Пользователи выполнить вход с их Azure Active Directory, Office 365 или учетные данные локальной Active Directory.
- **Проверка подлинности Windows.** Этот параметр предназначен для приложений интрасети и использует модуль IIS проверки подлинности Windows.

Дополнительные сведения об этих параметрах см. в разделе [Создание веб-проектов ASP.NET в Visual Studio 2013](../../../visual-studio/overview/2013/creating-web-projects-in-visual-studio.md#auth).

Отдельные учетные записи предоставляют два способа пользователю входить в систему:

- **Локальное имя входа**. Пользователь регистрирует на сайте, указав имя пользователя и пароль. Приложение хранит хэш пароля в базе данных членства. При входе пользователя в ASP.NET Identity система проверяет пароль.
- **Имя входа социальных**. Пользователь выполняет вход с помощью внешней службы, такие как Microsoft, Google или Facebook. Приложение по-прежнему создает запись для пользователя в базе данных членства, но учетные данные не хранятся. Выполняет проверку подлинности пользователя при входе в внешней службы.

В этой статье рассматриваются сценарии локальное имя входа. Для имени входа локальной и социальных веб-API использует OAuth2 для проверки подлинности запросов. Тем не менее потоки учетные данные отличаются для входа на локальных и социальных сетей.

В этой статье я продемонстрирую простое приложение, которое позволяет пользователю войти в систему и отправки проверенные на подлинность вызовы AJAX для веб-API. Можно загрузить образец кода [здесь](https://github.com/MikeWasson/LocalAccountsApp). Файл readme описывается создание образца с нуля в Visual Studio.

[![](individual-accounts-in-web-api/_static/image2.png)](individual-accounts-in-web-api/_static/image1.png)

Пример приложения использует Knockout.js для привязки данных и jQuery для отправки запросов AJAX. Я будет сосредоточиться на вызовы AJAX, поэтому не нужно знать Knockout.js для данной статьи.

Попутно я опишу:

- Приложение действия на стороне клиента.
- Что происходит на сервере.
- HTTP-трафика в середине.

Во-первых необходимо определить термины OAuth2.

- *Ресурс*. Часть данных, которые могут быть защищены.
- *Сервер ресурсов*. Сервер, на котором находится ресурс.
- *Владелец ресурса*. Сущность, можно предоставить разрешение на доступ к ресурсу. (Обычно пользователя).
- *Клиент*: приложение, которое хочет получить доступ к ресурсу. В этой статье клиент является веб-браузер.
- *Маркер доступа*. Токен, который предоставляет доступ к ресурсу.
- *Токен носителя*. Определенный тип маркер доступа, со свойством, что любой пользователь может использовать маркер. Другими словами клиент не требуется ключ шифрования или другие секретный код для использования токена носителя. По этой причине токены носителя можно использовать только по протоколу HTTPS и должно быть достаточно коротким сроком.
- *Сервер авторизации*. Сервер, который выдает токены доступа.

Приложение может действовать как сервер авторизации и ресурсов сервера. Шаблон проекта веб-API имеет следующую структуру.

## <a name="local-login-credential-flow"></a>Поток учетные данные локального входа

Для локального имени входа используется веб-API [потока пароль владельца ресурса](http://oauthlib.readthedocs.org/en/latest/oauth2/grants/password.html) определенные в OAuth2.

1. Пользователь вводит имя и пароль клиента.
2. Клиент отправляет эти учетные данные на сервере авторизации.
3. Сервер авторизации проверяет подлинность учетных данных и возвращает маркер доступа.
4. Чтобы получить доступ к защищенному ресурсу, клиент включает токен доступа в заголовок авторизации HTTP-запроса.

![](individual-accounts-in-web-api/_static/image3.png)

При выборе **отдельным учетным записям** в шаблоне проекта веб-API проект включает сервер авторизации, который проверяет учетные данные пользователя и выдает токены. В примере ниже показан одного потока учетных данных с точки зрения компоненты веб-API.

![](individual-accounts-in-web-api/_static/image4.png)

В этом сценарии контроллеров веб-API в качестве серверов ресурсов. Фильтр проверки подлинности проверяет маркеры доступа и **[Authorize]** атрибут используется для защиты ресурса. Если контроллер или действие имеет **[Authorize]** атрибута, все запросы к этому контроллеру или действия должен пройти проверку подлинности. В противном случае — отказано в авторизации, и веб-API возвращает ошибку 401 (несанкционированный).

Сервер авторизации и проверки подлинности фильтра, как вызывать [по промежуточного слоя OWIN](../../../aspnet/overview/owin-and-katana/an-overview-of-project-katana.md) компонент, который обрабатывает сведения OAuth2. Я опишу разработки более подробно далее в этом учебнике.

## <a name="sending-an-unauthorized-request"></a>Отправка неавторизованный запрос

Чтобы начать работу, запустите приложение и нажмите кнопку **вызова API** кнопки. По завершении выполнения запроса вы увидите сообщение об ошибке в **результат** поле. Это потому, что запрос не содержит маркер доступа, поэтому запрос не авторизован.

[![](individual-accounts-in-web-api/_static/image6.png)](individual-accounts-in-web-api/_static/image5.png)

**Вызова API** кнопка отправляет AJAX-запросом ~/api или значений, который вызывает действие контроллера Web API. Здесь приведена часть кода JavaScript, который отправляет запрос AJAX. В примере приложения весь код JavaScript приложения находится в файле Scripts\app.js.

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample1.js)]

Пока пользователь не выйдет, отсутствует токен на предъявителя и поэтому нет заголовка авторизации в запросе. В этом случае запрос возвращает ошибку 401.

Вот HTTP-запроса. (Я использовал [Fiddler](http://www.telerik.com/fiddler) для записи HTTP-трафика.)

[!code-console[Main](individual-accounts-in-web-api/samples/sample2.cmd)]

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample3.cmd?highlight=1,4)]

Обратите внимание, в ответ включается заголовок Www-Authenticate с проблемой, равным носителя. Это указывает, что сервер ожидает токен носителя.

## <a name="register-a-user"></a>Регистрация пользователя

В **зарегистрировать** раздел приложения, введите сообщения электронной почты и пароль и нажмите кнопку **зарегистрировать** кнопки.

Не нужно использовать допустимый адрес электронной почты для этого примера, но реальные приложения будет подтвердить адрес. (См. [создания безопасного веб-приложения ASP.NET MVC 5 с журналом в сбросить пароль и подтверждение по электронной почте](../../../mvc/overview/security/create-an-aspnet-mvc-5-web-app-with-email-confirmation-and-password-reset.md).) В поле пароля — используйте примерно «Password1!», с прописные буквы, строчные буквы, номер и отличных от буквенно цифровых символов. Чтобы не усложнять приложение, я опущены проверки на стороне клиента, поэтому если существует проблема с форматом пароль, вы получите ошибку 400 (неправильный запрос).

[![](individual-accounts-in-web-api/_static/image8.png)](individual-accounts-in-web-api/_static/image7.png)

**Зарегистрировать** кнопка отправляет запрос POST ~/api/Account/Register /. Текст запроса является объект JSON, который содержит имя и пароль. Ниже приведен код JavaScript, который отправляет запрос:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample4.js)]

HTTP-запроса:

[!code-console[Main](individual-accounts-in-web-api/samples/sample5.cmd?highlight=5,10)]

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample6.cmd)]

Этот запрос обрабатывается методом `AccountController` класса. На внутреннем уровне `AccountController` использует для управления базой данных членства ASP.NET Identity.

При локальном запуске приложения из Visual Studio учетные записи пользователей хранятся в LocalDB в таблице AspNetUsers. Чтобы просмотреть таблицы в Visual Studio, нажмите кнопку **представление** последовательно выберите пункты **обозревателя серверов**, затем разверните **подключения к данным**.

![](individual-accounts-in-web-api/_static/image9.png)

## <a name="get-an-access-token"></a>Получение токена доступа

Пока мы еще не все OAuth, но сейчас мы рассмотрим действия, сервер авторизации OAuth при запросе маркера доступа. В **входа в** области пример приложения, введите имя электронной почты и пароль и нажмите кнопку **входа в**.

[![](individual-accounts-in-web-api/_static/image11.png)](individual-accounts-in-web-api/_static/image10.png)

**Входа в** кнопку отправляет запрос в конечную точку токена. Текст запроса содержит следующие данные формы url кодированием:

- Предоставьте\_тип: «password»
- имя пользователя: &lt;пользователю по электронной почте&gt;
- пароль: &lt;пароль&gt;

Ниже приведен код JavaScript, который отправляет запрос AJAX:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample7.js?highlight=14)]

Если запрос выполнен успешно, сервер авторизации возвращает маркер доступа в тексте ответа. Обратите внимание, что маркер хранятся в хранилище сеанса, для последующего использования при отправке запросов к API. В отличие от некоторых форм проверки подлинности (например, проверку подлинности на основе куки-файл) браузер не будет содержать автоматически маркер доступа в последующих запросах. Приложение необходимо сделать это явным образом. Это удобно, так как она ограничивает [уязвимостей CSRF](preventing-cross-site-request-forgery-csrf-attacks.md).

HTTP-запроса:

[!code-console[Main](individual-accounts-in-web-api/samples/sample8.cmd?highlight=5,10)]

Вы увидите, что запрос содержит учетные данные пользователя. Вы *должен* использования протокола HTTPS для обеспечения безопасности транспортного уровня.

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample9.cmd?highlight=8)]

Для удобства чтения с отступом JSON и усечение маркер доступа, который является довольно длинными.

`access_token`, `token_type`, И `expires_in` свойства, определенные в спецификации OAuth2. Другие свойства (`userName`, `.issued`, и `.expires`) используются только в информационных целях. Можно найти код, который добавляет эти дополнительные свойства в `TokenEndpoint` метод в файле /Providers/ApplicationOAuthProvider.cs.

## <a name="send-an-authenticated-request"></a>Отправить запрос с проверкой подлинности

Теперь, когда у нас есть токен носителя, можно сделать запрос с проверкой подлинности к API. Это делается, задав для заголовка авторизации в запросе. Нажмите кнопку **вызова API** кнопку еще раз, чтобы увидеть его.

[![](individual-accounts-in-web-api/_static/image13.png)](individual-accounts-in-web-api/_static/image12.png)

HTTP-запроса:

[!code-console[Main](individual-accounts-in-web-api/samples/sample10.cmd?highlight=5)]

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample11.cmd)]

## <a name="log-out"></a>Выйдите из системы

Браузер не кэширует учетные данные или токен доступа, выход не просто «забыть» токен, удалив его из хранилища сеанса.

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample12.js)]

## <a name="understanding-the-individual-accounts-project-template"></a>Основные сведения о шаблоне проекта отдельным учетным записям

При выборе **отдельным учетным записям** в шаблоне проекта веб-приложения ASP.NET в проекте есть:

- Сервер авторизации OAuth2.
- Конечную точку веб-API для управления учетными записями пользователей
- Модель EF для хранения учетных записей пользователей.

Ниже приведены классы основного приложения, реализующие эти функции.

- `AccountController`. Предоставляет конечную точку веб-API для управления учетными записями пользователей. `Register` Действие — единственный, который используется в этом учебнике. Другие методы в классе поддерживает сброс паролей, имена входа социальных сетей и другие функциональные возможности.
- `ApplicationUser`, определенный в /Models/IdentityModels.cs. Этот класс является модель EF учетных записей пользователей в базе данных членства.
- `ApplicationUserManager`, определенный в /App\_Start/IdentityConfig.cs, этот класс является производным от [UserManager](https://msdn.microsoft.com/en-us/library/dn613290.aspx) автоматически сохраняет и выполняет операции для учетных записей пользователей, таких как создание нового пользователя, Проверка паролей и т. д. изменения в базе данных.
- `ApplicationOAuthProvider`. Этот объект подключается к по промежуточного слоя OWIN и обрабатывает данные событий, вызванных по промежуточного слоя. Он является производным от [OAuthAuthorizationServerProvider](https://msdn.microsoft.com/en-us/library/microsoft.owin.security.oauth.oauthauthorizationserverprovider.aspx).

![](individual-accounts-in-web-api/_static/image14.png)

### <a name="configuring-the-authorization-server"></a>Настройка сервера авторизации

В StartupAuth.cs следующий код служит для настройки сервера авторизации OAuth2.

[!code-csharp[Main](individual-accounts-in-web-api/samples/sample13.cs)]

`TokenEndpointPath` Свойство является URL-адрес конечной точки сервера авторизации. Это URL-адрес этого приложения используется для получения маркеров носителя.

`Provider` Свойство указывает поставщика, который подключается к по промежуточного слоя OWIN и обрабатывает данные событий, вызванных по промежуточного слоя.

Вот основные потока приложения хочет получить маркер.

1. Чтобы получить маркер доступа, приложение отправляет запрос на ~ / Token.
2. Вызовы по промежуточного слоя OAuth `GrantResourceOwnerCredentials` на поставщике.
3. Поставщик вызывает метод `ApplicationUserManager` для проверки учетных данных и создания удостоверений утверждений.
4. В случае успеха поставщик создает билет проверки подлинности, который используется для создания токена.

[![](individual-accounts-in-web-api/_static/image16.png)](individual-accounts-in-web-api/_static/image15.png)

По промежуточного слоя OAuth не знает, что-либо об учетных записях пользователей. Поставщик обеспечивает обмен данными между по промежуточного слоя и ASP.NET Identity. Дополнительные сведения о реализации сервер авторизации см. в разделе [OWIN OAuth 2.0 авторизации сервера](../../../aspnet/overview/owin-and-katana/owin-oauth-20-authorization-server.md).

### <a name="configuring-web-api-to-use-bearer-tokens"></a>Настройка веб-API для использования маркеров носителя

В `WebApiConfig.Register` метод, следующий код задает проверку подлинности для веб-API конвейера:

[!code-csharp[Main](individual-accounts-in-web-api/samples/sample14.cs)]

**HostAuthenticationFilter** класс включает проверку подлинности с использованием маркеров носителя.

**SuppressDefaultHostAuthentication** метод сообщает веб-API, чтобы пропустить проверку подлинности, произойдет, прежде чем запрос достигнет конвейер веб-API, службами IIS или по промежуточного слоя OWIN. Таким образом, мы можно ограничить веб-API для проверки подлинности, используя только токены носителя.

> [!NOTE]
> В частности MVC часть приложения могут использовать формы проверки подлинности, который хранит учетные данные в файле cookie. Проверка подлинности на основе куки-файл требует использования маркеров защиты от подделки, для предотвращения атак CSRF. Это проблема для веб-API, так как невозможно удобный для веб-API для отправки клиенту маркер защиты от подделки. (Дополнительные сведения об этой проблеме см. в разделе [препятствует CSRF атак в веб-API](preventing-cross-site-request-forgery-csrf-attacks.md).) Вызов **SuppressDefaultHostAuthentication** гарантирует, что веб-API не становится уязвимой для атак CSRF из учетные данные, хранящиеся в файлах cookie.


Когда клиент запрашивает защищенный ресурс, происходит следующее в конвейере веб-API:

1. **HostAuthentication** фильтра вызывает OAuth по промежуточного слоя для проверки токена.
2. По промежуточного слоя преобразует токен в идентификатор утверждений.
3. На этом этапе запрашивается *с проверкой подлинности* , но не *право*.
4. Фильтр авторизации проверяет идентификатор утверждений. Если утверждения авторизации пользователя для данного ресурса, запрос авторизован. По умолчанию **[Authorize]** атрибут авторизует запрос, который проходит проверку подлинности. Тем не менее может авторизовать роли или другие утверждения. Дополнительные сведения см. в разделе [проверки подлинности и авторизации в веб-API](authentication-and-authorization-in-aspnet-web-api.md).
5. Если предыдущие шаги выполняются успешно, возвращает защищенный ресурс. В противном случае клиент получает ошибку 401 (несанкционированный).

[![](individual-accounts-in-web-api/_static/image18.png)](individual-accounts-in-web-api/_static/image17.png)

## <a name="additional-resources"></a>Дополнительные ресурсы

- [ASP.NET Identity](../../../identity/index.md)
- [Основные сведения о функциях безопасности в шаблоне SPA для версии-Кандидата VS2013](https://blogs.msdn.com/b/webdev/archive/2013/09/20/understanding-security-features-in-spa-template.aspx). MSDN в блоге по Hongye Sun.
- [Разбор Web API отдельные учетные записи шаблона — часть 2: локальные учетные записи](http://leastprivilege.com/2013/11/26/dissecting-the-web-api-individual-accounts-templatepart-2-local-accounts/). Запись блога по Доминик Байер.
- [Разместить проверку подлинности и веб-API с OWIN](http://brockallen.com/2013/10/27/host-authentication-and-web-api-with-owin-and-active-vs-passive-authentication-middleware/). Подробное объяснение `SuppressDefaultHostAuthentication` и `HostAuthenticationFilter` по Brock Аллен.
- [Настройка данных профиля в ASP.NET Identity в шаблонах VS 2013](https://blogs.msdn.com/b/webdev/archive/2013/10/16/customizing-profile-information-in-asp-net-identity-in-vs-2013-templates.aspx). В блоге MSDN по Pranav Rastogi.
- [На запрос управления жизненным циклом для класса UserManager в ASP.NET Identity](https://blogs.msdn.com/b/webdev/archive/2014/02/12/per-request-lifetime-management-for-usermanager-class-in-asp-net-identity.aspx). В блоге MSDN по Suhas Joshi с подробное объяснение `UserManager` класса.
