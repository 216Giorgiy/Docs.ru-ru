---
uid: web-api/overview/security/authentication-and-authorization-in-aspnet-web-api
title: "Проверка подлинности и авторизация веб-API ASP.NET | Документы Microsoft"
author: MikeWasson
description: "Предоставляет общие сведения о проверке подлинности и авторизации в веб-API ASP.NET."
ms.author: aspnetcontent
manager: wpickett
ms.date: 11/27/2012
ms.topic: article
ms.assetid: 6dfb51ea-9f4d-4e70-916c-8ef8344a88d6
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/security/authentication-and-authorization-in-aspnet-web-api
msc.type: authoredcontent
ms.openlocfilehash: 137ac45166be03ae3c4864f41666d2acd1a37dc2
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="authentication-and-authorization-in-aspnet-web-api"></a>Проверка подлинности и авторизация веб-API ASP.NET
====================
по [Mike Wasson](https://github.com/MikeWasson)

Вы создали веб-API, но вы хотите управлять доступом к нему. В этой серии статей мы рассмотрим некоторые механизмы защиты от несанкционированного доступа из веб-API. Этой серии мы рассмотрим проверки подлинности и авторизации.

- *Проверка подлинности* требуется знать идентификатор пользователя. Например Алиса входе в систему с ее имя пользователя и пароль, и сервер использует пароль для проверки подлинности Алиса.
- *Авторизация* выбирают разрешено ли пользователь выполнить действие. Например Алиса имеет разрешение на получение ресурса, но не создавать ресурса.

Первой статье из серии предоставляет общие сведения о проверке подлинности и авторизации в веб-API ASP.NET. Другие разделы описаны стандартные сценарии проверки подлинности для веб-API.

> [!NOTE]
> Благодаря специалистами проверку этого ряда и предоставляли ценные отзывы: Рик Андерсон, Levi Broderick, Барри Dorrans, Tom Dykstra, Hongmei Ge, Дэвид Matson, рот Дэниэла, Тим Teebken.


## <a name="authentication"></a>Проверка подлинности

Веб-API предполагает, что происходит, проверку подлинности на узле. Для веб-размещения узел представляет IIS, который использует HTTP-модули для проверки подлинности. Можно настроить проект для использования этих модулей проверки подлинности, встроенной в IIS или ASP.NET, или написать собственный модуль HTTP для настраиваемой аутентификации.

Когда узел выполняет проверку подлинности пользователя, он создает *основной*, который является [IPrincipal](https://msdn.microsoft.com/en-us/library/System.Security.Principal.IPrincipal.aspx) , представляющий контекст безопасности, в котором работает код. Узел присоединяет участника к текущему потоку, задав **Thread.CurrentPrincipal**. Участник содержит связанный **удостоверение** объект, содержащий сведения о пользователе. Если пользователь прошел проверку подлинности, **Identity.IsAuthenticated** возвращает **true**. Для анонимных запросов **свойство IsAuthenticated** возвращает **false**. Дополнительные сведения об участниках см. в разделе [безопасности на основе ролей](https://msdn.microsoft.com/en-us/library/shz8h065.aspx).

### <a name="http-message-handlers-for-authentication"></a>Обработчики сообщений HTTP для проверки подлинности

Вместо узла для проверки подлинности, можно поместить логики проверки подлинности в [обработчик сообщений HTTP](../advanced/http-message-handlers.md). В этом случае обработчик сообщений проверяет HTTP-запрос и задает участника.

Когда следует использовать обработчики сообщений для проверки подлинности Ниже приведены некоторые компромиссы.

- HTTP-модуль видит все запросы, которые проходят через конвейер ASP.NET. Обработчик сообщений видят только те запросы, которые маршрутизируются веб-API.
- Можно задать обработчики сообщений-маршрута, который позволяет применить схему проверки подлинности для конкретного маршрута.
- HTTP-модули характерны для IIS. Обработчики сообщений зависит от узла, чтобы их можно использовать с веб размещения и резидентным размещением.
- HTTP-модули участвовать в ведение журнала IIS, аудит и т. д.
- Модули HTTP запуска ранее в конвейере. При обработке проверки подлинности в обработчике сообщений участника не получить задано, пока не будет запущен обработчик. Кроме того участника возвращается к предыдущего основного сервера, когда уходит ответ обработчик сообщений.

Как правило если не требуется для поддержки самостоятельного размещения, HTTP-модуль является лучшим вариантом. Если вам нужно резидентно размещать, рассмотрите возможность обработчик сообщений.

### <a name="setting-the-principal"></a>Задание участника

Если приложение выполняет логику нестандартной проверки подлинности, необходимо задать участника в двух местах:

- **Thread.CurrentPrincipal**. Это свойство является стандартным способом для задания участника потока в .NET.
- **HttpContext.Current.User**. Это свойство относится только к ASP.NET.

Ниже показано, как для задания участника:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample1.cs)]

Для размещения в сети, необходимо задать участника в обоих местах; в противном случае контекст безопасности могут оказаться несогласованными. Для резидентного размещения, однако **HttpContext.Current** имеет значение null. Для обеспечения независимой от размещения кода таким образом, проверка значений null перед назначением **HttpContext.Current**, как показано.

## <a name="authorization"></a>Авторизация

Авторизация происходит позже в конвейере, ближе к контроллеру. Позволяет вам выбрать более детализированные, предоставление доступа к ресурсам.

- *Фильтры авторизации* запуска перед выполнением действия контроллера. Если запрос не авторизован, фильтр выдает сообщение об ошибке, и действие не вызывается.
- В рамках действия контроллера, можно получить текущий участник из **ApiController.User** свойство. Например можно отфильтровать список ресурсов на основе имени пользователя, возвращает только те ресурсы, принадлежащие этому пользователю.

![](authentication-and-authorization-in-aspnet-web-api/_static/image1.png)

<a id="auth3"></a>
### <a name="using-the-authorize-attribute"></a>С помощью [авторизовать] атрибута

Веб-API предоставляет фильтр встроенной авторизации [AuthorizeAttribute](https://msdn.microsoft.com/en-us/library/system.web.http.authorizeattribute.aspx). Этот фильтр проверяет, является ли пользователь проверку подлинности. В противном случае возвращается код состояния HTTP 401 (не санкционировано) без вызова действия.

Можно применить фильтр глобально, на уровне контроллера или на уровне inidivual действий.

**Глобально**: чтобы ограничить доступ для каждого контроллера веб-API, добавьте **AuthorizeAttribute** фильтра в список глобальных фильтров:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample2.cs)]

**Контроллер**: чтобы ограничить доступ для определенного контроллера, добавьте фильтр как атрибут контроллера:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample3.cs)]

**Действие**: чтобы ограничить доступ для выполнения конкретных действий, добавьте атрибут к методу действия:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample4.cs)]

Кроме того, можно ограничить контроллер, а затем разрешить анонимный доступ к определенным действиям с помощью `[AllowAnonymous]` атрибута. В следующем примере `Post` метод ограничен, но `Get` метод разрешает анонимный доступ.

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample5.cs)]

В предыдущих примерах фильтр позволяет любой прошедший проверку пользователь для доступа к ограниченным методов; сохраняются только анонимные пользователи. Можно также ограничить доступ к определенным пользователям или определенных ролей пользователей:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample6.cs)]

> [!NOTE]
> **AuthorizeAttribute** фильтра для контроллеров веб-API находится в **System.Web.Http** пространства имен. Нет аналогичные фильтра для контроллеров MVC в **System.Web.Mvc** пространства имен, которое не совместим с контроллерами веб-API.


### <a name="custom-authorization-filters"></a>Пользовательская авторизация фильтры

Для записи настраиваемой авторизации фильтр, являются производными от одного из следующих типов:

- **AuthorizeAttribute**. Расширьте этот класс, чтобы выполнить логику авторизации на основе текущего пользователя и роли пользователя.
- **AuthorizationFilterAttribute**. Расширьте этот класс, чтобы выполнить логику синхронной авторизации, основанный на текущего пользователя или роли не обязательно.
- **IAuthorizationFilter**. Реализуйте этот интерфейс, чтобы выполнить логику асинхронного авторизации; Например, если логику авторизации выполняет асинхронные вызовы ввода-вывода или в сети. (Если логику авторизации ЦП, проще являются производными от **AuthorizationFilterAttribute**, так как вам не нужно написать асинхронный метод.)

Следующая диаграмма показывает иерархию классов для **AuthorizeAttribute** класса.

![](authentication-and-authorization-in-aspnet-web-api/_static/image2.png)

### <a name="authorization-inside-a-controller-action"></a>Авторизация внутри действия контроллера

В некоторых случаях может позволить запрос продолжить, но изменять поведение на основе субъекта. Например сведения, при возвращении может измениться в зависимости от роли пользователя. Внутри метода контроллера, можно получить из текущего участника **ApiController.User** свойство.

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample7.cs)]
