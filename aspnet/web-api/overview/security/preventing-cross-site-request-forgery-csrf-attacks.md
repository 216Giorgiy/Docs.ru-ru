---
uid: web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks
title: Предотвращение атак подделки межсайтовых запросов в веб-API ASP.NET | Документы Microsoft
author: MikeWasson
description: Описывает атаки подделки межсайтовых запросов и способ реализации меры противодействия CSRF в веб-API ASP.NET.
ms.author: aspnetcontent
manager: wpickett
ms.date: 12/12/2012
ms.topic: article
ms.assetid: 81d46f14-8f48-4d8c-830d-cc8d594dc11b
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks
msc.type: authoredcontent
ms.openlocfilehash: 1cd03f3b396cc2ece1d8dbe6820f6277c02d8e62
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
ms.locfileid: "26508153"
---
<a name="preventing-cross-site-request-forgery-csrf-attacks-in-aspnet-web-api"></a><span data-ttu-id="6b3b7-103">Предотвращение атак подделки межсайтовых запросов в веб-API ASP.NET</span><span class="sxs-lookup"><span data-stu-id="6b3b7-103">Preventing Cross-Site Request Forgery (CSRF) Attacks in ASP.NET Web API</span></span>
====================
<span data-ttu-id="6b3b7-104">по [Mike Wasson](https://github.com/MikeWasson)</span><span class="sxs-lookup"><span data-stu-id="6b3b7-104">by [Mike Wasson](https://github.com/MikeWasson)</span></span>

<span data-ttu-id="6b3b7-105">Подделки межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос уязвимым сайта, где пользователь вошел в настоящее время в</span><span class="sxs-lookup"><span data-stu-id="6b3b7-105">Cross-Site Request Forgery (CSRF) is an attack where a malicious site sends a request to a vulnerable site where the user is currently logged in</span></span>

<span data-ttu-id="6b3b7-106">Ниже приведен пример атаки CSRF:</span><span class="sxs-lookup"><span data-stu-id="6b3b7-106">Here is an example of a CSRF attack:</span></span>

1. <span data-ttu-id="6b3b7-107">Пользователь входит в www.example.com, с помощью форм проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-107">A user logs into www.example.com, using forms authentication.</span></span>
2. <span data-ttu-id="6b3b7-108">Сервер проверяет подлинность пользователя.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-108">The server authenticates the user.</span></span> <span data-ttu-id="6b3b7-109">Ответ от сервера включает файл cookie проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-109">The response from the server includes an authentication cookie.</span></span>
3. <span data-ttu-id="6b3b7-110">Не выходя из пользователь посещает вредоносный веб-узел.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-110">Without logging out, the user visits a malicious web site.</span></span> <span data-ttu-id="6b3b7-111">Этот вредоносный сайт содержит следующие HTML-формы:</span><span class="sxs-lookup"><span data-stu-id="6b3b7-111">This malicious site contains the following HTML form:</span></span> 

    [!code-html[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample1.html)]

    <span data-ttu-id="6b3b7-112">Обратите внимание, что действие формы в блогах уязвимым сайте, не вредоносный сайт.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-112">Notice that the form action posts to the vulnerable site, not to the malicious site.</span></span> <span data-ttu-id="6b3b7-113">Это часть CSRF «между сайтами».</span><span class="sxs-lookup"><span data-stu-id="6b3b7-113">This is the "cross-site" part of CSRF.</span></span>
4. <span data-ttu-id="6b3b7-114">При нажатии кнопки "Отправить".</span><span class="sxs-lookup"><span data-stu-id="6b3b7-114">The user clicks the submit button.</span></span> <span data-ttu-id="6b3b7-115">Браузер включает файл cookie проверки подлинности с запросом.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-115">The browser includes the authentication cookie with the request.</span></span>
5. <span data-ttu-id="6b3b7-116">Запрос выполняется на сервере с контекстом проверки подлинности пользователя и делать все, что разрешено делать прошедшего проверку подлинности пользователя.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-116">The request runs on the server with the user's authentication context, and can do anything that an authenticated user is allowed to do.</span></span>

<span data-ttu-id="6b3b7-117">Несмотря на то, что в этом примере требует от пользователя, нажмите кнопку «форма», страницу вредоносных удалось так же, как легко запускать скрипт, который автоматически отправляет форму.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-117">Although this example requires the user to click the form button, the malicious page could just as easily run a script that submits the form automatically.</span></span> <span data-ttu-id="6b3b7-118">Кроме того с помощью протокола SSL не запрещает атаки CSRF, так как вредоносный сайт можно отправить запрос «https://».</span><span class="sxs-lookup"><span data-stu-id="6b3b7-118">Moreover, using SSL does not prevent a CSRF attack, because the malicious site can send an "https://" request.</span></span>

<span data-ttu-id="6b3b7-119">Как правило атаки CSRF для веб-сайтов, которые используют файлы cookie для проверки подлинности, так как браузеры отправляют все соответствующие файлы cookie в веб-узел назначения.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-119">Typically, CSRF attacks are possible against web sites that use cookies for authentication, because browsers send all relevant cookies to the destination web site.</span></span> <span data-ttu-id="6b3b7-120">Тем не менее атаки CSRF ограничены не использовать файлы cookie.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-120">However, CSRF attacks are not limited to exploiting cookies.</span></span> <span data-ttu-id="6b3b7-121">Например Basic и дайджест-проверки подлинности также уязвимы.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-121">For example, Basic and Digest authentication are also vulnerable.</span></span> <span data-ttu-id="6b3b7-122">После входа пользователя в систему с обычная или краткая проверка подлинности.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-122">After a user logs in with Basic or Digest authentication.</span></span> <span data-ttu-id="6b3b7-123">браузер автоматически отправляет учетные данные до завершения сеанса.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-123">the browser automatically sends the credentials until the session ends.</span></span>

## <a name="anti-forgery-tokens"></a><span data-ttu-id="6b3b7-124">Маркеры защиты от подделки</span><span class="sxs-lookup"><span data-stu-id="6b3b7-124">Anti-Forgery Tokens</span></span>

<span data-ttu-id="6b3b7-125">Чтобы предотвратить атаки CSRF, ASP.NET MVC использует маркеров защиты от подделки, также называемый *запроса маркеров проверки*.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-125">To help prevent CSRF attacks, ASP.NET MVC uses anti-forgery tokens, also called *request verification tokens*.</span></span>

1. <span data-ttu-id="6b3b7-126">Клиент запрашивает страницу HTML, содержащий форму.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-126">The client requests an HTML page that contains a form.</span></span>
2. <span data-ttu-id="6b3b7-127">Сервер включает два маркера в ответе.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-127">The server includes two tokens in the response.</span></span> <span data-ttu-id="6b3b7-128">Один маркер отправляется в качестве файла cookie.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-128">One token is sent as a cookie.</span></span> <span data-ttu-id="6b3b7-129">Другой помещается в скрытом поле формы.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-129">The other is placed in a hidden form field.</span></span> <span data-ttu-id="6b3b7-130">Токены создаются случайным образом, чтобы злоумышленник невозможно подобрать значения.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-130">The tokens are generated randomly so that an adversary cannot guess the values.</span></span>
3. <span data-ttu-id="6b3b7-131">Когда клиент отправляет форму, отправьте оба маркера обратно на сервер.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-131">When the client submits the form, it must send both tokens back to the server.</span></span> <span data-ttu-id="6b3b7-132">Клиент отправляет маркер куки-файл как файл cookie и отправляет маркера формы внутри данные формы.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-132">The client sends the cookie token as a cookie, and it sends the form token inside the form data.</span></span> <span data-ttu-id="6b3b7-133">(Браузер клиента автоматически делает это когда пользователь отправляет форму.)</span><span class="sxs-lookup"><span data-stu-id="6b3b7-133">(A browser client automatically does this when the user submits the form.)</span></span>
4. <span data-ttu-id="6b3b7-134">Если запрос не содержит оба маркера, сервер запрещает запроса.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-134">If a request does not include both tokens, the server disallows the request.</span></span>

<span data-ttu-id="6b3b7-135">Ниже приведен пример формы HTML с помощью маркера скрытой форме:</span><span class="sxs-lookup"><span data-stu-id="6b3b7-135">Here is an example of an HTML form with a hidden form token:</span></span>

[!code-html[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample2.html)]

<span data-ttu-id="6b3b7-136">Маркеров защиты от подделки работать, поскольку вредоносный страницы не удается прочитать токенов пользователя, из-за политики для одного источника.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-136">Anti-forgery tokens work because the malicious page cannot read the user's tokens, due to same-origin policies.</span></span> <span data-ttu-id="6b3b7-137">([Одного источника политики](http://www.w3.org/Security/wiki/Same_Origin_Policy) предотвратить документы, размещенные на двух различных узлов из доступа к содержимому друг друга.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-137">([Same-origin policies](http://www.w3.org/Security/wiki/Same_Origin_Policy) prevent documents hosted on two different sites from accessing each other's content.</span></span> <span data-ttu-id="6b3b7-138">Поэтому в предыдущем примере вредоносных страницы могут отправлять запросы example.com, но его не удалось прочитать ответ).</span><span class="sxs-lookup"><span data-stu-id="6b3b7-138">So in the earlier example, the malicious page can send requests to example.com, but it cannot read the response.)</span></span>

<span data-ttu-id="6b3b7-139">Для предотвращения атак CSRF воспользуйтесь маркеров защиты от подделки с любой протокол проверки подлинности, где обозреватель автоматически отправляет учетные данные после входа пользователя.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-139">To prevent CSRF attacks, use anti-forgery tokens with any authentication protocol where the browser silently sends credentials after the user logs in.</span></span> <span data-ttu-id="6b3b7-140">Это включает в себя протоколы проверки подлинности на основе файлов cookie, такие как формы проверки подлинности, а также протоколов, таких как Basic и дайджест-проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-140">This includes cookie-based authentication protocols, such as forms authentication, as well as protocols such as Basic and Digest authentication.</span></span>

<span data-ttu-id="6b3b7-141">Для любых nonsafe методов (POST, PUT, DELETE) должна требовать маркеров защиты от подделки.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-141">You should require anti-forgery tokens for any nonsafe methods (POST, PUT, DELETE).</span></span> <span data-ttu-id="6b3b7-142">Кроме того убедитесь, что безопасные методы (GET, HEAD) не имеют никаких побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-142">Also, make sure that safe methods (GET, HEAD) do not have any side effects.</span></span> <span data-ttu-id="6b3b7-143">Кроме того Если включена поддержка между доменами, например CORS или JSONP, затем даже безопасные методы, такие как GET потенциально уязвимой для атак CSRF, что позволит злоумышленнику читать потенциально конфиденциальных данных.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-143">Moreover, if you enable cross-domain support, such as CORS or JSONP, then even safe methods like GET are potentially vulnerable to CSRF attacks, allowing the attacker to read potentially sensitive data.</span></span>

## <a name="anti-forgery-tokens-in-aspnet-mvc"></a><span data-ttu-id="6b3b7-144">Маркеры защиты от подделки в ASP.NET MVC</span><span class="sxs-lookup"><span data-stu-id="6b3b7-144">Anti-Forgery Tokens in ASP.NET MVC</span></span>

<span data-ttu-id="6b3b7-145">Чтобы добавить маркеров защиты от подделки страниц Razor, используйте **HtmlHelper.AntiForgeryToken** вспомогательный метод:</span><span class="sxs-lookup"><span data-stu-id="6b3b7-145">To add the anti-forgery tokens to a Razor page, use the **HtmlHelper.AntiForgeryToken** helper method:</span></span>

[!code-cshtml[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample3.cshtml)]

<span data-ttu-id="6b3b7-146">Этот метод добавляет скрытое поле формы, а также задается маркер cookie.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-146">This method adds the hidden form field and also sets the cookie token.</span></span>

## <a name="anti-csrf-and-ajax"></a><span data-ttu-id="6b3b7-147">CSRF защиты и AJAX</span><span class="sxs-lookup"><span data-stu-id="6b3b7-147">Anti-CSRF and AJAX</span></span>

<span data-ttu-id="6b3b7-148">Маркера формы может вызвать проблемы для запросов AJAX, так как запрос AJAX может отправить данные JSON, а не данные HTML-формы.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-148">The form token can be a problem for AJAX requests, because an AJAX request might send JSON data, not HTML form data.</span></span> <span data-ttu-id="6b3b7-149">Одним из решений является отправка токены в заголовок HTTP.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-149">One solution is to send the tokens in a custom HTTP header.</span></span> <span data-ttu-id="6b3b7-150">Следующий код использует синтаксис Razor для создания токенов, а затем добавляет токены для AJAX-запросом.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-150">The following code uses Razor syntax to generate the tokens, and then adds the tokens to an AJAX request.</span></span> <span data-ttu-id="6b3b7-151">Токены созданные на сервере путем вызова **AntiForgery.GetTokens**.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-151">The tokens are generated at the server by calling **AntiForgery.GetTokens**.</span></span>

[!code-html[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample4.html)]

<span data-ttu-id="6b3b7-152">При обработке запроса, извлеките токены из заголовка запроса.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-152">When you process the request, extract the tokens from the request header.</span></span> <span data-ttu-id="6b3b7-153">Затем вызовите **AntiForgery.Validate** метод для проверки токенов.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-153">Then call the **AntiForgery.Validate** method to validate the tokens.</span></span> <span data-ttu-id="6b3b7-154">**Проверки** метод вызывает исключение, если токены не допускаются.</span><span class="sxs-lookup"><span data-stu-id="6b3b7-154">The **Validate** method throws an exception if the tokens are not valid.</span></span>

[!code-csharp[Main](preventing-cross-site-request-forgery-csrf-attacks/samples/sample5.cs)]
