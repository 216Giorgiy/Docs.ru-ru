---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: Общие сведения о проекте Katana | Документы Microsoft
author: howarddierking
description: Платформа ASP.NET уже более десяти лет, и включения платформы разработки бесчисленное множество веб-сайтов и служб. Как разработка Web приложений...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/30/2013
ms.topic: article
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
ms.technology: ''
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 3c2bcbbc6e506af759f6d77af17d015278cc0bdf
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30878767"
---
<a name="an-overview-of-project-katana"></a>Общие сведения о проекте Katana
====================
по [Говард Дайеркинг](https://github.com/howarddierking)

> Платформа ASP.NET уже более десяти лет, и включения платформы разработки бесчисленное множество веб-сайтов и служб. Как отражающих развитие веб-стратегии разработки приложений, платформа была может изменяться в шаге с помощью технологий, как ASP.NET MVC и веб-API ASP.NET. Проект как следующего шага эволюционной разработки веб-приложения в среду облачных вычислений, [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) предоставляет базовый набор компонентов для приложения ASP.NET, обеспечивая их как гибкий и переносимый упрощенный и обеспечить более высокую производительность — другими словами, проектов [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) облака оптимизирует приложений ASP.NET.


## <a name="why-katana--why-now"></a>Почему Katana — почему сейчас?

 Независимо от того, является ли один описывается разработчика платформы или конечного пользователя продукта, очень важно понимать базовой причин для создания продукта — и часть, включает в себя зная создавшего для продукта. ASP.NET была создана с помощью двух клиентов в виду.   
  
**Первая группа клиентов был разработчики классический ASP.** В то время ASP был одним из первичного технологии для создания динамических, управляемых данными веб-сайтов и приложений с interweaving разметки и серверных скриптов. Среда выполнения ASP указано серверных скриптов с набором объектов, которые абстрагированы ключевых аспектов базовый протокол HTTP и веб-сервер и предоставленный доступ к дополнительных служб таких управление состоянием сеанса и приложения кэширования и т. д. Мощная, классических приложений ASP стало сложно управлять, так как они увеличился размер и сложность. Это было в основном из-за отсутствия структуре, обнаруженной в средах, в сочетании с дублированием код, полученный в результате чередованием код и разметку для создания сценариев. Чтобы выгоду от силы classic ASP при адресации некоторые его проблемы, ASP.NET воспользовался организации кода, при этом сохраняя серверную модель программирования, предоставляемые объектно ориентированные языки платформы .NET Framework для какой classic ASP разработчики выросла привычно.

**Вторая группа целевых клиентов для ASP.NET был разработчиков бизнес-приложений Windows.** В отличие от классического ASP разработчиками, было пользоваться записи HTML-разметку и код, чтобы создать дополнительные HTML-разметка, разработчики WinForms (например, разработчики VB6 перед ними) было пользоваться возможности во время разработки, которое включено полотна и широкий набор пользователей элементы управления интерфейса. Первая версия ASP.NET — также называется «Веб-форм» предоставленный аналогичные возможности времени проектирования модели событий на стороне сервера для компонентов пользовательского интерфейса и набор компонентов инфраструктуры (например ViewState) для создания тесную связь между клиентом и программирования стороны сервера. Web Forms эффективно hid состояний в модели с отслеживанием состояния событий, которое было известно разработчикам WinForms веб-узла.

### <a name="challenges-raised-by-the-historical-model"></a>Проблемы, вызванные исторической модели

**Конечный результат был зрелой многофункциональные среды выполнения и модель программирования разработчика.** Однако при, функция полноты приходится несколько важных проблем. Во-первых, платформа была **монолитные**, логически неравных единиц функциональных возможностей тесно связаны в той же сборке System.Web.dll (например, объекты ядра HTTP с Web forms framework). Во-вторых, ASP.NET был включен как часть более крупной платформы .NET, означает, что **времени между версиями было порядка нескольких лет.** Это затрудняет для ASP.NET не отставать все изменения, внесенные в быстрого развертывания веб-разработки. Наконец, System.Web.dll сам был вместе несколько разными способами для конкретного веб-хостинга параметр: Internet Information Services (IIS).

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a>Эволюционной действия: ASP.NET MVC и веб-API ASP.NET

И случается большое количество изменений в веб-разработки! Веб-приложения были более разрабатываются как ряд небольших, имеющий фокус, компоненты, а не больших платформы. Число компонентов, а также частоту, с которой они были выпущены рост частотой, когда-либо быстрее. Было ясно, что хранение темпа веб-службы с потребует платформ для получения меньшего размера, отделенный и более узкий вместо крупных и более многофункционального, поэтому **команды ASP.NET потребовалось несколько эволюционной действия, чтобы включить ASP.NET как семейство Подключаемые веб-компоненты, а не одну платформу, которая**.

Одно из изменений раннее была ростом популярности известный шаблон разработки model-view-controller (MVC) благодаря веб-платформы разработки как Ruby на направляющие. Такой стиль построения веб-приложений предлагает разработчику больше контроля над разметкой своего приложения, то же время сохраняя разделение разметки и бизнес-логику, которая была одной из начальной точки продажи для ASP.NET. Для удовлетворения этого спроса для этого стиля разработки веб-приложений, Майкрософт использует возможность поместить себя в будущем, лучше **разработки ASP.NET MVC аппаратного** (и не включать его в .NET Framework). ASP.NET MVC был выпущен как независимая загрузка. Команды разработчиков предлагает гибкость для доставки обновлений гораздо чаще, чем было возможно раньше.

Другой основной shift в разработке веб-приложений был переход от динамического, созданных с помощью сервера веб-страниц для разметки static начальной с динамических разделов страницы, созданные из клиентского скрипта взаимодействия **с серверной части веб-API через Запросы AJAX**. Сдвиг в архитектуре помогли развития подъем веб-API и разработки платформы ASP.NET Web API. В случае ASP.NET MVC в выпуске ASP.NET Web API предоставляется другой возможности дальнейшего более удобным framework развиваться ASP.NET. Команды разработчиков воспользовался возможной сделки и **построение веб-API ASP.NET таким образом, что без зависимостей и на любой из типов framework core, найденные в System.Web.dll**. Это позволило две вещи: во-первых, оно означает, что веб-API ASP.NET может изменяться в форме полностью автономными (а он может продолжить прохода быстро, так как оно будет доставлено через NuGet). Во-вторых так как не было без внешних зависимостей для System.Web.dll и, следовательно, без зависимостей в службах IIS, ASP.NET Web API включены возможностью для запуска в пользовательское основное приложение (например, консольного приложения, службы Windows, и т. д.)

### <a name="the-future-a-nimble-framework"></a>Будущее: Nimble платформу

Отделение компоненты framework друг от друга и затем освободить их в NuGet, теперь может платформы **прохода более независимо друг от друга и быстрее**. Кроме того, мощность и гибкость возможность резидентного размещения веб-API оказалась очень полезным для разработчиков, желавшим **небольшие, простое узла** своих служб. Было столь важным, на самом деле других платформ также исправили этой возможности и это подключить новый запрос, в том, что каждая платформа выполнялся в своем собственном процессе узла на собственный базовый адрес и его нужно управлять (запущена, остановлена, т. д.) независимо друг от друга. Современные веб-приложения обычно поддерживает обслуживание статических файлов, создание динамической страницы, веб-API и более недавно режиме реального-времени или push-уведомлений. Ожидается, что каждая из этих служб следует работают и управляются независимо друг от друга не просто реалистичных.

Требовался одного размещения абстракции, дают разработчику возможность составлять приложения из множества различных компонентов и платформы и затем выполнить приложение вспомогательные узла.

## <a name="the-open-web-interface-for-net-owin"></a>Откройте веб-интерфейса для .NET (OWIN)

 Вдохновлен преимущества, достигнутые [для монтажа в стойку](http://rack.github.io/) в сообществе Ruby несколько членов сообщества .NET решил сделать абстракции между веб-серверов и компоненты платформы. Две цели проектирования для абстракции OWIN были было простой и потребовалось наименьшее число возможных зависимостей от других типов framework. Эти две цели обеспечения:

- Новые компоненты могут разработаны более просто и использованы.
- Приложения может легко переносить между узлами и потенциально всей платформы и операционные системы.

Полученный абстракции состоит из двух основных элементов. Первый — словарь среды. Эта структура данных отвечает за хранение все сведения о состоянии, необходимые для обработки HTTP-запроса и ответа, а также любые состоянии соответствующего сервера. Словарь среды определяется следующим образом:

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

OWIN-совместимых веб-сервер отвечает за заполнение словарь среды с данными, например потоки текста и коллекциями заголовков HTTP-запроса и ответа. Он отвечает затем компонентов приложение или платформу, для заполнения или обновить словарь дополнительными значениями и записи в поток тела откликов.

Кроме указания типа в словаре среды, спецификация OWIN определяет список основных пары ключ-значение словаря. Например ниже приведены нужный словарь ключей для HTTP-запроса:

| Имя ключа | Описание значения |
| --- | --- |
| `"owin.RequestBody"` | Поток с текста запроса, если таковые имеются. Stream.Null может использоваться как заполнитель, если текст не запрос. В разделе [текст запроса](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics). |
| `"owin.RequestHeaders"` | `IDictionary<string, string[]>` Заголовков запроса. В разделе [заголовки](http://owin.org/html/owin.html#3-3-headers). |
| `"owin.RequestMethod"` | Объект `string` содержащая метод HTTP-запроса запроса (например, `"GET"`, `"POST"`). |
| `"owin.RequestPath"` | Объект `string` содержит путь запроса. Путь должен задаваться относительно «root» делегата приложения; в разделе [пути](http://owin.org/html/owin.html#5-3-paths). |
| `"owin.RequestPathBase"` | Объект `string` содержащая часть пути запроса, соответствующий «root» приложения делегата;. в разделе [пути](http://owin.org/html/owin.html#5-3-paths). |
| `"owin.RequestProtocol"` | Объект `string` с именем протокол и версия (например `"HTTP/1.0"` или `"HTTP/1.1"`). |
| `"owin.RequestQueryString"` | Объект `string` содержит компонент строки запроса HTTP-запроса URI, без начальных «?» (например, `"foo=bar&baz=quux"`). Значение может быть пустой строкой. |
| `"owin.RequestScheme"` | Объект `string` содержащий схему URI, используемый для запроса (например, `"http"`, `"https"`); в разделе [схема URI](http://owin.org/html/owin.html#5-1-uri-scheme). |

Второй элемент OWIN ключа является делегатом приложения. Это сигнатуру функции, который служит в качестве основной интерфейс между всеми компонентами приложения OWIN. Определение делегата приложения выглядит следующим образом:

`Func<IDictionary<string, object>, Task>;`

Затем делегат приложения является просто реализацией типа делегата Func, где функция принимает словарь среды как входные данные и возвращает задачу. Такой подход имеет несколько последствий для разработчиков:

- Существует небольшое число тип зависимости, необходимые для записи компонентами OWIN. Это значительно увеличивает доступность OWIN для разработчиков.
- Асинхронного программирования позволяет абстракции эффективности вычислительных ресурсов, особенно в несколько операций с большим объемом операций ввода-вывода его обработки.
- Поскольку делегат приложения является неделимой единицей работы и так как словарь среды переносятся в качестве параметра в делегате, компонентами OWIN можно легко связывать друг с другом для создания сложных HTTP обработки конвейеров.

С точки зрения реализации OWIN представляет собой спецификацию ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)). Его целью является не быть далее веб-платформа, но вместо спецификацию для взаимодействия веб-платформы и веб-серверов.

Если изучения [OWIN](http://owin.org/) или [Katana](https://github.com/aspnet/AspNetKatana/wiki), возможно, вы также заметили [пакет Owin NuGet](http://nuget.org/packages/Owin) и Owin.dll. Эта библиотека содержит единый интерфейс [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), который является формальным и фиксирует принципы последовательности запуска, описанные в [подраздел 4](http://owin.org/html/owin.html#4-application-startup) спецификации OWIN. Хотя это не обязательно для создания серверов OWIN [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) интерфейс предоставляет конкретные контрольной точки и используется компонентами Katana проекта.

## <a name="project-katana"></a>Katana проекта

В то время как оба [OWIN](http://owin.org/html/owin.html) спецификации и *Owin.dll* являются собственностью сообщества и сообщества усилия с открытым исходным кодом, запустите [Katana](https://github.com/aspnet/AspNetKatana/wiki) проект представляет набор OWIN компоненты, которые создаются и выпускаемых корпорацией Майкрософт при открытом источника. Эти компоненты включают как компоненты инфраструктуры, такие как узлы и серверы, так и функциональные компоненты, например компоненты проверки подлинности и привязки к платформам например [SignalR](../../../signalr/index.md) и [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md). Проект содержит следующие три задачи верхнего уровня: 

- **Переносимый** — компоненты должны иметь возможность легко заменить новые компоненты, которые становятся доступными. Сюда входят все типы компонентов, от платформы к серверу и узла. Эта цель имеет что сторонних платформ без проблем может работать на серверах Microsoft во время платформы Майкрософт потенциально могут выполняться на сторонние серверы и узлы.
- **Модульная и гибкие**— в отличие от многих платформ, включающих множество функций, которые включены по умолчанию, Katana проекта компоненты должны быть небольшим и конкретное, предоставляя элемент управления разработчику приложения определить, какие компоненты будут Используйте в своих приложениях.
- **Упрощенный и высокопроизводительных и масштабируемых** —, разбив традиционных понятие платформу на небольшой набор компонентов, которые будут добавлены явно разработчиком приложения, полученное Katana приложение может использовать меньшее количество вычислений с фокусом ввода ресурсы и в результате обработки больше нагрузки, чем для других типов серверов и платформы. Как приложения требует дополнительных функций из базовой инфраструктурой, их можно добавить в конвейер OWIN, но это должен быть явное решение со стороны разработчика приложения. Кроме того заменяемости низкоуровневые компоненты означает, что как только они становятся доступными, новых высокопроизводительных серверов можно легко ввести для повышения производительности приложений OWIN, не нарушая работу этих приложений.

## <a name="getting-started-with-katana-components"></a>Приступая к работе с компонентами Katana

Когда он впервые появилась, одним из аспектов [Node.js](http://nodejs.org/) framework, немедленно, перетащенной привлекает внимание было простота, с помощью которого можно создавать и запуска веб-сервера. Если были в рамке Katana целей light из [Node.js](http://nodejs.org/), один может суммировать, о том, что Katana переводит многие преимущества [Node.js](http://nodejs.org/) (и платформ, таких как его) без перезагрузки разработчику погрузится все, что она знает о разработке веб-приложений ASP.NET. В этой инструкции действительным Приступая к работе с проектом Katana должно быть так же просто по своей природе для [Node.js](http://nodejs.org/).

## <a name="creating-hello-world"></a>Создание «Hello World!»

Примечательным отличием между JavaScript и .NET development является наличие (или отсутствие) компилятора. Таким образом начальной точкой для простого Katana сервера — это проект Visual Studio. Тем не менее, мы начнем с минимальными типов проектов: пустое веб-приложение ASP.NET.

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

Далее мы установим [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) пакета NuGet в проект. Этот пакет содержит OWIN сервера, работающего в конвейер запросов ASP.NET. Его можно найти на [галереи NuGet](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) и могут быть установлены с помощью диалогового окна диспетчера пакетов Visual Studio или консоли диспетчера пакетов с помощью следующей команды:

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

Установка `Microsoft.Owin.Host.SystemWeb` пакет будет установлен несколько дополнительных пакетов в качестве зависимостей. Одна из этих зависимостей является `Microsoft.Owin`, библиотеку, которая предоставляет несколько вспомогательные типы и методы для разработки приложений OWIN. Эти типы можно использовать для быстрого написания следующего сервера «hello world».

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

Это очень простой веб-сервере можно запустить с помощью Visual Studio **F5** команды и включает полную поддержку для отладки.

## <a name="switching-hosts"></a>Переключение узлов

По умолчанию в предыдущем примере «hello world» работает в конвейер запросов ASP.NET использует System.Web в контексте служб IIS. Это можно самостоятельно добавить значительные преимущества как позволяет использовать преимущества гибкости и возможность компоновки конвейер OWIN с возможностями управления и общую надежность IIS. Тем не менее могут быть случаи, когда преимущества, предоставляемые IIS не требуются и желания предназначен для узла меньшего размера, более простое. Что требуется, затем для выполнения простого веб-сервере за пределами служб IIS и System.Web?

Чтобы проиллюстрировать переносимость цель, для перемещения с узла веб сервера на узле командной строки требуется просто Добавление нового сервера и узел зависимостей в выходную папку проекта, а затем запустить узел. В этом примере мы проводим веб-сервере в Katana узла с именем `OwinHost.exe` и будет использовать сервер под управлением Katana HttpListener. Аналогичным образом в других компонентах Katana эти будет получена из NuGet с помощью следующей команды:

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

Из командной строки, можно затем перейдите в корневую папку проекта и просто запустите `OwinHost.exe` (который был установлен в папку tools его соответствующий пакет NuGet). По умолчанию `OwinHost.exe` настроен для поиска сервера на основании HttpListener и поэтому не требуется никаких дополнительных настроек. Переходы в веб-браузере `http://localhost:5000/` показано приложение, теперь работает через консоль.

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a>Архитектура Katana

 Архитектура компонентов Katana разделяет приложение на четыре логических слоев, как показано ниже: *узла, сервер, по промежуточного слоя,* и *приложения*. Архитектура компонентов добавляется таким образом, что реализации этих слоев можно легко заменить, во многих случаях без повторной компиляции приложения.   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a>Ведущее приложение

 Основное приложение отвечает за:

- Управление в базовый процесс.
- Оркестрация рабочего процесса, который приводит к выбора сервера и построении конвейер OWIN через какие запросы будут обрабатываться.

  В настоящее существует 3 основных размещения возможности для приложений на основе Katana:  
  
**IIS/ASP.NET**: с помощью стандартных типов HttpModule и HttpHandler, конвейеры OWIN можно выполнять в IIS как часть потока обработки запросов ASP.NET. Поддержка размещения ASP.NET включена путем установки пакета Microsoft.AspNet.Host.SystemWeb NuGet в проект веб-приложения. Кроме того так как IIS работает как узлом и сервером, в этот пакет NuGet, то есть, если узел SystemWeb, разработчик не могут подставить реализацию альтернативный сервер связывается различие узла или сервера OWIN.  
  
**Пользовательское основное приложение**: Katana компонент набора дает разработчику возможность размещать приложения в собственный пользовательский процесс, будь это консольное приложение, служба Windows, и т. д. Эта возможность выглядит аналогично резидентной возможности, предоставляемые веб-API. В следующем примере показано пользовательское основное приложение веб-API кода:  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

Аналогично резидентной программы установки для приложения Katana:

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

Между веб-API и Katana примеры резидентной примечательным отличием является то, что пример резидентного размещения Katana отсутствует код конфигурации веб-API. Чтобы обеспечить совместимость и возможность компоновки, Katana отделяет код, который запускает сервер из кода, который настраивает конвейер обработки запросов. Код, который настраивает веб-API, а затем содержится в классе запуска, кроме того указанного в качестве параметра типа в WebApplication.Start.

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

Класс startup обсуждаются более подробно далее в этой статье. Однако код, необходимый для запуска Katana, резидентной процесс похож удивительно код может использоваться в приложениях резидентного размещения веб-API ASP.NET сегодня.

**OwinHost.exe**: хотя некоторые может потребоваться написать пользовательский процесс запуск Katana веб-приложений, многие предпочитаете просто запустите предварительно построенного исполняемого файла, можно запустить сервер и запускать приложения. Для этого сценария набор компонентов Katana входят `OwinHost.exe`. При запуске в корневом каталоге проекта этот исполняемый файл запустить сервер (использует HttpListener сервер по умолчанию) и использовать соглашения для поиска и запуска класс запуска пользователя. Для более детального контроля исполняемый файл предоставляет ряд дополнительных параметров командной строки.

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a>Сервер

 Хотя основное приложение отвечает за запуск и обслуживание процесс, в котором выполняется приложение, ответственность за сервера открыть к сетевому сокету прослушивать запросы и отправлять их по конвейеру компонентами OWIN указано пользователем (как вы возможно уже заметили, этот конвейер указан в классе запуска разработчик приложения). В настоящее время Katana проект включает две реализации сервера: 

- **Microsoft.Owin.Host.SystemWeb**: как упоминалось ранее, служит узлом и сервером IIS в сочетании с конвейера ASP.NET. Таким образом при выборе этого варианта размещения, IIS и управляет детали реализации на уровне узла, например активации и прослушивает HTTP-запросы. Для веб-приложений ASP.NET после этого он отправляет запросы в конвейере ASP.NET. Узел Katana SystemWeb регистрирует ASP.NET HttpModule и HttpHandler может перехватывать запросы, как они проходят через конвейер HTTP, а затем отправить их через конвейер OWIN определяемый пользователем.
- **Microsoft.Owin.Host.HttpListener**: как названия, этот сервер Katana использует HttpListener класс .NET Framework для открытия сокет и отправки запросов в конвейер OWIN определенные разработчиком. В настоящее время это параметр сервера по умолчанию для самостоятельного размещения API Katana и OwinHost.exe.

## <a name="middlewareframework"></a>По промежуточного слоя и framework

 Как упоминалось ранее когда сервер принимает запрос от клиента, он отвечает за передается через конвейер OWIN компонентов, которые задаются в коде запуска разработчика. Эти компоненты конвейера известны как по промежуточного слоя.  
 На уровне очень простой компонент по промежуточного слоя OWIN просто необходимо реализовать делегат приложения OWIN, чтобы он может быть вызван.

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

Однако для упрощения разработки и сочетание компонентов по промежуточного слоя, Katana поддерживает несколько соглашений и вспомогательные типы для компонентов по промежуточного слоя. Наиболее распространенной из них является `OwinMiddleware` класса. Компонента пользовательского по промежуточного слоя, созданного с помощью этого класса будет выглядеть следующим образом: 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 Этот класс является производным от `OwinMiddleware`, реализует конструктор, который принимает экземпляр следующее по промежуточного слоя в конвейере как один из его аргументов и передает ее в конструктор базового класса. Дополнительные аргументы, используемые для настройки по промежуточного слоя также объявляются как параметры конструктора после следующего параметра по промежуточного слоя.   
  
Во время выполнения, выполняется по промежуточного слоя через переопределенные `Invoke` метод. Этот метод принимает один аргумент типа `OwinContext`. Предоставляемые этим объектом контекста `Microsoft.Owin` пакет NuGet описано выше и обеспечивает строго типизированный доступ к словарю запрос ответа и среды, вместе с несколько дополнительные вспомогательные типы.   
  
Класс по промежуточного слоя можно легко добавить в конвейер OWIN в коде запуска приложения следующим образом:   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

Поскольку инфраструктуры Katana просто создает конвейер OWIN по промежуточного слоя компоненты и компоненты просто должны поддерживать делегат приложения для участия в конвейере, компонентов по промежуточного слоя могут различаться по сложности с простой средства ведения журнала для всего платформ, таких как ASP.NET, веб-API или [SignalR](../../../signalr/index.md). Например добавление веб-API ASP.NET в конвейер OWIN предыдущих необходимо добавить следующий код запуска.

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

Инфраструктура Katana построит конвейера, на основе порядка, в котором они были добавлены в объект IAppBuilder в метод конфигурации компонентов по промежуточного слоя. Затем, в нашем примере LoggerMiddleware может обрабатывать все запросы, поступающие по конвейеру, независимо от того, как эти запросы обрабатываются в конечном счете. Это позволяет эффективных сценариев, где программный компонент (например компонента для проверки подлинности), может обрабатывать запросы для конвейера, который включает несколько компонентов и платформы (например веб-API ASP.NET SignalR и статических файлового сервера).
 
## <a name="applications"></a>Приложения

Как показано в предыдущих примерах, OWIN и Katana проекта следует не рассматривать как новую модель программирования приложения, а также как абстракцию для отделения модели программирования приложений и платформ с сервера и инфраструктура размещения. Например при построении приложений для веб-API, платформа разработчика продолжат использовать платформу веб-API ASP.NET, независимо от того, является ли приложение выполняется в конвейер OWIN с помощью компонентов из проекта Katana. Одном месте, где будет отображаться на разработчик приложения OWIN относящихся к коду будет кода запуска приложения, где разработчик объединяется в конвейер OWIN. В коде запуска разработчик регистрирует ряд UseXx инструкций, обычно для каждого компонента по промежуточного слоя, который будет обрабатывать входящие запросы. Этот интерфейс будет иметь тот же эффект, как регистрация HTTP-модулей в текущее универсальное System.Web. Как правило, больше framework по промежуточного слоя, например веб-API ASP.NET или [SignalR](../../../signalr/index.md) будет зарегистрирован в конце конвейера. Перекрестные компонентов по промежуточного слоя, например для проверки подлинности или кэширование, обычно регистрируются к началу конвейера, чтобы они будут обрабатывать запросы для всех платформ и компоненты, зарегистрированные в конвейере. Такое разделение компонентов по промежуточного слоя друг от друга и от базовых компонентов инфраструктуры включает компоненты развиваться различные скорости, гарантируя, что общей системы остается неизменным.

## <a name="components--nuget-packages"></a>Компоненты — пакетами NuGet

Как и многие текущие библиотеки и платформ компоненты проекта Katana предоставляются как набор пакетов NuGet. Для предстоящих версии 2.0 граф зависимостей пакета Katana выглядит следующим образом. (Щелкните изображение для увеличения).

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

Практически все пакеты в проекте Katana зависит, прямо или косвенно, пакет Owin. Вы помните, что это пакет, содержащий интерфейс IAppBuilder, который предоставляет конкретную реализацию последовательность запуска приложения, описанной в разделе 4 спецификации OWIN. Кроме того многие пакеты зависят от Microsoft.Owin, который предоставляет набор вспомогательные типы для работы с HTTP-запросов и ответов. В оставшейся части пакета можно классифицировать как размещения инфраструктуры пакетов (серверов или узлов) или по промежуточного слоя. Пакеты и зависимости, которые являются внешними для проекта Katana отображаются оранжевым цветом.

Размещения инфраструктура для Katana 2.0 включает SystemWeb и серверы на базе HttpListener, OwinHost пакета для запуска приложений OWIN, с помощью OwinHost.exe и пакета Microsoft.Owin.Hosting для резидентного размещения приложений OWIN в пользовательское основное приложение (например консольного приложения, службы Windows, и т. д.)

2.0 Katana компонентов по промежуточного слоя в основном направлен на предоставление разные способы проверки подлинности. Один компонент дополнительного по промежуточного слоя для диагностики предоставляется для поддержки для запуска и ошибки страниц. При увеличении OWIN в фактически размещения абстракцию экосистеме компонентов по промежуточного слоя, оба разработанные корпорацией Майкрософт и сторонних разработчиков, также будет увеличиваться в числе.

## <a name="conclusion"></a>Заключение

 С самого начала, не было цель проекта Katana для создания и тем самым требует от разработчиков узнать еще другой веб-платформы. Вместо этого для создания абстракцию для предоставления разработчикам приложений .NET Web варианты, ранее было возможно был цели. Разбив логических слоев типичного веб приложения в набор замена компонентов, проект Katana позволяет компонентам во всем стеке для улучшения в любой курс имеет смысл для этих компонентов. При построении все компоненты вокруг простой абстракции OWIN, Katana позволяет платформы и приложения, построена на базе их, можно переносить на другие разнообразные различных серверов и узлов. Поместив разработчика в элементе управления стека, Katana гарантирует, что разработчик вносит окончательное решение о том, как упрощенный или как многофункциональные должен быть свой веб-решения.  
  

## <a name="for-more-information-about-katana"></a>Дополнительные сведения о Katana

- В проекте Katana на GitHub: [ https://github.com/aspnet/AspNetKatana/ ](https://github.com/aspnet/AspNetKatana/).
- Видео: [проект Katana - OWIN для ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), по Говард Дайеркинг.

## <a name="acknowledgements"></a>Благодарности

- [Рик Андерсон](https://blogs.msdn.com/b/rickandy/): (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT) ) Рик имеет старший программный модуль записи для Microsoft Azure и MVC.
- [Скотт Хансельман](http://www.hanselman.com/blog/): (twitter [ @shanselman ](https://twitter.com/shanselman) )
- [Джон Гэллоуэй](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [ @jongalloway ](https://twitter.com/jongalloway) )
