---
uid: aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead
title: "Что не делать в ASP.NET и что нужно делать вместо этого | Документы Microsoft"
author: tfitzmac
description: "В этом разделе описаны некоторые распространенные ошибки, вносить пользователям в рамках веб-проектов ASP.NET. Оно предоставляет рекомендации по что делать, чтобы избежать этих commo..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/08/2014
ms.topic: article
ms.assetid: c39b9965-545c-4b04-8f55-21be7f28a9e5
ms.technology: 
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead
msc.type: authoredcontent
ms.openlocfilehash: 6790cd0deb36c9fb297ccd4df371f763dba17844
ms.sourcegitcommit: 17b025bd33f4474f0deaafc6d0447a4e72bcad87
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/27/2017
---
<a name="what-not-to-do-in-aspnet-and-what-to-do-instead"></a>Что не делать в ASP.NET и что нужно делать вместо этого
====================
по [Tom FitzMacken](https://github.com/tfitzmac)

> В этом разделе описаны некоторые распространенные ошибки, вносить пользователям в рамках веб-проектов ASP.NET. Оно предоставляет рекомендации по что делать, чтобы избежать этих распространенных ошибок. Он основан на [презентации](http://vimeo.com/68390507) по **Edwards — Дэмьен** норвежский конференции разработчиков.


## <a name="disclaimer"></a>Отказ от ответственности

В этом разделе не предназначен как полное руководство по, чтобы убедиться, что приложение является безопасный и эффективный. Необходимо по-прежнему следуйте рекомендациям по безопасности и производительности, которые не описаны в этом разделе. Предлагаются только как избежать распространенных ошибок, связанных с классами .NET и процессов.

## <a name="overview"></a>Обзор

В этом разделе содержатся следующие подразделы.

- [Соответствие стандартам](#standards)

    - [Адаптеры элементов управления](#adapters)
    - [Свойства стиля для элементов управления](#styleprop)
    - [Страницы и обратные вызовы для элемента управления](#callback)
    - [Определение возможностей браузера](#browsercap)
- [Безопасность](#security)

    - [Проверка запросов](#validation)
    - [Проверка подлинности форм без поддержки файлов cookie и сеансов](#cookieless)
    - [EnableViewStateMac](#viewstatemac)
    - [Средний уровень доверия](#medium)
    - [&lt;appSettings&gt;](#appsettings)
    - [UrlPathEncode](#urlpathencode)
- [Надежность и производительность](#performance)

    - [PreSendRequestHeaders и PreSendRequestContent](#presend)
    - [События асинхронной страницы с веб-форм](#asyncevents)
    - [Выстрелил и забыл работы](#fire)
    - [Тело сущности запроса](#requestentity)
    - [Response.Redirect и Response.End](#redirect)
    - [EnableViewState и ViewStateMode](#viewstatemode)
    - [SqlMembershipProvider](#sqlprovider)
    - [Длительные запросы, под управлением (> 110 секунд)](#long)

<a id="standards"></a>

## <a name="standards-compliance"></a>Соответствие стандартам

<a id="adapters"></a>

### <a name="control-adapters"></a>Адаптеры элементов управления

Рекомендация: Остановить с помощью адаптеров элементов управления для адаптивной отрисовки и вместо этого используйте CSS медиа-запросами и совместимый со стандартами HTML.

Адаптеры элементов управления появились в .NET 2.0 для визуализации представления код, который был настроен для различных устройств и сред. Теперь этот адаптивной отрисовки может быть выполнено с CSS и HTML. Следует остановить с помощью адаптеров элементов управления и преобразуйте все существующие адаптеры CSS и HTML.

Дополнительные сведения см. в разделе [медиа-запросами](http://www.w3.org/TR/css3-mediaqueries/) и [How To: Добавление страниц для мобильных устройств для вашего веб-форм ASP.NET и MVC-приложении](../../../whitepapers/add-mobile-pages-to-your-aspnet-web-forms-mvc-application.md).

<a id="styleprop"></a>

### <a name="style-properties-on-controls"></a>Свойства стиля для элементов управления

Рекомендация: Остановить задание значений стиля в разметку элемента управления и вместо этого задать форматирование значений в таблицах стилей CSS.

Веб-сервера управления содержат множество свойств, которые можно использовать для задания свойств стиля в строке. Например свойства ForeColor задает цвет текста для элемента управления. Это можно сделать этого же эффекта эффективнее посредством таблицы стилей CSS. Таблицы стилей позволяют централизовать значения стилей и не задавайте эти значения во всем приложении.

Следующий пример показывает класс CSS наборов текст на красный.

[!code-css[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample1.css)]

В следующем примере показано, как динамически применить класс CSS.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample2.cs)]

<a id="callback"></a>

### <a name="page-and-control-callbacks"></a>Страницы и обратные вызовы для элемента управления

Рекомендация: Прекратить использование обратных вызовов страниц и элементов управления и вместо этого использовать любой из следующих: AJAX, UpdatePanel, методы действия MVC, веб-API или SignalR.

В более ранних версиях ASP.NET страниц и элементов управления методы обратного вызова включено обновление части веб-страницы без обновления всей страницы. Теперь можно выполнить частичных обновлений через [AJAX](../../../ajax/index.md), [UpdatePanel](https://msdn.microsoft.com/en-US/library/bb386454.aspx), [MVC](../../../mvc/index.md), [веб-API](../../../web-api/index.md) или [SignalR](../../../signalr/index.md). Следует остановить с помощью методов обратного вызова, так как они могут вызвать проблемы с понятные URL-адреса и маршрутизацию. По умолчанию элементы управления, не включайте методы обратного вызова, но если вы включили этот компонент в элементе управления, его следует отключить.

<a id="browsercap"></a>

### <a name="browser-capability-detection"></a>Определение возможностей браузера

Рекомендация: Прекратить использование статических браузера возможность обнаружения, а вместо этого используйте функцию динамического обнаружения.

В более ранних версиях ASP.NET поддерживаемых функций для каждого браузера, хранятся в XML-файл. Обнаружение поддержка функций через статический подстановки не лучшим подходом. Теперь можно динамически обнаруживать поддерживаемых возможностей браузера с помощью платформы обнаружение компонентов, таких как [Modernizr](http://modernizr.com/). Функция обнаружения определяет поддержки попытка использовать метод или свойство, и затем проверив для просмотра, если браузер формируется нужного результата. По умолчанию Modernizr состава шаблонов веб-приложений.

<a id="security"></a>

## <a name="security"></a>Безопасность

<a id="validation"></a>

### <a name="request-validation"></a>Проверка запросов

Рекомендация: Проверки пользовательского ввода и кодирование вывода от пользователей.

Проверка запроса — это функция ASP.NET, проверяет каждый запрос и останавливает запрос при обнаружении предполагаемых угроз. Не полагайтесь на проверку запросов для защиты приложения от атак с использованием межсайтовых сценариев. Вместо этого проверяйте весь ввод от пользователей и кодирования выходных данных. В некоторых случаях можно использовать регулярные выражения для проверки входных данных, но в более сложных случаях следует проверять ввод данных пользователем с помощью классов .NET, которые определяют, если значение совпадает с допустимыми значениями.

В следующем примере показано, как использовать статический метод в класс Uri, чтобы определить, является ли допустимым Uri, предоставленный пользователем.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample3.cs)]

Тем не менее, чтобы достаточно проверить Uri, обратитесь к убедитесь, что он указывает `http` или `https`. В следующем примере методы экземпляра убедитесь, что Uri является допустимым.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample4.cs)]

Прежде чем визуализации ввод данных пользователем в формате HTML или включая пользовательский ввод SQL-запроса, кодирования значений, чтобы убедиться, что вредоносный код не был включен.

Вы можете HTML кодирования значения в разметке, с &lt;%: %&gt; синтаксис, как показано ниже.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample5.aspx?highlight=1)]

В синтаксис Razor, вы также можете HTML кодирования с @, как показано ниже.

[!code-cshtml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample6.cshtml?highlight=1)]

В следующем примере показан способ необходима кодировка HTML значение в коде.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample7.cs)]

Для безопасного кодирования значение для команды SQL, используйте параметры команды, например [SqlParameter](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlparameter.aspx). <a id="cookieless"></a>

### <a name="cookieless-forms-authentication-and-session"></a>Проверка подлинности форм без поддержки файлов cookie и сеансов

Рекомендация: Требуется файлы cookie.

Передача данных проверки подлинности в строке запроса не является безопасным. Таким образом требуют файлы cookie, если приложение включает проверку подлинности. Если файлы cookie с компьютера хранятся конфиденциальные сведения, рассмотрите возможность применения SSL для файла cookie.

Следующий пример показывает способ указания в файле Web.config, что проверка подлинности форм требуется файл cookie, отправленных по протоколу SSL.

[!code-xml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample8.xml)]

<a id="viewstatemac"></a>

### <a name="enableviewstatemac"></a>EnableViewStateMac

Рекомендация: Никогда не задано значение false.

По умолчанию EnbableViewStateMac задано значение true. Даже если приложение не использует состояние просмотра, не устанавливайте EnableViewStateMac значение false. Установка этого значения равным false делает приложение уязвимым для межсайтовых сценариев.

Начиная с ASP.NET 4.5.2, среда выполнения обеспечивает **EnableViewStateMac = true**. Даже если присвоить ему значение false, среда выполнения игнорирует это значение и выполняет заданное значение в значение true. Дополнительные сведения см. в разделе [ASP.NET 4.5.2 и EnableViewStateMac](https://blogs.msdn.com/b/webdev/archive/2014/05/07/asp-net-4-5-2-and-enableviewstatemac.aspx).

В следующем примере показано, как EnableViewStateMac присвоено значение true. Необходимо фактически задано значение true, так как он имеет значение true, если по умолчанию. Если вы настроили его значение false на любой странице в приложении, необходимо немедленно исправить это значение.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample9.aspx)]

<a id="medium"></a>

### <a name="medium-trust"></a>Средний уровень доверия

Рекомендация: Как защитная граница не полагаться на средний уровень доверия (или любом другом уровне доверия).

Не могут обеспечить адекватную защиту приложения с частичным доверием и не должны использоваться. Вместо этого используйте полное доверие и изолировать без доверия приложения в разных пулах приложений. Кроме того запустите каждый пул приложений с уникальным удостоверением. Дополнительные сведения см. в разделе [частичное доверие в ASP.NET не обеспечивает изоляцию приложений](https://support.microsoft.com/kb/2698981).

<a id="appsettings"></a>

### <a name="ltappsettingsgt"></a>&lt;appSettings&gt;

Рекомендация: Не отключайте параметры безопасности в &lt;appSettings&gt; элемента.

Элемент appSettings содержит много значений, которые необходимы для обновления для системы безопасности. Нельзя изменить или отключить эти значения. Если эти значения необходимо отключить при развертывании обновления, немедленно повторно включите после завершения развертывания.

Дополнительные сведения см. в разделе [элементу appSettings ASP.NET](https://msdn.microsoft.com/en-us/library/hh975440.aspx).

<a id="urlpathencode"></a>

### <a name="urlpathencode"></a>UrlPathEncode

Рекомендации: Используйте [кодируют](https://msdn.microsoft.com/en-us/library/zttxte6w.aspx) вместо него.

Метод UrlPathEncode была добавлена в .NET Framework, чтобы устранить проблему совместимости очень конкретного браузера. Не кодирует адекватно URL-адреса и не обеспечивает дополнительную защиту от межсайтовых сценариев. Он никогда не следует использовать в приложении. Вместо этого используйте [кодируют](https://msdn.microsoft.com/en-us/library/zttxte6w.aspx).

В следующем примере показано, как передать закодированный URL-адрес в качестве параметра строки запроса для элемента управления hyperlink.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample10.cs)]

<a id="performance"></a>

## <a name="reliability-and-performance"></a>Надежность и производительность

<a id="presend"></a>

### <a name="presendrequestheaders-and-presendrequestcontent"></a>PreSendRequestHeaders и PreSendRequestContent

Рекомендация: Не используйте эти события с управляемых модулей. Вместо этого можно напишите собственный модуль IIS для выполнения требуемой задачи. В разделе [создания модулей машинного кода HTTP](https://msdn.microsoft.com/en-us/library/ms693629.aspx).

Можно использовать [PreSendRequestHeaders](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.presendrequestheaders.aspx) и [PreSendRequestContent](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.presendrequestcontent.aspx) событий с собственные модули IIS.
> [!WARNING]
> Не используйте `PreSendRequestHeaders` и `PreSendRequestContent` с управляемых модулей, которые реализуют `IHttpModule`. Настройка этих свойств может вызвать трудности в асинхронных запросов. Сочетание маршрутизации запрошенный приложений (ARR) и websockets может стать причиной исключения нарушения прав доступа, которые могут вызвать w3wp к сбою. Например, iiscore! W3_CONTEXT_BASE::GetIsLastNotification + 68 в iiscore.dll вызвала нарушение прав доступа (0xC0000005).

<a id="asyncevents"></a>

### <a name="asynchronous-page-events-with-web-forms"></a>События асинхронной страницы с веб-форм

Рекомендации: В веб-формы, не используйте запись async void методов, событий жизненного цикла страницы, а вместо этого использовать [Page.RegisterAsyncTask](https://msdn.microsoft.com/en-us/library/system.web.ui.page.registerasynctask.aspx) для асинхронного кода.

Если пометить события страницы с **async** и **void**, не может определить, после завершения асинхронного кода. Вместо этого используйте Page.RegisterAsyncTask для выполнения асинхронного кода в способом, который позволяет отслеживать его выполнение.

В следующем примере показан кнопки выберите обработчик, который содержит асинхронного кода. Данный пример включает асинхронно, считывая значение строки, предоставляемое только как упрощенный пример асинхронной задачи, а не рекомендуется.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample11.cs)]

При использовании асинхронных задач присвоено Http среды выполнения требуемая версия .NET framework 4.5 в файле Web.config. Настройке требуемой версии .NET framework 4.5 Включение на новый контекст синхронизации, была добавлена в .NET 4.5. Это значение установлено значение по умолчанию в новых проектах в Visual Studio 2012, но не была настроена при работе с существующим проектом.

[!code-xml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample12.xml)]

<a id="fire"></a>

### <a name="fire-and-forget-work"></a>Выстрелил и забыл работы

Рекомендация: При обработке запроса в ASP.NET, избегайте запуска рабочих выстрелил и забыл (такой вызов метода ThreadPool.QueueUserWorkItem или создания таймер, который многократно вызывает делегат).

Если приложение имеет выстрелил и забыл работы, которая выполняется в ASP.NET, приложение можно получить синхронизированы. В любое время домен приложения можно удалить это означает, что ваш текущий процесс больше не соответствует текущее состояние приложения.

Этот тип работы вне ASP.NET следует переместить. Можно использовать веб-задания, службы Windows или рабочей роли в Azure для выполнения текущей работы и запускать этот код от другого процесса.

Если необходимо выполнить эту работу в ASP.NET, можно добавить пакет Nuget вызывается [WebBackgrounder](http://www.nuget.org/packages/webbackgrounder) выполнение кода.

<a id="requestentity"></a>

### <a name="request-entity-body"></a>Тело сущности запроса

Рекомендация: Избегайте чтение Request.Form или Request.InputStream до обработчика выполнить событие.

Самый ранний лимит должны считываться Request.Form или Request.InputStream во время работы обработчика выполнить событие. В платформе MVC контроллер обработчик а execute события при выполнении метода. В веб-формы страница является обработчик и выполнить событие после возникновения события Page.Init. Если более ранних, чем событие выполнения прочитать тело сущности запроса, помешать обработки запроса.

Если вам нужно прочитать тело сущности запроса, прежде чем событие выполнения, используйте либо [Request.GetBufferlessInputStream](https://msdn.microsoft.com/en-us/library/ff406798.aspx) или [Request.GetBufferedInputStream](https://msdn.microsoft.com/en-us/library/system.web.httprequest.getbufferedinputstream.aspx). При использовании GetBufferlessInputStream, вы получаете исходный поток из запроса и принимают на себя ответственность за обработку всего запроса. После вызова GetBufferlessInputStream, Request.Form и Request.InputStream недоступны, так как они не заполнены в ASP.NET. При использовании GetBufferedInputStream, можно получить копию потока из запроса. Request.Form и Request.InputStream по-прежнему доступны в запрос, так как ASP.NET заполняет другие копии.

<a id="redirect"></a>

### <a name="responseredirect-and-responseend"></a>Response.Redirect и Response.End

Рекомендация: Следует учитывать различия в обработке потока после вызова [Response.Redirect(String)](https://msdn.microsoft.com/en-us/library/t9dwyts4.aspx).

[Response.Redirect(String)](https://msdn.microsoft.com/en-us/library/t9dwyts4.aspx) метод вызывает метод Response.End. Синхронного процесса вызов Request.Redirect вызывает немедленно прерывание текущего потока. Тем не менее в асинхронном процессе, вызов Response.Redirect не будет прерываться текущего потока, поэтому выполнение кода продолжается для запроса. В асинхронном процессе необходимо вернуть задачу из метода, для остановки выполнения кода.

В проект MVC не следует вызывать Response.Redirect. Вместо этого возвращает RedirectResult.

<a id="viewstatemode"></a>

### <a name="enableviewstate-and-viewstatemode"></a>EnableViewState и ViewStateMode

Рекомендация: ViewStateMode используйте вместо EnableViewState для предоставления детальный контроль над которой элементы управления используют состояние представления.

При EnableViewState задано значение false в директиве Page, состояние просмотра отключено для всех элементов управления на странице и не может быть включен. Если вы хотите включить состояние представления только для определенных элементов управления на странице, значение Disabled ViewStateMode для страницы.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample13.aspx)]

Затем задайте ViewStateMode включена на только элементы управления, которые действительно нужны состояния представления.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample14.aspx)]

Включить состояние представления только элементов управления, которым она необходима, можно уменьшить размер состояния представления для веб-страниц.

<a id="sqlprovider"></a>

### <a name="sqlmembershipprovider"></a>SqlMembershipProvider

Рекомендация: Используйте универсальные поставщики.

В текущем шаблоны проектов, SqlMembershipProvider будет заменен [универсальные поставщики ASP.NET](http://www.nuget.org/packages/Microsoft.AspNet.Providers), который доступен как пакет NuGet. Если вы используете SqlMembershipProvider в проекте, который был создан с более ранней версией шаблонов, следует перейти к универсальные поставщики. Универсальные поставщики работают всеми базами данных, которые поддерживаются платформой Entity Framework.

Дополнительные сведения см. в разделе [введение в универсальные поставщики ASP.NET](http://www.hanselman.com/blog/IntroducingSystemWebProvidersASPNETUniversalProvidersForSessionMembershipRolesAndUserProfileOnSQLCompactAndSQLAzure.aspx).

<a id="long"></a>

### <a name="long-running-requests-110-seconds"></a>Длительные запросы (> 110 секунд)

Рекомендации: Используйте [WebSockets](https://msdn.microsoft.com/en-us/library/system.net.websockets.websocket.aspx) или [SignalR](../../../signalr/index.md) для подключенных клиентов и используйте асинхронные операции ввода-вывода.

Длительные запросы может привести к непредсказуемым результатам и снижению производительности веб-приложения. Значение по умолчанию время ожидания для запроса составляет 110 секунд. При использовании состояния сеанса с помощью запроса долго выполняющихся ASP.NET будет снимать блокировку для объекта сеанса через 110 секунд. Однако приложение может находиться в процессе операции в объекте сеанса после снятия блокировки и не может выполнить операцию. Если второй запрос от пользователя блокируется во время первого запроса, второй запрос может получить доступ к объекту сеанса в несогласованном состоянии.

Если приложение включает блокировки (или синхронный) операций ввода-вывода, приложение будет отвечать на запросы.

Чтобы повысить производительность, используйте асинхронные операции ввода-вывода в .NET Framework. Кроме того при подключении клиентов к серверу используйте WebSockets или SignalR. Эти функции предназначены для оптимально долго выполняющихся запросов.
