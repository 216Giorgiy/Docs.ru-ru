---
uid: signalr/overview/older-versions/handling-connection-lifetime-events
title: Понимание и обработка событий время существования подключения SignalR 1.x | Документы Microsoft
author: pfletcher
description: В этой статье описывается использование событий, предоставляемых API концентраторов.
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/05/2013
ms.topic: article
ms.assetid: e608e263-264d-448b-b0eb-6eeb77713b22
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/older-versions/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 4fe77769c27dd46967da2e1d68791d7142021d99
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
ms.locfileid: "28036730"
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr-1x"></a>Понимание и обработка событий время существования подключения SignalR 1.x
====================
по [Флетчера Патрик](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)

> Это статье представлен обзор событий подключение, повторное подключение и отключение SignalR, которые можно обрабатывать и параметры времени ожидания и keepalive, которые можно настроить.
> 
> Статьи предполагается, что уже имеется знание SignalR и подключение события времени жизни. Сведения о SignalR см. в разделе [SignalR - Обзор — начало работы](index.md). Списки события жизненного цикла соединения см. следующие ресурсы:
> 
> - [Как обрабатывать события времени жизни соединений в классе концентратора](index.md)
> - [Как обрабатывать события времени жизни подключений клиентов JavaScript](index.md)
> - [Как обрабатывать события времени жизни подключений клиентов .NET](index.md)


## <a name="overview"></a>Обзор

В этом разделе содержатся следующие подразделы:

- [Терминология время существования подключения и сценариев](#terminology)

    - [SignalR, транспорт, подключения и физических соединений](#signalrvstransport)
    - [Сценарии отключения транспорта](#transportdisconnect)
    - [Сценарии отключения клиентов](#clientdisconnect)
    - [Сценарии отключения сервера](#serverdisconnect)
- [Параметры времени ожидания и проверки активности](#timeoutkeepalive)

    - [ConnectionTimeout](#connectiontimeout)
    - [DisconnectTimeout](#disconnecttimeout)
    - [KeepAlive](#keepalive)
    - [Как изменить параметры времени ожидания и проверки активности](#changetimeout)
- [Уведомление пользователя о отключения](#notifydisconnect)
- [Повторное подключение постоянно](#continuousreconnect)
- [Отключение клиента в серверном коде](#disconnectclientfromserver)

Ссылки на разделы справки по API, до версии .NET 4.5 API-интерфейса. Если вы используете .NET 4, см. раздел [версии .NET 4 разделов API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a>Терминология время существования подключения и сценариев

`OnReconnected` Обработчик событий в концентратор SignalR можно выполнить непосредственно после `OnConnected` , но не в конце `OnDisconnected` для данного клиента. Причина может иметь переподключения без разрыва соединения — что можно несколькими способами, в которых слово «соединения» используется в SignalR.

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a>SignalR, транспорт, подключения и физических соединений

В этой статье будет различать *подключениями SignalR*, *транспорта подключения*, и *физических соединений*:

- **Подключения SignalR** ссылается на логическую связь между клиентом и URL-адрес сервера, поддерживаемых SignalR API и однозначно определяется идентификатор подключения. Данные об отношении обслуживается SignalR и используется для установления подключения транспорта. Элементы связи и SignalR удаляет данные при вызове клиентом `Stop` метода или ограничение времени ожидания достигается при SignalR предпринимается попытка повторно установить потеряны транспортное соединение.
- **Подключение транспорта** ссылается на логическую связь между клиентом и сервером, обслуживается одним из четырех транспорта API-интерфейсы: WebSockets события отправки сервером, непрерывно кадра или long опроса. SignalR использует транспорт API для создания подключения транспорта и API транспорта зависит от существования физического сетевого подключения для создания подключения транспорта. Транспортное соединение завершается, когда SignalR завершает его или транспорт API обнаруживает, что физическое соединение разрывается.
- **Физическое подключение** ссылается ссылки физической сети — проводов, сигнал беспроводной связи, маршрутизаторы, т. д. —, которые упрощают взаимодействие между клиентским компьютером и компьютере сервера. Для установки транспортного соединения должен присутствовать физическое соединение и необходимо установить подключение транспорта для подключения SignalR. Тем не менее критические физического соединения не ограничивается всегда следуют сразу транспортного соединения или подключения SignalR, как будет описано далее в этом разделе.

На следующей диаграмме подключения SignalR представляется API концентраторов и уровня API SignalR подключение PersistentConnection транспортное соединение представляется на уровне транспорта и физическое соединение представляется линиями между сервером и клиентами.

![Диаграмма архитектуры SignalR](handling-connection-lifetime-events/_static/image1.png)

При вызове `Start` метода в клиенте SignalR, вы предоставляете код клиента SignalR с все сведения, необходимые для выполнения физического подключения к серверу. SignalR клиентский код использует эти сведения для выполнения запроса HTTP и установить физическое соединение, в которых используется один из методов четыре транспорта. Если происходит сбой подключения транспорта или сервер выйдет из строя, подключения SignalR не исчезнуть немедленно потому, что клиент по-прежнему содержит сведения, необходимые для автоматической установки нового подключения транспорта же URL-адрес SignalR повторно. В этом случае участвует без вмешательства пользователя приложения, и, когда клиентский код SignalR устанавливает новое транспортное подключение, не запускаются новые подключения SignalR. Непрерывность подключения SignalR отражается в том, идентификатор соединения, который создается при вызове `Start` метода, не изменяется.

`OnReconnected` Обработчику событий в концентратор выполняется, когда транспортное соединение будет автоматически восстановлено после выхода из строя. `OnDisconnected` Обработчик события выполняется в конце подключения SignalR. Подключения SignalR можно завершить одним из следующих способов:

- Если клиент вызывает `Stop` метод, сообщение отправляется на сервер и клиентские и серверные подключения SignalR немедленно завершен.
- После потери связи между клиентом и сервером, клиент пытается подключиться, и сервер ожидает повторного подключения клиента. Если попытки повторного подключения не завершаются успехом, заканчивается время ожидания отключения клиента и сервера завершения подключения SignalR. Клиент не остановит повторного подключения и сервера удаляет его представление подключения SignalR.
- Если клиент прекращает работу без необходимости возможность вызова `Stop` метода ожидания сервером ответа клиента для повторного подключения, а затем завершает подключения SignalR после истечения времени ожидания отключения.
- Если сервер прекращает выполнение, клиент пытается подключиться (повторно создать транспортное соединение), а затем завершает подключения SignalR после истечения времени ожидания отключения.

Когда отсутствуют проблемы подключения и пользовательское приложение завершает подключения SignalR путем вызова `Stop` метода, подключения SignalR и подключение транспорта начинаться и завершаться в то же время. В следующих разделах описаны более подробно других сценариев.

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a>Сценарии отключения транспорта

Физические соединения может быть медленным, или может быть перерывы в связи. В зависимости от таких факторов, как длина прерывания могут отбрасываться транспортное соединение. SignalR пытается повторно установить подключение транспорта. Иногда подключение транспорта API обнаруживает прерывания и разрывает подключение транспорта и SignalR выясняется, немедленно потеряно соединение. В других сценариях ни транспортное соединение API ни SignalR виду сразу становится подключение было потеряно. Для всех транспортов за исключением долго опрашивающего клиента SignalR использует функцию с именем *keepalive* для проверки потери подключения, используемые API транспорта не удается обнаружить. Сведения о времени опроса соединениях см. в разделе [параметры времени ожидания и keepalive](#timeoutkeepalive) далее в этом разделе.

Если подключение не используется, периодически сервер отправляет пакета проверки активности клиента. Начиная с даты, который выполняется запись в этой статье частота по умолчанию — каждые 10 секунд. С помощью прослушивания для этих пакетов клиентов можно определить, существует ли проблема с подключением. Если пакета проверки активности не получено, если предполагается, что, в течение некоторого времени клиент предполагает проблем подключения, таких как низкая или перерывы в работе. Если keepalive по-прежнему не будет получено после больше времени, клиент предполагает сброс подключения, что оно начинается при попытке подключения.

На следующей схеме показана клиентские и серверные события, возникающие в типичном сценарии, если имеются проблемы с физического соединения, которые не распознаются немедленно транспортом API. Диаграммы применяется в следующих случаях:

- Транспортом является WebSockets, непрерывно кадра или событий, отправленных сервером.
- Существуют различные точки прерывания в физической сети.
- Транспорта API не распознать перерывы в работе, поэтому SignalR полагается на функции проверки активности для их обнаружения.

![Отключения транспорта](handling-connection-lifetime-events/_static/image2.png)

Если клиент переходит в режим повторного подключения, но не удалось установить транспортное соединение в течение времени ожидания отключения, сервер разрывает подключение SignalR. Когда это происходит, сервер выполняет концентратора `OnDisconnected` метод и очереди копирование сообщение об отключении отправки клиенту в случае, если клиент управляет для последующих подключений. Если клиент затем подключиться снова, он получает команды отключения и вызовы `Stop` метод. В этом сценарии `OnReconnected` не выполняется при повторном подключении клиента и `OnDisconnected` выполняется только в том случае, когда клиент вызывает `Stop`. На следующей схеме показана этот сценарий.

![Нарушений в работе транспорта - время ожидания сервера](handling-connection-lifetime-events/_static/image3.png)

Ниже перечислены события времени жизни подключения SignalR, которые могут возникать на клиенте.

- `ConnectionSlow`событие клиента.

    Вызывается, когда предустановленную долю истечения времени ожидания проверки активности прошел с момента последнего сообщения или keepalive ping было получено. По умолчанию keepalive предупреждение время ожидания составляет 2/3 времени ожидания проверки активности. Время ожидания проверки активности-20 секунд, поэтому предупреждение возникает в около 13 секунд.

    По умолчанию сервер отправляет пакеты проверки активности каждые 10 секунд, а клиент проверяет наличие связи keepalive о каждые 2 секунды (трети разница между значением времени ожидания проверки активности и предупреждение значение времени ожидания проверки активности).

    В случае разрыва соединения учитывать транспорта API SignalR может информировать о отключении перед передачей предупреждение время ожидания проверки активности. В этом случае `ConnectionSlow` событие не будет вызываться и SignalR перейдет непосредственно `Reconnecting` событий.
- `Reconnecting`событие клиента.

    Вызывается, когда (a) транспорта API обнаруживает соединение потеряно, или (б) время ожидания проверки активности прошел с момента последнего сообщения или получено keepalive ping. Код клиента SignalR начинает повторного подключения. Это событие можно обработать, если требуется приложению использовать какие-либо действия при потере соединения транспорта. В настоящее время, время ожидания проверки активности по умолчанию — 20 секунд.

    Если код клиента пытается выполнить вызов метода концентратора во режим повторного подключения SignalR, SignalR будет пытаться отправить команду. В большинстве случаев, такие попытки завершаются ошибкой, но в некоторых случаях они может завершиться успешно. Для событий, отправляемых сервером, непрерывно кадра и долго опрашивающий транспорт SignalR использует два канала связи, используемый клиентом для отправки сообщений и который используется для получения сообщений. Канал, используемый для получения используется постоянно открытыми, а также, является тот, который будет закрыт, когда прерывается физического соединения. Канал, используемый для отправки остается доступной, поэтому восстанавливается физическое подключение, вызов метода от клиента к серверу может иметь успешно до получения канала будет восстановлено. Возвращаемое значение будет не получено, пока SignalR повторно открывает канал для приема.
- `Reconnected`событие клиента.

    Вызывается при повторном подключении транспорта. `OnReconnected` Выполняется в обработчике событий в концентратор.
- `Closed`событие клиента (`disconnected` событий на языке JavaScript).

    Вызывается, когда истекает время ожидания отключения SignalR код клиента пытается восстановить после потери подключения транспорта. Значение по умолчанию отключить время ожидания составляет 30 секунд. (Это событие также возникает при завершении подключения, так как `Stop` вызывается метод.)

Нарушения подключения транспорта, которые не определяются транспортом API и не отложить прием пакеты проверки активности на сервере дольше, чем период предупреждение времени ожидания проверки активности не может привести любые соединения, время существования события.

Некоторых сетевых средах намеренно закройте неактивных соединений, а другую функцию пакеты проверки активности — помочь избежать этого, позволяя этих сетей означает, что подключения SignalR используется. В крайних случаях частотой по умолчанию keepalive связи может оказаться недостаточно для предотвращения закрытые соединения. В этом случае можно настроить пакеты проверки активности отправляемых чаще. Дополнительные сведения см. в разделе [параметры времени ожидания и keepalive](#timeoutkeepalive) далее в этом разделе.

> [!NOTE] 
> 
> [!IMPORTANT]
> Последовательность событий, описанные здесь не гарантируется. SignalR делает все возможное для вызова события времени жизни соединений предсказуемым образом в соответствии с этой схемы, но существует много разновидностей события сети и многими способами, в которых их обработки базовой платформы связи, например транспорта API-интерфейсы. Например `Reconnected` событие не может быть вызвано при повторном подключении клиента или `OnConnected` обработчик на сервере может выполняться, если попытка соединения завершается неудачно. В этом разделе описывает только результатов, которые обычно будут получены, определенных в обычных условиях.


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a>Сценарии отключения клиентов

В клиенте браузера код клиента SignalR, который будет поддерживать соединение SignalR выполняется в контексте JavaScript веб-страницы. Имеет почему подключения SignalR имеет конечную при переходе из одной страницы на другой, а вот почему имеется несколько подключений с нескольких идентификаторов подключений при подключении из несколько окон браузера или вкладок. Когда пользователь закрывает окно или вкладка, или переход на новую страницу или обновляет страницу, подключения SignalR сразу же завершается, так как клиентский код SignalR обрабатывает это событие браузера для вас и вызовы `Stop` метод. В этих сценариях или в любой клиентской платформе, когда приложение вызывает `Stop` метода `OnDisconnected` обработчик событий будет выполнено немедленно на сервере и вызывает клиент `Closed` событий (событие называется `disconnected` в JavaScript).

Если клиентское приложение или компьютер, на котором он выполняется на аварийно завершает работу, или переходит в спящий режим (например, когда пользователь закрывает ноутбука), сервер не получает уведомления о том, что произошло. Как сервер знал, потери клиента возможно из-за прерывания подключений и клиент может попытаться повторно подключиться. Таким образом, в этих сценариях сервер ожидает, чтобы дать возможность повторного подключения, клиент и `OnDisconnected` не выполняется, пока не истечет время ожидания отключения (около 30 секунд по умолчанию). На следующей схеме показана этот сценарий.

![Сбой клиентского компьютера](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a>Сценарии отключения сервера

Когда сервер переходит в автономный режим — он перезагрузки, происходит сбой, домен приложения по графику, т. д. — результаты могут быть аналогично потерянного подключения или транспорта API и SignalR может немедленно узнать отсутствует сервер и SignalR, может начинаться без повторного подключения вызов `ConnectionSlow` событий. Если клиент переходит в режим повторного подключения и восстанавливает сервер или перезапуска или новый сервер переводится в оперативный режим, прежде чем истечет время ожидания отключения, клиент будет повторно подключиться к серверу восстановленным или новым. В этом случае подключения SignalR продолжается на клиенте и `Reconnected` события. На первом сервере `OnDisconnected` никогда не выполняется и на новом сервере `OnReconnected` выполняется несмотря на то что `OnConnected` не была выполнена на этом сервере до этого клиента. (Действует так же при повторном подключении клиента к тому же серверу после очистки домена приложения или перезагрузки, так как при перезапуске сервера, он имеет память действия предыдущего подключения.) Следующая диаграмма предполагает, что транспорта API узнает о потере подключения немедленно, поэтому `ConnectionSlow` событие не происходит.

![Сбой сервера и повторное подключение](handling-connection-lifetime-events/_static/image5.png)

Если сервер не становятся доступными в течение периода ожидания отключения, завершении подключения SignalR. В этом сценарии `Closed` событий (`disconnected` в клиентов JavaScript) возникает на стороне клиента, но `OnDisconnected` никогда не будет вызван на сервере. Следующая схема предполагается, что транспорта API не получают сведения о потере подключения, определяемого функциональность keepalive SignalR и `ConnectionSlow` события.

![Сбой сервера и время ожидания](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a>Параметры времени ожидания и проверки активности

Значение по умолчанию `ConnectionTimeout`, `DisconnectTimeout`, и `KeepAlive` значения подходят для большинства сценариев, но можно изменить, если в вашей среде имеется особых требований. Например сетевой среды закрывает подключений, которые простаивают в течение 5 секунд, возможно уменьшить значение keepalive.

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a>ConnectionTimeout

Этот параметр представляет количество времени, чтобы оставить транспортное соединение открыто и ожидает ответа перед его закрытия и открытия нового соединения. Значение по умолчанию — 110 секунд.

Этот параметр применяется только при keepalive отключается функциональность, которая обычно применяется только к длинных опрашивающий транспорт. На следующей схеме показано влияние этого параметра на long опроса транспортное соединение.

![Длинная опросе подключения транспорта](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a>DisconnectTimeout

Этот параметр представляет время ожидания после потери транспортного соединения перед порождением `Disconnected` событий. Значение по умолчанию - 30 секунды. При задании `DisconnectTimeout`, `KeepAlive` автоматически устанавливается значение 1/3 `DisconnectTimeout` значение.

<a id="keepalive"></a>

### <a name="keepalive"></a>KeepAlive

Этот параметр представляет время ожидания перед отправкой пакета проверки активности через бездействующее подключение. Значение по умолчанию — 10 секунд. Это значение должно быть не более 1/3 `DisconnectTimeout` значение.

Если вы хотите установить оба `DisconnectTimeout` и `KeepAlive`, задайте `KeepAlive` после `DisconnectTimeout`. В противном случае ваш `KeepAlive` параметр будет перезаписан при `DisconnectTimeout` автоматически задает `KeepAlive` 1/3 значение времени ожидания.

Если вы хотите отключить функции keepalive, задайте `KeepAlive` значение null. KeepAlive функции автоматически отключаются в случае долго опрашивающий транспорт.

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a>Как изменить параметры времени ожидания и проверки активности

Чтобы изменить значения по умолчанию для этих параметров, установите их `Application_Start` в ваш *Global.asax* файла, как показано в следующем примере. В образце кода значения совпадают значения по умолчанию.

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a>Уведомление пользователя о отключения

В некоторых приложениях может потребоваться отображать сообщение для пользователя, при наличии проблем с подключением. У вас есть несколько вариантов как и когда это сделать. В следующих примерах кода предназначены для клиента с помощью созданного прокси JavaScript.

- Обрабатывать `connectionSlow` событий для отображения сообщения, как только SignalR учитывает проблем с подключением, прежде чем он переходит в режим повторного подключения.

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- Обрабатывать `reconnecting` событий для отображения сообщения, когда SignalR известно об отключении и переходит в режим повторного подключения.

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- Обрабатывать `disconnected` событий будет отображать сообщение при попытке повторного подключения истекло. В этом сценарии единственным способом, чтобы заново установить соединение с сервером снова является перезапустите подключения SignalR, вызвав `Start` метод, который будет создан новый идентификатор подключения. В следующем образце кода используют флаг, чтобы убедиться, выдается уведомление только после тайм-аута новом подключении не после нормальным завершением для подключения SignalR, вызвать `Stop` метод.

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a>Повторное подключение постоянно

В некоторых приложениях может потребоваться автоматически повторно установить соединение после его потеряно, истекло время ожидания попытки повторного подключения. Чтобы сделать это, можно вызвать `Start` метода из вашего `Closed` обработчик событий (`disconnected` обработчику событий в JavaScript клиентов). Может потребоваться подождать в течение заданного времени перед вызовом `Start` во избежание этого слишком часто при сервера или физического соединения недоступны. Следующий пример кода предназначен для клиента с помощью созданного прокси JavaScript.

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

О потенциальной проблеме, которые следует учитывать в мобильных клиентов — попыток непрерывного повторного соединения, если недоступен сервер или физическое соединение может привести к стока ненужные батареи.

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a>Отключение клиента в серверном коде

SignalR версии 1.1.1 не имеет встроенных API сервера для с отключением клиентов. Существуют [планы для добавления этой функции в будущем](https://github.com/SignalR/SignalR/issues/2101). В текущем выпуске SignalR для отключения клиента от сервера проще реализовать метод отключения на клиенте, а затем вызывайте этот метод с сервера. В следующем образце кода показан метод disconnect для клиента с помощью созданного прокси JavaScript.

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> Безопасность — ни этот метод для отключения клиентов, ни предложенный встроенных API, поможет решить сценария взломанных клиентов, работающих под управлением вредоносного кода, так как клиенты могут повторно установить соединение или взломанных кода может привести к удалению `stopClient` метода или измените действие. Это лучшее место для реализации с отслеживанием состояния защиты типа "отказ в обслуживании" (DOS) — не в платформу или на уровне сервера, а также в интерфейсном инфраструктуры.
