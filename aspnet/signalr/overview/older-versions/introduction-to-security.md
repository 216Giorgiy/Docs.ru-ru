---
uid: signalr/overview/older-versions/introduction-to-security
title: Общие сведения о безопасности SignalR (SignalR 1.x) | Документы Microsoft
author: pfletcher
description: Описывает вопросы безопасности, которые следует учитывать при разработке приложения SignalR.
ms.author: aspnetcontent
manager: wpickett
ms.date: 10/17/2013
ms.topic: article
ms.assetid: 715a4059-d307-4631-abbb-c789c95d6eb4
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/older-versions/introduction-to-security
msc.type: authoredcontent
ms.openlocfilehash: b756d3e71d89b6c826bd497f73d052c4c8f634e8
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
---
<a name="introduction-to-signalr-security-signalr-1x"></a>Общие сведения о безопасности SignalR (SignalR 1.x)
====================
по [Флетчера Патрик](https://github.com/pfletcher), [Tom FitzMacken](https://github.com/tfitzmac)

> В этой статье описаны вопросы безопасности, которые следует учитывать при разработке приложения SignalR.


## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Основные понятия безопасности SignalR](#concepts)

    - [Проверка подлинности и авторизация](#authentication)
    - [Маркер подключения](#connectiontoken)
    - [Если повторное подключение, повторное присоединение групп](#rejoingroup)
- [Как SignalR предотвращает межсайтовой подделки запроса](#csrf)
- [Рекомендации по обеспечению безопасности SignalR](#recommendations)

    - [Безопасный протокол слои сокетов (SSL)](#ssl)
    - [Не используйте группы в качестве механизма обеспечения безопасности](#groupsecurity)
    - [Безопасно обработки входные данные от клиентов](#input)
    - [Согласование изменений в состояние пользователей с активным соединением](#reconcile)
    - [Автоматически созданные файлы JavaScript прокси-сервера](#autogen)
    - [Исключения](#exceptions)

<a id="concepts"></a>

## <a name="signalr-security-concepts"></a>Основные понятия безопасности SignalR

<a id="authentication"></a>

### <a name="authentication-and-authorization"></a>Аутентификация и авторизация

SignalR предназначен для интеграции в существующую структуру проверки подлинности для приложения. Он не предоставляет функций для проверки подлинности пользователей. Вместо этого можно проверять подлинность пользователей, как обычно в приложении и затем работать с результатами проверки подлинности в коде SignalR. Например может проверять подлинность пользователей с помощью проверки подлинности форм ASP.NET и на концентраторе, принудительно применить пользователей, которые или ролей авторизованы для вызова метода. На концентраторе можно также передать данные проверки подлинности, такие как имя пользователя или принадлежности пользователя к роли, для клиента.

SignalR обеспечивает [авторизовать](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.authorizeattribute(v=vs.111).aspx) атрибут, чтобы указать, какие пользователи имеют доступ к концентратору или метода. К концентратору или отдельные методы в концентраторе применить атрибут Authorize. Без атрибута авторизовать все открытые методы концентратора доступны для клиента, который подключен к концентратору. Дополнительные сведения о концентраторах см. в разделе [проверки подлинности и авторизации для концентраторов SignalR](../security/hub-authorization.md).

`Authorize` Атрибут используется только с концентраторами. Для применения правила авторизации при использовании `PersistentConnection` необходимо переопределить `AuthorizeRequest` метод. Дополнительные сведения о постоянные подключения см. в разделе [проверки подлинности и авторизации для постоянного подключения SignalR](../security/persistent-connection-authorization.md).

<a id="connectiontoken"></a>

### <a name="connection-token"></a>Маркер подключения

SignalR уменьшает риск выполнения вредоносных команд путем проверки подлинности источника. Маркер подключения, содержащая идентификатор подключения и имя пользователя для прошедших проверку пользователей передаются между клиентом и сервером для каждого запроса. Идентификатор подключения — это уникальный идентификатор, который формируется сервером случайным образом, если создается новое соединение и сохраняется в течение всего соединения. Имя пользователя предоставляется с помощью механизма проверки подлинности для веб-приложения. Маркер подключения защищен с помощью шифрования и цифровой подписи.

![](introduction-to-security/_static/image2.png)

Для каждого запроса сервер проверяет содержимое маркера, убедитесь что запрос поступает из указанного пользователя. Имя пользователя должно соответствовать идентификатор подключения. Проверив идентификатор подключения и имя пользователя, SignalR мешает злоумышленникам легко олицетворение другого пользователя. Если сервер не удается проверить маркер подключения, запрос завершается ошибкой.

![](introduction-to-security/_static/image4.png)

Так как идентификатор подключения является частью процесса проверки, не следует раскрывать один пользователь идентификатор подключения для других пользователей или сохраняет значение на клиенте, например, в файле cookie.

<a id="rejoingroup"></a>

### <a name="rejoining-groups-when-reconnecting"></a>Если повторное подключение, повторное присоединение групп

По умолчанию SignalR приложение будет автоматически повторно назначить пользователя в соответствующие группы при повторном подключении от временного прерывания, таких как после удалены и повторно установить подключение времени ожидания соединения. При повторном подключении, клиент передает токен группы, который включает идентификатор соединения и назначенной группы. Токен группы цифровой подписывается и шифруется. Клиент сохраняет тот же идентификатор соединения после повторного подключения; Таким образом идентификатор соединения, переданные от повторного подключения клиента должен соответствовать предыдущих идентификатор соединения, используемый клиентом. Такая проверка предотвращает злонамеренный пользователь передача запросы на присоединение несанкционированного групп при повторном подключении.

Однако важно отметить, маркер группы не истек. Если пользователь принадлежал к группе в прошлом, но был заблокированный из этой группы, этот пользователь может быть возможность имитировать группы маркер, который содержит запрещенные группы. Если необходимо безопасно управлять какие пользователи являются членами групп, которые необходимо сохранять данные на сервере, например, в базе данных. Затем добавьте логику для приложения, который проверяет на сервере, является ли пользователь принадлежит к группе. Пример проверка членства в группе см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

Автоматическое повторное присоединение групп применяется только после повторного подключения после временному перерыву в предоставлении. Если пользователь отключает по покидая приложение или повторного запуска приложения, приложения должны обрабатывать как добавить этого пользователя в требуемые группы. Дополнительные сведения см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="csrf"></a>

## <a name="how-signalr-prevents-cross-site-request-forgery"></a>Как SignalR предотвращает межсайтовой подделки запроса

Подделки межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос уязвимым сайта, где пользователь вошел в данный момент в. SignalR предотвращает CSRF, делая крайне маловероятно, что для вредоносный сайт для создания запроса на допустимый для приложения SignalR.

### <a name="description-of-csrf-attack"></a>Описание атаки CSRF

Ниже приведен пример атаки CSRF:

1. Пользователь входит в www.example.com, с помощью форм проверки подлинности.
2. Сервер проверяет подлинность пользователя. Ответ от сервера включает файл cookie проверки подлинности.
3. Не выходя из пользователь посещает вредоносный веб-узел. Этот вредоносный сайт содержит следующие HTML-формы: 

    [!code-html[Main](introduction-to-security/samples/sample1.html)]

   Обратите внимание, что действие формы в блогах уязвимым сайте, не вредоносный сайт. Это часть CSRF «между сайтами».
4. При нажатии кнопки "Отправить". Браузер включает файл cookie проверки подлинности с запросом.
5. Запрос выполняется на сервере example.com с контекстом проверки подлинности пользователя и могут выполнять все, что разрешено делать прошедшего проверку подлинности пользователя.

Несмотря на то, что в этом примере требует от пользователя, нажмите кнопку «форма», страницу вредоносных удалось так же, как легко запускать сценарий, который отправляет запрос AJAX в приложение SignalR. Кроме того с помощью протокола SSL не запрещает атаки CSRF, так как вредоносный сайт можно отправить запрос «https://».

Как правило атаки CSRF для веб-сайтов, которые используют файлы cookie для проверки подлинности, так как браузеры отправляют все соответствующие файлы cookie в веб-узел назначения. Тем не менее атаки CSRF ограничены не использовать файлы cookie. Например Basic и дайджест-проверки подлинности также уязвимы. После входа пользователя в систему с обычная или краткая проверка подлинности браузер автоматически отправляет учетные данные до завершения сеанса.

### <a name="csrf-mitigations-taken-by-signalr"></a>Возможные способы устранения CSRF выполняемое SignalR

SignalR принимает следующие шаги, чтобы предотвратить создание допустимых запросов к приложению SignalR вредоносный сайт. Эти шаги взяты по умолчанию и не требуют никаких действий, в коде.

- **Отключение запросов между доменами**  
 По умолчанию междоменные запросы отключены в приложении SignalR, чтобы запретить пользователям вызов конечной точки SignalR из внешнего домена. Все запросы, поступающие из внешнего домена автоматически считается недействительным и будет заблокирован. Рекомендуется оставить поведение по умолчанию; в противном случае вредоносный сайт может обманом заставить пользователей отправки команд на узел. Если необходимо использовать междоменные запросы, см. раздел [как для установления соединения между доменами](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain) .
- **Передать маркер подключения в строке запроса, а не файл cookie**  
 SignalR передает маркер подключения как значение строки запроса, а не как файл cookie. Не сохраняя маркер подключения в качестве файла cookie, маркер подключения не пересылаются случайно браузером при обнаружении вредоносных программ. Кроме того маркер подключения не сохраняется вне текущего соединения. Таким образом пользователь-злоумышленник не может сделать запрос под учетными данными другого пользователя.
- **Проверьте маркер подключения**  
 Как описано в [маркер подключения](#connectiontoken) раздел сервер знает, какой идентификатор соединения связан с каждого проверенного пользователя. Сервер не обрабатывает все запросы от идентификатор соединения, который не соответствует имени пользователя. Маловероятно, пользователь-злоумышленник может узнать допустимый запрос, так как пользователь-злоумышленник нужно знать имя пользователя и идентификатор текущего подключения формируется случайным образом. Этот идентификатор соединения становится недействительным, сразу после завершения соединения. Анонимных пользователей нет доступа к конфиденциальным сведениям.

<a id="recommendations"></a>

## <a name="signalr-security-recommendations"></a>Рекомендации по обеспечению безопасности SignalR

<a id="ssl"></a>

### <a name="secure-socket-layers-ssl-protocol"></a>Безопасный протокол слои сокетов (SSL)

Протокол SSL использует шифрование для защиты передачи данных между клиентом и сервером. Если приложение SignalR передает конфиденциальные данные между клиентом и сервером, использование протокола SSL для транспорта. Дополнительные сведения о настройке SSL см. в разделе [настройке SSL в службах IIS 7](https://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis).

<a id="groupsecurity"></a>

### <a name="do-not-use-groups-as-a-security-mechanism"></a>Не используйте группы в качестве механизма обеспечения безопасности

Группы представляют собой удобный способ сбора связанных пользователей, но они не являются безопасный механизм для ограничения доступа к конфиденциальной информации. Это особенно важно в тех случаях, когда пользователи могут автоматически повторно присоединиться к группам во время переподключения. Вместо этого рассмотрите возможность добавления привилегированных пользователей к роли и ограничение доступа к метода концентратора, чтобы только члены этой роли. Пример ограничения доступа на основе роли см. в разделе [проверки подлинности и авторизации для концентраторов SignalR](../security/hub-authorization.md). Пример проверки доступа пользователей к группам, при повторном подключении см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="input"></a>

### <a name="safely-handling-input-from-clients"></a>Безопасно обработки входные данные от клиентов

Все входные данные от клиентов, предназначенной для широковещательной рассылки для других клиентов должны быть закодированы, чтобы убедиться, что пользователь-злоумышленник не отправляет скрипт другим пользователям. Проще всего для кодирования сообщений в принимающее клиентов, а не на сервере, так как приложение SignalR может иметь много различных клиентов. Таким образом HTML-кодирование работает для веб-клиента, но не для других типов клиентов. Например, веб-метода клиента для отображения сообщения чата будет безопасно обрабатывать имя пользователя и сообщение путем вызова `html()` функции.

[!code-html[Main](introduction-to-security/samples/sample2.html?highlight=3-4)]

<a id="reconcile"></a>

### <a name="reconciling-a-change-in-user-status-with-an-active-connection"></a>Согласование изменений в состояние пользователей с активным соединением

Если состояние проверки подлинности пользователя, изменяет время существования активного соединения, пользователь получит сообщение об ошибке, «идентификатор пользователя невозможно изменить во время активного подключения SignalR». В этом случае приложение должно повторного подключения к серверу, чтобы убедиться в том, что идентификатор соединения и имени пользователя будут соответствовать друг другу. Например если приложение позволяет пользователю выйти из системы, пока существует активное соединение, пользователя для соединения больше не будет соответствовать имени, переданный для следующего запроса. Будет остановить соединения, прежде чем пользователь выходит из системы и перезапустите ее.

Однако важно отметить, что большинство приложений не потребуется вручную остановить и запустить подключение. Если приложение перенаправляет пользователей на отдельную страницу после входа, такие как поведение по умолчанию в MVC-приложений или приложений веб-форм или обновляет текущую страницу после выхода, активное подключение будет автоматически отключен и не делает требуются какие-либо действия.

В следующем примере показано, как остановить и запустить подключение при изменении состояния пользователя.

[!code-html[Main](introduction-to-security/samples/sample3.html)]

Или состояние проверки подлинности пользователя может измениться, если веб-сайт использует скользящий срок действия с помощью форм и активности, не следует допустимый файл cookie проверки подлинности. В этом случае пользователь будет иметь вышел из системы и имя пользователя больше не будет соответствовать имени пользователя в маркер подключения. Эту неполадку можно устранить путем добавления определенный скрипт, который периодически запрашивает ресурс на веб-сервере, чтобы сохранить допустимый файл cookie проверки подлинности. В следующем примере показано, как для запроса ресурса каждые 30 минут.

[!code-javascript[Main](introduction-to-security/samples/sample4.js)]

<a id="autogen"></a>

### <a name="automatically-generated-javascript-proxy-files"></a>Автоматически созданные файлы JavaScript прокси-сервера

Если вы не хотите включать все концентраторам и методам в файле JavaScript прокси-сервера для каждого пользователя, можно отключить автоматическое создание файла. Можно выбрать этот параметр, если имеется несколько концентраторов и методов, но не выполнять каждого пользователя, которые следует учитывать все методы. Отключить автоматическое создание, задав **EnableJavaScriptProxies** для **false**.

[!code-csharp[Main](introduction-to-security/samples/sample5.cs)]

Дополнительные сведения о файлах прокси JavaScript см. в разделе [созданный прокси и делает за вас](../guide-to-the-api/hubs-api-guide-javascript-client.md#genproxy). <a id="exceptions"></a>

### <a name="exceptions"></a>Исключения

Следует избегать передача объектов исключений для клиентов, так как объекты могут передавать важные данные для клиентов. Вместо этого необходимо вызовите метод на стороне клиента, отображается соответствующее сообщение об ошибке.

[!code-csharp[Main](introduction-to-security/samples/sample6.cs)]
