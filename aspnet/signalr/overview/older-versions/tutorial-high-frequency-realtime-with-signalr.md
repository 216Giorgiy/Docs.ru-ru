---
uid: signalr/overview/older-versions/tutorial-high-frequency-realtime-with-signalr
title: "Высокая частота в реальном времени с SignalR 1.x | Документы Microsoft"
author: pfletcher
description: "Этот учебник показывает, как создание веб-приложения, использующего ASP.NET SignalR для предоставления функций обмена сообщениями с высокой частотой. Высокочастотные обмена сообщениями в..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 04/16/2013
ms.topic: article
ms.assetid: ad2a5da5-2e79-40ea-bc84-028d327f5982
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/older-versions/tutorial-high-frequency-realtime-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 0c680a7d8b911b2734647948b683d5ff6e47aec4
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="high-frequency-realtime-with-signalr-1x"></a>Высокая частота в реальном времени с SignalR 1.x
====================
по [Патрик Флетчера](https://github.com/pfletcher)

> Этот учебник показывает, как создание веб-приложения, использующего ASP.NET SignalR для предоставления функций обмена сообщениями с высокой частотой. Высокая частота обмена сообщениями в данном случае означает обновления, которые отправляются по фиксированной ставке; в случае использования этого приложения до 10 сообщений за секунду.
> 
> Приложение, которое вы создадите в этом учебнике показывает фигуру, пользователи могут перетаскивать. Положение фигуры во всех браузерах подключенных будут обновлены в соответствии положение перетаскиваемого фигуры с помощью синхронизированного обновления.
> 
> Концепции, реализованные в этом учебнике у приложений в игры в режиме реального времени и других приложений моделирования.
> 
> Комментарии в этом учебнике приветствуются. Если у вас есть вопросы, которые не связаны непосредственно для работы с учебником, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com).


## <a name="overview"></a>Обзор

Демонстрирует создание приложения, совместно с другими браузерами, в режиме реального времени состояние объекта. Приложение, которое мы создадим называется MoveShape. На MoveShape странице будет показан элемент Div в HTML, в котором пользователь может перетаскивать; Когда пользователь перетаскивает элемент Div, новое положение будут отправляться на сервер, который затем сообщает о других подключенных клиентов для обновления фигуры позиции для сопоставления.

![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image1.png)

Приложение, созданное в этом учебнике основан на демонстрацию — Дэмьен эвардс. Видео, содержащий этой демонстрации можно увидеть [здесь](https://channel9.msdn.com/Series/Building-Web-Apps-with-ASP-NET-Jump-Start/Building-Web-Apps-with-ASPNET-Jump-Start-08-Real-time-Communication-with-SignalR).

Учебник для начала необходимо демонстрации для отправки сообщений SignalR из каждого события, которое возникает при перетаскивании фигуры. Каждый подключенный клиент обновит позицию локальная версия фигуры при каждом получении сообщения.

Хотя приложение будет работать с помощью этого метода, это не является рекомендуемые модель программирования, поскольку будет верхний предел на число получение отправленных сообщений, поэтому клиенты и сервер может получить перегружены большим количеством сообщений, и может привести к снижению производительности . Отображаемые анимации на стороне клиента также будут несвязанном, как форма будет перенесено мгновенно для каждого метода, а не скользящего плавно в каждое новое расположение. В последующих подразделах учебника показано, как создать функцию таймера, который ограничивает максимальной скорости, с которой сообщения отправляются с сервера или клиента и перемещении фигуры плавно между расположениями. Окончательная версия приложения, созданного в этом учебнике можно загрузить с [коллекции кода](https://code.msdn.microsoft.com/SignalR-MoveShape-demo-3366dac6).

Этот учебник содержит следующие разделы:

- [Необходимые компоненты](#prerequisites)
- [Создание проекта](#createtheproject)
- [Добавление пакетов ASP.NET SignalR и JQuery.UI NuGet](#nugetpackages)
- [Создание базового приложения](#baseapp)
- [Добавить цикл клиента](#clientloop)
- [Добавить цикл сервера](#serverloop)
- [Добавление анимации на стороне клиента](#animation)
- [Дальнейшие действия](#furthersteps)

<a id="prerequisites"></a>

## <a name="prerequisites"></a>Предварительные требования

Этот учебник требуется Visual Studio 2012 или Visual Studio 2010. Если используется Visual Studio 2010, проект будет использовать .NET Framework 4, а не в .NET Framework 4.5.

Если вы используете Visual Studio 2012, рекомендуется установить [обновление ASP.NET и 2012.2 средства Web](https://go.microsoft.com/fwlink/?LinkId=282650). Это обновление содержит новые функции, например усовершенствования публикации новых функциональных возможностей и новые шаблоны.

При наличии Visual Studio 2010, убедитесь, что [NuGet](https://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c) установлен.

<a id="createtheproject"></a>

## <a name="create-the-project"></a>Создание проекта

В этом разделе мы создадим проект в Visual Studio.

1. Из **файл** меню **новый проект**.
2. В **новый проект** диалогового окна разверните **C#** под **шаблоны** и выберите **Web**.
3. Выберите **пустое веб-приложение ASP.NET** шаблона, имя проекта *MoveShapeDemo*и нажмите кнопку **ОК**.

    ![Создание нового проекта](tutorial-high-frequency-realtime-with-signalr/_static/image2.png)

<a id="nugetpackages"></a>

## <a name="add-the-signalr-and-jqueryui-nuget-packages"></a>Добавление пакетов JQuery.UI NuGet и SignalR

SignalR функции можно добавить в проект, установка пакета NuGet. Этот учебник также можно использовать пакет JQuery.UI разрешающим фигуры перетащить и анимации.

1. Нажмите кнопку **инструменты | Диспетчер пакетов библиотеки | Консоль диспетчера пакетов**.
2. Введите следующую команду в диспетчер пакетов.

    [!code-powershell[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample1.ps1)]

    Пакет SignalR устанавливает ряд других пакетах NuGet в качестве зависимостей. После завершения установки у вас все серверные и клиентские компоненты, необходимые для использования в приложении ASP.NET SignalR.
3. Введите следующую команду в консоли диспетчера пакетов для установки пакетов JQuery и JQuery.UI.

    [!code-powershell[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample2.ps1)]

<a id="baseapp"></a>

## <a name="create-the-base-application"></a>Создание базового приложения

В этом разделе мы создадим приложение браузера, которое отправляет расположение формы на сервер во время каждого события перемещения мыши. Сервер затем осуществляет широковещательную рассылку эту информацию для всех остальных подключенных клиентов при его получении. Мы будем разверните в это приложение, в последующих разделах.

1. В **обозревателе решений**, щелкните правой кнопкой мыши проект и выберите **добавить**, **класса...** . Имя класса **MoveShapeHub** и нажмите кнопку **добавить**.
2. Замените код в новом **MoveShapeHub** класса следующим кодом.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample3.cs)]

    `MoveShapeHub` Выше класс представляет собой реализацию концентратора SignalR. Как и в [Приступая к работе с SignalR](index.md) учебнике концентратора содержит метод, который клиенты будут вызывать напрямую. В этом случае клиент передает объект, содержащий новый координаты X и Y фигуры на сервер, затем возвращает широковещательной рассылки для всех остальных подключенных клиентов. SignalR будет автоматически сериализации этого объекта с помощью JSON.

    Объект, который отправляется клиентам (`ShapeModel`) содержит члены для хранения позиции фигуры. Версия объекта на сервере также содержит элемент для отслеживания хранится какие клиентские данные, чтобы данного клиента не будет отправлять свои собственные данные. Этот член использует `JsonIgnore` атрибут для предотвращения сериализации и отправляются на клиент.
3. Далее мы составим концентратора при запуске приложения. В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **добавить | Глобального класса приложения**. Примите имя по умолчанию *Global* и нажмите кнопку **ОК**.

    ![Добавление глобального класса приложения](tutorial-high-frequency-realtime-with-signalr/_static/image3.png)
4. Добавьте следующие `using` инструкции после указанных **с помощью** операторов в классе Global.asax.cs.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample4.cs)]
5. Добавьте следующую строку кода в `Application_Start` метод глобального класса, чтобы зарегистрировать маршрут по умолчанию для SignalR.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample5.cs)]

    Файл global.asax должен выглядеть следующим образом:

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample6.cs)]
6. Далее мы добавим в клиент. В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **добавить | Новый элемент**. В **Добавление нового элемента** диалогового окна выберите **HTML-страницу**. Присвойте странице соответствующее имя (например **Default.html**) и нажмите кнопку **добавить**.
7. В **обозревателе решений**, щелкните правой кнопкой мыши только что созданный страницы и нажмите кнопку **задать в качестве начальной страницы**.
8. Замените код по умолчанию в HTML-страницу с помощью следующего фрагмента кода.

    > [!NOTE]
    > Проверьте, скрипт ссылается ниже соответствия пакеты, добавлены в проект в папку «скрипты». В Visual Studio 2010 версии JQuery и добавлена в проект SignalR может не соответствовать указанные номера версий.

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample7.html)]

    Приведенный выше код HTML и JavaScript создает красный Div вызывается фигуры, включает режим перетаскивания фигуры, с помощью библиотеки jQuery и использует фигуры `drag` событий для отправки на сервер положения фигуры.
9. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image4.png)

<a id="clientloop"></a>

## <a name="add-the-client-loop"></a>Добавить цикл клиента

С момента отправки расположение фигуры на каждого события перемещения мыши создаст лишние объем сетевого трафика, сообщения от клиента должны регулироваться. Мы будем использовать javascript `setInterval` функции, чтобы настроить цикл, который отправляет на сервер по фиксированной ставке новые сведения о положении. Этот цикл является очень простым представлением цикла «игры», многократно вызываемой функции, вызывающее все функциональные возможности, игры или других моделирования.

1. Обновите код клиента в HTML-страницу для сопоставления в следующем фрагменте кода.

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample8.html)]

    Добавляет выше обновления `updateServerModel` функции, которая вызывается на фиксированной частотой. Эта функция отправляет данные положения на сервер при каждом `moved` флаг указывает, что новые данные позиции для отправки.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера. Поскольку будет регулировать количество сообщений, отправляемых на сервер, анимации не будут отображаться как smooth, как в предыдущем разделе.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image5.png)

<a id="serverloop"></a>

## <a name="add-the-server-loop"></a>Добавить цикл сервера

В текущем приложении сообщения, отправленные сервером клиенту начнутся так часто, как их получения. Это представляет подобную проблему, как была обнаружена на клиенте; сообщения могут отправляться чаще, чем они нужны, и соединение может стать переполняющее в результате. В этом разделе описывается обновление сервера для реализации таймер, который регулирует количество исходящих сообщений.

1. Замените содержимое `MoveShapeHub.cs` с помощью следующего фрагмента кода.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample9.cs)]

    Приведенный выше код при развертывании клиента для добавления `Broadcaster` класс, который регулирует исходящих сообщений с помощью `Timer` класса из платформы .NET framework.

    Поскольку концентратора, сам является временной (он создается каждый раз при необходимости), `Broadcaster` будет создана как Singleton-классом. Чтобы отложить ее создания, время, необходимое, убедившись, что первый экземпляр концентратора полностью создан, до запуска таймера используется отложенная инициализация (появился в .NET 4).

    Вызов клиентов `UpdateShape` функция затем перемещается за пределы концентратора `UpdateModel` метода, так что он больше не вызывается немедленно в том случае, когда получения входящих сообщений. Вместо этого будут отправляться сообщения для клиентов со скоростью 25 вызовов в секунду, управляется `_broadcastLoop` таймера изнутри `Broadcaster` класса.

    Наконец, вместо вызова метода клиента от концентратора напрямую, `Broadcaster` классу необходимо получить ссылку на момент работы концентратора (`_hubContext`) с помощью `GlobalHost`.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера. Не будет видимым разницу в браузере из предыдущего раздела, но число сообщений, отправляемых клиенту будет возвращена.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image6.png)

<a id="animation"></a>

## <a name="add-smooth-animation-on-the-client"></a>Добавление анимации на стороне клиента

Приложение практически завершена, но можно сделать один Дополнительные улучшения, движущихся фигуры на стороне клиента при их перемещении в ответ на сообщения сервера. Вместо задания положения фигуры в новое расположение, заданный сервером, мы будем использовать библиотеку JQuery UI `animate` function для перемещения фигуры плавно между его текущим и новым положение.

1. Обновление клиента `updateShape` метод для поиска, такие как выделенный код ниже:

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample10.html?highlight=35-42)]

    Приведенный выше код перемещает фигуры из старого расположения в новую, заданный сервером в течение интервала анимации (в данном случае 100 миллисекунд). Все предыдущие анимацию на фигуре очищается перед запуском новой анимацией.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера. Перемещение фигуры в другом окне должен появиться менее рывками, как ее движение интерполируются по времени, а не устанавливается один раз на входящее сообщение.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image7.png)

<a id="furthersteps"></a>

## <a name="further-steps"></a>Дальнейшие действия

В этом учебнике вы узнали, как запрограммировать приложение SignalR, которое отправляет сообщения с высокой частотой между клиентами и серверами. Этого принципа взаимодействия помогает при разработке играх и других моделей, таких как [ShootR игры, созданных с помощью SignalR](http://shootr.signalr.net).

Полное приложение, созданной в этом учебнике можно загрузить из [коллекции кода](https://code.msdn.microsoft.com/SignalR-MoveShape-demo-3366dac6).

Дополнительные сведения об основных понятиях разработки SignalR, посетите следующие сайты для SignalR исходный код и ресурсы:

- [Проект SignalR](http://signalr.net)
- [SignalR Github и образцы](https://github.com/SignalR/SignalR)
- [Вики-сайте SignalR](https://github.com/SignalR/SignalR/wiki)
