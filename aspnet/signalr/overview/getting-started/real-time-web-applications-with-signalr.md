---
uid: signalr/overview/getting-started/real-time-web-applications-with-signalr
title: 'Практическое лабораторное занятие: В режиме реального времени веб-приложений с помощью SignalR | Документы Microsoft'
author: rick-anderson
description: Возможности передачи содержимого для подключенных клиентов, как это происходит в режиме реального времени серверных возможностей, в реальном времени веб-приложений. Для разработчиков ASP.NET, ASP...
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/16/2014
ms.topic: article
ms.assetid: ba07958c-42e1-4da0-81db-ba6925ed6db0
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/getting-started/real-time-web-applications-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 5a2bc120ded18ad2302fd6c5cde65a5323e86ca8
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30878052"
---
<a name="hands-on-lab-real-time-web-applications-with-signalr"></a>Практическое лабораторное занятие: В режиме реального времени веб-приложений с помощью SignalR
====================
По [Web лагеря команды](https://twitter.com/webcamps)

[Загрузите комплект учебных материалов лагеря Web](http://aka.ms/webcamps-training-kit)

> Возможности передачи содержимого для подключенных клиентов, как это происходит в режиме реального времени серверных возможностей, в реальном времени веб-приложений. Для разработчиков ASP.NET **ASP.NET SignalR** — это библиотека для добавления в реальном времени веб-функций в свои приложения. Она использует несколько транспортных протоколов, автоматический выбор клиента и сервера лучше всего транспортировки лучше всего доступных транспорта. Она позволяет воспользоваться **WebSocket**, HTML5 API, который обеспечивает двунаправленный обмен данными между браузером и сервером.
> 
> **SignalR** также предоставляет простое, высокоуровневое API для выполнения сервера до клиента RPC (вызывают функции JavaScript в браузерах клиентов из кода .NET на стороне сервера) в приложении ASP.NET, а также добавление полезные обработчики для управления подключениями как отключить или подключить события, группирования подключений и авторизации.
> 
> **SignalR** — это абстракция над некоторые транспорты, которые необходимы для выполнения работы в режиме реального времени между клиентом и сервером. Объект **SignalR** соединение для запуска в качестве HTTP, а затем повышается до **WebSocket** соединения, если он доступен. **WebSocket** является идеальным транспортом для **SignalR**, поскольку оно обеспечивает наиболее эффективное использование памяти сервера с минимальной задержкой, и имеет наиболее функциональным возможностям (например полную дуплексную связь между клиентом и сервер), но также имеет самым строгим требованиям: **WebSocket** требуется, чтобы использовать сервер **Windows Server 2012** или **Windows 8**, вместе с **.NET framework 4.5**. Если эти требования не выполнены, **SignalR** будет предпринята попытка использовать другие транспорты, чтобы сделать его подключения (например *Ajax продолжительный опрос*).
> 
> **SignalR** API содержит две модели для обмена данными между клиентами и серверами: **постоянные подключения** и **концентраторов**. Объект **подключения** представляет простой конечную точку для отправки одного получателя, группирования или широковещательной передачи сообщений. Объект **концентратора** является более высокого уровня конвейера построено подключение API, который позволяет клиенту и серверу прямого вызова методов друг от друга.
> 
> ![Архитектура SignalR](real-time-web-applications-with-signalr/_static/image1.png)
> 
> Все образцы кода и фрагменты кода включаются в Web лагеря комплект учебных материалов, доступных в [ http://aka.ms/webcamps-training-kit ](http://aka.ms/webcamps-training-kit).


<a id="Overview"></a>
## <a name="overview"></a>Обзор

<a id="Objectives"></a>
### <a name="objectives"></a>Цели

В этой практической вы узнаете, как:

- Отправьте уведомления от сервера к клиенту с использованием SignalR.
- Масштабирования приложений SignalR с помощью **SQL Server**.

<a id="Prerequisites"></a>
### <a name="prerequisites"></a>Предварительные требования

Для завершения этой практической требуется следующее:

- [Visual Studio Express 2013 для Web](https://www.microsoft.com/visualstudio/) или выше

<a id="Setup"></a>
### <a name="setup"></a>Установка

Чтобы выполнить упражнения в этой практической, необходимо настроить среду.

1. Откройте окно проводника Windows и перейдите в лаборатории **источника** папки.
2. Щелкните правой кнопкой мыши **Setup.cmd** и выберите **Запуск от имени администратора** для запуска процесса установки, будет настроить среду и установить фрагменты кода Visual Studio для этой лабораторной работы.
3. Если отображается диалоговое окно контроля учетных записей, подтвердите действие для продолжения.

> [!NOTE]
> Убедитесь, что все зависимости для этой лабораторной работы вы вернули перед запуском программы установки.


<a id="CodeSnippets"></a>
### <a name="using-the-code-snippets"></a>Фрагменты кода

В документе лаборатории будет предложено вставлять блоки кода. Visual Studio к фрагментам кода, к которому можно получить из в Visual Studio 2013, чтобы избежать необходимости вручную добавить большая часть кода предоставляется для удобства.

> [!NOTE]
> Каждого упражнения сопровождается начальный решений, расположенный в **начать** папку расчетов, позволяющий выполнить каждого упражнения независимо от других. Имейте в виду, что фрагменты кода, которые добавляются во время упражнения, отсутствуют на их запуск решения и могут не работать до завершения этого упражнения. В исходном коде для упражнения, вы также найдете **окончания** папку, содержащую решение Visual Studio с кодом, полученный в результате выполнения действий в соответствующий упражнении. Эти решения можно использовать как рекомендации, если вам нужна дополнительная помощь, отвечая на этой практической.


* * *

<a id="Exercises"></a>
## <a name="exercises"></a>Упражнения

Данная практическая работа включает следующие упражнения:

1. [Работа с данными в режиме реального времени, с использованием SignalR](#Exercise1)
2. [Масштабное развертывание с помощью SQL Server](#Exercise2)

Предполагаемое время для выполнения этого занятия: **60 минут**

> [!NOTE]
> При первом запуске Visual Studio, необходимо выбрать одну из коллекций предварительно определенных параметров. Каждая предопределенная коллекция соответствует конкретному стилю разработки и определяет макетов окон, поведение редактора, фрагменты кода IntelliSense и параметры диалогового окна. В этой лаборатории описаны действия, необходимые для выполнения данной задачи в Visual Studio при использовании **обычные параметры разработки** коллекции. При выборе другого набора параметров для среды разработки может быть отличия в этапах, которые следует принимать во внимание.


<a id="Exercise1"></a>
### <a name="exercise-1-working-with-real-time-data-using-signalr"></a>Упражнение 1: Работа с данными в режиме реального времени, используя SignalR

Во время разговора часто используется в качестве примера, можно сделать всего дополнительные с веб-функций, в режиме реального времени. Каждый раз, пользователь обновляет веб-страницы для просмотра новых данных или реализует страница Ajax продолжительный опрос для получения новых данных можно использовать SignalR.

Поддерживает SignalR **принудительной сервера** или **широковещательной передачи** функциональные возможности; он автоматически выполняет управление соединениями. В классическом HTTP-соединений для соединения клиент сервер подключение будет восстановлено, для каждого запроса, но SignalR обеспечивает постоянное подключение между клиентом и сервером. В SignalR, который вызывает серверный код в клиентский код в браузере, с помощью удаленный вызов процедур (RPC) а не модели запрос ответ мы знаем, сегодня.

В этом упражнении вы настроите **компьютерный фанат тест** приложения для использования SignalR для отображения панели мониторинга статистики с обновленной метрики без необходимости обновления всей страницы.

<a id="Ex1Task1"></a>
#### <a name="task-1--exploring-the-geek-quiz-statistics-page"></a>Задача 1 – изучение странице компьютерный фанат головоломки статистики

В этой задаче будет проходить через приложения, а также проверить, как отображаются страницы статистики и как можно улучшить работу сведения обновляется.

1. Откройте **Visual Studio Express 2013 для Web** и откройте **GeekQuiz.sln** решение находится в **Source\Ex1 WorkingWithRealTimeData\Begin** папки.
2. Нажмите клавишу **F5** для запуска решения. **Входа** страница должна выглядеть в браузере.

    ![Запуск решения](real-time-web-applications-with-signalr/_static/image2.png "запуск решения")

    *Запуск решения*
3. Нажмите кнопку **зарегистрировать** в правом верхнем углу страницы, чтобы создать нового пользователя в приложении.

    ![Зарегистрировать ссылку](real-time-web-applications-with-signalr/_static/image3.png "регистр связи")

    *Регистр связи*
4. В **зарегистрировать** введите **имя пользователя** и **пароль**, а затем нажмите кнопку **зарегистрировать**.

    ![Регистрация пользователя](real-time-web-applications-with-signalr/_static/image4.png "Регистрация пользователя")

    *Регистрация пользователя*
5. Приложение регистрирует новую учетную запись, и пользователь проверку подлинности и перенаправляется обратно на домашней странице отображаются первый вопрос головоломки.
6. Откройте **статистики** страницы в новом окне и поместить **Главная** страницы и **статистики** страницы side-by-side.

    ![Windows Side-by-side](real-time-web-applications-with-signalr/_static/image5.png "рядом стороне windows")

    *Windows Side-by-side*
7. В **Главная** страницы, ответить на вопрос, щелкнув один из вариантов.

    ![Ответить на вопрос о](real-time-web-applications-with-signalr/_static/image6.png "ответы на вопросы")

    *Ответы на вопросы*
8. Щелкните одну из кнопок и появится ответ.

    ![На вопрос правильный](real-time-web-applications-with-signalr/_static/image7.png "правильный вопрос")

    *Ответ на вопрос*
9. Обратите внимание, что информация, содержащаяся в странице статистики устаревшим. Обновите страницу для просмотра обновленных результатов.

    ![Страница статистики](real-time-web-applications-with-signalr/_static/image8.png "страница статистики")

    *Страница статистики*
10. Вернитесь в Visual Studio и остановить отладку.

<a id="Ex1Task2"></a>
#### <a name="task-2--adding-signalr-to-geek-quiz-to-show-online-charts"></a>Задача 2 – Добавление SignalR для компьютерный фанат тест, чтобы показать сети диаграммы

В этой задаче будет добавить в решение SignalR и автоматически отправлять обновления клиентов, когда новый ответ отправляется на сервер.

1. Из **средства** в Visual Studio, выберите пункт меню **диспетчер пакетов библиотеки**, а затем нажмите кнопку **консоль диспетчера пакетов**.
2. В **консоль диспетчера пакетов** окно, выполните следующую команду:

    [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample1.ps1)]

    ![Установка пакета SignalR](real-time-web-applications-with-signalr/_static/image9.png "SignalR установки пакета")

    *Установка пакета SignalR*

   > [!NOTE]
   > При установке **SignalR** NuGet пакеты версии 2.0.2 из нового приложения MVC 5, необходимо будет вручную обновить **OWIN** пакетов версию 2.0.1 (или более поздней версии) перед установкой SignalR. Чтобы сделать это, можно выполнить следующий сценарий в **консоль диспетчера пакетов**:
   > 
   > [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample2.ps1)]
   > 
   > В следующем выпуске SignalR OWIN зависимости автоматически обновляется.
3. В **обозревателе решений**, разверните **сценариев** папки и обратите внимание, SignalR *js* файлы были добавлены в решение.

    ![SignalR JavaScript ссылается на](real-time-web-applications-with-signalr/_static/image10.png "SignalR JavaScript ссылается на")

    *Ссылки на SignalR JavaScript*
4. В **обозревателе решений**, щелкните правой кнопкой мыши **GeekQuiz** проекта, выберите **добавить** | **новую папку**и назовите его  **Концентраторы**.
5. Щелкните правой кнопкой мыши **концентраторов** папку и выберите **добавить | Новый элемент**.

    ![Добавить новый элемент](real-time-web-applications-with-signalr/_static/image11.png "добавить новый элемент")

    *Добавление нового элемента*
6. В **Добавление нового элемента** выберите **Visual C# | Web | SignalR** узел в левой области выберите **класс концентратора SignalR (v2)** из центральной области, назовите файл **StatisticsHub.cs** и нажмите кнопку **добавить**.

    ![Добавление нового элемента диалогового](real-time-web-applications-with-signalr/_static/image12.png "добавить новый элемент диалоговое окно «»")

    *Добавить новый элемент-диалоговое окно*
7. Замените код в **StatisticsHub** класса следующим кодом.

    (Фрагмент - кода *StatisticsHubClass RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample3.cs)]
8. Откройте **файла Startup.cs** и добавьте следующую строку в конце **конфигурации** метод.

    (Фрагмент - кода *MapSignalR RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample4.cs)]
9. Откройте **StatisticsService.cs** страницы внутри **служб** папки и добавьте следующие директивы using.

    (Фрагмент - кода *UsingDirectives RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample5.cs)]
10. Чтобы уведомить подключенных клиентов обновлений, сначала нужно получить **контекста** объект для текущего соединения. **Концентратора** объект содержит методы для отправки сообщений для одного клиента или широковещательной рассылки для всех подключенных клиентов. Добавьте следующий метод **StatisticsService** класс рассылка статистических данных.

    (Фрагмент - кода *NotifyUpdatesMethod RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample6.cs)]

    > [!NOTE]
    > В приведенном выше коде используется имя произвольного метод для вызова функции на стороне клиента (т. е.: *updateStatistics*). Имя метода, указываемое интерпретируется как динамический объект, это означает, что нет IntelliSense или проверки во время компиляции для него. Выражение вычисляется во время выполнения. Когда выполняется вызов метода, SignalR отправляет клиенту имя метода и значения параметров. Если у клиента есть метод, который совпадает с именем, что вызывается метод и значения параметров передаются в него. При обнаружении на стороне клиента нет соответствующего метода ошибка не возникает. Дополнительные сведения см. в [концентраторов API ASP.NET SignalR руководство](../guide-to-the-api/hubs-api-guide-server.md).
11. Откройте **TriviaController.cs** страницы внутри **контроллеров** папки и добавьте следующие директивы using.

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample7.cs)]
12. Добавьте следующий выделенный код в **Post** метода действия.

    (Фрагмент - кода *NotifyUpdatesCall RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample8.cs)]
13. Откройте **Statistics.cshtml** страницы внутри **представления | Главная** папки. Найдите **сценариев** статьи и добавьте следующие ссылки на скрипты в начале раздела.

    (Фрагмент - кода *SignalRScriptReferences RealTimeSignalR - сервера Ex1 -*)

    [!code-cshtml[Main](real-time-web-applications-with-signalr/samples/sample9.cshtml)]

    > [!NOTE]
    > При добавлении SignalR и другие библиотеки скриптов в проект Visual Studio, диспетчер пакетов может установить версию файла сценария SignalR, который имеет более новую версию, приведенные в этом разделе. Убедитесь, что ссылку на скрипт в коде соответствует версии библиотеки скриптов, установленные в проекте.
14. Добавьте следующий выделенный код для подключения клиента к концентратору SignalR и обновления статистических данных, при получении нового сообщения от концентратора.

    (Фрагмент - кода *SignalRClientCode RealTimeSignalR - сервера Ex1 -*)

    [!code-cshtml[Main](real-time-web-applications-with-signalr/samples/sample10.cshtml)]

    В этом коде создав класс-посредник концентратора и регистрации обработчика событий для прослушивания сообщений, отправленных сервером. В этом случае прослушивать сообщения, проходящие через *updateStatistics* метод.

<a id="Ex1Task3"></a>
#### <a name="task-3--running-the-solution"></a>Задача 3 – Запуск решения

В этой задаче будет запустите решение, чтобы убедиться, что представление Статистика обновляется автоматически после ответа на свой вопрос, используя SignalR.

1. Нажмите клавишу **F5** для запуска решения.

    > [!NOTE]
    > Если еще не вошли в приложение, войдите в систему пользователя, который был создан в задаче 1.
2. Откройте **статистики** страницы в новом окне и поместить **Главная** страницы и **статистики** страницы side-by-side, как это было сделано в задаче 1.
3. В **Главная** страницы, ответить на вопрос, щелкнув один из вариантов.

    ![Ответы на другой вопрос](real-time-web-applications-with-signalr/_static/image13.png "ответа на другой вопрос")

    *Ответы на другой вопрос*
4. Щелкните одну из кнопок и появится ответ. Обратите внимание, что статистические данные на странице обновляется автоматически после ответа на вопрос обновленной информации без необходимости обновления всей страницы.

    ![Обновление статистики страницы после ответов](real-time-web-applications-with-signalr/_static/image14.png "обновление статистики страницы после ответов")

    *Страницы статистические данные обновляются после ответов*

<a id="Exercise2"></a>
### <a name="exercise-2-scaling-out-using-sql-server"></a>Упражнение 2: Масштабирование с помощью SQL Server

При масштабировании веб-приложения, обычно можно между *вертикальное масштабирование* и *масштабирование* параметры. *Вертикальное масштабирование* означает использование более мощный сервер с большим объемом ресурсов (ЦП, оперативной памяти, т. д.) при *горизонтальное масштабирование* означает добавлены дополнительные серверы, чтобы справиться с нагрузкой. Проблема с второе —, клиенты могут получить направлено на разных серверах. Клиент, который подключен к одному серверу, не получат сообщения, отправленные с другого сервера.

Эти проблемы можно решить с помощью компонентом, называется *объединительной платы*, для передачи сообщений между серверами. В объединительной панели включен каждый экземпляр приложения отправляет сообщения объединительной плате, а объединительной плате пересылает их на другие экземпляры приложения.

В настоящее время существует три типа соединительных панелях для SignalR.

- **Windows Azure Service Bus**. Шина обслуживания является инфраструктуры обмена сообщениями, который позволяет отправлять сообщения слабосвязанных с компонентами.
- **SQL Server**. На задней стороне SQL Server записывает сообщения таблиц SQL. Задняя панель для эффективного обмена сообщениями с компонентом Service Broker. Однако она также работает, если не включен компонент Service Broker.
- **Redis**. Redis представляет хранилищу ключей и значений в памяти. Redis поддерживает шаблон публикации подписки («pub/sub») для отправки сообщений.

Каждое сообщение отправляется через канал сообщений. Реализует канал сообщений [IMessageBus](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.messaging.imessagebus(v=vs.100).aspx) интерфейс, который предоставляет абстракцию публикации или подписки. Соединительных панелях работы, заменив значение по умолчанию **IMessageBus** с шиной, предназначенный для этого объединительной платы.

Каждый экземпляр сервера подключается через шину объединительной плате. При отправке сообщения, он переходит объединительной платы и объединительной плате отправляет его на каждый сервер. Когда сервер получает сообщение от объединительной платы, она хранит сообщения в локальный кэш. Затем сервер доставляет сообщения клиентам из своего локального кэша.

Дополнительные сведения о принципах работы на задней стороне SignalR, см. в этой [статьи](../performance/scaleout-in-signalr.md).

> [!NOTE]
> Существуют некоторые сценарии, где объединительной платы могут стать узким местом. Ниже приведены некоторые стандартные сценарии, SignalR.
> 
> - [Рассылка сервера](tutorial-server-broadcast-with-signalr.md) (например, биржевые сводки): соединительных панелях хорошо подходят для этого сценария server контролирует скорость, с которой сообщения отправляются.
> - [Клиент клиент](tutorial-getting-started-with-signalr.md) (например, чат): В этом случае объединительной платы могут быть узким местом, если количество сообщений, масштабируется по числу клиентов, то есть если растет число сообщений, пропорционально как Дополнительные клиенты присоединяются.
> - [В реальном времени высокой частотой](tutorial-high-frequency-realtime-with-signalr.md) (например, в режиме реального времени игры): объединительной платы не рекомендуется для этого сценария.


В этом упражнении вы воспользуетесь **SQL Server** для распределения сообщений между **компьютерный фанат тест** приложения. Следует выполнять эти задачи на один тестовый компьютер, чтобы узнать, как настроить конфигурацию, но чтобы получить результат, необходимо развернуть приложение SignalR на несколько серверов. Также необходимо установить SQL Server на одном из серверов или на отдельном выделенном сервере.

![Горизонтальное масштабирование с помощью схемы SQL Server](real-time-web-applications-with-signalr/_static/image15.png)

<a id="Ex2Task1"></a>
#### <a name="task-1---understanding-the-scenario"></a>Задача 1. основные сведения о сценарии

В этой задаче вы выполните 2 экземпляров **компьютерный фанат тест** имитация IIS нескольких экземпляров на локальном компьютере. В этом сценарии для ответов на вопросы trivia одного приложения обновления не будут высылаться уведомления на странице статистики второго экземпляра. Эмуляция напоминает среде, где приложение развертывается на нескольких экземплярах и взаимодействовать с ними с помощью подсистемы балансировки нагрузки.

1. Откройте **Begin.sln** решение находится в **источника/Ex2-ScalingOutWithSQLServer/начало** папки. После загрузки, обратите внимание на **обозревателя серверов** , решение содержит два проекта с одинаковыми структурами но разные имена. Это имитирует с двумя запущенными экземплярами того же приложения на локальном компьютере.

    ![Начать решение имитация двух экземпляров головоломки компьютерный фанат](real-time-web-applications-with-signalr/_static/image16.png "начать решение имитация двух экземпляров компьютерный фанат головоломки")

    *Начать решение имитация двух экземпляров компьютерный фанат головоломки*
2. Откройте страницу свойств решения, щелкнув правой кнопкой мыши узел решения и выбрав **свойства**. В разделе **запускаемый проект**выберите **несколько запускаемых проектов** и измените **действия** значение для обоих проектов для *запустить*.

    ![Запуск нескольких проектов](real-time-web-applications-with-signalr/_static/image17.png "запуск нескольких проектов")

    *Запуск нескольких проектов*
3. Нажмите клавишу **F5** для запуска решения. Приложение будет запущено два экземпляра **компьютерный фанат тест** в разные порты имитация несколько экземпляров одного приложения. ПИН-код одного из браузеров слева, а другой — в правой части экрана. Войти с использованием учетных данных или регистрации нового пользователя. После входа хранить на одной странице слева и перейдите к **статистики** страницу в браузере справа.

    ![Компьютерный фанат головоломки рядом](real-time-web-applications-with-signalr/_static/image18.png)

    *Компьютерный фанат головоломки рядом*

    ![Компьютерный фанат головоломка в разные порты](real-time-web-applications-with-signalr/_static/image19.png)

    *Компьютерный фанат головоломка в разные порты*
4. Запустить отвечая на вопросы в левой браузера, и можно будет заметить, что **статистики** страницу в браузере вправо не обновляется. Это вызвано **SignalR** использует локальный кэш для распределения сообщений между клиентами и этот сценарий имитирует несколько экземпляров, поэтому кэш не используется совместно между ними. Можно убедиться, что **SignalR** работы за счет тестировании те же действия, но с помощью одного приложения. В следующих задачах вы настроите объединительной платы для репликации сообщений между экземплярами.
5. Вернитесь в Visual Studio и остановить отладку.

<a id="Ex2Task2"></a>
#### <a name="task-2--creating-the-sql-server-backplane"></a>Задача 2 – Создание на задней стороне SQL Server

В этой задаче вы создадите базы данных, которая будет использоваться в качестве объединительной платы для **компьютерный фанат тест** приложения. Вы воспользуетесь **обозреватель объектов SQL Server** Обзор сервера и инициализировать базу данных. Кроме того, вы включите **компонента Service Broker**.

1. В **Visual Studio**, откройте меню **представление** и выберите **обозреватель объектов SQL Server**.
2. Подключиться к своему экземпляру LocalDB, щелкнув правой кнопкой мыши **SQL Server** узла и выбрав **добавить SQL Server...**  параметр.

    ![Добавление экземпляра SQL Server](real-time-web-applications-with-signalr/_static/image20.png "Добавление экземпляра SQL Server")

    *Добавление экземпляра SQL Server в обозревателе объектов SQL Server*
3. Задать **имя сервера** для *(localdb) \v11.0* и оставить **проверки подлинности Windows** как свой режим проверки подлинности. Нажмите кнопку **Connect** для продолжения.

    ![Подключение к LocalDB](real-time-web-applications-with-signalr/_static/image21.png "подключение к LocalDB")

    *Подключение к LocalDB*
4. Теперь, когда вы подключены к своему экземпляру LocalDB, необходимо будет создать базу данных, представляющий на задней стороне SQL Server для SignalR. Для этого щелкните правой кнопкой мыши **баз данных** , а затем выберите **добавить новую базу данных**.

    ![Добавление новой базы данных](real-time-web-applications-with-signalr/_static/image22.png "Добавление новой базы данных")

    *Добавление новой базы данных*
5. Задайте имя базы данных *SignalR* и нажмите кнопку **ОК** для его создания.

    ![Создание базы данных SignalR](real-time-web-applications-with-signalr/_static/image23.png "Создание базы данных SignalR")

    *Создание базы данных SignalR*

    > [!NOTE]
    > Можно выбрать любое имя для базы данных.
6. Более эффективно получать обновления от объединительной платы, рекомендуется включить компонент Service Broker для базы данных. Компонент Service Broker обеспечивает собственную поддержку для обмена сообщениями и очередей в SQL Server. Задняя панель также работает без компонента Service Broker. Открытие нового запроса, щелкнув правой кнопкой мыши базу данных и выберите **новый запрос**.

    ![Открытие нового запроса](real-time-web-applications-with-signalr/_static/image24.png "Открытие нового запроса")

    *Открытие нового запроса*
7. Чтобы проверить, включен ли компонент Service Broker, запрос **—\_broker\_включен** столбца в **sys.databases** представления каталога. Выполните следующий скрипт в окне недавно открывавшихся запроса.

    [!code-sql[Main](real-time-web-applications-with-signalr/samples/sample11.sql)]

    ![Запрос состояния компонента Broker Service](real-time-web-applications-with-signalr/_static/image25.png "запросе состояния службы брокера")

    *Запрос состояния брокера службы*
8. Если значение **—\_broker\_включен** столбец базы данных является &quot;0&quot;, используйте следующую команду, чтобы включить его. Замените **&lt;базы данных ВАШЕГО&gt;** с именем, заданным при создании базы данных (например: SignalR).

    [!code-sql[Main](real-time-web-applications-with-signalr/samples/sample12.sql)]

    ![Включение компонента Service Broker](real-time-web-applications-with-signalr/_static/image26.png "активации компонента Service Broker")

    *Включение компонента Service Broker*

    > [!NOTE]
    > Если взаимоблокировка, убедитесь, что этот запрос нет приложений, подключенных к базе данных.

<a id="Ex2Task3"></a>
#### <a name="task-3--configuring-the-signalr-application"></a>Задача 3 – Настройка приложения SignalR

В этой задаче вы настроите **компьютерный фанат тест** для подключения к SQL Server объединительной плате. Сначала вы добавите **SignalR.SqlServer** пакета NuGet и задайте соединение строка объединительной платы базы данных.

1. Откройте **консоль диспетчера пакетов** из **средства** | **диспетчер пакетов библиотеки**. Убедитесь, что **GeekQuiz** проект выбран в **проекта по умолчанию** раскрывающегося списка. Введите следующую команду, чтобы установить **Microsoft.AspNet.SignalR.SqlServer** пакет NuGet.

    [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample13.ps1)]
2. Повторите предыдущий шаг, но это время для проекта **GeekQuiz2**.
3. Чтобы настроить на задней стороне SQL Server, откройте **файла Startup.cs** файл **GeekQuiz** проекта и добавьте следующий код в **Настройка** метод. Замените **&lt;базы данных ВАШЕГО&gt;** именем вашей базы данных, используемый при создании на задней стороне SQL Server. Повторите этот шаг для **GeekQuiz2** проекта.

    (Фрагмент - кода *StartupConfiguration RealTimeSignalR - Ex2 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample14.cs)]
4. Теперь, когда оба проекта настроены для использования на задней стороне SQL Server, нажмите клавишу **F5** одновременно запустить.
5. Опять же **Visual Studio** будет запустите два экземпляра **компьютерный фанат тест** в разные порты. Одно из браузеров закрепить слева, а другой — в правой части экрана и войти с использованием учетных данных. Оставить страницу Trivia в левой части экрана и перейдите к **статистики** pagein вправо браузера.
6. Запустите ответы на вопросы в левой браузера. На этот раз **статистики** страница обновляется благодаря объединительной плате. Переключение между приложениями (**статистики** теперь находится в левой части экрана и **Trivia** находится справа) и повторить тест для проверки работоспособности для обоих экземпляров. Служит в качестве объединительной платы *общего кэша* сообщений для каждого подключенного сервера и каждого сервера будет сообщения можно хранить в собственный локальный кэш для распределения подключенных клиентов.
7. Вернитесь в Visual Studio и остановить отладку.
8. Задняя панель компонент SQL Server автоматически создает необходимые таблицы в указанной базе данных. В **обозреватель объектов SQL Server** панели, откройте базу данных, созданную объединительной платы (например: SignalR) и разверните его таблиц. Вы увидите следующие таблицы:

    ![Задняя панель созданные таблицы](real-time-web-applications-with-signalr/_static/image27.png)

    *Задняя панель созданные таблицы*
9. Щелкните правой кнопкой мыши **SignalR.Messages\_0** таблицы и выберите **данные представления**.

    ![Просмотр таблицы сообщения объединительной платы SignalR](real-time-web-applications-with-signalr/_static/image28.png)

    *Просмотр таблицы сообщения объединительной платы SignalR*
10. Вы увидите различные сообщения, отправленные **концентратора** для ответов на вопросы trivia. Задняя панель распространяет эти сообщения для любого подключенного экземпляра.

    ![Таблица объединительной платы сообщений](real-time-web-applications-with-signalr/_static/image29.png)

    *Таблица объединительной платы сообщений*

* * *

<a id="Summary"></a>
## <a name="summary"></a>Сводка

В этой практической вы узнали, как добавить **SignalR** для вашего приложения и отправки уведомлений с сервера подключенных клиентов с помощью **концентраторов**. Кроме того, вы узнали, как масштабировать приложение с помощью *объединительной платы* компонента, когда приложение развертывается на нескольких экземплярах служб IIS.
