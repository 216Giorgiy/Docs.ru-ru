---
uid: signalr/overview/getting-started/introduction-to-signalr
title: Общие сведения о SignalR | Документы Microsoft
author: pfletcher
description: В этой статье описывается SignalR и некоторые решения, для которого она была разработана для создания.
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 0ceca3edc26d35b1155946e60863a84da0bbe592
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
---
<a name="introduction-to-signalr"></a>Общие сведения о SignalR
====================
по [Патрик Флетчера](https://github.com/pfletcher)

> В этой статье описывается SignalR и некоторые решения, для которого она была разработана для создания. 
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте отзыв на том, как вам понравилось этого учебника и что можно улучшить в комментарии в нижней части страницы. Если у вас есть вопросы, которые не связаны непосредственно для работы с учебником, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).


## <a name="what-is-signalr"></a>Что такое SignalR

ASP.NET SignalR представляет собой библиотеку для разработчиков в среде ASP.NET, который упрощает процесс добавления в реальном времени веб-функций для приложений. В режиме реального времени веб-функций является возможность принудительной кода сервера содержимого с мгновенно предоставлять подключенным клиентам, как они станут доступны, а не сервере ожидания клиента на прием новых данных.

SignalR можно использовать для добавления каких-либо «в режиме реального времени» веб-функций для приложения ASP.NET. Во время разговора часто используется в качестве примера, можно сделать гораздо более. Каждый раз, когда пользователь обновляет веб-страницы для просмотра новых данных или реализует страницы [долго опрашивающего](http://en.wikipedia.org/wiki/Push_technology#Long_polling) для получения новых данных, он является кандидатом для использования SignalR. Примеры включают панели мониторинга и мониторинга приложений, совместной работы приложения (такие как одновременное изменение документов) и для задания сведений о ходе выполнения формы в режиме реального времени.

SignalR также позволяет полностью новые типы веб-приложений, требующих высокой частотой обновления с сервера, например, в режиме реального времени игры.

SignalR обеспечивает простой API-Интерфейс для создания клиента server удаленных вызовов процедур (RPC), вызывающие функции JavaScript в клиентских браузерах (и других клиентских платформ) из кода .NET на стороне сервера. SignalR также включает API для управления подключениями (например, подключаться и отключаться событий) и группировки подключений.

![Вызов методов с SignalR](introduction-to-signalr/_static/image1.png)

SignalR автоматически выполняет управление соединениями и позволяет широковещательных сообщений для всех подключенных клиентов одновременно, например чата. Также можно отправлять сообщения для конкретных клиентов. Соединение между клиентом и сервером является постоянным, в отличие от классической подключение HTTP, оно снова устанавливается для каждой связи.

SignalR поддерживает функции «принудительной отправки с сервера», в котором серверный код может выполнить вызов клиентского кода в браузере, используя удаленный вызов процедур (RPC), а не привычную модель запрос ответ сегодня в Интернете.

SignalR приложения можно масштабировать до тысяч клиентов с помощью Service Bus, SQL Server или [Redis](http://redis.io).

SignalR открытым исходным кодом, доступная с помощью [GitHub](https://github.com/signalr).

## <a name="signalr-and-websocket"></a>SignalR и WebSocket

SignalR использует новый транспорт WebSocket, если они доступны и возвращается к старой транспортов при необходимости. Хотя определенно можно написать приложение непосредственно с помощью WebSocket, с помощью SignalR означает, что множество дополнительных функциональных возможностей, которые необходимо реализовать будет уже быть сделано автоматически. Самое главное это значит, можно создать приложение, чтобы воспользоваться преимуществами WebSocket не нужно беспокоиться о создании путь отдельный код для старых клиентов. SignalR также скрывает от вас не беспокоиться об изменениях в WebSocket, поскольку SignalR будут обновлены для поддержки изменений в используемому транспорту предоставления согласованного интерфейса приложения во всех версиях WebSocket.

Хотя определенно для создания решения с использованием только WebSocket, SignalR предоставляет все функциональные возможности, необходимо написать самостоятельно, например для других транспортов или обновление приложения для обновления реализаций WebSocket.

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a>Транспортные протоколы и в случае ошибки

SignalR — это абстракция над некоторые транспорты, которые необходимы для выполнения работы в режиме реального времени между клиентом и сервером. Подключения SignalR запускается как HTTP и затем повышен до соединения WebSocket, если он доступен. WebSocket находится идеальный транспорта для SignalR, так как он делает наиболее эффективное использование памяти сервера, имеет наименьшую задержку и наиболее базовых компонентов (например, полную дуплексную связь между клиентом и сервером), но также имеет самые строгие требования требования: WebSocket требуется, чтобы использовать Windows Server 2012 или Windows 8 и .NET Framework 4.5 сервер. Если эти требования не выполнены, SignalR попытается использовать другие транспорты, чтобы сделать его подключения.

### <a name="html-5-transports"></a>Транспортов HTML 5

Эти транспорты зависит от поддержки для [HTML 5](http://en.wikipedia.org/wiki/HTML5). Если браузер клиента не поддерживает стандарт HTML 5, будет использоваться старые транспорты.

- **WebSocket** (если сервер и браузер указывают, они могут поддерживать Websocket). WebSocket находится только транспорта, который устанавливает значение true, постоянного двусторонние подключения между клиентом и сервером. Тем не менее также имеет WebSocket самым строгим требованиям; полностью поддерживается только в последних версиях Microsoft Internet Explorer, Mozilla Firefox и Google Chrome и имеет только частичная реализация в других браузерах, таких как Opera и Safari.
- **События отправки сервером**, также называемой EventSource (если браузер поддерживает отправки событий сервера, который представляет собой все браузеры, за исключением того, Internet Explorer.)

### <a name="comet-transports"></a>Кометы транспортов

На основе следующих транспортов [комета](http://en.wikipedia.org/wiki/Comet_(programming)) модели веб-приложения, в котором браузер или другой клиент поддерживает запрос HTTP долго удерживается, что сервер может использовать для отправки данных клиенту без использования клиента специально запрашивает ее.

- **Непрерывно фрейма** (для Internet Explorer). Рамки создает скрытого IFrame, который выполняет запрос в конечную точку на сервере, не была завершена. Затем сервер постоянно отправляет скрипт на клиентском компьютере, который выполняется немедленно, устанавливая соединение одностороннего в реальном времени от сервера клиенту. Подключение от клиента к серверу использует отдельное соединение с сервера для клиентского соединения, и как стандартный HTTP-запроса, создается новое соединение для каждого фрагмента данных, которые требуется отправить.
- **AJAX продолжительный опрос**. Продолжительного опроса не создает постоянное подключение, но вместо этого опрашивает сервер вместе с запросом, который остается открытым, пока сервер отвечает, после чего закрывает подключение и сразу же запрашивается новое соединение. Это может вызвать некоторая задержка, пока сбрасывает соединение.

Дополнительные сведения о какой транспортов, поддерживаемых в конфигурации см. в разделе [поддерживаемые платформы](supported-platforms.md).

### <a name="transport-selection-process"></a>Процесс выбора транспорта

Ниже перечислены шаги, которые использует SignalR, чтобы определить, что транспорта для использования.

1. Если это браузер Internet Explorer 8 или более ранней версии, используется много опроса.
2. Если настроен JSONP (т. е `jsonp` параметр имеет значение `true` при запуске соединения), используется много опроса.
3. (То есть, если конечная точка SignalR не в том же домене, что страница размещения) попытки подключения между доменами, WebSocket будет использован, если выполнены следующие условия:

   - Клиент поддерживает CORS (доступ к ресурсам независимо от источника). Дополнительные сведения, в которых клиенты поддерживают CORS см. в разделе [CORS в caniuse.com](http://www.caniuse.com/CORS).
   - Клиент поддерживает WebSocket
   - Сервер поддерживает WebSocket

     Если любой из этих условий не выполняются, Long опроса будет использоваться. Дополнительные сведения для соединений между доменами см. в разделе [как для установления соединения между доменами](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).
4. Если JSONP не настроен и подключение не находится между доменами, WebSocket будет использоваться, если клиент и сервер поддерживают его.
5. Если клиент или сервер не поддерживает WebSocket, отправки событий сервера используется в том случае, если он доступен.
6. В случае события отправки сервером недоступно, попытки навсегда кадра.
7. Длинные опроса используется при сбое навсегда кадра.

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a>Мониторинг транспортов

Можно определить, какой транспорт использует ваше приложение, включив ведение журнала на концентраторе и открытия в окне консоли в браузере.

Чтобы включить ведение журнала для событий в концентратор в браузере, добавьте следующую команду для клиентского приложения:

`$.connection.hub.logging = true;`

- Открытие средств разработчика, нажав клавишу F12 в Internet Explorer и перейдите на вкладку консоли.

    ![Консоль в Microsoft Internet Explorer](introduction-to-signalr/_static/image2.png)
- В браузере Chrome откройте консоль, нажав клавиши Ctrl + Shift + J.

    ![Консоль в Google Chrome](introduction-to-signalr/_static/image3.png)

Откройте консоль и ведение журнала включено можно будет увидеть, какие транспорта используется с SignalR.

![Консоли в Internet Explorer, показывающая транспорт WebSocket](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a>Указание транспорта

Согласования транспорта занимает некоторое время и клиентом и сервером ресурсов. Клиентские возможности известны, транспорт можно указывать, при запуске клиентского соединения. В следующем фрагменте кода показано, как запускается соединения с помощью транспорта Long опроса Ajax, как будет использоваться, если он назывался клиента не поддерживали другого протокола:

`connection.start({ transport: 'longPolling' });`

Можно указать порядок возврата, если требуется, чтобы клиент для использования конкретных транспортов в порядке. В следующем фрагменте кода демонстрируется идет WebSocket и сбои, перейдите непосредственно в длинное опроса.

`connection.start({ transport: ['webSockets','longPolling'] });`

Строковые константы для указания транспортов, определяются следующим образом:

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a>Подключениями и концентраторами

SignalR API содержит две модели для обмена данными между клиентами и серверами: постоянные подключения и концентраторов.

Соединение представляет простой конечную точку для отправки одного получателя, сгруппированные или широковещательные сообщения. Обеспечивает постоянное подключение API-Интерфейс (представленной в коде .NET класс подключение PersistentConnection), разработчику прямой доступ к низкоуровневого взаимодействия протокол, который предоставляет SignalR. С помощью модели связи соединения будут знакомы разработчикам, которые использовали API на основе подключения, например Windows Communication Foundation.

Концентратор является более высокого уровня конвейера построено подключение API, который позволяет клиенту и серверу прямого вызова методов друг от друга. SignalR обрабатывает доставку за пределами границ машины как при magic, позволив клиентам вызывать методы на сервере, как легко, как локальные методы и наоборот. С помощью модели взаимодействия концентраторы будут знакомы разработчикам, которые использовали удаленный вызов API, например удаленного взаимодействия .NET. С помощью концентратора также позволяет для передачи строго типизированных параметров к методам, включение привязки модели.

### <a name="architecture-diagram"></a>Диаграмма архитектуры

Следующей схеме показана связь между концентраторы, постоянные подключения и базовых технологиях, используемых для транспортов.

![Схема архитектуры SignalR, показывающая API-интерфейсы, транспорты и клиентов](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a>Как работают концентраторы

Когда серверный код вызывает метод на стороне клиента, пакет отправляется через активный транспорт, содержащий имя и параметры вызываемого метода (отправке объекта как параметра метода, он сериализуется с помощью JSON). Клиент проверяет соответствие имя метода для методов, определенных в код на стороне клиента. Если соответствие, метод клиента выполняется с помощью данных десериализованный параметра.

Вызов метода можно отслеживать с помощью таких средств, как [Fiddler.](http://fiddler2.com/) На следующем рисунке вызов метода, который отправляется веб-браузера в панель журналов Fiddler с сервера SignalR. Вызов метода отправляется от концентратора вызывается `MoveShapeHub`, а вызываемый метод называется `updateShape`.

![Представление журнала Fiddler, показывающая трафика SignalR](introduction-to-signalr/_static/image6.png)

В этом примере определяется имя концентратора `H` параметр; метод имени обозначена `M` параметр и объем данных, передаваемых в метод обозначается `A` параметра. Приложения, создавшего это сообщение создается в [реального времени с высокой частотой](tutorial-high-frequency-realtime-with-signalr.md) учебника.

### <a name="choosing-a-communication-model"></a>Выбор модели взаимодействия

Большинство приложений следует использовать API концентраторов. API соединения может использоваться в следующих случаях:

- Формат должен быть указан фактический сообщение, отправленное.
- Разработчик предпочитает работать с модели обмена сообщениями и диспетчеризации, а не модели удаленного вызова.
- При переносе существующего приложения, использующего модели обмена сообщениями для использования SignalR.
