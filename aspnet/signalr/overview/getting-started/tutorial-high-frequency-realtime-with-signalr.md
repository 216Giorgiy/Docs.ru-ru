---
uid: signalr/overview/getting-started/tutorial-high-frequency-realtime-with-signalr
title: "Учебник: В реальном времени с SignalR 2 по высокой частотой | Документы Microsoft"
author: pfletcher
description: "Этот учебник показывает, как создание веб-приложения, использующего ASP.NET SignalR для предоставления функций обмена сообщениями с высокой частотой. Высокочастотные обмена сообщениями в..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: 9f969dda-78ea-4329-b1e3-e51c02210a2b
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/getting-started/tutorial-high-frequency-realtime-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 5af7289392c18d58de11249c75e539c9e08954be
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="tutorial-high-frequency-realtime-with-signalr-2"></a>Учебник: В реальном времени с SignalR 2 по высокой частотой
====================
по [Патрик Флетчера](https://github.com/pfletcher)

[Загрузка завершенного проекта](http://code.msdn.microsoft.com/SignalR-20-MoveShape-Demo-6285b83a)

> Этот учебник показывает, как создание веб-приложения, для обеспечения высокой частотой функциональные возможности обмена сообщениями используется ASP.NET SignalR 2. Высокая частота обмена сообщениями в данном случае означает обновления, которые отправляются по фиксированной ставке; в случае использования этого приложения до 10 сообщений за секунду.
> 
> Приложение, которое вы создадите в этом учебнике показывает фигуру, пользователи могут перетаскивать. Положение фигуры во всех браузерах подключенных будут обновлены в соответствии положение перетаскиваемого фигуры с помощью синхронизированного обновления.
> 
> Концепции, реализованные в этом учебнике у приложений в игры в режиме реального времени и других приложений моделирования.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемая в этом учебнике
> 
> 
> - [Visual Studio 2013](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - .NET 4.5
> - SignalR версии 2
>   
> 
> 
> ## <a name="using-visual-studio-2012-with-this-tutorial"></a>С помощью Visual Studio 2012 с помощью этого учебника
> 
> 
> Чтобы использовать Visual Studio 2012 с помощью этого учебника, выполните следующее:
> 
> - Обновление вашего [диспетчера пакетов](http://docs.nuget.org/docs/start-here/installing-nuget) до последней версии.
> - Установка [веб-установщика платформы](https://www.microsoft.com/web/downloads/platform.aspx).
> - Установщик веб-платформы для поиска и установки **ASP.NET и 2013.1 Web Tools для Visual Studio 2012**. Это будет установки Visual Studio шаблоны для SignalR классов, таких как **концентратора**.
> - Некоторые шаблоны (такие как **класс запуска OWIN**) будет недоступен; в этом случае используйте файл класса.
> 
> 
> ## <a name="tutorial-versions"></a>Версии учебника
> 
> Сведения о более ранних версий SignalR см. в разделе [более ранних версий SignalR](../older-versions/index.md).
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте отзыв на том, как вам понравилось этого учебника и что можно улучшить в комментарии в нижней части страницы. Если у вас есть вопросы, которые не связаны непосредственно для работы с учебником, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).


## <a name="overview"></a>Обзор

Демонстрирует создание приложения, совместно с другими браузерами, в режиме реального времени состояние объекта. Приложение, которое мы создадим называется MoveShape. На MoveShape странице будет показан элемент Div в HTML, в котором пользователь может перетаскивать; Когда пользователь перетаскивает элемент Div, новое положение будут отправляться на сервер, который затем сообщает о других подключенных клиентов для обновления фигуры позиции для сопоставления.

![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image1.png)

Приложение, созданное в этом учебнике основан на демонстрацию — Дэмьен эвардс. Видео, содержащий этой демонстрации можно увидеть [здесь](https://channel9.msdn.com/Series/Building-Web-Apps-with-ASP-NET-Jump-Start/Building-Web-Apps-with-ASPNET-Jump-Start-08-Real-time-Communication-with-SignalR).

Учебник для начала необходимо демонстрации для отправки сообщений SignalR из каждого события, которое возникает при перетаскивании фигуры. Каждый подключенный клиент обновит позицию локальная версия фигуры при каждом получении сообщения.

Хотя приложение будет работать с помощью этого метода, это не является рекомендуемые модель программирования, поскольку будет верхний предел на число получение отправленных сообщений, поэтому клиенты и сервер может получить перегружены большим количеством сообщений, и может привести к снижению производительности . Отображаемые анимации на стороне клиента также будут несвязанном, как форма будет перенесено мгновенно для каждого метода, а не скользящего плавно в каждое новое расположение. В последующих подразделах учебника показано, как создать функцию таймера, который ограничивает максимальной скорости, с которой сообщения отправляются с сервера или клиента и перемещении фигуры плавно между расположениями. Окончательная версия приложения, созданного в этом учебнике можно загрузить с [коллекции кода](https://code.msdn.microsoft.com/SignalR-20-MoveShape-Demo-6285b83a).

Этот учебник содержит следующие разделы:

- [Необходимые компоненты](#prerequisites)
- [Создание проекта и добавьте пакет SignalR и JQuery.UI NuGet](#createtheproject2013)
- [Создание базового приложения](#baseapp)
- [Запуск концентратора при запуске приложения](#startup2013)
- [Добавить цикл клиента](#clientloop)
- [Добавить цикл сервера](#serverloop)
- [Добавление анимации на стороне клиента](#animation)
- [Дальнейшие действия](#furthersteps)

<a id="prerequisites"></a>

## <a name="prerequisites"></a>Предварительные требования

Этот учебник требуется Visual Studio 2013.

<a id="createtheproject2013"></a>

## <a name="create-the-project-and-add-the-signalr-and-jqueryui-nuget-package"></a>Создание проекта и добавьте пакет SignalR и JQuery.UI NuGet

В этом разделе мы создадим проект в Visual Studio 2013.

В следующих действиях используется Visual Studio 2013 для создания пустой веб-приложения ASP.NET и добавлять библиотеки SignalR и jQuery.UI:

1. В Visual Studio создайте веб-приложение ASP.NET.

    ![Создание веб-](tutorial-high-frequency-realtime-with-signalr/_static/image2.png)
2. В **новый проект ASP.NET** окна, оставьте **пустой** флажок и нажмите кнопку **Создание проекта**.

    ![Создать пустой веб-узел](tutorial-high-frequency-realtime-with-signalr/_static/image3.png)
3. В **обозревателе решений**, щелкните правой кнопкой мыши проект, выберите **добавить | Класс концентратора SignalR (v2)**. Имя класса **MoveShapeHub.cs** и добавить его в проект. На этом шаге создается **MoveShapeHub** и добавляет в проект набор файлов сценариев и ссылки на сборки, которые поддерживают SignalR.

    > [!NOTE]
    > SignalR можно также добавить в проект, щелкнув **инструменты | Диспетчер пакетов библиотеки | Консоль диспетчера пакетов** и такую команду:

    `install-package Microsoft.AspNet.SignalR`. 

    При использовании консоли для добавления SignalR, создайте класс концентратора SignalR как отдельный шаг после добавления SignalR.
4. Нажмите кнопку **инструменты | Диспетчер пакетов библиотеки | Консоль диспетчера пакетов**. В окне диспетчера пакетов выполните следующую команду:

    `Install-Package jQuery.UI.Combined`

    При этом устанавливаются библиотеки jQuery UI, которая будет использоваться для анимации фигуры.
5. В **обозревателе решений** разверните узел «скрипты». Библиотеки скриптов jQuery, jQueryUI и SignalR, отображаются в проект.

    ![Ссылки на библиотеки скриптов](tutorial-high-frequency-realtime-with-signalr/_static/image4.png)

<a id="baseapp"></a>

## <a name="create-the-base-application"></a>Создание базового приложения

В этом разделе мы создадим приложение браузера, которое отправляет расположение формы на сервер во время каждого события перемещения мыши. Сервер затем осуществляет широковещательную рассылку эту информацию для всех остальных подключенных клиентов при его получении. Мы будем разверните в это приложение, в последующих разделах.

1. Если не был уже создан класс MoveShapeHub.cs в **обозревателе решений**, щелкните правой кнопкой мыши проект и выберите **добавить**, **класса...** . Имя класса **MoveShapeHub** и нажмите кнопку **добавить**.
2. Замените код в новом **MoveShapeHub** класса следующим кодом.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample1.cs)]

    `MoveShapeHub` Выше класс представляет собой реализацию концентратора SignalR. Как и в [Приступая к работе с SignalR](tutorial-getting-started-with-signalr.md) учебнике концентратора содержит метод, который клиенты будут вызывать напрямую. В этом случае клиент передает объект, содержащий новый координаты X и Y фигуры на сервер, затем возвращает широковещательной рассылки для всех остальных подключенных клиентов. SignalR будет автоматически сериализации этого объекта с помощью JSON.

    Объект, который отправляется клиентам (`ShapeModel`) содержит члены для хранения позиции фигуры. Версия объекта на сервере также содержит элемент для отслеживания хранится какие клиентские данные, чтобы данного клиента не будет отправлять свои собственные данные. Этот член использует `JsonIgnore` атрибут для предотвращения сериализации и отправляются на клиент.

<a id="startup2013"></a>
## <a name="starting-the-hub-when-the-application-starts"></a>Запуск концентратора при запуске приложения

1. Далее мы составим сопоставления к концентратору при запуске приложения. SignalR 2, это делается путем добавления класса запуска OWIN, который вызовет `MapSignalR` при запуске класса `Configuration` метод выполняется при запуске OWIN. Класс добавляется для запуска OWIN обработать с помощью `OwinStartup` атрибут сборки.

    В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **добавить | Класс запуска OWIN**. Имя класса *запуска* и нажмите кнопку **ОК**.
2. Измените содержимое файла Startup.cs:

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample2.cs)]

<a id="client"></a>
## <a name="adding-the-client"></a>Добавление клиента

1. Далее мы добавим в клиент. В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **добавить | Новый элемент**. В **Добавление нового элемента** диалогового окна выберите **HTML-страницу**. Назовите страницу **Default.html** и нажмите кнопку **добавить**.
2. В **обозревателе решений**, щелкните правой кнопкой мыши только что созданный страницы и нажмите кнопку **задать в качестве начальной страницы**.
3. Замените код по умолчанию в HTML-страницу с помощью следующего фрагмента кода.

    > [!NOTE]
    > Проверьте, скрипт ссылается ниже соответствия пакеты, добавлены в проект в папку «скрипты».

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample3.html)]

    Приведенный выше код HTML и JavaScript создает красный Div вызывается фигуры, включает режим перетаскивания фигуры, с помощью библиотеки jQuery и использует фигуры `drag` событий для отправки на сервер положения фигуры.
4. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image5.png)

<a id="clientloop"></a>

## <a name="add-the-client-loop"></a>Добавить цикл клиента

С момента отправки расположение фигуры на каждого события перемещения мыши создаст лишние объем сетевого трафика, сообщения от клиента должны регулироваться. Мы будем использовать javascript `setInterval` функции, чтобы настроить цикл, который отправляет на сервер по фиксированной ставке новые сведения о положении. Этот цикл является очень простым представлением цикла «игры», многократно вызываемой функции, вызывающее все функциональные возможности, игры или других моделирования.

1. Обновите код клиента в HTML-страницу для сопоставления в следующем фрагменте кода.

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample4.html)]

    Добавляет выше обновления `updateServerModel` функции, которая вызывается на фиксированной частотой. Эта функция отправляет данные положения на сервер при каждом `moved` флаг указывает, что новые данные позиции для отправки.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера. Поскольку будет регулировать количество сообщений, отправляемых на сервер, анимации не будут отображаться как smooth, как в предыдущем разделе.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image6.png)

<a id="serverloop"></a>

## <a name="add-the-server-loop"></a>Добавить цикл сервера

В текущем приложении сообщения, отправленные сервером клиенту начнутся так часто, как их получения. Это представляет подобную проблему, как была обнаружена на клиенте; сообщения могут отправляться чаще, чем они нужны, и соединение может стать переполняющее в результате. В этом разделе описывается обновление сервера для реализации таймер, который регулирует количество исходящих сообщений.

1. Замените содержимое `MoveShapeHub.cs` с помощью следующего фрагмента кода.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample5.cs)]

    Приведенный выше код при развертывании клиента для добавления `Broadcaster` класс, который регулирует исходящих сообщений с помощью `Timer` класса из платформы .NET framework.

    Поскольку концентратора, сам является временной (он создается каждый раз при необходимости), `Broadcaster` будет создана как Singleton-классом. Чтобы отложить ее создания, время, необходимое, убедившись, что первый экземпляр концентратора полностью создан, до запуска таймера используется отложенная инициализация (появился в .NET 4).

    Вызов клиентов `UpdateShape` функция затем перемещается за пределы концентратора `UpdateModel` метода, так что он больше не вызывается немедленно в том случае, когда получения входящих сообщений. Вместо этого будут отправляться сообщения для клиентов со скоростью 25 вызовов в секунду, управляется `_broadcastLoop` таймера изнутри `Broadcaster` класса.

    Наконец, вместо вызова метода клиента от концентратора напрямую, `Broadcaster` классу необходимо получить ссылку на момент работы концентратора (`_hubContext`) с помощью `GlobalHost`.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера. Не будет видимым разницу в браузере из предыдущего раздела, но число сообщений, отправляемых клиенту будет возвращена.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image7.png)

<a id="animation"></a>

## <a name="add-smooth-animation-on-the-client"></a>Добавление анимации на стороне клиента

Приложение практически завершена, но можно сделать один Дополнительные улучшения, движущихся фигуры на стороне клиента при их перемещении в ответ на сообщения сервера. Вместо задания положения фигуры в новое расположение, заданный сервером, мы будем использовать библиотеку JQuery UI `animate` function для перемещения фигуры плавно между его текущим и новым положение.

1. Обновление клиента `updateShape` метод для поиска, такие как выделенный код ниже:

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample6.html?highlight=33-40)]

    Приведенный выше код перемещает фигуры из старого расположения в новую, заданный сервером в течение интервала анимации (в данном случае 100 миллисекунд). Все предыдущие анимацию на фигуре очищается перед запуском новой анимацией.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; Переместить фигуру в окне браузера. Перемещение фигуры в другом окне должен появиться менее рывками, как ее движение интерполируются по времени, а не устанавливается один раз на входящее сообщение.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image8.png)

<a id="furthersteps"></a>

## <a name="further-steps"></a>Дальнейшие действия

В этом учебнике вы узнали, как запрограммировать приложение SignalR, которое отправляет сообщения с высокой частотой между клиентами и серверами. Этого принципа взаимодействия помогает при разработке играх и других моделей, таких как [ShootR игры, созданных с помощью SignalR](http://shootr.signalr.net).

Полное приложение, созданной в этом учебнике можно загрузить из [коллекции кода](https://code.msdn.microsoft.com/SignalR-20-MoveShape-Demo-6285b83a).

Дополнительные сведения об основных понятиях разработки SignalR, посетите следующие сайты для SignalR исходный код и ресурсы:

- [Проект SignalR](http://signalr.net)
- [SignalR Github и образцы](https://github.com/SignalR/SignalR)
- [Вики-сайте SignalR](https://github.com/SignalR/SignalR/wiki)

Пошаговое руководство по развертыванию приложения на SignalR для Azure см. в разделе [SignalR с помощью с веб-приложений в службе приложений Azure](../deployment/using-signalr-with-azure-web-sites.md). Подробные сведения о развертывании веб-проекта Visual Studio для веб-сайта Windows Azure см. в разделе [создать веб-приложение ASP.NET в службе приложений Azure](https://azure.microsoft.com/en-us/documentation/articles/web-sites-dotnet-get-started/).
