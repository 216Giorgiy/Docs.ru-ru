---
uid: signalr/overview/guide-to-the-api/hubs-api-guide-server
title: Справочник по API концентраторов ASP.NET SignalR - сервера (C#) | Документы Microsoft
author: pfletcher
description: Этот документ содержит введение в программирование API концентраторов SignalR ASP.NET со стороны сервера для SignalR, версия 2, с использованием образцы кода, демонстрирующие...
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: b19913e5-cd8a-4e4b-a872-5ac7a858a934
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/guide-to-the-api/hubs-api-guide-server
msc.type: authoredcontent
ms.openlocfilehash: c2567d4d39a494daf77a23db5dff83c8fae4925d
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
ms.locfileid: "28039213"
---
<a name="aspnet-signalr-hubs-api-guide---server-c"></a>Справочник по API концентраторов ASP.NET SignalR - сервера (C#)
====================
по [Флетчера Патрик](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)

> Этот документ содержит введение в программирование API концентраторов SignalR ASP.NET со стороны сервера для SignalR, версия 2, с использованием образцы кода, демонстрирующие общих параметров.
> 
> API концентраторов SignalR позволяет вносить удаленные вызовы процедур (RPC) с сервера на подключенных клиентов и от клиентов к серверу. В серверном коде определять методы, которые могут быть вызваны клиентов и вызова методов, которые выполняются на клиенте. В клиентском коде определяют методы, которые могут быть вызваны с сервера и вызывать методы, которые выполняются на сервере. SignalR обеспечивает всех коммуникаций клиент сервер для вас.
> 
> SignalR также предлагает API нижнего уровня, который называется постоянные подключения. Введение SignalR, концентраторов и постоянные подключения см. в разделе [Общие сведения о SignalR 2](../getting-started/introduction-to-signalr.md).
> 
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемого в этом разделе
> 
> 
> - [Visual Studio 2013](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - .NET 4.5
> - SignalR версии 2
>   
> 
> 
> ## <a name="topic-versions"></a>Версии раздела
> 
> Сведения о более ранних версий SignalR см. в разделе [более ранних версий SignalR](../older-versions/index.md).
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте отзыв на том, как вам понравилось этого учебника и что можно улучшить в комментарии в нижней части страницы. Если у вас есть вопросы, которые не связаны непосредственно для работы с учебником, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).


## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Как зарегистрировать SignalR по промежуточного слоя](#route)

    - [URL-адрес /signalr](#signalrurl)
    - [Настройка параметров SignalR](#options)
- [Создание и использование классов Hub](#hubclass)

    - [Время существования объекта концентратора](#transience)
    - [Верблюжий концентратора имен клиентов JavaScript](#hubnames)
    - [Несколько концентраторов](#multiplehubs)
    - [Строго типизированные концентраторы](#stronglytypedhubs)
- [Как определить методы в классе концентратора, который клиенты смогут вызывать](#hubmethods)

    - [Верблюжий имена методов в клиентов JavaScript](#methodnames)
    - [Если для асинхронного выполнения](#asyncmethods)
    - [Определение перегрузки](#overloads)
    - [Отчеты о ходе выполнения из вызовов методов концентратора](#progress)
- [Способ вызова методов клиента от концентратора класса](#callfromhub)

    - [При выборе какие клиенты будут получать RPC](#selectingclients)
    - [Имена методов не проверяются во время компиляции](#dynamicmethodnames)
    - [Совпадение имен метод без учета регистра](#caseinsensitive)
    - [Асинхронное выполнение](#asyncclient)
- [Как управлять членством в группах от класса концентратора](#groupsfromhub)

    - [Асинхронное выполнение методы Add и Remove](#asyncgroupmethods)
    - [Сохраняемость членство группы](#grouppersistence)
    - [Группы в однопользовательском режиме](#singleusergroups)
- [Как обрабатывать события времени жизни соединений в классе концентратора](#connectionlifetime)

    - [При вызове OnConnected, OnDisconnected и OnReconnected](#onreconnected)
    - [Состояние вызывающего объекта не заполнен](#nocallerstate)
- [Как получить информацию о клиенте из контекстного свойства](#contextproperty)
- [Передача состояния между клиентами и класс концентратора](#passstate)
- [Способ обработки ошибок в классе концентратора](#handleErrors)
- [Как вызывать методы клиента групп и управление ими из вне класса концентратора](#callfromoutsidehub)

    - [Вызов методов клиента](#callingclientsoutsidehub)
    - [Управление членством в группе](#managinggroupsoutsidehub)
- [Как включить трассировку](#tracing)
- [Настройка конвейера концентраторы](#hubpipeline)

Для получения сведений о программе клиентов см. следующие ресурсы:

- [Справочник по API концентраторов SignalR - клиент JavaScript](hubs-api-guide-javascript-client.md)
- [Справочник по API концентраторов SignalR - клиент .NET](hubs-api-guide-net-client.md)

Серверные компоненты для SignalR 2 доступны только в .NET 4.5. Серверы под управлением .NET 4.0 необходимо использовать SignalR v1.x.

<a id="route"></a>

## <a name="how-to-register-signalr-middleware"></a>Как зарегистрировать SignalR по промежуточного слоя

Чтобы определить маршрут, который будет использоваться клиентами для подключения к концентратору, вызовите `MapSignalR` метод при запуске приложения. `MapSignalR`— [метод расширения](https://msdn.microsoft.com/library/vstudio/bb383977.aspx) для `OwinExtensions` класса. В следующем примере показан способ определения концентраторы SignalR маршрут, используя класс запуска OWIN.

[!code-csharp[Main](hubs-api-guide-server/samples/sample1.cs)]

При добавлении SignalR функциональности в приложение ASP.NET MVC убедитесь, что маршрута SignalR добавляется раньше, чем другие маршруты. Дополнительные сведения см. в разделе [учебник: Приступая к работе с SignalR 2 и MVC 5](../getting-started/tutorial-getting-started-with-signalr-and-mvc.md).

<a id="signalrurl"></a>

### <a name="the-signalr-url"></a>URL-адрес /signalr

По умолчанию используется URL-адрес маршрута, который клиенты будут использовать для подключения к концентратору «/ signalr». (Не путайте этот URL-адрес с URL-адрес «/ signalr/концентраторов», предназначенная для автоматически созданный файл JavaScript. Дополнительные сведения о созданном прокси см. в разделе [руководство по API концентраторов SignalR - клиент JavaScript - созданный прокси и делает за вас](hubs-api-guide-javascript-client.md#genproxy).)

Может быть непредвиденных обстоятельств, которые делают этот базовый URL-адрес не может использоваться для SignalR; Например, имеется папка с именем проекта *signalr* и вы не хотите изменить имя. В этом случае можно изменить базовый URL-адрес, как показано в следующих примерах (Замените «/ signalr» в образце кода с нужный URL-адрес).

**Код сервера, на который указывает URL-адрес**

[!code-csharp[Main](hubs-api-guide-server/samples/sample2.cs?highlight=1)]

**Клиентский код JavaScript, который указывает URL-адрес (с созданный прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample3.js?highlight=1)]

**Клиентский код JavaScript, который указывает URL-адрес (без созданный прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample4.js?highlight=1)]

**Клиентский код .NET, который указывает URL-адрес**

[!code-csharp[Main](hubs-api-guide-server/samples/sample5.cs?highlight=1)]

<a id="options"></a>

### <a name="configuring-signalr-options"></a>Настройка параметров SignalR

Перегруженные версии `MapSignalR` метода позволяют указать настраиваемый URL-адрес, Сопоставитель пользовательскую зависимость и следующие параметры:

- Включите вызовы между доменами с помощью CORS или JSONP от клиентов браузера.

    Как правило, если браузер загружает страницу из `http://contoso.com`, подключения SignalR находится в том же домене, в `http://contoso.com/signalr`. Если страницы из `http://contoso.com` подключается к `http://fabrikam.com/signalr`, то есть соединение между доменами. По соображениям безопасности соединения между доменами отключены по умолчанию. Дополнительные сведения см. в разделе [ASP.NET руководство по API концентраторов SignalR - клиент JavaScript - как для установления соединения между доменами](hubs-api-guide-javascript-client.md#crossdomain).
- Включите подробные сообщения об ошибках.

    При возникновении ошибки, по умолчанию для SignalR выполняется для отправки клиентам сообщение уведомления без подробной информации о том, что произошло. Подробные сведения об ошибке отправки клиентам в рабочей среде, не рекомендуется, поскольку пользователей-злоумышленников, можно использовать информацию в атаки, направленные на ваше приложение. Сведения об устранении неполадок, можно использовать этот параметр, чтобы временно включить более информативные сообщения об ошибках.
- Отключите автоматически созданные файлы прокси JavaScript.

    По умолчанию файл JavaScript с прокси-серверы для классов Hub создается в ответ на URL-адрес «/ signalr/концентраторов». Если вы не хотите использовать прокси-серверы JavaScript, или если вы хотите создать этот файл вручную и ссылаться на физическом файле в клиентов, можно использовать этот параметр, чтобы отключить создание прокси-сервера. Дополнительные сведения см. в разделе [руководство по API концентраторов SignalR - клиент JavaScript - прокси-сервера создается как создать физический файл для SignalR](hubs-api-guide-javascript-client.md#manualproxy).

Приведенный ниже показано, как указать URL-адрес подключения SignalR и эти параметры при вызове `MapSignalR` метода. Чтобы задать пользовательский URL-адрес, замените «/ signalr» в примере на URL-адрес, который вы хотите использовать.

[!code-csharp[Main](hubs-api-guide-server/samples/sample6.cs)]

<a id="hubclass"></a>

## <a name="how-to-create-and-use-hub-classes"></a>Создание и использование классов Hub

Для создания концентратора, создайте класс, производный от [Microsoft.Aspnet.Signalr.Hub](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hub(v=vs.111).aspx). Следующий пример показывает простой класс концентратора для приложения разговора.

[!code-csharp[Main](hubs-api-guide-server/samples/sample7.cs)]

В этом примере можно вызвать подключенный клиент `NewContosoChatMessage` метода, и когда это происходит, данные, полученные широковещательной рассылки для всех подключенных клиентов.

<a id="transience"></a>

### <a name="hub-object-lifetime"></a>Время существования объекта концентратора

Не создавать экземпляр класса концентратора и вызывать его методы из собственного кода на сервере. все, что произведена за вас конвейером концентраторов SignalR. SignalR создает новый экземпляр класса концентратора каждый раз, он должен обрабатывать операции концентратора, например, когда клиент подключается, отключает или выполняет вызов метода к серверу.

Так как экземпляры класса концентратора являются временными, их нельзя использовать для поддержания состояния от одного вызова метода к другому. Каждый раз, сервер получает вызов метода из клиента, новый экземпляр класса процессов концентратора сообщения. Для поддержания состояния через несколько соединений и вызовы методов, используйте другой метод, например базы данных или статическая переменная концентратора класса или другого класса, который является производным от `Hub`. Если сохранить данные в памяти, с помощью метода, например статической переменной класса концентратора, данные будут потеряны при очистке домена приложения.

Если вы хотите отправлять сообщения для клиентов из собственного кода, который выполняется вне класса концентратора, просто нельзя сделать с помощью создания экземпляра класса концентратора, но это можно сделать путем получения ссылку на объект контекста SignalR для класса концентратора. Дополнительные сведения см. в разделе [как вызывать методы клиента групп и управление ими из вне класса концентратора](#callfromoutsidehub) далее в этом разделе.

<a id="hubnames"></a>

### <a name="camel-casing-of-hub-names-in-javascript-clients"></a>Верблюжий концентратора имен клиентов JavaScript

По умолчанию клиенты JavaScript ссылаются концентраторов с использованием версии стиле Camel имени класса. SignalR автоматически делает это изменение, чтобы код JavaScript может соответствовать соглашениям JavaScript. Предыдущий пример будет называться `contosoChatHub` в коде JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample8.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample9.js?highlight=1)]

Если вы хотите указать другое имя, чтобы клиенты могли использовать, добавьте `HubName` атрибута. При использовании `HubName` атрибут, не изменяется имя верблюжий на клиентах JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample10.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample11.js?highlight=1)]

<a id="multiplehubs"></a>

### <a name="multiple-hubs"></a>Несколько концентраторов

Можно определить несколько классов концентратора в приложении. При этом общий доступ к подключению, но отдельные группы:

- Все клиенты будут использовать же URL-адрес для подключения SignalR с вашей службой («/ signalr» или пользовательских URL-адрес, если вы указали одну), и что соединение используется для всех концентраторов определенной службой.

    Нет никаких различий производительности для нескольких концентраторов по сравнению с определением в одном классе все функциональные возможности концентратора.
- Все концентраторы получить те же данные HTTP-запроса.

    Поскольку все концентраторы имеют то же подключение, только сведения о запросе HTTP, сервер возвращает — что поставляется в исходном запросе HTTP, устанавливает соединение SignalR. Если вы используете запрос на подключение для передачи данных от клиента к серверу, указав строку запроса, не может предоставить различные строки запросов в разных концентраторы. Все концентраторы будут получать те же сведения.
- Созданный файл прокси JavaScript будет содержать учетные записи-посредники для всех концентраторов в одном файле.

    Сведения о прокси-серверы JavaScript см. в разделе [руководство по API концентраторов SignalR - клиент JavaScript - созданный прокси и делает за вас](hubs-api-guide-javascript-client.md#genproxy).
- Группы определяются в пределах концентраторов.

    В SignalR, которые можно определить имя группы для передачи на подмножества подключенных клиентов. Группы поддерживаются отдельно для каждого концентратора. Например, группа «Администраторы» включить один набор клиентов для вашего `ContosoChatHub` относится к другому набору клиентов для класса и тем же именем вашего `StockTickerHub` класса.

<a id="stronglytypedhubs"></a>
### <a name="strongly-typed-hubs"></a>Строго типизированные концентраторы

Чтобы определить интерфейс для методов концентратора, клиент может ссылки (и включить Intellisense в методах hub) являются производными концентратор из `Hub<T>` (впервые появилась в SignalR 2.1) вместо `Hub`:

[!code-csharp[Main](hubs-api-guide-server/samples/sample12.cs)]

<a id="hubmethods"></a>

## <a name="how-to-define-methods-in-the-hub-class-that-clients-can-call"></a>Как определить методы в классе концентратора, который клиенты смогут вызывать

Чтобы предоставить метод на концентраторе, должен быть вызван из клиента, объявите открытый метод, как показано в следующих примерах.

[!code-csharp[Main](hubs-api-guide-server/samples/sample13.cs?highlight=3)]

[!code-csharp[Main](hubs-api-guide-server/samples/sample14.cs?highlight=3)]

Можно указать тип возвращаемого значения и параметры, включая сложные типы массивов и, как и в любой метод C#. Все данные, в параметрах получения или возврата вызывающему передается между клиентом и сервером с помощью JSON и SignalR обрабатывает привязки сложные объекты и массивы объектов автоматически.

<a id="methodnames"></a>

### <a name="camel-casing-of-method-names-in-javascript-clients"></a>Верблюжий имена методов в клиентов JavaScript

По умолчанию клиенты JavaScript ссылаются методов концентратора с использованием версии стиле Camel имени метода. SignalR автоматически делает это изменение, чтобы код JavaScript может соответствовать соглашениям JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample15.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample16.js?highlight=1)]

Если вы хотите указать другое имя, чтобы клиенты могли использовать, добавьте `HubMethodName` атрибута.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample17.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample18.js?highlight=1)]

<a id="asyncmethods"></a>

### <a name="when-to-execute-asynchronously"></a>Если для асинхронного выполнения

Если метод будет иметь длительные или должен работать, следует включать ожидания, например, поиск в базе данных или вызов веб-службы, создания асинхронного метода концентратора, возвращая [задачи](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) (вместо `void` возврата) или [ Задача&lt;T&gt; ](https://msdn.microsoft.com/library/dd321424.aspx) объектов (вместо `T` тип возвращаемого значения). При возвращении `Task` ожидает объект из метода SignalR `Task` для завершения, а затем отправляет распаковать результат обратно клиенту, поэтому нет никаких различий в том, как код вызова метода в клиенте.

Создание метода концентратора асинхронной позволяет избежать блокировать подключение, если она использует транспорт WebSocket. Если транспортом является WebSocket метод концентратора выполняется синхронно, последующие вызовы методов в концентраторе от одного клиента, блокируются до завершения выполнения метода концентратора.

В следующем примере показано, тот же метод в коде выполняются синхронно или асинхронно, а затем клиентский код JavaScript, который работает для вызова любой версии.

**Synchronous**

[!code-csharp[Main](hubs-api-guide-server/samples/sample19.cs)]

**Asynchronous**

[!code-csharp[Main](hubs-api-guide-server/samples/sample20.cs?highlight=1,7-8)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample21.js)]

Дополнительные сведения об использовании асинхронных методов в ASP.NET 4.5 см. в разделе [использование асинхронных методов в ASP.NET MVC 4](../../../mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4.md).

<a id="overloads"></a>

### <a name="defining-overloads"></a>Определение перегрузки

Если вы хотите определить перегрузки для метода, число параметров в каждой перегрузке должны быть разными. Если перегрузка отличить просто задав разные типы параметров, класс концентратора будет скомпилирован, но службы SignalR будет вызывать исключение во время выполнения, когда клиенты пытаются вызов перегрузки.

<a id="progress"></a>
### <a name="reporting-progress-from-hub-method-invocations"></a>Отчеты о ходе выполнения из вызовов методов концентратора

SignalR 2.1 добавляет поддержку для [шаблон отчета о состоянии](https://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx) появился в .NET 4.5. Для реализации отчета о ходе выполнения, определять `IProgress<T>` параметра для метода концентратора, которые клиент может получить доступ к:

[!code-csharp[Main](hubs-api-guide-server/samples/sample22.cs)]

При записи метода сервера длительное время, очень важно использовать асинхронную модель программирования как Async / Await вместо блокировки потока концентратора.

<a id="callfromhub"></a>

## <a name="how-to-call-client-methods-from-the-hub-class"></a>Способ вызова методов клиента от концентратора класса

Для вызова методов клиента с сервера, используйте `Clients` свойство метод в классе концентратора. В следующем примере показано серверного кода, который вызывает `addNewMessageToPage` на всех подключенных клиентов и клиентский код, который определяет метод, в клиент JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample23.cs?highlight=5)]

**С помощью созданного прокси клиента JavaScript**

[!code-html[Main](hubs-api-guide-server/samples/sample24.html?highlight=1)]

Не удается получить значение, возвращаемое из метода клиента; синтаксис, такие как `int x = Clients.All.add(1,1)` не работает.

Можно указать, сложные типы и массивы параметров. В следующем примере передается сложный тип клиенту в параметре метода.

**Код сервера, который вызывает клиентский метод, с помощью сложного объекта**

[!code-csharp[Main](hubs-api-guide-server/samples/sample25.cs?highlight=3)]

**Код сервера, который определяет сложный объект**

[!code-csharp[Main](hubs-api-guide-server/samples/sample26.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample27.js?highlight=2-3)]

<a id="selectingclients"></a>

### <a name="selecting-which-clients-will-receive-the-rpc"></a>При выборе какие клиенты будут получать RPC

Это свойство возвращает клиентов [HubConnectionContext](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubconnectioncontext(v=vs.111).aspx) объект, который предоставляет несколько параметров для указания, какие клиенты получат RPC:

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample28.cs)]
- Вызывающий клиент.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample29.cs)]
- Все клиенты, кроме вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample30.cs)]
- Конкретным клиентом, определяется идентификатор соединения.

    [!code-css[Main](hubs-api-guide-server/samples/sample31.css)]

    В этом примере вызывается `addContosoChatMessageToPage` на вызывающего клиента и действует так же, как с помощью `Clients.Caller`.
- Все подключенные клиенты, кроме указанным клиентам, определяемый по идентификатору соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample32.cs)]
- Все подключенные клиенты в указанной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample33.css)]
- Все подключенные клиенты в указанной группе, кроме указанным клиентам, определяемый по идентификатору соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample34.cs)]
- Все подключенные клиенты в указанной группе, кроме вызывающего клиента.

    [!code-css[Main](hubs-api-guide-server/samples/sample35.css)]
- Конкретного пользователя, обозначенную userId.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample36.cs)]

    По умолчанию это `IPrincipal.Identity.Name`, но его можно изменить, [регистрации реализация IUserIdProvider с сервером глобального](mapping-users-to-connections.md#IUserIdProvider).
- Все клиенты и группы в список идентификаторов подключений.

    [!code-css[Main](hubs-api-guide-server/samples/sample37.css)]
- Список групп.

    [!code-css[Main](hubs-api-guide-server/samples/sample38.css)]
- Пользователя по имени.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample39.cs)]
- Список имен пользователей (впервые появилась в SignalR 2.1).

    [!code-csharp[Main](hubs-api-guide-server/samples/sample40.cs)]

<a id="dynamicmethodnames"></a>

### <a name="no-compile-time-validation-for-method-names"></a>Имена методов не проверяются во время компиляции

Имя метода, указываемое интерпретируется как динамический объект, это означает, что нет IntelliSense или проверки во время компиляции для него. Выражение вычисляется во время выполнения. При вызове метода SignalR отправляет имя метода и значения параметров клиента, а если клиент содержит метод, который совпадает с именем, что вызывается метод и значения параметров передаются в него. При обнаружении на стороне клиента нет соответствующего метода ошибка не возникает. Сведения о формате данных, SignalR передает клиенту за кулисами, при вызове метода клиента см. в разделе [Общие сведения о SignalR](../getting-started/introduction-to-signalr.md).

<a id="caseinsensitive"></a>

### <a name="case-insensitive-method-name-matching"></a>Совпадение имен метод без учета регистра

Метод совпадение имен регистр не учитывается. Например `Clients.All.addContosoChatMessageToPage` на сервере будет выполняться `AddContosoChatMessageToPage`, `addcontosochatmessagetopage`, или `addContosoChatMessageToPage` на стороне клиента.

<a id="asyncclient"></a>

### <a name="asynchronous-execution"></a>Асинхронное выполнение

Метод, вызываемый выполняется асинхронно. Любой код, который поставляется после вызова метода для клиента будет выполняться немедленно без ожидания SignalR для завершения передачи данных на клиентов, если не указать, что следующие строки кода следует подождать завершения метода. В следующем примере кода показано, как для последовательного выполнения двух методов клиента.

**С помощью Await (.NET 4.5)**

[!code-csharp[Main](hubs-api-guide-server/samples/sample41.cs?highlight=1,3)]

Если вы используете `await` подождать, пока клиентский метод завершения до выполнения следующей строке кода, это не значит, клиенты фактически будут получать сообщение перед выполнением следующей строке кода. Вызов клиентского метода «завершения» означает только то SignalR выполнил все компоненты, необходимые для отправки сообщения. Если требуется проверка, что клиенты получили сообщение, необходимо самостоятельно программы такой механизм. Например, можно код `MessageReceived` метод на концентраторе и в `addContosoChatMessageToPage` метод на стороне клиента, можно вызвать `MessageReceived` после этого любые работала должен выполнить на клиенте. В `MessageReceived` в концентраторе можно сделать, независимо от работы зависит от клиента фактическое получение и обработка вызова исходного метода.

### <a name="how-to-use-a-string-variable-as-the-method-name"></a>Использование строковой переменной в качестве имени метода

Если необходимо вызвать метод клиента с помощью строковой переменной как имя метода, приведение `Clients.All` (или `Clients.Others`, `Clients.Caller`, т. д.) для `IClientProxy` и затем вызвать [Invoke (имя_метода, args...) ](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.iclientproxy.invoke(v=vs.111).aspx).

[!code-csharp[Main](hubs-api-guide-server/samples/sample42.cs)]

<a id="groupsfromhub"></a>

## <a name="how-to-manage-group-membership-from-the-hub-class"></a>Как управлять членством в группах от класса концентратора

Группы в SignalR предоставляют метод для широковещательной рассылки сообщений для указанного подмножества подключенных клиентов. Группа может иметь любое количество клиентов, и клиент может быть членом любое количество групп.

Чтобы управлять членством в группах, используйте [добавить](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.add(v=vs.111).aspx) и [удалить](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.remove(v=vs.111).aspx) методы, предоставляемые `Groups` свойство класса концентратора. В следующем примере показан `Groups.Add` и `Groups.Remove` методы, которые используются в методах Hub, которые вызываются из клиентского кода, а затем клиентский код JavaScript, который вызывает их.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample43.cs?highlight=5,10)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample44.js)]

[!code-javascript[Main](hubs-api-guide-server/samples/sample45.js)]

Не нужно явно создавать группы. Фактически группа автоматически создается впервые, укажите его имя в вызове `Groups.Add`, и удаляется при удалении последнего соединения через членство в ней.

Нет никакой интерфейс API для получения список членства в группе или список групп. SignalR отправляет сообщения клиентам и группам на основе [модели pub/sub](http://en.wikipedia.org/wiki/Publish/subscribe), и не поддерживает списки групп или членства в группах. Это позволяет увеличить масштабируемость, так как каждый раз при добавлении узла к веб-ферме, любое состояние, которое поддерживает SignalR для нового узла.

<a id="asyncgroupmethods"></a>

### <a name="asynchronous-execution-of-add-and-remove-methods"></a>Асинхронное выполнение методы Add и Remove

`Groups.Add` И `Groups.Remove` методы асинхронного выполнения. Если вы хотите добавить в группу клиента и немедленно отправить клиенту сообщение с помощью группы, необходимо убедиться, что `Groups.Add` метод завершается первой. В следующем примере кода показано, как это сделать.

**Добавление клиента в группу и затем обмена сообщениями этого клиента**

[!code-csharp[Main](hubs-api-guide-server/samples/sample46.cs?highlight=1,3)]

<a id="grouppersistence"></a>

### <a name="group-membership-persistence"></a>Сохраняемость членство группы

SignalR отслеживает соединения, не пользователей, поэтому, если требуется, чтобы пользователю не проходить в той же группе каждый раз, когда пользователь выполняет подключение, необходимо вызвать `Groups.Add` каждый раз, когда пользователь выполняет новое подключение.

После временной потери связи иногда SignalR можно восстановить подключение автоматически. В этом случае SignalR восстановление то же соединение без создания нового подключения и таким образом, членство в группе клиентских восстанавливается автоматически. Это возможно даже в том случае, если временной приостановки выполнения не в результате перезагрузки сервера или сбой, так как состояние соединения для каждого клиента, в том числе членства в группах, обхода клиенту. Если сервер выйдет из строя и заменяется на новый сервер до истечения времени ожидания соединения, клиент может автоматически подключаться к новому серверу и повторите регистрацию в группах, в которую он входит.

Когда соединение невозможно восстановить автоматически после потери подключения, или если время ожидания соединения или при отключении клиента (например, когда браузер переходит на новую страницу), членство в группах будут потеряны. При очередном подключении будет новое соединение. Для поддержки членства в группах, когда пользователь устанавливает новое соединение, приложение должно отслеживать связи между пользователями и группами, а также восстановить членства в группах каждый раз пользователь устанавливает новое соединение.

Дополнительные сведения о подключениях и переподключения см. в разделе [способ обработки событий время существования подключения в классе концентратора](#connectionlifetime) далее в этом разделе.

<a id="singleusergroups"></a>

### <a name="single-user-groups"></a>Группы в однопользовательском режиме

Приложения, использующие SignalR обычно имеют для отслеживания сопоставлений пользователей и подключений, чтобы узнать, какой пользователь отправил сообщение и какие пользователи должны быть способны получать сообщения. Группы используются в одном из двух шаблонов, часто используемых для соответствующей.

- Группы в однопользовательском режиме.

    Укажите имя пользователя в качестве имени группы и добавление в группу идентификатор текущего подключения каждый раз пользователь подключается или повторном подключении. Для отправки сообщений пользователю отправлять в группу. Недостаток этого метода заключается в том, группе не предоставляют способ выяснить, является ли пользователь сети или вне сети.
- Отслеживать взаимосвязи между имена пользователей и идентификаторов подключений.

    Можно сохранить ассоциацию между именами пользователей и один или несколько идентификаторов подключений в словарь или базы данных и обновить сохраненные данные при каждом его подключении или отключении. Для отправки сообщений пользователю указать идентификаторов подключений. Недостатком этого метода является то, что требуется больше памяти.

<a id="connectionlifetime"></a>

## <a name="how-to-handle-connection-lifetime-events-in-the-hub-class"></a>Как обрабатывать события времени жизни соединений в классе концентратора

Типичные причины для обработки события времени жизни соединения: для отслеживания ли пользователь должен быть подключен или не и для отслеживания сопоставление имен пользователей и идентификаторов подключений. Для выполнения собственного кода клиентам подключать или отключать, переопределите `OnConnected`, `OnDisconnected`, и `OnReconnected` виртуальные методы концентратора класса, как показано в следующем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample47.cs?highlight=3,14,22)]

<a id="onreconnected"></a>

### <a name="when-onconnected-ondisconnected-and-onreconnected-are-called"></a>При вызове OnConnected, OnDisconnected и OnReconnected

Каждый раз, браузер переходит на новую страницу, новое соединение имеет должно устанавливаться, это означает, что будет выполняться SignalR `OnDisconnected` метода, за которым следует `OnConnected` метод. SignalR всегда создает новый идентификатор соединения, если установлено новое соединение.

`OnReconnected` Метод вызывается, когда была временной разрыв подключения, можно автоматически восстановить SignalR, например при кабелем временно отключен и использовать подключение до истечения времени ожидания соединения. `OnDisconnected` Метод вызывается, когда клиент отключен и SignalR не может автоматически подключаться, например когда браузер переходит на новую страницу. Таким образом, возможно последовательность событий для данного клиента — `OnConnected`, `OnReconnected`, `OnDisconnected`; или `OnConnected`, `OnDisconnected`. Вы не увидите последовательность `OnConnected`, `OnDisconnected`, `OnReconnected` для данного соединения.

`OnDisconnected` Домен приложения получает перезапущен или метод не вызывается в некоторых сценариях, например при отказе одного сервера. При другой сервер переходит в оперативный или домен приложений завершает его повторный запуск, некоторые клиенты могут быть возможность повторного подключения и инициировать `OnReconnected` событий.

Дополнительные сведения см. в разделе [понимание и обработка события времени жизни соединений в SignalR](handling-connection-lifetime-events.md).

<a id="nocallerstate"></a>

### <a name="caller-state-not-populated"></a>Состояние вызывающего объекта не заполнен

Методы обработчиков событий времени существования соединения вызываются на сервере, это означает, что любое состояние, которое необходимо поместить в `state` объекта на стороне клиента не заполняется в `Caller` свойство на сервере. Сведения о `state` объекта и `Caller` свойство, в разделе [передача состояния между клиентами и классу Hub](#passstate) далее в этом разделе.

<a id="contextproperty"></a>

## <a name="how-to-get-information-about-the-client-from-the-context-property"></a>Как получить информацию о клиенте из контекстного свойства

Чтобы получить сведения о клиенте, используйте `Context` свойство класса концентратора. `Context` Возвращает [HubCallerContext](https://msdn.microsoft.com/library/jj890883(v=vs.111).aspx) объект, который предоставляет доступ к следующим данным:

- Идентификатор подключения вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample48.cs?highlight=1)]

    Идентификатор подключения — это GUID, назначаемый SignalR (в собственном коде невозможно задать значение). Имеется один идентификатор подключения для каждого подключения и то же подключение, при наличии нескольких концентраторов в своем приложении код используется всех концентраторов.
- Данные заголовка HTTP.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample49.cs?highlight=1)]

    Можно также получить HTTP-заголовки от `Context.Headers`. Несколько ссылок на одно и то же самое обусловлено тем, `Context.Headers` была создана, во-первых, `Context.Request` свойство было добавлено более поздней версии, и `Context.Headers` было сохранено для обратной совместимости.
- Запрос данных строки.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample50.cs?highlight=1)]

    Можно также получить строку запроса из `Context.QueryString`.

    Строка запроса, вы получаете в это свойство является тот, который был использован с HTTP-запроса, установленного подключения SignalR. Можно добавлять параметры строки запроса в клиенте, настраивая соединение, которое является удобным способом для передачи данных о клиенте от клиента к серверу. В примере показан один из способов добавления строки запроса в клиенте JavaScript при использовании созданного прокси.

    [!code-javascript[Main](hubs-api-guide-server/samples/sample51.js?highlight=1)]

    Дополнительные сведения о настройке параметров строки запроса см. в разделе руководства по API для [JavaScript](hubs-api-guide-javascript-client.md) и [.NET](hubs-api-guide-net-client.md) клиентов.

    Можно найти метод транспорта, используемый для соединения в данные строки запроса, а также некоторые значения, используются внутренними механизмами SignalR:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample52.cs)]

    Значение `transportMethod` будет «webSockets», «serverSentEvents», «foreverFrame» или «longPolling». Обратите внимание, что если вы установите это значение `OnConnected` метод обработчика событий, в некоторых сценариях может изначально появиться транспорта значение, которое не является метод окончательного согласованный транспорта для подключения. В этом случае метод вызовет исключение и будет вызван позже при установлении метод окончательного транспорта.
- Файлы cookie.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample53.cs?highlight=1)]

    Можно также получить файлы cookie из `Context.RequestCookies`.
- Сведения о пользователе.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample54.cs?highlight=1)]
- Объект HttpContext для запроса:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample55.cs?highlight=1)]

    Используйте этот метод вместо `HttpContext.Current` для получения `HttpContext` объект для подключения SignalR.

<a id="passstate"></a>

## <a name="how-to-pass-state-between-clients-and-the-hub-class"></a>Передача состояния между клиентами и класс концентратора

Предоставляет клиентский прокси-класс `state` объекта, в котором можно хранить данные, необходимые для передачи на сервер с каждым вызовом метода. На сервере можно получить доступ к данным в `Clients.Caller` свойство в методах Hub, которые называются клиентами. `Clients.Caller` Свойство не заполняется для методы обработки событий время существования подключения `OnConnected`, `OnDisconnected`, и `OnReconnected`.

Создание или обновление данных в `state` объекта и `Clients.Caller` свойство работает в обоих направлениях. Можно обновить значения на сервере, и они передаются обратно клиенту.

В следующем примере клиентский код JavaScript, которая сохраняет состояние для передачи на сервер с каждым вызовом метода.

[!code-javascript[Main](hubs-api-guide-server/samples/sample56.js?highlight=1-2)]

В следующем примере показан эквивалентный код в клиент .NET.

[!code-csharp[Main](hubs-api-guide-server/samples/sample57.cs?highlight=1-2)]

В классе концентратора, можно получить доступ к эти данные в `Clients.Caller` свойство. В примере показан код, который получает состояние говорится в предыдущем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample58.cs?highlight=3-4)]

> [!NOTE]
> Этот механизм для сохранения состояния не предназначен для больших объемов данных, поскольку все символы можно поместить в `state` или `Clients.Caller` свойства обхода с каждого вызова метода. Это полезно для небольших элементов, таких как имена пользователей и счетчики.


В VB.NET или концентратор строгой типизацией, вызывающий объект состояния не может осуществляться через `Clients.Caller`; вместо этого используйте `Clients.CallerState` (впервые появилась в SignalR 2.1):

**С помощью CallerState в C#**

[!code-csharp[Main](hubs-api-guide-server/samples/sample59.cs?highlight=3-4)]

**С помощью CallerState в Visual Basic**

[!code-vb[Main](hubs-api-guide-server/samples/sample60.vb)]

<a id="handleErrors"></a>

## <a name="how-to-handle-errors-in-the-hub-class"></a>Способ обработки ошибок в классе концентратора

Для обработки ошибок, возникающих в методах класса концентратора, воспользуйтесь одним из следующих методов.

- Перенос кода метода в блоки try-catch и войдите в объект исключения. В целях отладки исключения можно отправить клиенту, но для обеспечения безопасности причин отправки подробные сведения на клиентах в рабочей среде не рекомендуется.
- Создание модуля концентраторов конвейера, который будет обрабатывать [OnIncomingError](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubpipelinemodule.onincomingerror(v=vs.111).aspx) метод. В следующем примере показано конвейера модуль, который регистрирует ошибки, затем код в файле Startup.cs, которое вставляет модуль в конвейере концентраторов.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample61.cs)]

    [!code-csharp[Main](hubs-api-guide-server/samples/sample62.cs?highlight=4)]
- Используйте `HubException` класса (появился в SignalR 2). Эта ошибка может быть создано из любого вызова концентратора. `HubError` Конструктор принимает строковое сообщение и объект для хранения дополнительных ошибок данных. SignalR будет автоматически сериализации исключения и отправить его клиенту, где будет использоваться на отклонение или сбой вызова метода концентратора.

    В следующих примерах кода показано, как вызывать `HubException` во время вызова концентратора и как обрабатывать исключение на клиентах JavaScript и .NET.

    **Серверный код, демонстрирующий HubException класса**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample63.cs)]

    **Клиентский код JavaScript, демонстрирующий ответ на вызов HubException в концентраторе**

    [!code-html[Main](hubs-api-guide-server/samples/sample64.html)]

    **.NET клиентского кода, демонстрирующий ответ на вызов HubException в концентраторе**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample65.cs)]

Дополнительные сведения о модулях конвейер концентратора см. в разделе [Настройка конвейера концентраторов](#hubpipeline) далее в этом разделе.

<a id="tracing"></a>

## <a name="how-to-enable-tracing"></a>Как включить трассировку

Чтобы включить трассировку на стороне сервера, добавьте элемент system.diagnostics файла Web.config, как показано в следующем примере:

[!code-html[Main](hubs-api-guide-server/samples/sample66.html?highlight=17-72)]

При запуске приложения в Visual Studio, можно просмотреть журналы в **вывода** окна.

<a id="callfromoutsidehub"></a>

## <a name="how-to-call-client-methods-and-manage-groups-from-outside-the-hub-class"></a>Как вызывать методы клиента групп и управление ими из вне класса концентратора

Для вызова методов клиента от другого класса от класса концентратора, получить ссылку на объект контекста SignalR для концентратора и используйте его для вызова методов на стороне клиента и управление группами.

Следующий пример `StockTicker` класса возвращает объект контекста, сохраняет его в экземпляр класса, сохраняет экземпляр класса в статическое свойство и использует контекст из одноэлементный экземпляр класса для вызова `updateStockPrice` метод на клиентах, которые являются подключение к концентратору с именем `StockTickerHub`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample67.cs?highlight=8,24)]

Если необходимо использовать время несколько контекста в долгоживущих объектов, получить ссылку на один раз и сохраните его, а не получение файла каждый раз. После получения контекста гарантирует, что SignalR отправляет сообщения на клиентах в той же последовательности, в которой свои методы концентратора выполнять клиентские вызовы метода. Учебник, в котором показано, как использовать контекст SignalR концентратора, в разделе [Server широковещательных пакетов с помощью ASP.NET SignalR](../getting-started/tutorial-server-broadcast-with-signalr.md).

<a id="callingclientsoutsidehub"></a>

### <a name="calling-client-methods"></a>Вызов методов клиента

Можно указать, какие клиенты получат RPC, но имеется меньше возможностей, чем при вызове из класса концентратора. Это обусловлено тем, контекст не поддерживается связанной с определенной вызов от клиента, любые методы, требуется знание идентификатор текущего соединения, такие как `Clients.Others`, или `Clients.Caller`, или `Clients.OthersInGroup`, недоступны. Доступны следующие параметры.

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample68.cs)]
- Конкретным клиентом, определяется идентификатор соединения.

    [!code-css[Main](hubs-api-guide-server/samples/sample69.css)]
- Все подключенные клиенты, кроме указанным клиентам, определяемый по идентификатору соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample70.cs)]
- Все подключенные клиенты в указанной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample71.css)]
- Все подключенные клиенты в указанной группе, кроме указанным клиентам, определяемый по идентификатору соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample72.cs)]

При вызове в класс без концентратора с помощью методов в классе концентратора, можно передать идентификатор текущего соединения и использовать его с `Clients.Client`, `Clients.AllExcept`, или `Clients.Group` для имитации `Clients.Caller`, `Clients.Others`, или `Clients.OthersInGroup`. В следующем примере `MoveShapeHub` класс передает идентификатор соединения для `Broadcaster` класса, чтобы `Broadcaster` имитирует класс `Clients.Others`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample73.cs?highlight=12,36)]

<a id="managinggroupsoutsidehub"></a>

### <a name="managing-group-membership"></a>Управление членством в группе

Для управления группами имеют те же параметры, как в класс концентратора.

- Добавление клиента в группу

    [!code-csharp[Main](hubs-api-guide-server/samples/sample74.cs)]
- Удаление клиента из группы

    [!code-css[Main](hubs-api-guide-server/samples/sample75.css)]

<a id="hubpipeline"></a>

## <a name="how-to-customize-the-hubs-pipeline"></a>Настройка конвейера концентраторы

SignalR позволяет ввести собственный код в конвейер концентратора. Ниже приведен пример пользовательский модуль конвейер концентратора, который регистрирует каждого входящего вызова метода, полученные от клиента и исходящий вызов метод вызван на клиенте.

[!code-csharp[Main](hubs-api-guide-server/samples/sample76.cs)]

В следующем примере кода в *файла Startup.cs* файл регистрирует модуль для выполнения в конвейер концентратора:

[!code-csharp[Main](hubs-api-guide-server/samples/sample77.cs?highlight=3)]

Существует множество различных методов, которые можно переопределить. Полный список см. в разделе [HubPipelineModule методы](https://msdn.microsoft.com/library/jj918633(v=vs.111).aspx).
