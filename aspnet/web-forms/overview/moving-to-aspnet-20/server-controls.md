---
uid: web-forms/overview/moving-to-aspnet-20/server-controls
title: Серверные элементы управления | Документы Microsoft
author: microsoft
description: ASP.NET 2.0 повышает серверных элементов управления различными способами. В этом модуле будет обсуждаться ряд архитектурных изменений способом ASP.NET 2.0 и Visual Studio 200...
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2005
ms.topic: article
ms.assetid: 43f6ac47-76fc-4cf7-8e9f-c18ce673dfd8
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/server-controls
msc.type: authoredcontent
ms.openlocfilehash: 72e9cac7cf9a01791c30783fa56ad7ea205a5a11
ms.sourcegitcommit: a510f38930abc84c4b302029d019a34dfe76823b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2018
ms.locfileid: "28885197"
---
<a name="server-controls"></a>Серверные элементы управления
====================
по [Microsoft](https://github.com/microsoft)

> ASP.NET 2.0 повышает серверных элементов управления различными способами. В этом модуле будет обсуждаться ряд архитектурных изменений, так же как ASP.NET 2.0 и Visual Studio 2005 обрабатывает серверных элементов управления.


ASP.NET 2.0 повышает серверных элементов управления различными способами. В этом модуле будет обсуждаться ряд архитектурных изменений, так же как ASP.NET 2.0 и Visual Studio 2005 обрабатывает серверных элементов управления.

## <a name="view-state"></a>Состояние представления

Основное изменение в состоянии представления в ASP.NET 2.0 является к значительному сокращению размера. Рассмотрим страницы с использованием только управления календаря на нем. Вот состояние представления в ASP.NET версии 1.1.

[!code-css[Main](server-controls/samples/sample1.css)]

Теперь Вот состояние представления на странице идентичными в ASP.NET 2.0.

[!code-css[Main](server-controls/samples/sample2.css)]

Это очень значительное изменение, и учитывая передаваемые состояния просмотра вперед и назад по линии связи, это изменение может предоставить разработчикам увеличивая производительность. Уменьшение размера состояния представления является главным образом из-за способ, которым мы обработать внутренним образом. Помните, что строка в кодировке Base64 находится в состоянии представления. Чтобы лучше понять изменения в состоянии представления в ASP.NET 2.0, давайте взглянем на расшифрованных значений из приведенных выше примерах.

Вот декодировать состояние 1.1 представления:

[!code-css[Main](server-controls/samples/sample3.css)]

Это может выглядеть немного как непонятен, но здесь закономерность. В ASP.NET 1.x, мы использовать одиночные символы для идентификации типов данных и использование значений с разделителями &lt; &gt; символов. В примере выше представление состояния «t» представляет три полосы. Три полосы содержит пару ArrayLists («l» представляет ArrayList). Один из этих ArrayLists содержит Int32 («i») со значением 1, второй содержит другой треугольник. Три полосы содержит пару ArrayLists и т. д. Важно помнить — мы используем триплетов, которые содержат пары, мы определить типы данных через буквы, что мы используем &lt; и &gt; символов в качестве разделителей.

В ASP.NET 2.0 состояние представления декодированный выглядит немного по-разному.

[!code-powershell[Main](server-controls/samples/sample4.ps1)]

Следует заметить, огромный изменение внешнего вида состояние декодированный представления. Это изменение имеет несколько архитектуры вещи. Состояние представления в ASP.NET 1.x используемое LosFormatter для сериализации данных. В версии 2.0 мы используем новый класс ObjectStateFormatter. Этот класс был специально разработан для облегчения сериализация и десериализация состояния представления и состояние элемента управления. (Состояние элемента управления будет рассмотрена в следующем разделе.) Существует много преимуществ, изменив метод, с помощью которого сериализация и десериализация выполняются. Одним из наиболее серьезных является тот факт, что в отличие от LosFormatter, который использует TextWriter, ObjectStateFormatter использует BinaryWriter. Это позволяет ASP.NET 2.0 для сохранения состояния представления последовательность байтов, а не строк. Возьмем, например, целое число. В ASP.NET версии 1.1 целое число обязательных 4 байта состояния просмотра. В ASP.NET 2.0 же целого числа требуется только 1 байт. Для уменьшения объема состояния представления, которое хранится были внесены другие улучшения. Значения даты и времени, например, теперь хранятся с использованием TickCount вместо строки.

Как если бы все это не были достаточно, уплаченной особое внимание тот факт, что один из наиболее потребителям состояния просмотра 1.x был DataGrid и схожих элементов управления. Основной недостаток элементов управления, такие как DataGrid, где связано состояние представления — он часто содержит большое количество повторяющихся информации. В ASP.NET 1.x, повторяться сведения просто был сохранен и снова в результате чего состояния просмотра перегруженными. В ASP.NET 2.0 новый класс IndexedString используется для хранения таких данных. Если строка повторяется, мы просто хранить маркер IndexedString и индекс в выполняемой таблице объектов IndexedString.

## <a name="control-state"></a>Состояние элемента управления

Один из основных gripes, которые разработчики были состояния представления был размер, добавленный в полезные данные HTTP. Как упоминалось ранее, наибольшее потребители состояния просмотра, он элемента управления DataGrid. Во избежание огромные объемы состояния представления, созданные в элемент управления DataGrid, многие разработчики просто отключить состояние просмотра для этого элемента управления. К сожалению это решение не всегда было вполне уместно. Состояние представления в ASP.NET 1.x содержит не только данные, необходимые для правильного функционирования элемента управления. Он также содержит сведения, касающиеся состояние элемента управления пользовательского интерфейса. Это означает, что если вы хотите разрешить для разбиения на страницы в DataGrid, даже если все данные пользовательского интерфейса, просмотр не требуется, необходимо включить состояние представления состояния содержит. Это подразумевает сценарий.

В ASP.NET 2.0 состояние элемента управления решает эту проблему, хорошо через выходом состояние элемента управления. Состояние элемента управления с данными, совершенно необходима для правильной работы элемента управления. В отличие от состояния представления состояние элемента управления нельзя отключить. Таким образом важно тщательно управляется данные, сохраняемые в состоянии элемента управления.

> [!NOTE]
> Состояние элемента управления сохраняется вместе с состоянием представления в \_ \_VIEWSTATE скрытое поле формы.


Этот видеоролик — Пошаговое руководство по состояние представления и состояние элемента управления.


![](server-controls/_static/image1.png)


[Откройте весь экран](server-controls/_static/state1.wmv)


Чтобы серверному элементу управления для управления состоянием чтения и записи необходимо выполнить три действия.

## <a name="step-1-call-the-registerrequirescontrolstate-method"></a>Шаг 1: Вызовите метод RegisterRequiresControlState

Метод RegisterRequiresControlState сообщает ASP.NET, необходимость элемента управления для сохранения состояния управления. Он принимает один аргумент типа элемента управления, который элемент управления, который регистрируется.

Это важно отметить, что регистрации не сохраняется от запроса для запроса. Таким образом этот метод должен вызываться при каждом запросе Если элемент управления для сохранения состояния управления. Метод вызывать в OnInit рекомендуется.

[!code-csharp[Main](server-controls/samples/sample5.cs)]

## <a name="step-2-override-savecontrolstate"></a>Шаг 2: Переопределение SaveControlState

Метод SaveControlState сохраняет изменения состояния элемента управления элемента управления с момента последней передачи данных. Возвращает объект, представляющий состояние элемента управления.

## <a name="step-3-override-loadcontrolstate"></a>Шаг 3: Переопределение LoadControlState

Метод LoadControlState загружает сохраненное состояние в элемент управления. Метод принимает один аргумент типа Object, содержащий сохраненное состояние элемента управления.

## <a name="full-xhtml-compliance"></a>XHTML полного соответствия

Все веб-разработчиком знает важность стандартов в веб-приложениях. Чтобы сохранить среду разработки, основанную на стандартах, ASP.NET 2.0 полностью — с XHTML. Таким образом все теги, готовый для просмотра в соответствии со стандартами XHTML в браузерах, поддерживающих HTML 4.0 или более поздней.

Определение DOCTYPE в ASP.NET версии 1.1, имел следующий вид:

[!code-html[Main](server-controls/samples/sample6.html)]

В ASP.NET 2.0 определение default DOCTYPE выглядит следующим образом:

[!code-html[Main](server-controls/samples/sample7.html)]

Если выбрано, можно изменить соответствия XHML по умолчанию через узел xhtmlConformance в файле конфигурации. Например следующий узел в файле web.config изменится XHTML соответствие XHTML 1.0 Strict:

[!code-xml[Main](server-controls/samples/sample8.xml)]

Если выбрано, можно также настроить ASP.NET для использования устаревших конфигурацию, используемую в ASP.NET 1.x следующим образом:

[!code-xml[Main](server-controls/samples/sample9.xml)]

## <a name="adaptive-rendering-using-adapters"></a>Адаптивной отрисовки, с помощью адаптеров

В ASP.NET 1.x, файле конфигурации содержится &lt;browserCaps&gt; раздел, который заполняется объект HttpBrowserCapabilities. Этот объект может разработчику возможность определить, какое устройство успешно конкретный запрос и отображать код соответствующим образом. В ASP.NET 2.0 модель улучшен и теперь использует новый класс ControlAdapter. Класс ControlAdapter переопределяет события жизненного цикла элемента управления и элементы управления для подготовки к просмотру элементов управления на основе возможности агента пользователя. Файл определения браузера (файл с расширением файла с расширением BROWSER), хранящиеся в c:\windows\microsoft.net\framework\v2.0 определяется возможности конкретного агента пользователя. \* \* \* \*\CONFIG\Browsers папки.

> [!NOTE]
> Класс ControlAdapter является абстрактным классом.


Как &lt;browserCaps&gt; раздела 1.x в файле определения браузера регулярное выражение используется для разбора строки агента пользователя для идентификации запрашивающему браузеру. Он их определяет возможности, определенного для этого агента пользователя. ControlAdapter отображает элемент управления через метод Render. Таким образом Если переопределить метод Render, не следует вызывать отрисовки в базовом классе. Это может привести к визуализации дважды, один раз для адаптера, один для самого элемента управления.

## <a name="developing-a-custom-adapter"></a>Разработка настраиваемого адаптера

Можно разработать собственный пользовательский адаптер путем наследования от ControlAdapter. Кроме того можно наследовать от абстрактного класса PageAdapter в случаях, где требуется адаптер для страницы. Сопоставление элементов управления и адаптера пользовательские действия выполняются с помощью &lt;controlAdapters&gt; элемент в файле определения браузера. Например следующий XML из файла описания браузера отображается элемент управления меню класс MenuAdapter:

[!code-html[Main](server-controls/samples/sample10.html)]

С помощью этой модели, становится очень просто разработчик элемента управления, предназначенную для конкретного устройства или браузера. Это довольно просто разработчику полный контроль над страницы подготовки к просмотру на каждом устройстве.

## <a name="per-device-rendering"></a>Отрисовка на устройство

Свойства серверного элемента управления в ASP.NET 2.0 может быть указанного на устройство с помощью префикса обозревателем. Например приведенный ниже код изменит текст метки, в зависимости от того, какое устройство используется для просмотра страницы.

[!code-aspx[Main](server-controls/samples/sample11.aspx)]

При просмотре страницы, содержащей эту метку из Internet Explorer метка будет отображать текст, о том, «При переходе из Internet Explorer.» При просмотре страницы в Firefox, будет отображена надпись текст «Просмотр выполняется с Firefox.» При просмотре страницы с любого другого устройства будет отображаться «При переходе от неизвестного устройства.» С помощью этого синтаксиса можно указать любое свойство.

## <a name="setting-focus"></a>Установка фокуса

Разработчики ASP.NET 1.x и ответы о способах установки начального фокуса на определенный элемент управления. Например на странице входа, полезно иметь текстовое поле ИД пользователя получить фокус, при первой загрузке страницы. В ASP.NET 1.x, таким образом необходимые записи некоторых клиентского скрипта. Несмотря на то, что такого сценария является тривиальным, его нет необходимости в ASP.NET 2.0 благодаря метода SetFocus. Метод SetFocus принимает один аргумент, указывающее, элемент управления, который должен получить фокус. Этот аргумент может быть идентификатор клиента элемента управления в виде строки или имя серверного элемента управления как объект элемента управления. Например, чтобы задать исходный фокус на элемент управления TextBox с именем txtUserID при первой загрузке страницы, добавьте следующий код к странице\_нагрузки:

[!code-csharp[Main](server-controls/samples/sample12.cs)]

--или

[!code-csharp[Main](server-controls/samples/sample13.cs)]

ASP.NET 2.0 использует дескриптор Webresource.axd (как описано ранее) для отображения клиентской функции, которая устанавливает фокус ввода. Имя клиентской функции — WebForm\_AutoFocus, как показано ниже:

[!code-html[Main](server-controls/samples/sample14.html)]

Кроме того можно использовать метод фокуса для элемента управления для установки начального фокуса на этот элемент управления. Метод фокус является производным от класса элемента управления и доступна для всех элементов управления ASP.NET 2.0. Можно также установить фокус на определенный элемент управления, при возникновении ошибки проверки. Который будет рассматриваться в более поздней версии модуля.

## <a name="new-server-controls-in-aspnet-20"></a>Новые элементы управления сервера ASP.NET 2.0

Ниже приведены новые серверные элементы управления в ASP.NET 2.0. Давайте более подробно на некоторые из них в модулях, более поздней версии.

## <a name="imagemap-control"></a>Управления ImageMap

Управления ImageMap позволяет добавлять точки беспроводного доступа, можно инициировать обратной передачи или перейти на URL-адрес изображения. Доступны три типа точек беспроводного доступа; CircleHotSpot RectangleHotSpot и PolygonHotSpot. Точки беспроводного доступа добавляются через редактор коллекции в Visual Studio, или программно в коде. Нет пользовательского интерфейса для рисования точки беспроводного доступа на изображении. Координаты и размера или radius гиперобъекта должно быть указано декларативно. Имеется также не визуальное представление активную область в конструкторе. Если активная область настроена для перехода на URL-адрес, URL-адрес указываются с помощью свойства NavigateUrl гиперобъекта. В случае отправки обратно гиперобъектов PostBackValue, свойство позволяет передавать строку в обратной передачи, которые можно получить в коде на стороне сервера.


![Редактор коллекции гиперобъектов в Visual Studio](server-controls/_static/image1.jpg)

**Рис. 1**: редактор коллекции гиперобъектов в Visual Studio


## <a name="bulletedlist-control"></a>Элемент управления маркированный список

Элемент списка BulletedList — маркированный список, который может быть легко с привязкой к данным. Список может быть упорядочен (нумерованные) или неупорядоченную через свойство BulletStyle. Каждый элемент в списке представлен объект ListItem.


![Элемент управления маркированный список в Visual Studio](server-controls/_static/image1.gif)

**На рисунке 2**: элемент управления маркированный список в Visual Studio


## <a name="hiddenfield-control"></a>Элемент управления HiddenField

Управления HiddenField добавляет скрытое поле формы к странице, значение которого доступен в коде на стороне сервера. Значение скрытого поля формы, обычно ожидается остаются неизменными на пути от операции обратной. Тем не менее злонамеренный пользователь может изменить значение предварительного обратную. В этом случае элемент управления HiddenField инициирует событие ValueChanged. Если имеется конфиденциальные сведения в элементе управления HiddenField и вы хотите убедиться, что он остается неизменным, должен обрабатывать событие ValueChanged в коде.

## <a name="fileupload-control"></a>Элемент управления fileUpload

Управления FileUpload в ASP.NET 2.0 позволяет отправить файлы на веб-сервере через страницы ASP.NET. Этот элемент управления похож на класс HtmlInputFile ASP.NET 1.x за некоторыми исключениями. В ASP.NET 1.x, рекомендовалось проверяется свойство PostedFile на равенство null для определения того, если имеется файл просто. Элемент управления FileUpload в ASP.NET 2.0 добавляет новое свойство HasFile, можно использовать для той же цели, и более эффективно.

Свойство PostedFile по-прежнему доступен для доступа к объекту HttpPostedFile, но некоторые функции HttpPostedFile теперь доступен по своей природе с элементом управления FileUpload. Например, чтобы сохранить загруженный файл в ASP.NET 1.x, можно вызвать метод SaveAs HttpPostedFile объекта. В ASP.NET 2.0 с помощью элемента управления FileUpload, будет вызван метод SaveAs на сам элемент управления FileUpload.

Еще одно важное изменение в 2.0 поведение (и, вероятно, наиболее значительное изменение) — это больше не требуется загрузить загруженный файл целиком в память перед сохранением. В 1.x, любой файл, который был загружен сохраняется целиком в память до записи на диск. Такая архитектура предотвращает передача больших файлов.

В ASP.NET 2.0 requestLengthDiskThreshold атрибут элемента httpRuntime позволяет настроить какое количество килобайтов, помещаются в буфер в памяти до записи на диск.

**ВАЖНЫЕ**: документация MSDN (и в других местах документации) указывает, что это значение задается в байтах (не килобайт), значение по умолчанию — 256. Фактически значение указывается в килобайтах и значение по умолчанию — 80. Когда значение по умолчанию 80 КБ, убедитесь, что буфер не попадут в куче больших объектов.

## <a name="wizard-control"></a>Мастер управления

Это довольно часто возникают разработчиков ASP.NET, стараясь при попытке получить информацию в ряду «страниц» с помощью панелей или посредством перемещения между страницами. Чаще всего процесс является утомительным и может занять длительное время. Новый мастер управления позволяет решить проблемы, позволяя линейных и нелинейных шаги в интерфейсе мастера, пользователи знакомы с. Мастер управления формами ввода представляет ряд шагов. Каждый шаг — определенного типа, указанного в свойстве StepType элемента управления. Существуют следующие типы доступных шагов.

| **Тип шага** | **Объяснение** |
| --- | --- |
| Авто | Мастер автоматически определяет тип шага, основываясь на его положение в иерархии шаг. |
| Запуск | Первый шаг, часто используется для представления вводной инструкции. |
| Шаг | Обычный шаг. |
| Готово | И наконец, обычно используется для представления кнопку, чтобы завершить работу мастера. |
| Завершено | Представляет сообщение связи успешное выполнение или сбой. |

> [!NOTE]
> Мастер управления хранит информацию о его состояние с помощью состояния элемента управления ASP.NET. Таким образом свойство EnableViewState можно задать значение false, без любой ущерб.


В этом видеоролике приведен пример элемента управления мастера.


![](server-controls/_static/image2.png)


[Откройте весь экран](server-controls/_static/wizard1.wmv)


## <a name="localize-control"></a>Localize-элемент управления

Элемент управления Localize аналогична текстовым элементом управления. Тем не менее, элемент управления Localize имеет **режим** свойство, которое определяет способ отображения разметку, которая к нему добавляется. Свойство режима поддерживает следующие значения:

| **Режим** | **Объяснение** |
| --- | --- |
| Transform | Разметка преобразуется согласно протоколу запрашивающего браузера. |
| Транзитная пересылка | Разметка подготавливается к просмотру как-является. |
| Кодирование | Разметку, которая добавляется к элементу управления кодируются с помощью HtmlEncode. |

## <a name="multiview-and-view-controls"></a>MultiView элементы управления и представления

Управления MultiView выступает в роли контейнера для элементов управления представления и элементе управления выступает в роли контейнера для других элементов управления (аналогично элемент панели управления). Каждое представление в элемент управления MultiView будет представлен в одном элементе управления представления. Первый элемент управления View в MultiView представления 0, второй — представление 1, и т. д. Указав ActiveViewIndex управления MultiView могут переключать представления.

## <a name="substitution-control"></a>Элемент управления Substitution

Элемент управления Substitution используется в сочетании с кэшированием ASP.NET. В случаях, где вы хотите использовать преимущества кэширования, но у части страницы, который должен быть обновлен при каждом запросе (другими словами, части страницы, будут исключены из кэширования) компонент подстановки предоставляет эффективное решение. Фактически никаких выходных данных сам по себе не выполняет отрисовку элемента управления. Вместо этого он привязывается к методу в серверный код. При запросе страницы вызывается метод и возвращенная разметка подготавливается к просмотру вместо управления substitution.

Метод, к которому привязан элемент управления Substitution указываются с помощью **имя_метода** свойство. Этот метод должен удовлетворять следующим условиям:

- Он должен быть методом статические (совместно используемый в Visual Basic).
- Он принимает один параметр типа HttpContext.
- Он возвращает строку, представляющую разметку, следует заменить элемент управления на странице.

Элемент управления Substitution не имеет возможность изменять любой другой элемент управления на странице, но он имеет доступа к текущий объект HttpContext через его параметр.

## <a name="gridview-control"></a>Элемент управления GridView

Элемент управления GridView является заменой для элемента управления DataGrid. Этот элемент управления рассматриваются более подробно в более поздней версии модуля.

## <a name="detailsview-control"></a>Элемент управления DetailsView

Элемент управления DetailsView позволяет для отображения одной записи из источника данных и изменить или удалить его. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="formview-control"></a>Элемент управления FormView

Элемент управления FormView используется для отображения одной записи из источника данных в интерфейсе можно настроить. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="accessdatasource-control"></a>Элемент управления AccessDataSource

Используется для управления AccessDataSource привязать данные базы данных Access. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="objectdatasource-control"></a>Элемент управления ObjectDataSource

Элемент управления ObjectDataSource используется для поддержки трехуровневая архитектура, чтобы элементы управления могут быть привязкой к данным для среднего уровня бизнес-объект, в отличие от модели двухуровневом где элементы управления привязаны непосредственно к источнику данных. Обсуждаются более подробно в более поздней версии модуля.

## <a name="xmldatasource-control"></a>Управления XmlDataSource

Элемент управления XmlDataSource используется для привязки данных к источнику данных XML. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="sitemapdatasource-control"></a>Элемент управления SiteMapDataSource

Элемент управления SiteMapDataSource предоставляет привязки данных для элементов управления навигацией сайта основании карты сайта. Обсуждаются более подробно в более поздней версии модуля.

## <a name="sitemappath-control"></a>Элемент управления SiteMapPath

Элемент управления SiteMapPath выводит ряд часто называют адресной строки ссылки навигации. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="menu-control"></a>Элемент управления меню

Элемент управления меню отображает динамические меню с помощью DHTML. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="treeview-control"></a>Элемент управления TreeView

TreeView-элемент управления используется для отображения иерархического дерева представлений данных. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="login-control"></a>Элемент управления входа

Элемент управления входа обеспечивает механизм для входа в веб-сайта. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="loginview-control"></a>Элемент управления LoginView

Элемент управления LoginView позволяет отображение различные шаблоны в зависимости от состояния входа пользователя. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="passwordrecovery-control"></a>Элемент управления PasswordRecovery

Управления PasswordRecovery используется для получения забытые пароли пользователей приложения ASP.NET. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="loginstatus"></a>LoginStatus

Элемент управления LoginStatus отображает состояние входа пользователя. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="loginname"></a>LoginName

Элемент управления LoginName отображает определенного пользователя после регистрируются в приложение ASP.NET. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="createuserwizard"></a>CreateUserWizard

CreateUserWizard — это можно настроить мастер, который дает пользователям возможность создавать учетную запись членства ASP.NET для использования в приложении ASP.NET. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="changepassword"></a>Изменение пароля

Элемент управления ChangePassword позволяет пользователям менять свой пароль для приложения ASP.NET. Он является более подробно рассматривается в более поздней версии модуля.

## <a name="various-webparts"></a>Различные веб-части

ASP.NET 2.0 поставляется с различных веб-частей. Они рассматриваются подробно в более поздней версии модуля.
