---
uid: web-forms/overview/moving-to-aspnet-20/caching
title: "Кэширование | Документы Microsoft"
author: microsoft
description: "Понимание кэширования важно для высокопроизводительных приложений ASP.NET. ASP.NET 1.x предлагаемых три разных параметра для кэширования; кэширование, вывода..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2005
ms.topic: article
ms.assetid: 2bb109d2-e299-46ea-9054-fa0263b59165
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/caching
msc.type: authoredcontent
ms.openlocfilehash: 9b229de60e09b94189f62a6bb6fa61a9973d637b
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="caching"></a>Кэширование
====================
по [Microsoft](https://github.com/microsoft)

> Понимание кэширования важно для высокопроизводительных приложений ASP.NET. ASP.NET 1.x предлагаемых три разных параметра для кэширования; кэширование вывода, фрагментарное кэширование и API кэша.


Понимание кэширования важно для высокопроизводительных приложений ASP.NET. ASP.NET 1.x предлагаемых три разных параметра для кэширования; кэширование вывода, фрагментарное кэширование и API кэша. ASP.NET 2.0 предлагает все эти три метода, но добавляет некоторые важные дополнительные функции. Существует несколько новые зависимости кэша и разработчики получили возможность создания пользовательских зависимостей кэша также. Настройка кэширования также были значительно улучшены в ASP.NET 2.0.

## <a name="new-features"></a>Новые функции

## <a name="cache-profiles"></a>Профили кэша

Профили кэша позволяют разработчикам определить параметры конкретного кэша, которые затем могут быть применены к отдельным страницам. Например если имеется несколько страниц, срок действия из кэша через 12 часов, можно легко создавать профиль кэша, который может применяться к этим страницам. Чтобы добавить новый профиль кэша, используйте &lt;outputCacheSettings&gt; в файле конфигурации. Например, ниже приведен конфигурации профиль кэша с именем *twoday* , настраивает длительность кэширования 12 часов.

[!code-xml[Main](caching/samples/sample1.xml)]

Чтобы применить этот профиль кэша на определенную страницу, используйте атрибут CacheProfile директивы @ OutputCache, как показано ниже:

[!code-aspx[Main](caching/samples/sample2.aspx)]

## <a name="custom-cache-dependencies"></a>Настраиваемые зависимости кэша

Разработчики ASP.NET 1.x пришел для пользовательских зависимостей кэша. В ASP.NET 1.x, класс CacheDependency была запечатана предотвращено разработчики свои собственные классы на его основе. В ASP.NET 2.0 это ограничение удаляется, и разработчики могут разрабатывать собственные настраиваемые зависимости кэша. Класс CacheDependency позволяет создавать зависимости пользовательского кэша на основе файлов, каталогов или ключей кэша.

Например приведенный ниже код создает новую зависимость пользовательского кэша на основе файла с именем stuff.xml, находящийся в корне веб-приложения:

[!code-csharp[Main](caching/samples/sample3.cs)]

В этом случае при изменении файла stuff.xml кэшированный элемент является недопустимым.

Можно также создать зависимость пользовательского кэша с помощью ключей кэша. При использовании этого метода для удаления ключа кэша станут недействительными кэшированные данные. Это показано в приведенном ниже примере.

[!code-csharp[Main](caching/samples/sample4.cs)]

Требуется сделать недействительной элемент, который был вставлен выше, просто удалите элемент, который был вставлен в кэш в качестве ключа кэша.

[!code-csharp[Main](caching/samples/sample5.cs)]

Обратите внимание, что ключ элемента, который выступает в качестве ключа кэша должен быть таким же, как значение, добавляемое в массив ключей кэша.

## <a name="polling-based-sql-cache-dependenciesalso-called-table-based-dependencies"></a>На основе опроса зависимости кэша SQL*(также называемые зависимости на основе таблиц)*

SQL Server 7 и 2000 используют модель на основе опроса для зависимости кэша SQL. Модель на основе опроса триггер в таблицу базы данных, которое вызывается при изменении данных в таблице. Запускать обновления **changeId** в таблице уведомлений, который периодически проверяет ASP.NET. Если **changeId** поле было обновлено, ASP.NET знает, что данные были изменены, и он делает недействительными кэшированные данные.

> [!NOTE]
> Модель на основе опроса можно также использовать SQL Server 2005, но модель на основе опроса не является наиболее эффективным, то рекомендуется использовать модель на основе запроса (см. описание далее) с SQL Server 2005.


В порядке зависимости кэша SQL, для правильной работы с помощью модели на основе опроса для таблицы должны иметь включены уведомления. Это можно сделать программно с помощью класса SqlCacheDependencyAdmin или с помощью aspnet\_regsql.exe программы.

Следующая команда регистрирует таблице Products в базе данных Northwind, размещенной на экземпляре SQL Server с именем *dbase* зависимости кэша SQL.

[!code-console[Main](caching/samples/sample6.cmd)]

Ниже приведено описание параметров командной строки, используемый в предыдущей команде.

| **Параметр командной строки** | **Назначение** |
| --- | --- |
| -S *server* | Указывает имя сервера. |
| -ed | Указывает, что базы данных должен быть включен для функции зависимости в кэше SQL. |
| -d *базы данных\_имя* | Указывает имя базы данных, должна быть включена для зависимости в кэше SQL. |
| -E | Указывает, что aspnet\_regsql следует использовать проверку подлинности Windows при подключении к базе данных. |
| -et | Указывает, что мы включается таблицу базы данных для функции зависимости в кэше SQL. |
| -t *таблицы\_имя* | Задает имя таблицы для включения зависимости кэша SQL для базы данных. |

> [!NOTE]
> Нет других параметров, доступных для aspnet\_regsql.exe. Полный список запуска aspnet\_regsql.exe-? из командной строки.


При выполнении этой команды происходят следующие изменения в базу данных SQL Server:

- **AspNet\_SqlCacheTablesForChangeNotification** будет добавлена таблица. Эта таблица содержит по одной строке для каждой таблицы в базе данных, для которой включено зависимостью от кэша SQL.
- Следующие хранимые процедуры создаются внутри модели базы данных.


| AspNet\_SqlCachePollingStoredProcedure | Запрашивает AspNet\_SqlCacheTablesForChangeNotification таблицу и возвращает все таблицы, для которых включена поддержка зависимости кэша SQL, а значение changeId для каждой таблицы. Данная хранимая процедура используется для опроса для определения того, если данные были изменены. |
| --- | --- |
| AspNet\_SqlCacheQueryRegisteredTablesStoredProcedure | Возвращает все таблицы, включенных для функции зависимости кэша SQL запросив AspNet\_SqlCacheTablesForChangeNotification таблицу и возвращает все таблицы включен для SQL зависимости кэша. |
| AspNet\_SqlCacheRegisterTableStoredProcedure | Регистрирует зависимости кэша SQL для таблицы, добавив необходимые записи в таблице уведомлений и добавляет триггер. |
| AspNet\_SqlCacheUnRegisterTableStoredProcedure | Отменяет регистрацию зависимости кэша SQL для таблицы, удалив записи в таблице уведомлений и удаляет триггер. |
| AspNet\_SqlCacheUpdateChangeIdStoredProcedure | Обновляет таблицу уведомлений, увеличивая changeId с измененной таблицей. ASP.NET использует это значение для определения, если данные были изменены. Как показано ниже, данная хранимая процедура выполняется с помощью триггера, созданная при включении таблицы. |


- Триггер SQL Server вызывается ***таблицы\_имя *\_AspNet\_SqlCacheNotification\_триггер** создается для таблицы. Этот триггер выполняет AspNet\_SqlCacheUpdateChangeIdStoredProcedure при выполнении инструкции INSERT, UPDATE или DELETE для таблицы.
- Роль SQL Server называется **aspnet\_ChangeNotification\_ReceiveNotificationsOnlyAccess** добавляется в базу данных.

**Aspnet\_ChangeNotification\_ReceiveNotificationsOnlyAccess** роли SQL Server имеет разрешения EXEC для AspNet\_SqlCachePollingStoredProcedure. Чтобы модель опроса работал правильно, необходимо добавить учетной записи процесса для aspnet\_ChangeNotification\_ReceiveNotificationsOnlyAccess роли. Aspnet\_regsql.exe средство будет выполнить эту задачу.

### <a name="configuring-polling-based-sql-cache-dependencies"></a>Настройка зависимости кэша SQL на основе опроса

Существуют несколько шагов, которые требуются для настройки на основе опроса зависимостей кэша SQL. Первым шагом является включение базы данных и таблицы, как описано выше. После завершения этого шага остальной конфигурацией выглядит следующим образом:

- Настройка файла конфигурации ASP.NET.
- Настройка SqlCacheDependency

### <a name="configuring-the-aspnet-configuration-file"></a>Настройка файла конфигурации ASP.NET

Помимо добавления строки подключения, как описано в предыдущем модуле, необходимо также настроить &lt;кэша&gt; элемент с &lt;sqlCacheDependency&gt; элемента, как показано ниже:

[!code-xml[Main](caching/samples/sample7.xml)]

Такая конфигурация обеспечивает зависимость кэша SQL на *pubs* базы данных. Обратите внимание, что атрибут pollTime &lt;sqlCacheDependency&gt; элемент по умолчанию на 60 000 миллисекунд или 1 минута. (Это значение не может быть меньше 500 миллисекунд). В этом примере &lt;добавить&gt; элемент добавляет новую базу данных и переопределяет pollTime, параметру 9000000 миллисекунд.

#### <a name="configuring-the-sqlcachedependency"></a>Настройка SqlCacheDependency

Следующий шаг — Настройка SqlCacheDependency. Самый простой способ сделать это является указание значения для атрибута SqlDependency в директиве @ Outcache следующим образом:

[!code-aspx[Main](caching/samples/sample8.aspx)]

В директиве @ OutputCache выше зависимость кэша SQL настроена для *авторов* в таблицу *pubs* базы данных. Можно настроить несколько зависимостей, разделяя их точкой с запятой следующим образом:

[!code-aspx[Main](caching/samples/sample9.aspx)]

Другой способ настройки SqlCacheDependency — сделать это программным способом. В следующем коде создается новая зависимость кэша SQL на *авторов* в таблицу *pubs* базы данных.

[!code-csharp[Main](caching/samples/sample10.cs)]

Одним из преимуществ программным способом определения зависимость кэша SQL является, что может обрабатывать все исключения, которые могут возникнуть. Например, при попытке определить зависимости кэша SQL для базы данных, который не был включен для уведомлений **DatabaseNotEnabledForNotificationException** будет создано исключение. В этом случае можно попытаться разрешить для базы данных уведомления путем вызова **SqlCacheDependencyAdmin.EnableNotifications** метод и передает имя базы данных.

Аналогично, при попытке определить зависимости кэша SQL для таблицы, которая не была включена для уведомлений, **TableNotEnabledForNotificationException** будет создано. Затем можно вызвать **SqlCacheDependencyAdmin.EnableTableForNotifications** метод имя базы данных и имя таблицы.

В следующем образце кода показано, как правильно настроить обработку исключений при настройке зависимости кэша SQL.

[!code-csharp[Main](caching/samples/sample11.cs)]

Дополнительные сведения: [https://msdn.microsoft.com/library/t9x04ed2.aspx](https://msdn.microsoft.com/library/t9x04ed2.aspx)

## <a name="query-based-sql-cache-dependencies-sql-server-2005-only"></a>Зависимости кэша SQL на основе запроса (только для SQL Server 2005)

При использовании SQL Server 2005 для зависимости кэша SQL, модели на основе опроса не требуется. При использовании с SQL Server 2005, зависимости кэша SQL связь напрямую через подключения SQL к экземпляру SQL Server (никакая дополнительная настройка не требуется) с помощью уведомлений о запросах SQL Server 2005.

Для включения уведомлений на основе запроса проще всего сделать декларативно, установив **SqlCacheDependency** атрибута объекта источника данных для **CommandNotification** и задание **EnableCaching** атрибут **true**. При использовании этого метода не требуется кода. Если результатом выполнения команды выполняемые в данные изменений источника, он сделает данные кэша.

В следующем примере настраивается элемент управления источником данных для функции зависимости в кэше SQL:

[!code-aspx[Main](caching/samples/sample12.aspx)]

В этом случае, если в запросе указано **SelectCommand** возвращает другой результат, чем оно было сделано ранее, результаты которых кэшируются становятся недействительными.

Можно также указать, что все источники данных включить для зависимости кэша SQL, установите **SqlDependency** атрибут **@ OutputCache** директиву **CommandNotification** . Это показано в приведенном ниже примере.

[!code-aspx[Main](caching/samples/sample13.aspx)]

> [!NOTE]
> Дополнительные сведения на уведомления о запросах в SQL Server 2005 см. в разделе электронной документации по SQL Server.


Другой способ настройки на основе запроса зависимости кэша SQL — делать это программно с помощью класса SqlCacheDependency. В следующем образце кода показано, как это сделать.

[!code-csharp[Main](caching/samples/sample14.cs)]

Дополнительные сведения: [https://msdn.microsoft.com/library/default.asp?url=/library/enus/dnvs05/html/querynotification.asp](https://msdn.microsoft.com/library/default.asp?url=/library/enus/dnvs05/html/querynotification.asp)

## <a name="post-cache-substitution"></a>Подстановка после кэширования

Страница «кэширование» могут значительно повысить производительность веб-приложения. Однако в некоторых случаях необходимо большую часть страницы должен быть кэширован и некоторые фрагменты страницы динамическими. Например при создании страницы новостей, которая является полностью статической в течение заданного периода времени, можно задать кэширование всей страницы. Если необходимо включить чередующееся баннер измененного при каждом запросе страницы, часть страницы, содержащая баннер должен быть динамическим. Позволяет кэшировать страницу, но заменять часть содержимого динамически, можно использовать подстановку после кэширования ASP.NET. При использовании подстановки после кэширования вся страница кэшируется с определенными частями, помеченные как исключена из кэширования. В примере с рекламными объявлениями управления AdRotator позволяет воспользоваться преимуществами подстановки после кэширования, чтобы рекламные объявления динамически создаются для каждого пользователя и для каждого обновления страницы.

Существует три способа реализации подстановки после кэширования:

- Декларативно с помощью управления Substitution.
- Программно с помощью API-Интерфейс управления подстановки.
- Неявно с помощью элемента управления AdRotator.

### <a name="substitution-control"></a>Элемент управления Substitution

Элемент управления ASP.NET Substitution указывает раздел кэшированной страницы, которая создана динамически, чем в кэше. Поместите элемент управления Substitution в местоположение, где динамическое содержимое для отображения на страницы. Во время выполнения элемент управления Substitution вызывает метод, который указывается с помощью свойства MethodName. Метод должен вернуть строку, которая заменит содержимое элемента управления подстановки. Метод должен быть статическим методом cтраницы или UserControl элемента управления. Использование управления substitution приводит клиентские возможности кэширования сервера кэширования, необходимо изменить, чтобы страница не будет кэшироваться на клиенте. Это гарантирует, что последующие запросы на страницу вызвать метод снова для создания динамического содержимого.

### <a name="substitution-api"></a>Подстановка API

Чтобы создать динамическое содержимое для кэшированных страниц программными средствами, можно вызвать [WriteSubstitution](https://msdn.microsoft.com/library/system.web.httpresponse.writesubstitution.aspx) метод в коде страницы, передав имя метода, как параметр. Метод, обрабатывающий создание динамического содержимого принимает один [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) параметр и возвращает строку. Возвращаемая строка представляет содержимое, которое будет использоваться в данном месте. Преимуществом вызова метода WriteSubstitution вместо использования управления Substitution декларативно является, можно вызвать метод любые объекты, а не вызов статического метода страницы или объекта UserControl.

Вызов метода WriteSubstitution вызывает клиентские возможности кэширования сервера кэширования, необходимо изменить, чтобы страница не будет кэшироваться на клиенте. Это гарантирует, что последующие запросы на страницу вызвать метод снова для создания динамического содержимого.

### <a name="adrotator-control"></a>Элемент управления AdRotator

AdRotator, реализуемых серверный элемент управления поддерживает внутренне для подстановки после кэширования. Если поместить элемент управления AdRotator на страницу, он подготавливается к просмотру объявлений, уникальный для каждого запроса, независимо от того, кэшируются ли родительская страница. В результате странице, которая содержит элемент управления AdRotator — только кэшированные стороне сервера.

## <a name="controlcachepolicy-class"></a>Класс ControlCachePolicy

Класс ControlCachePolicy обеспечивает программное управление фрагмент кэширования с помощью пользовательских элементов управления. Пользовательские элементы управления в пределах внедряет ASP.NET [BasePartialCachingControl](https://msdn.microsoft.com/library/system.web.ui.basepartialcachingcontrol.aspx) экземпляра. Класс BasePartialCachingControl представляет пользовательский элемент управления, которая имеет выходные включено кэширование.

При доступе к [BasePartialCachingControl.CachePolicy](https://msdn.microsoft.com/library/system.web.ui.basepartialcachingcontrol.cachepolicy.aspx) свойство [PartialCachingControl](https://msdn.microsoft.com/library/system.web.ui.partialcachingcontrol.aspx) управления, всегда будет получать допустимый объект ControlCachePolicy. Тем не менее при доступе к [UserControl.CachePolicy](https://msdn.microsoft.com/library/system.web.ui.usercontrol.cachepolicy.aspx) свойство [UserControl](https://msdn.microsoft.com/library/system.web.ui.usercontrol.aspx) управления, появляется допустимый объект ControlCachePolicy только в том случае, если пользовательский элемент управления уже оболочкой Элемент управления BasePartialCachingControl. Если она не переносится, при попытке управлять ими, так как он не имеет связанного BasePartialCachingControl ControlCachePolicy объекта, возвращаемого свойством породят исключения. Чтобы определить, поддерживает ли экземпляр пользовательского элемента управления, кэширование без появления исключения, проверить [SupportsCaching](https://msdn.microsoft.com/library/system.web.ui.controlcachepolicy.supportscaching.aspx) свойство.

С помощью класса ControlCachePolicy является одним из следующих способов, которые можно включить кэширование вывода. Ниже перечислены методы, которые можно использовать, чтобы включить кэширование вывода.

- Используйте [@ OutputCache](https://msdn.microsoft.com/library/hdxfb6cy.aspx) директивы для включения кэширования в декларативных сценариях выводимых данных.
- Используйте [PartialCachingAttribute](https://msdn.microsoft.com/library/system.web.ui.partialcachingattribute.aspx) атрибут, чтобы включить кэширование для пользовательского элемента управления в файле кода.
- Класс ControlCachePolicy используется для указания параметров кэша в программных сценариев, в которых вы работаете с BasePartialCachingControl экземпляры, которые были кэш включен с помощью одного из предыдущих методов и динамически загружается с помощью [System.Web.UI.TemplateControl.LoadControl](https://msdn.microsoft.com/library/system.web.ui.templatecontrol.loadcontrol.aspx) метод.

Экземпляр ControlCachePolicy успешно осуществляется только между Init и PreRender этапы жизненного цикла. При изменении объекта ControlCachePolicy после стадии PreRender, ASP.NET создает исключение, поскольку любые изменения, внесенные после отрисовки элемента управления не окажет воздействия на самом деле параметры кэша (элемент управления кэшируется на этапе отрисовки). Наконец пользовательский экземпляр элемента управления (и, следовательно, его объект ControlCachePolicy) доступен только для программной обработки при фактической визуализации.

## <a name="changes-to-caching-configuration---the-ltcachinggt-element"></a>Изменения конфигурации, кэширование - &lt;кэширование&gt; элемент

Существуют некоторые изменения в конфигурации кэша в ASP.NET 2.0. &lt;Кэширование&gt; элемент является новым в ASP.NET 2.0 и позволяет вносить изменения в конфигурации кэширования в файле конфигурации. Доступны следующие атрибуты.

| **Элемент** | **Описание** |
| --- | --- |
| **cache** | Необязательный элемент. Определяет параметры глобального кэша приложений. |
| **outputCache** | Необязательный элемент. Задает параметры кэша вывода на уровне приложения. |
| **outputCacheSettings** | Необязательный элемент. Задает параметры кэша вывода, которые могут быть применены к страницам в приложении. |
| **sqlCacheDependency** | Необязательный элемент. Настраивает зависимости кэша SQL для приложения ASP.NET. |

### <a name="the-ltcachegt-element"></a>&lt;Кэша&gt; элемент

Доступны следующие атрибуты в &lt;кэша&gt; элемента:

| **Attribute (XElement Dynamic Property)** (Attribute (динамическое свойство XElement)) | **Описание** |
| --- | --- |
| **disableMemoryCollection** | Необязательный **логическое** атрибута. Возвращает или задает значение, указывающее, отключен ли коллекция памяти кэша, при которой компьютер испытывает нехватку памяти. |
| **disableExpiration** | Необязательный **логическое** атрибута. Возвращает или задает значение, указывающее, отключено ли истечение срока действия кэша. При отключении кэшированных элементов не истекает, и фоновой очистки элементов с истекшим сроком действия кэша не выполняется. |
| **privateBytesLimit** | Необязательный **Int64** атрибута. Возвращает или задает значение, указывающее максимальное число байт исключительного приложения, прежде чем начинается удаление из кэша просроченные элементы и попытке освобождения памяти. Это ограничение включает память, используемая кэшем как, так и обычных память, потребляемую выполняющегося приложения. Значение 0 указывает, что ASP.NET будет использовать собственную эвристику для определения ситуаций, когда следует начать высвобождение памяти. |
| **percentagePhysicalMemoryUsedLimit** | Необязательный **Int32** атрибута. Возвращает или задает значение, указывающее максимальную долю физической памяти компьютера, которые могут использоваться приложением перед начинается удаление из кэша просроченные элементы и попытке освобождения памяти, что оба памяти, кэша, а также включает использование этой памяти как использование обычной памяти работающего приложения. Значение 0 указывает, что ASP.NET будет использовать собственную эвристику для определения ситуаций, когда следует начать высвобождение памяти. |
| **privateBytesPollTime** | Необязательный **TimeSpan** атрибута. Возвращает или задает значение, указывающее временной интервал между опросами для байтов исключительного пользования потребления памяти. |

### <a name="the-ltoutputcachegt-element"></a>&lt;OutputCache&gt; элемент

Следующие атрибуты, доступные для &lt;outputCache&gt; элемента.

| **Attribute (XElement Dynamic Property)** (Attribute (динамическое свойство XElement)) | **Описание** |
| --- | --- |
| **enableOutputCache** | Необязательный **логическое** атрибута. Включает или отключает кэшем вывода страниц. Если отключены, кэширование страниц не выполняется независимо от того, программные или декларативные параметры. Значение по умолчанию — **true**. |
| **enableFragmentCache** | Необязательный **логическое** атрибута. Включает или отключает кэширование фрагмента приложения. Если отключены, кэширование страниц не выполняется независимо от [@ OutputCache](https://msdn.microsoft.com/library/hdxfb6cy.aspx) директива или профиль, используемый кэширования. Включает заголовок управления кэшем, указывающее, что вышестоящие прокси-серверы, а также клиенты браузера не следует пытаться вывода страниц кэша. Значение по умолчанию — **false**. |
| **sendCacheControlHeader** | Необязательный **логическое** атрибута. Возвращает или задает значение, указывающее ли **кэша-элемент управления: private** заголовок отправляется модулем выходного кэша по умолчанию. Значение по умолчанию — **false**. |
| **omitVaryStar** | Необязательный **логическое** атрибута. Включает или отключает отправку Http "**Vary: \*** «заголовок в ответе. По умолчанию равным false, «**Vary: \*** «заголовок отправляется для кэшированных страниц. При отправке заголовка Vary он позволяет для различных версий для кэширования на основе тем, что указывается в заголовке Vary. Например *Vary: пользователь-агентов* будут храниться разные версии страницы, основанный на запрос агента пользователя. Значение по умолчанию — **false**. |

### <a name="the-ltoutputcachesettingsgt-element"></a>&lt;OutputCacheSettings&gt; элемент

&lt;OutputCacheSettings&gt; элемент позволяет создавать кэш профилей, как описано выше. Только дочерний элемент для &lt;outputCacheSettings&gt; элемент &lt;outputCacheProfiles&gt; элемента для настройки профилей кэша.

### <a name="the-ltsqlcachedependencygt-element"></a>&lt;SqlCacheDependency&gt; элемент

Следующие атрибуты, доступные для &lt;sqlCacheDependency&gt; элемента.

| **Attribute (XElement Dynamic Property)** (Attribute (динамическое свойство XElement)) | **Описание** |
| --- | --- |
| **включен** | Требуется **логическое** атрибута. Указывает, будут ли изменения выполняется опрос на наличие. |
| **pollTime** | Необязательный **Int32** атрибута. Задает частоту, с которой SqlCacheDependency опрашивает таблицу базы данных для изменений. Это значение соответствует время в миллисекундах между последовательными pollings. Он не может быть присвоено меньше 500 миллисекунд. Значение по умолчанию — 1 минута. |

### <a name="more-information"></a>Дополнительные сведения

Есть некоторые дополнительные сведения, которые необходимо знать о настройке кэша.

- Если задано ограничение числа байтов исключительного пользования рабочих процессов, кэш с помощью одного из следующих ограничений: 

    - x86 2 ГБ: 800 МБ или 60% физической памяти, какое значение меньше
    - x86 3 ГБ: 1800 МБ или 60% физической памяти, какое значение меньше
    - x 64: 1 ТБ или 60% физической памяти какое значение меньше
- Если оба рабочий процесс закрытый ограничить байт и &lt;кэшировать privateBytesLimit /&gt; настраиваются, кэш будет использовать минимальное из двух.
- Так же, как в 1.x, мы drop записей кэша и вызвать GC. Сбор по двум причинам: 

    - Мы очень приближается предельного количества байтов исключительного пользования
    - Объем доступной памяти near или меньше 10%
- Фактически можно отключить trim и кэшировать в нехватке доступной памяти, задав &lt;кэшировать percentagePhysicalMemoryUseLimit /&gt; до 100.
- В отличие от 1.x, 2.0 будет приостанавливать вызовы функции trim и сбор последней сборки Мусора. Получение была уменьшает байтов исключительного пользования или размер управляемых кучах на более чем на 1% предел памяти (кэш).

## <a name="lab1-custom-cache-dependencies"></a>Lab1: Настраиваемые зависимости кэша

1. Создайте новый веб-сайт.
2. Добавьте новый файл XML с именем cache.xml и сохраните его в корневую папку веб-приложения.
3. Добавьте следующий код к странице\_метод в коде программной части default.aspx нагрузки: 

    [!code-csharp[Main](caching/samples/sample15.cs)]
4. Добавьте следующее в верхней части default.aspx в представлении исходного кода: 

    [!code-aspx[Main](caching/samples/sample16.aspx)]
5. Обзор Default.aspx. Что сообщает время?
6. Обновите страницу в браузере. Что сообщает время?
7. Откройте cache.xml и добавьте следующий код: 

    [!code-xml[Main](caching/samples/sample17.xml)]
8. Сохраните cache.xml.
9. Обновите страницу в браузере. Что сообщает время?
10. Объясняется, почему время изменений вместо отображения ранее кэшированных значений:

## <a name="lab-2-using-polling-based-cache-dependencies"></a>Лабораторное занятие 2: Зависимости кэша на основе опроса с помощью

Эта лаборатория использует проект, созданный в предыдущей модуль, поддерживающий изменение данных в базе данных Northwind с помощью элемента управления GridView и DetailsView.

1. Откройте проект в Visual Studio 2005.
2. Запустите aspnet\_regsql программы в базе данных Northwind, чтобы включить базу данных и таблицы Products. Используйте следующую команду из командной строки Visual Studio: 

    [!code-console[Main](caching/samples/sample18.cmd)]
3. Добавьте следующее в файл web.config: 

    [!code-xml[Main](caching/samples/sample19.xml)]
4. Добавьте новый веб-форма вызывается showdata.aspx.
5. Добавьте следующие @ директивы outputcache на страницу showdata.aspx: 

    [!code-aspx[Main](caching/samples/sample20.aspx)]
6. Добавьте следующий код к странице\_загрузки showdata.aspx: 

    [!code-html[Main](caching/samples/sample21.html)]
7. Добавьте новый элемент управления SqlDataSource showdata.aspx и настройте его для использования подключения к базе данных "Борей". Нажмите кнопку Далее.
8. Установите флажки, ProductName и ProductID и нажмите кнопку Далее.
9. Нажмите кнопку «Готово».
10. Добавьте новый GridView showdata.aspx страницу.
11. Выберите SqlDataSource1 из раскрывающегося списка.
12. Сохраните и обзор showdata.aspx. Запишите время отображения.
