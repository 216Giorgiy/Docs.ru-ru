---
uid: web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
title: Модель ASP.NET 2.0 страницы | Документы Microsoft
author: microsoft
description: В ASP.NET 1.x, разработчики были выбирать между моделью встроенный код и код модели кода. Кода могут быть реализованы с помощью либо attr Src...
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2005
ms.topic: article
ms.assetid: af4575a3-0ae3-4638-ba4d-218fad7a1642
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
msc.type: authoredcontent
ms.openlocfilehash: fda85ec03f845cafa7720382bf85652937932c44
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30891299"
---
<a name="the-aspnet-20-page-model"></a>Модель 2.0 страницы ASP.NET
====================
по [Microsoft](https://github.com/microsoft)

> В ASP.NET 1.x, разработчики были выбирать между моделью встроенный код и код модели кода. Кода может быть реализован с помощью атрибута Src или атрибут CodeBehind @Page директивы. В ASP.NET 2.0 разработчики по-прежнему есть выбор между встроенного кода и кода, но были внесены значительные улучшения модели кода.


В ASP.NET 1.x, разработчики были выбирать между моделью встроенный код и код модели кода. Кода может быть реализован с помощью атрибута Src или атрибут CodeBehind @Page директивы. В ASP.NET 2.0 разработчики по-прежнему есть выбор между встроенного кода и кода, но были внесены значительные улучшения модели кода.

## <a name="improvements-in-the-code-behind-model"></a>Усовершенствования в модели кода

Чтобы полностью понять изменения в модели кода в ASP.NET 2.0, все усилия, чтобы быстро просмотреть модели, как он существовал в ASP.NET 1.x.

## <a name="the-code-behind-model-in-aspnet-1x"></a>Модель фонового кода в ASP.NET 1.x

В ASP.NET 1.x, модель фонового кода включал ASPX-файл (Webform) и файл кода, содержащий программный код. Оба файла были подключены с помощью @Page директив в ASPX-файле. Каждый элемент управления на странице ASPX имели соответствующее объявление в файле кода как переменная экземпляра. Файл кода программной также содержится код для привязки событий и созданный код, необходимый для конструктора Visual Studio. Эта модель работала, довольно хорошо, но поскольку каждый элемент ASPX-страницы ASP.NET требуется соответствующий код в файл кода, была не true разделение кода и содержимое. Например если конструктор добавлен новый серверный элемент управления ASPX-файл вне Visual Studio IDE, приложение будет нарушена из-за отсутствия объявления для этого элемента управления в файле кода.

## <a name="the-code-behind-model-in-aspnet-20"></a>Модель фонового кода ASP.NET 2.0

ASP.NET 2.0 значительно улучшает работу этой модели. В ASP.NET 2.0 кода реализуется с использованием нового *разделяемые классы* в ASP.NET 2.0. Класс кода программной части в ASP.NET 2.0 — definied как разделяемый класс, это означает, что он содержит только часть определения класса. Оставшаяся часть определения класса динамически созданные с помощью страницы ASPX, во время выполнения или при предкомпилированного веб-сайта ASP.NET 2.0. Связь между файл кода программной части и страницы ASPX по-прежнему устанавливается с помощью директивы @ Page. Тем не менее а не атрибут CodeBehind или Src ASP.NET 2.0 теперь использует атрибута CodeFile. Атрибут Inherits также используется для указания имени класса для страницы.

Типичная директива @ Page может выглядеть следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample1.aspx)]

Определение обычной класса в файле кода ASP.NET 2.0 может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample2.cs)]

> [!NOTE]
> C# и Visual Basic — только управляемые языки, которые поддерживают разделяемые классы. Таким образом разработчики, использующие J# нельзя будет использовать модель фонового кода ASP.NET 2.0.


Новая модель расширяет возможности модели кода, так как разработчики получают файлы кода, которые содержат код, который они создали. Он также предоставляет true разделение кода и содержимое из-за объявления переменных не экземпляр в файле кода.

> [!NOTE]
> Так как разделяемый класс для страницы ASPX, где происходит событие привязки разработчики Visual Basic и добиться увеличения спад производительности с ключевым словом дескрипторов в коде для привязки событий. C# имеется нет ключевого слова-эквивалент.


## <a name="new--page-directive-attributes"></a>Новые атрибуты директива @ Page

Директива @ Page ASP.NET 2.0 добавляет много новых атрибутов. В ASP.NET 2.0 появились следующие атрибуты.

## <a name="async"></a>Async

Асинхронный атрибут позволяет настроить страница может выполняться асинхронно. Также охватывает асинхронные страницы позже в этом модуле.

## <a name="asynctimeout"></a>AsyncTimeout

Указанное время ожидания для асинхронных страниц. Значение по умолчанию составляет 45 секунд.

## <a name="codefile"></a>CodeFile

Атрибута CodeFile является заменой атрибут CodeBehind в Visual Studio 2002/2003.

### <a name="codefilebaseclass"></a>CodeFileBaseClass

Атрибут CodeFileBaseClass используется в случаях, где требуется несколько страниц для наследования от одного базового класса. Из-за реализации разделяемые классы в ASP.NET, без этого атрибута базового класса, который использует общие общих полей для ссылки на элементы управления, объявленные в страницу ASPX будет работать неправильно из-за ASP. Модуль компиляции сетями автоматически создаст новые члены, основан на элементах управления на странице. Таким образом, если требуется общий базовый класс для двух или нескольких страниц ASP.NET, необходимо определить в атрибуте CodeFileBaseClass задать базовый класс и затем создайте каждой страницы класс, производный от этого базового класса. Атрибута CodeFile также является обязательным при использовании этого атрибута.

## <a name="compilationmode"></a>compilationMode

Этот атрибут можно задать свойство CompilationMode страницы ASPX. Свойство CompilationMode является перечислением, содержащий значения **всегда**, **автоматически**, и **никогда**. Значение по умолчанию — **всегда**. **Автоматически** параметр будет препятствовать динамически по возможности компиляции страницы ASP.NET. За исключением страниц от динамической компиляции повышает производительность. Тем не менее если страница, на которой исключается содержит этот код, который должен быть скомпилирован, выдается ошибка при просмотре страницы.

## <a name="enableeventvalidation"></a>EnableEventValidation

Этот атрибут указывает, проверяется ли события обратной передачи и обратного вызова. Если эта функция включена, аргументы для обратной передачи или обратного вызова события проверяются, чтобы убедиться, что они были получены из серверного элемента управления, их первоначального формирования.

## <a name="enabletheming"></a>EnableTheming

Этот атрибут указывает, используются ли темы ASP.NET на странице. Значение по умолчанию — **false**. Темы ASP.NET охваченных [10 модуль](profiles-themes-and-web-parts.md).

## <a name="linepragmas"></a>LinePragmas

Этот атрибут указывает, следует ли добавить директивы pragma во время компиляции. Директивы pragma, параметры, используемые в отладчиках для выделения определенных разделов кода.

## <a name="maintainscrollpositiononpostback"></a>MaintainScrollPositionOnPostback

Этот атрибут указывает, вставляется ли JavaScript в страницы для обеспечения позиции прокрутки между обратными передачами. Этот атрибут является **false** по умолчанию.

Если этот атрибут имеет **true**, ASP.NET добавит &lt;сценарий&gt; блок при обратной передаче, выглядит следующим образом:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample3.html)]

Обратите внимание, что для этого блока сценария src WebResource.axd. Этот ресурс не физический путь. Получив этот сценарий, ASP.NET динамически создает скрипт.

### <a name="masterpagefile"></a>MasterPageFile

Этот атрибут задает файл главной страницы для текущей страницы. Путь может быть относительным или абсолютным. Главные страницы охваченных [4 модуля](master-pages.md).

## <a name="stylesheettheme"></a>StyleSheetTheme

Этот атрибут позволяет переопределять свойства внешнего вида пользовательского интерфейса, определенные темы ASP.NET 2.0. Темы рассматриваются в [10 модуль](profiles-themes-and-web-parts.md).

## <a name="theme"></a>Тема

Определяет тему для страницы. Если значение не указано для атрибута StyleSheetTheme, атрибут Theme переопределяет все стили, примененные к элементу управления на странице.

## <a name="title"></a>Заголовок

Задание заголовка для страницы. Указанное здесь значение будет отображаться в &lt;заголовок&gt; элемент отображаемой страницы.

### <a name="viewstateencryptionmode"></a>ViewStateEncryptionMode

Задает значение перечисления ViewStateEncryptionMode. Доступные значения: **всегда**, **автоматически**, и **никогда**. Значение по умолчанию — **автоматически**. Если этот атрибут имеет значение в значение **автоматически**, шифруется viewstate элемента управления запрашивает его путем вызова **RegisterRequiresViewStateEncryption** метод.

## <a name="setting-public-property-values-via-the--page-directive"></a>Задание значения открытых свойств через директива @ Page

Другой новой функции директива @ Page в ASP.NET 2.0 — возможность задать начальное значение общих свойств базового класса. Предположим, что имеется открытое свойство вызвать, например **SomeText** в базового класса и d, как она будет инициализирована **Hello** при загрузке страницы. Это можно сделать, просто задав значение в директиве @ Page следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample4.aspx)]

**SomeText** атрибута директивы @ Page задает начальное значение SomeText свойства базового класса, чтобы *Hello!*. Видео ниже приведен пример начальное значение открытого свойства в базовом классе с помощью директивы @ Page.


![](the-asp-net-2-0-page-model/_static/image1.png)


[Откройте весь экран](the-asp-net-2-0-page-model/_static/setprop1.wmv)


## <a name="new-public-properties-of-the-page-class"></a>Новые свойства открытого класса страницы

В ASP.NET 2.0 появились следующие открытые свойства.

## <a name="apprelativetemplatesourcedirectory"></a>AppRelativeTemplateSourceDirectory

Возвращает путь относительно приложения для страницы или элемента управления. Например, для страницы, расположенный в http://app/folder/page.aspx, это свойство возвращает ~ / folder /.

## <a name="apprelativevirtualpath"></a>AppRelativeVirtualPath

Возвращает относительный виртуальный путь к каталогу страницы или элемента управления. Например, для страницы, расположенный в http://app/folder/page.aspx, это свойство возвращает ~ / folder/page.aspx.

## <a name="asynctimeout"></a>AsyncTimeout

Возвращает или задает время ожидания, используемое для обработки асинхронной страницы. (Асинхронные страницы будет рассматриваться далее в этом модуле.)

## <a name="clientquerystring"></a>ClientQueryString

Свойство только для чтения, которое возвращает часть строки запроса запрошенного URL-адреса. Это значение является URL-кодированием. Метод UrlDecode класса HttpServerUtility для декодирования.

## <a name="clientscript"></a>ClientScript

Это свойство возвращает объект ClientScriptManager, который может использоваться для управления ASP.NETs вывод клиентского скрипта. (Класс ClientScriptManager рассматривается далее в этом модуле.)

## <a name="enableeventvalidation"></a>EnableEventValidation

Это свойство определяет, включена ли проверка событий для события обратной передачи и обратного вызова. При включении, чтобы убедиться, что они были получены из серверного элемента управления, их первоначального формирования проверяются аргументы для обратной передачи или обратного вызова события.

## <a name="enabletheming"></a>EnableTheming

Это свойство Возвращает или задает логическое значение, указывающее, применяется ли темы ASP.NET 2.0 на страницу.

## <a name="form"></a>Form

Это свойство возвращает HTML-форму на странице ASPX, как объект HtmlForm.

## <a name="header"></a>Header

Это свойство возвращает ссылку на объект HtmlHead, содержащий верхний колонтитул страницы. Возвращаемый объект HtmlHead можно использовать для получения или задания таблицы стилей, мета-теги, и т. д.

## <a name="idseparator"></a>IdSeparator

Это свойство только для чтения получает символ, используемый для разделения идентификаторов элементов управления, когда ASP.NET создает уникальный идентификатор для элементов управления на странице. Он не предназначен для использования непосредственно в вашем коде.

## <a name="isasync"></a>IsAsync

Это свойство позволяет асинхронные страницы. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="iscallback"></a>IsCallback

Это свойство только для чтения возвращает **true** Если страница является результат обратного вызова. Обратных звонков, рассматриваются далее в этом модуле.

## <a name="iscrosspagepostback"></a>IsCrossPagePostBack

Это свойство только для чтения возвращает **true** Если страница является частью обратной передаче между страницы. Обратную передачу страницы между рассматриваются далее в этом модуле.

## <a name="items"></a>Элементы

Возвращает ссылку на экземпляр IDictionary, содержащий все объекты, хранящиеся в контексте страницы. Можно добавить элементы к этому объекту IDictionary и они будут доступны для вас в течение времени существования контекста.

## <a name="maintainscrollpositiononpostback"></a>MaintainScrollPositionOnPostBack

Это свойство управляет ли ASP.NET создает JavaScript, который обслуживается прокручиваются страницы позицию в браузере после обратной передаче. (Подробные сведения этого свойства были описаны ранее в этом модуле.)

## <a name="master"></a>Образец

Это свойство только для чтения возвращает ссылку на экземпляр MasterPage к этой странице, к которым был применен главной страницы.

## <a name="masterpagefile"></a>MasterPageFile

Возвращает или задает имя файла главной страницы для страницы. Это свойство можно задать только в методе PreInit.

## <a name="maxpagestatefieldlength"></a>MaxPageStateFieldLength

Это свойство Возвращает или задает максимальную длину для состояния страницы в байтах. Если свойство задано на положительное число, состояние представления страницы будет выделить несколько скрытых полей, чтобы он не превышает число байтов, указанного в. Если свойство имеет отрицательное значение, состояние представления будет не разбивается на фрагменты.

## <a name="pageadapter"></a>PageAdapter

Возвращает ссылку на объект PageAdapter, изменяет страницы для запрашивающего браузера.

## <a name="previouspage"></a>PreviousPage

Возвращает ссылку на предыдущую страницу в случаях Server.Transfer или обратной передаче между страницы.

## <a name="skinid"></a>SkinID

Указывает ASP.NET 2.0 обложку, применяемую к странице.

## <a name="stylesheettheme"></a>StyleSheetTheme

Это свойство Возвращает или задает таблицу стилей, примененной к странице.

## <a name="templatecontrol"></a>TemplateControl

Возвращает ссылку на содержащего элемента управления для страницы.

## <a name="theme"></a>Тема

Возвращает или задает имя темы ASP.NET 2.0, применяемой к странице. Это значение должно быть установлено до PreInit метод.

## <a name="title"></a>Заголовок

Это свойство Возвращает или задает заголовок для страницы, полученный из заголовка страницы.

## <a name="viewstateencryptionmode"></a>ViewStateEncryptionMode

Возвращает или задает ViewStateEncryptionMode страницы. См. Подробное описание этого свойства ранее в этом модуле.

## <a name="new-protected-properties-of-the-page-class"></a>Новые свойства защищенного класса страницы

Ниже приведены новые защищенные свойства класса страницы в ASP.NET 2.0.

## <a name="adapter"></a>Адаптер

Возвращает ссылку на ControlAdapter, отображающий страницу на устройстве, которые запросили его.

## <a name="asyncmode"></a>AsyncMode

Это свойство указывает, обрабатывается ли страница асинхронно. Он предназначен для использования средой выполнения, а не непосредственно в коде.

## <a name="clientidseparator"></a>ClientIDSeparator

Это свойство возвращает символ, используемый в качестве разделителя, при создании уникального клиента идентификаторы для элементов управления. Он предназначен для использования средой выполнения, а не непосредственно в коде.

## <a name="pagestatepersister"></a>PageStatePersister

Это свойство возвращает объект PageStatePersister для страницы. Это свойство используется преимущественно разработчиками элементов управления ASP.NET.

## <a name="uniquefilepathsuffix"></a>UniqueFilePathSuffix

Это свойство возвращает уникальный suffic, добавляемое к пути файла для кэширование браузеров. Значение по умолчанию — \_ \_ufps = и 6 цифр.

## <a name="new-public-methods-for-the-page-class"></a>Новые общие методы для класса страницы

Для класса страницы в ASP.NET 2.0 появились следующие открытые методы.

## <a name="addonprerendercompleteasync"></a>AddOnPreRenderCompleteAsync

Этот метод регистрирует делегатов обработчиков событий для выполнения асинхронной страницы. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="applystylesheetskin"></a>ApplyStyleSheetSkin

Свойства в таблице стилей страницы применяется к странице.

## <a name="executeregisteredasynctasks"></a>ExecuteRegisteredAsyncTasks

Этот метод начинается асинхронной задачи.

### <a name="getvalidators"></a>GetValidators

Возвращает коллекцию проверяющих элементов управления для указанной группе или группе проверки по умолчанию, если он не задан.

## <a name="registerasynctask"></a>Метод RegisterAsyncTask

Этот метод регистрирует новый асинхронной задачи. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="registerrequirescontrolstate"></a>RegisterRequiresControlState

Этот метод сообщает ASP.NET, что состояние элемента управления страницы должен быть сохранен.

## <a name="registerrequiresviewstateencryption"></a>RegisterRequiresViewStateEncryption

Этот метод сообщает ASP.NET, что viewstate страниц требует шифрования.

## <a name="resolveclienturl"></a>ResolveClientUrl

Возвращает относительный URL-адрес, который может использоваться для клиентских запросов для изображений и т. д.

## <a name="setfocus"></a>Функция SetFocus

Этот метод будет установить фокус на элемент управления, который указывается при начальной загрузке страницы.

## <a name="unregisterrequirescontrolstate"></a>UnregisterRequiresControlState

Этот метод будет отменена регистрация элемент управления, который передается как больше не требует сохранения состояния управления.

## <a name="changes-to-the-page-lifecycle"></a>Изменения в жизненном цикле страницы

Жизненного цикла страницы ASP.NET 2.0 не существенно изменилось, но есть несколько новых методов, которые следует обратить внимание. Ниже приведены жизненного цикла страницы ASP.NET 2.0.

## <a name="preinit-new-in-aspnet-20"></a>PreInit (введено в ASP.NET 2.0)

Событие PreInit — самый ранний этап жизненного цикла, разработчик может получить доступ. Добавление данного события позволяет программно изменять темы ASP.NET 2.0, главные страницы, доступ к свойствам профиля ASP.NET 2.0 и т. д. Если вы находитесь в обратной передачи состояния, необходимо понимать, что Viewstate имеет еще не были применены к элементам управления на этом этапе жизненного цикла. Таким образом Если разработчик изменяет свойство элемента управления на этом этапе, он скорее всего перезаписывается позднее в жизненном цикле страницы.

## <a name="init"></a>Init

События Init не отличается от ASP.NET 1.x. Это будет место для чтения или инициализации свойств элементов управления на странице. В этой рабочей области, главные страницы, темы и т.д. уже применяется к странице.

## <a name="initcomplete-new-in-20"></a>InitComplete (введено в версии 2.0)

Событие InitComplete вызывается в конце этапа инициализации страницы. На этом этапе жизненного цикла, доступны элементы управления на странице, но их состояние еще не заполнены.

## <a name="preload-new-in-20"></a>Предварительная загрузка (новое в версии 2.0)

Это событие вызывается после применения всех данных обратной передачи и перед страницы\_нагрузки.

## <a name="load"></a>Load

Событие загрузки не отличается от ASP.NET 1.x.

## <a name="loadcomplete-new-in-20"></a>LoadComplete (введено в версии 2.0)

Событие LoadComplete — последнего события в стадии загрузки страницы. На этом этапе все данные обратной передачи и viewstate была применена к странице.

## <a name="prerender"></a>PreRender

При желании для viewstate правильно поддерживаемое для элементов управления, которые добавляются к странице динамически события PreRender является последняя возможность добавлять их.

## <a name="prerendercomplete-new-in-20"></a>PreRenderComplete (введено в версии 2.0)

На этапе PreRenderComplete были добавлены все элементы управления на страницу и страница готова для отображения. События PreRenderComplete является последнее событие, возникающее перед сохранением viewstate страниц.

## <a name="savestatecomplete-new-in-20"></a>SaveStateComplete (введено в версии 2.0)

Событие SaveStateComplete вызывается сразу после сохранения все страницы viewstate и состояния элемента управления. Это последнее событие, прежде чем фактически отображении страницы в браузере.

## <a name="render"></a>Прорисовка

Метод Render не была изменена с момента ASP.NET 1.x. Это где HtmlTextWriter инициализируется и отображении страницы в браузере.

## <a name="cross-page-postback-in-aspnet-20"></a>Обратной передачи страницы между в ASP.NET 2.0

В ASP.NET 1.x, обратных передач требовались для учета на одной странице. Обратную передачу между страницы, не допускалось. ASP.NET 2.0 добавляет возможность выполнять обратную передачу на другую страницу в интерфейсе IButtonControl. Любой элемент управления, реализующий интерфейс записи IButtonControl (кнопка LinkButton и ImageButton помимо пользовательские элементы управления сторонних разработчиков) могут воспользоваться преимуществами этой новой функциональной возможности, посредством использования атрибута PostBackUrl. В следующем коде показано элемент управления Button, отправляет второй страницы.

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample5.aspx)]

При отправке страницы обратно, инициирующего обратной передачи страницы доступна через свойство PreviousPage на второй странице. Эта функциональная возможность реализуется через новый веб-форма\_DoPostBackWithOptions клиентской функции, если элемент управления выполняет обратную передачу другой страницы ASP.NET 2.0 отображает для страницы. Новый дескриптор WebResource.axd, который порождает сценарий клиенту предоставляется этой функции JavaScript.

Видео ниже приведен пример страницы между обратной передачи.


![](the-asp-net-2-0-page-model/_static/image2.png)


[Откройте весь экран](the-asp-net-2-0-page-model/_static/xpage1.wmv)


## <a name="more-details-on-cross-page-postbacks"></a>Дополнительные сведения об обратных передач между страницы

### <a name="viewstate"></a>Состояние просмотра

Может запрос самостоятельно уже сведения о том, что происходит с первой страницы в сценарии обратной передачи страницы между в viewstate. В конце концов любой элемент управления, который не реализует IPostBackDataHandler таким образом сохранять свое состояние через состояние просмотра, чтобы иметь доступ к свойствам этого элемента управления на второй странице обратной передачи страницы между, необходимо иметь доступ к состояние отображения для страницы. ASP.NET 2.0 берет на себя этот сценарий с помощью нового скрытого поля на второй странице называется \_ \_PREVIOUSPAGE. \_ \_PREVIOUSPAGE поле формы содержит viewstate для первой страницы, чтобы на второй странице можно получить доступ к свойствам всех элементов управления.

### <a name="circumventing-findcontrol"></a>Обход FindControl

В видеоруководство обратной передачи страницы между я использовал метод FindControl для получения ссылки на элемент управления TextBox на первой странице. Этот метод хорошо подходит для этой цели, но метод FindControl расходуется, которому требуется написать дополнительный код. К счастью ASP.NET 2.0 представляет собой альтернативу FindControl для этой цели, который будет работать в разных сценариях. Директива PreviousPageType позволяет иметь строго типизированную ссылку на предыдущую страницу с помощью TypeName или VirtualPath атрибута. Атрибут TypeName позволяет указать тип предыдущей страницы, хотя атрибут VirtualPath позволяет ссылаться на предыдущую страницу, с помощью виртуального пути. После выбора директива PreviousPageType, необходимо предоставить элементы управления, т. д., к которому вы хотите разрешить доступ с помощью открытые свойства.

## <a name="lab-1-cross-page-postback"></a>Обратной передачи страницы между Практическое занятие 1

В этой лабораторной работы вы создадите приложение, использующее новый кросс-обратной передачи функциональных возможностей страницы ASP.NET 2.0.

1. Откройте Visual Studio 2005 и создайте новый веб-сайте ASP.NET.
2. Добавьте новый веб-форма вызывается page2.aspx.
3. Откройте страницу Default.aspx в представлении конструктора и добавьте элемент управления Button и элемент управления TextBox. 

    1. Присвойте кнопке Идентификатором **кнопка '' Отправить** и текстовое поле элемента управления с Идентификатором **UserName**.
    2. Значение свойства PostBackUrl кнопки page2.aspx.
4. Откройте page2.aspx в режиме исходного кода.
5. Добавьте директиву @ PreviousPageType, как показано ниже:
6. Добавьте следующий код к странице\_загрузку page2.aspx элемента кода: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample6.cs)]
7. Постройте проект, щелкнув меню "Построение" в сборке.
8. Добавьте следующий код, чтобы код программной части для Default.aspx: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample7.cs)]
9. Изменить страницу\_нагрузки в page2.aspx следующее: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample8.cs)]
10. Выполните построение проекта.
11. Запустите проект.
12. Введите имя в текстовое поле и нажмите кнопку.
13. Что такое результат?

## <a name="asynchronous-pages-in-aspnet-20"></a>Асинхронные страницы в ASP.NET 2.0

Многие конфликты при работе в ASP.NET вызываются задержки внешних вызовов (например, вызовы службы или базы данных Web), задержка ввода-ВЫВОДА файла, и т. д. При выполнении запроса для приложения ASP.NET, ASP.NET использует один из рабочих потоков для обслуживания этого запроса. Этот запрос является владельцем этого потока до завершения запроса и отправки ответа. ASP.NET 2.0 предназначено для устранения проблемы задержки с помощью таких проблем путем добавления возможность асинхронного выполнения страницы. Означает, что рабочий поток можно запустить запрос и передать дополнительные выполнение другому потоку, тем самым быстро возвращение пул доступных потоков. После завершения операции ввода-ВЫВОДА для файла, вызов базы данных, т. д. получен новый поток из пула потоков для завершения запроса.

Первым шагом в создании асинхронного выполнения страницы является установка **Async** атрибута директивы страницы следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample9.aspx)]

Этот атрибут сообщает ASP.NET для реализации IHttpAsyncHandler для страницы.

Следующим шагом является вызов метода метода AddOnPreRenderCompleteAsync в определенный момент в жизненном цикле страницы до PreRender. (Этот метод обычно вызывается в страницу\_нагрузки.) Метод метода AddOnPreRenderCompleteAsync принимает два параметра; BeginEventHandler и EndEventHandler. BeginEventHandler возвращает значение IAsyncResult, который затем передается как параметр EndEventHandler.

Видео, ниже приведен пример запроса асинхронной страницы.


![](the-asp-net-2-0-page-model/_static/image3.png)


[Откройте весь экран](the-asp-net-2-0-page-model/_static/async1.wmv)


> [!NOTE]
> До завершения EndEventHandler страницей async не отобразить в обозревателе. Несомненно, но некоторым разработчикам будет рассматривать запросов асинхронного как аналог асинхронные обратные вызовы. Очень важно помнить, что они не являются. Преимущество для асинхронных запросов заключается в том, что первый рабочий поток могут быть возвращены в пул потоков для обслуживания новых запросов, снижая таким образом состязания из-за привязки ввода-ВЫВОДА и т. д.


## <a name="script-callbacks-in-aspnet-20"></a>Обратные вызовы из сценария в ASP.NET 2.0

Веб-разработчики всегда поиск способов предотвратить мерцание, связанные с обратным вызовом. В ASP.NET 1.x, SmartNavigation был наиболее распространенный способ избежать мерцание, но SmartNavigation причиной проблемы для разработчиков, некоторые из-за сложности реализации на стороне клиента. ASP.NET 2.0 решает эту проблему с обратные вызовы из сценария. Обратные вызовы из сценария используйте XMLHttp для запросов к веб-сервере через JavaScript. XMLHttp запрос возвращает XML-данных, можно управлять с помощью обозревателя DOM. XMLHttp код является скрытым от пользователя, новый дескриптор WebResource.axd.

Существуют несколько шагов, которые необходимы для настройки обратный вызов сценария в ASP.NET 2.0.

## <a name="step-1--implement-the-icallbackeventhandler-interface"></a>Шаг 1: Реализация интерфейса ICallbackEventHandler

Чтобы ASP.NET, чтобы распознать страницы участвовать в обратный вызов сценария необходимо реализовать интерфейс ICallbackEventHandler. Это можно сделать в файле кода следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample10.cs)]

Также это можно сделать с помощью like директиву @ Implements так:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample11.aspx)]

Обычно используется директива @ Implements при использовании встроенного кода ASP.NET.

## <a name="step-2--call-getcallbackeventreference"></a>Шаг 2: Вызов GetCallbackEventReference

Как упоминалось ранее, вызов XMLHttp инкапсулируется в дескриптор WebResource.axd. При отображении страницы ASP.NET будет добавить вызов веб-форма\_DoCallback клиентский скрипт, который предоставляется WebResource.axd. Веб-форма\_DoCallback функция заменяет \_ \_doPostBack функции для обратного вызова. Следует помнить, что \_ \_doPostBack программным путем отправки формы на странице. В сценарии обратного вызова, необходимо предотвратить обратной передачи, поэтому \_ \_doPostBack не будет достаточно.

> [!NOTE]
> \_\_doPostBack будет отображаться в клиентском сценарии обратного вызова скрипта к странице. Однако он не используется для обратного вызова.


Аргументы для веб-форма\_DoCallback клиентской функции предоставляются через серверные функции GetCallbackEventReference, который обычно называется странице\_нагрузки. Типичный вызов GetCallbackEventReference может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample12.cs)]

> [!NOTE]
> В этом случае cm является экземпляром ClientScriptManager. Класс ClientScriptManager будет рассматриваться далее в этом модуле.


Существует несколько перегруженных версий GetCallbackEventReference. В этом случае аргументы являются следующим образом:

`this`

Ссылка на элемент управления, где вызывается GetCallbackEventReference. В этом случае это сама страница.

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample13.js)]

Строковый аргумент, который будет передаваться из клиентского кода серверного события. В этом случае обмена мгновенными сообщениями при передаче значения из раскрывающегося списка вызывается ddlCompany.

`ShowCompanyName`

Имя клиентской функции, которая будет принимать возвращаемое значение (в форме строки) из события обратного вызова на стороне сервера. Эта функция будет вызываться только в случае успешного обратного вызова на стороне сервера. Таким образом для обеспечения надежности, обычно рекомендуется использовать перегруженную версию GetCallbackEventReference, принимающий аргумент дополнительной строки, указав имя клиентской функции для выполнения в случае ошибки.

`null`

Строка, представляющая клиентской функции, инициированное перед выполнением обратного вызова на сервере. В этом случае нет нет таких сценариев, поэтому аргумент равен null.

`true`

Логическое значение, определяющее, асинхронно поведения обратного вызова или нет.

Вызов веб-форма\_DoCallback на клиенте будет передавать эти аргументы. Таким образом, эта страница отображается на клиентском компьютере, этот код будет выглядеть следующим образом:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample14.js)]

Обратите внимание на сигнатуру функции на стороне клиента немного по-разному. Клиентские функции передает 5 строк и логическое значение. Дополнительная строка, (который имеет значение null, в приведенном выше примере) содержит клиентской функции, который будет обрабатывать ошибки из обратного вызова на стороне сервера.

## <a name="step-3--hook-the-client-side-control-event"></a>Шаг 3.-Обработчик событий клиентский элемент управления

Обратите внимание, что возвращаемое значение выше GetCallbackEventReference был назначен переменной типа string. Эта строка используется для обработки событий на стороне клиента для элемента управления, который инициирует обратный вызов. В этом примере обратный вызов инициируется раскрывающийся список на странице, поэтому требуется подключаться к *OnChange* события.

Для обработки событий на стороне клиента, просто добавьте обработчик разметки клиентские следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample15.cs)]

Помните, что *cbRef* является возвращаемым значением из вызова GetCallbackEventReference. Он содержит вызов веб-форма\_DoCallback, показанном выше.

## <a name="step-4--register-the-client-side-script"></a>Шаг 4: Регистрация клиентского скрипта

Напомним, что вызов GetCallbackEventReference указано, что клиентского скрипта с именем **ShowCompanyName** будет выполняться после успешного завершения обратного вызова на стороне сервера. Этот скрипт должен быть добавлен на страницу с помощью экземпляра ClientScriptManager. (Класс ClientScriptManager будет dicussed далее в этом модуле.) Как сделать так:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample16.js)]

## <a name="step-5--call-the-methods-of-the-icallbackeventhandler-interface"></a>Шаг 5: Вызовите методы интерфейса ICallbackEventHandler

ICallbackEventHandler содержит два метода, которые необходимо реализовать в коде. Они являются **RaiseCallbackEvent** и **GetCallbackEvent**.

**RaiseCallbackEvent** принимает строку в качестве аргумента и возвращает значение nothing. Аргумент строки передается из вызова клиентского веб-форма\_DoCallback. В этом случае это значение является *значение* атрибут называется ddlCompany раскрывающегося списка. Ваш серверный код следует разместить в методе RaiseCallbackEvent. Например если обратного вызова совершает WebRequest от внешнего ресурса, этот код должно находиться в RaiseCallbackEvent.

**GetCallbackEvent** отвечает за обработку возврата обратного вызова клиента. Он не принимает аргументы и возвращает строку. Строка, она возвращает будет передан в качестве аргумента клиентской функции, в этом случае *ShowCompanyName*.

После завершения действия вы готовы выполнить обратный вызов сценария в ASP.NET 2.0.


![](the-asp-net-2-0-page-model/_static/image4.png)


[Откройте весь экран](the-asp-net-2-0-page-model/_static/callback1.wmv)


Обратные вызовы из сценария в ASP.NET поддерживаются в любого браузера, поддерживающего вызовах XMLHttp. Включает все современные браузеры используется сегодня. Internet Explorer использует объект XMLHttp ActiveX, а другие современных браузеров (в том числе предстоящих Internet Explorer 7) используйте встроенный объект XMLHttp. Для программного определения, если браузер поддерживает обратных вызовов, можно использовать **Request.Browser.SupportCallback** свойство. Это свойство будет возвращать **true** Если запрашивающему клиенту поддерживает обратные вызовы из сценария.

## <a name="working-with-client-script-in-aspnet-20"></a>Работа с клиентским скриптом в ASP.NET 2.0

Клиентские скрипты в ASP.NET 2.0 управляются посредством использования ClientScriptManager класса. Класс ClientScriptManager хранит информацию о клиентских скриптов, используя тип и имя. Это предотвращает тот же скрипт, программно вставляемого на странице более одного раза.

> [!NOTE]
> После скрипт был успешно зарегистрирован на странице, все последующие попытки зарегистрировать тот же скрипт просто приведет к скрипт не регистрируется повторно. Повторяющиеся сценарии не будут добавлены и исключение не возникает. Чтобы избежать ненужных вычислений, существуют методы, которые можно использовать для определения, скрипт зарегистрирован ли, чтобы не пытайтесь зарегистрировать его несколько раз.


Методы ClientScriptManager должны быть знакомы разработчикам все текущего ASP.NET:

## <a name="registerclientscriptblock"></a>RegisterClientScriptBlock

Этот метод добавляет скрипт к началу отображаемой страницы. Это полезно для добавления функций, которые будут вызываться явным образом на клиенте.

Существует две перегруженные версии этого метода. Три из четырех аргументов являются общими для них. Они приведены ниже.

`type (string)`

***Тип*** аргумент указывает тип для скрипта. Обычно рекомендуется использовать тип страницы (это. GetType()) для типа.

`key (string)`

***Ключ*** аргумент — это определяемые пользователем ключ для скрипта. Это должно быть уникальным для каждого сценария. Если попытаться добавить скрипт с один и тот же ключ и тип уже добавленных сценария, он не будет добавлен.

`script (string)`

***Сценарий*** аргумент — строка, содержащая фактический сценарий для добавления. Рекомендуется использовать для создания скрипта и затем с помощью метода ToString() на StringBuilder присваивать StringBuilder ***сценарий*** аргумент.

При использовании перегруженных RegisterClientScriptBlock, которая принимает только три аргумента, должен включать элементы сценария (&lt;сценарий&gt; и &lt;/script&gt;) в скрипте.

Вы можете использовать перегрузку, принимающую четвертый аргумент RegisterClientScriptBlock. Четвертый аргумент — логическое значение, которое указывает, должна ли ASP.NET добавлять элементы сценария для вас. Если этот аргумент является **true**, сценарий не должно содержать элементов скрипта явным образом.

Метод IsClientScriptBlockRegistered используется для определения, если скрипт уже был зарегистрирован. Это позволяет избежать попытка повторно зарегистрировать скрипт, который уже был зарегистрирован.

### <a name="registerclientscriptinclude-new-in-20"></a>RegisterClientScriptInclude (введено в версии 2.0)

Тег RegisterClientScriptInclude создает блок скрипта, ссылки на внешний файл сценария. Он имеет две перегрузки. Одна принимает ключ и URL-адрес. Второй добавляет третий аргумент, задающий тип.

Например следующий код приводит к возникновению ошибки блок сценария, ссылающийся на jsfunctions.js в корневой папке сценариев приложения:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample17.cs)]

Этот код выводит следующий код в отображаемой странице:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample18.html)]

> [!NOTE]
> Блок сценария отображается в нижней части страницы.


Метод IsClientScriptIncludeRegistered используется для определения, если скрипт уже был зарегистрирован. Это позволяет избежать попытка повторно зарегистрировать скрипт.

## <a name="registerstartupscript"></a>RegisterStartupScript

Метод RegisterStartupScript принимает те же аргументы, что и метод RegisterClientScriptBlock. Сценарий зарегистрирована RegisterStartupScript выполняет после загрузки страницы, но до загрузки клиентского события. В 1.X, скрипты, зарегистрированные с RegisterStartupScript были размещены непосредственно перед закрывающим тегом &lt;/form&gt; тег пока скрипты, зарегистрированные с RegisterClientScriptBlock были размещены сразу же после открывающего &lt;формы&gt; тег. В ASP.NET 2.0 и размещаются непосредственно перед закрывающим тегом &lt;/form&gt; тег.

> [!NOTE]
> Зарегистрировать функцию с RegisterStartupScript, эта функция не будет выполняться до явным образом вызвать его в код на стороне клиента.


Метод IsStartupScriptRegistered используется для определения, если скрипт уже был зарегистрирован и избежать попытка повторно зарегистрировать скрипт.

## <a name="other-clientscriptmanager-methods"></a>Другие методы ClientScriptManager

Ниже приведены некоторые полезные методы класса ClientScriptManager.


|  <strong>GetCallbackEventReference</strong>   |                                                 См. выше в этом модуле обратные вызовы из сценария.                                                 |
|-----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
|  <strong>GetPostBackClientHyperlink</strong>  |                Возвращает ссылку JavaScript (javascript:&lt;вызовите&gt;) может использоваться для отправки обратно из событий на стороне клиента.                 |
|  <strong>GetPostBackEventReference</strong>   |                                   Возвращает строку, который может использоваться для запуска отправки обратно клиенту.                                    |
|      <strong>GetWebResourceUrl</strong>       | Возвращает URL-адрес ресурса, внедренного в сборку. Необходимо использовать в сочетании с <strong>RegisterClientScriptResource</strong>. |
| <strong>RegisterClientScriptResource</strong> |     Регистрирует страницу веб-ресурса. Это встроенный в сборку и может быть обработано новый дескриптор WebResource.axd ресурсов.      |
|     <strong>RegisterHiddenField</strong>      |                                                 Регистрирует скрытое поле формы со страницей.                                                 |
|  <strong>RegisterOnSubmitStatement</strong>   |                                  Регистрирует клиентский код, который выполняется при отправке формы HTML.                                   |

