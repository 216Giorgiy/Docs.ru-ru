---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: "Профили, темы и веб-частей | Документы Microsoft"
author: microsoft
description: "Существуют значительные изменения в конфигурации и инструментирования в ASP.NET 2.0. ASP.NET configuration API позволяет сделать pr изменения конфигурации..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2005
ms.topic: article
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: c9fe97dbd5fe10cbde25b9daf5ddd35b2d7eaab5
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="profiles-themes-and-web-parts"></a>Профили, темы и веб-частей
====================
по [Microsoft](https://github.com/microsoft)

> Существуют значительные изменения в конфигурации и инструментирования в ASP.NET 2.0. Новый API конфигурации ASP.NET позволяет программным путем вносить изменения конфигурации. Кроме того, существует множество новые параметры конфигурации позволяют новые конфигурации и инструментария.


ASP.NET 2.0 представляет существенно повышает области настраиваемый веб-сайтов. В дополнение к уже распространяется weve функции членства профилей ASP.NET, темы и веб-частей значительно улучшить персонализации в веб-сайтов.

## <a name="aspnet-profiles"></a>Профили ASP.NET

Профили ASP.NET похожи на сеансы. Разница заключается в том, что профиль является постоянным, в то время как при закрытии сеанса теряется. Еще одно существенное отличие между сеансами и профили — что профилей строго типизированы, таким образом обеспечивая IntelliSense во время разработки.

Профиль определяется в файле конфигурации машины или файл web.config для приложения. (Не удается определить профиль в файле web.config вложенных папок.) В следующем примере кода определяется профиля для хранения посетителей веб-узла, сначала имена и фамилии.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

Тип данных по умолчанию для свойства профиля — System.String. В приведенном выше примере типы данных не указан. Поэтому свойства FirstName и LastName имеют тип строки. Как упоминалось ранее, профиль, который свойства являются строго типизированными. Приведенный ниже код добавляет новое свойство для возраста, который относится к типу Int32.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

Профили обычно используются с помощью форм ASP.NET. При использовании в сочетании с помощью форм, каждый пользователь имеет отдельный профиль, связанный с идентификатора пользователя. Тем не менее, существует также возможность разрешить использование профилей в анонимных приложения с помощью &lt;anonymousIdentification&gt; элемент файла конфигурации вместе с **allowAnonymous** атрибута показан ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

Когда анонимный пользователь просматривает сайт, ASP.NET создает экземпляр **ProfileCommon** для пользователя. Этот профиль содержит уникальный идентификатор, который сохранен в файле cookie в браузере для идентификации пользователя в качестве уникальным посетителем. Таким образом можно хранить сведения о профиле для пользователей, просматривающих анонимно.

## <a name="profile-groups"></a>Группы профилей

Существует возможность свойства группы профилей. Свойствами группирования можно имитировать несколько профилей для конкретного приложения.

Следующая конфигурация настраивает свойство FirstName и LastName для двух групп; Покупателей и потенциальных заказчиков.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

Затем можно настроить свойства в конкретной группе следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>Хранение сложных объектов.

Таким образом примеры, которые мы рассмотрели хранятся простые типы данных в профиле. Невозможно сохранить сложные типы данных в профиле, указав сериализации с помощью метода **serializeAs** атрибута следующим образом:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

В этом случае тип — PurchaseInvoice. Класс PurchaseInvoice должен быть помечен как сериализуемый и может содержать любое количество свойств. Например, если PurchaseInvoice имеет свойство с именем **NumItemsPurchased**, обратитесь к этому свойству в коде следующим образом:

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>Профиль наследования

Можно создать профиль для использования в нескольких приложениях. Создание профиля класса, производного от ProfileBase, позволяет повторно использовать профиль в несколько приложений с помощью **наследует** атрибута, как показано ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

В данном случае класс **PurchasingProfile** будет выглядеть следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>Поставщики профилей

Профили ASP.NET использовать модель поставщика. Поставщик по умолчанию эти сведения хранятся в базе данных SQL Server Express в приложении\_папки данных с помощью поставщика SqlProfileProvider веб-приложения. Если база данных не существует, ASP.NET автоматически создаст ее при попытке сохранить сведения профиля.

Однако в некоторых случаях может потребоваться создать собственного поставщика профиля. Функция профиля ASP.NET позволяет легко использовать другого поставщика.

Создание пользовательского поставщика профилей при:

- Необходимо хранить информацию профиля в источнике данных, таких как базы данных FoxPro или в базе данных Oracle, который не поддерживается поставщиками профилей, входящий в состав .NET Framework.
- Необходимо управлять информацией профиля с помощью схемы базы данных, которая отличается от схемы базы данных, используемые поставщиками, входящий в состав .NET Framework. Распространенным примером является то, что вы хотите интегрировать данные профиля с данными пользователя в существующей базы данных SQL Server.

### <a name="required-classes"></a>Необходимые классы

Для реализации поставщика профилей, необходимо создать класс, наследующий абстрактный класс System.Web.Profile.ProfileProvider. **Поставщик профиля** абстрактный класс, в свою очередь, наследуется System.Configuration.SettingsProvider абстрактный класс, который наследует абстрактный класс System.Configuration.Provider.ProviderBase. Из-за этой цепочки наследования в дополнение к необходимым членам **поставщик профиля** класса, необходимо реализовать требуемые элементы **SettingsProvider** и  **ProviderBase** классы.

В следующих таблицах описаны свойства и методы, которые должны быть реализованы **ProviderBase**, **SettingsProvider**, и **поставщик профиля** абстрактный классы.

### <a name="providerbase-members"></a>ProviderBase члены

| **Член** | **Описание** |
| --- | --- |
| Initialize - метод | Принимает в качестве входных данных, имя экземпляра поставщика и NameValueCollection параметров конфигурации. Используется для задания параметров и значений свойств для экземпляра поставщика, включая зависящие от реализации значения и параметры, указанные в конфигурации компьютера или в файле Web.config. |

### <a name="settingsprovider-members"></a>SettingsProvider члены

| **Член** | **Описание** |
| --- | --- |
| Свойство ApplicationName | Имя приложения, который хранится вместе с каждым профилем. Поставщик профилей использует имя приложения для хранения информации профиля отдельно для каждого приложения. Это позволяет нескольким приложениям ASP.NET использовать один и тот же источник данных без конфликтов, если то же имя пользователя создается в разных приложениях. Кроме того несколько приложений ASP.NET можно использовать источник данных профиля, указав имя приложения; |
| Метод GetPropertyValues | Принимает в качестве входных данных SettingsContext и объект SettingsPropertyCollection. **SettingsContext** предоставляет сведения о пользователе. Данные можно использовать в качестве первичного ключа для извлечения сведений о свойствах профиля для пользователя. Используйте **SettingsContext** объекта, чтобы получить имя пользователя и ли пользователь проверку подлинности или является анонимным. **SettingsPropertyCollection** содержит коллекцию объектов SettingsProperty. Каждый **SettingsProperty** объект предоставляет имя и тип свойства, а также дополнительные сведения, такие как значение по умолчанию для свойства и является ли свойство только для чтения. **GetPropertyValues** метод заполняет SettingsPropertyValueCollection SettingsPropertyValue объекты на основании **SettingsProperty** объектов в качестве входного аргумента. Значения из источника данных для указанного пользователя присваиваются PropertyValue свойства для каждого **SettingsPropertyValue** возвращается объект и вся коллекция. Вызов метода также обновляет значение LastActivityDate для указанного профиля пользователя на текущую дату и время. |
| Метод SetPropertyValues | Принимает в качестве входных **SettingsContext** и **SettingsPropertyValueCollection** объекта. **SettingsContext** предоставляет сведения о пользователе. Данные можно использовать в качестве первичного ключа для извлечения сведений о свойствах профиля для пользователя. Используйте **SettingsContext** объекта, чтобы получить имя пользователя и ли пользователь проверку подлинности или является анонимным. **SettingsPropertyValueCollection** содержит коллекцию **SettingsPropertyValue** объектов. Каждый **SettingsPropertyValue** объект предоставляет имя, тип и значение свойства, а также дополнительные сведения, такие как значение по умолчанию для свойства и является ли свойство только для чтения. **SetPropertyValues** метод обновляет значения свойств в источнике данных для указанного пользователя. Вызов метода также обновляет **LastActivityDate** и LastUpdatedDate значения для указанного профиля пользователя на текущую дату и время. |

### <a name="profileprovider-members"></a>Поставщик профиля члены

| **Член** | **Описание** |
| --- | --- |
| Метод DeleteProfiles | Принимает в качестве входных данных пользователя строковый массив имен и удаляет из источника данных все профиля сведения и значения свойств для указанных имен, где имя приложения соответствует **ApplicationName** значение свойства. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатывать транзакцию и создания исключения, если любая операция удаления завершается неудачей. |
| Метод DeleteProfiles | Принимает в качестве входных данных, коллекцию ProfileInfo объектов и удаляет из источника данных все профиля сведения и значения свойств для каждого профиля, где имя приложения соответствует **ApplicationName** значение свойства. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатывать транзакцию и создания исключения, если любая операция удаления завершается неудачей. |
| Метод DeleteInactiveProfiles | Принимает в качестве входного значения ProfileAuthenticationOption объект DateTime и удаляет из данных источника все данные профиля и значения свойств, в которых дата последнего действия меньше или равно указанной даты и времени и в которых имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывающее, установлено ли только анонимные профили, только профили, или все профили должны быть удалены. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатывать транзакцию и создания исключения, если любая операция удаления завершается неудачей. |
| Метод GetAllProfiles | Принимает в качестве входных **ProfileAuthenticationOption** значение, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, указывающее общее количество профилей. Возвращает ProfileInfoCollection, который содержит **ProfileInfo** объектов для всех профилей в источнике данных, в которых имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывающее, установлено ли только анонимные профили, только профили, или должны быть возвращены все профили. Результаты, возвращенные **GetAllProfiles** метод ограничены индекса страницы и значения размера страницы. Значение размера страницы указывает максимальное число **ProfileInfo** объектов, включаемых в **ProfileInfoCollection**. Значение индекса страницы указывает страницу результатов для возвращения, где 1 означает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеющим значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения и значение индекса страницы равно 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Когда метод возвращает общее число записей значение равно 13. |
| Метод GetAllInactiveProfiles | Принимает в качестве входных **ProfileAuthenticationOption** значение **DateTime** объект, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, будет установлено Общее количество профилей. Возвращает **ProfileInfoCollection** , содержащий **ProfileInfo** объектов для всех профилей в источнике данных, в которых дата последнего действия меньше или равно указанному **даты и времени**  и в которых имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывающее, установлено ли только анонимные профили, только профили, или должны быть возвращены все профили. Результаты, возвращенные **GetAllInactiveProfiles** метод ограничены индекса страницы и значения размера страницы. Значение размера страницы указывает максимальное число **ProfileInfo** объектов, включаемых в **ProfileInfoCollection**. Значение индекса страницы указывает страницу результатов для возвращения, где 1 означает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеющим значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения и значение индекса страницы равно 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Когда метод возвращает общее число записей значение равно 13. |
| Метод FindProfilesByUserName | Принимает в качестве входных **ProfileAuthenticationOption** значение, строку, содержащую имя пользователя, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, которое будет присвоено общего количества профили. Возвращает **ProfileInfoCollection** , содержащий **ProfileInfo** объектов для всех профилей в данные источника, где имя пользователя соответствует указанному имени пользователя и в которых соответствует имени приложения **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывающее, установлено ли только анонимные профили, только профили, или должны быть возвращены все профили. Если источник данных поддерживает дополнительные возможности поиска, такие как символы-шаблоны, чтобы обеспечить расширенные возможности поиска для имен пользователей. Результаты, возвращенные **FindProfilesByUserName** метод ограничены индекса страницы и значения размера страницы. Значение размера страницы указывает максимальное число **ProfileInfo** объектов, включаемых в **ProfileInfoCollection**. Значение индекса страницы указывает страницу результатов для возвращения, где 1 означает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеющим значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения и значение индекса страницы равно 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Когда метод возвращает общее число записей значение равно 13. |
| Метод FindInactiveProfilesByUserName | Принимает в качестве входных **ProfileAuthenticationOption** , строку, содержащую имя пользователя, **DateTime** объект, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылка на целое число, указывающее общее количество профилей. Возвращает **ProfileInfoCollection** , содержащий **ProfileInfo** объектов для всех профилей в источнике данных, где имя пользователя совпадает с указанным именем пользователя, где Дата последнего действия меньше или равно указанной **DateTime**, и в которых имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывающее, установлено ли только анонимные профили, только профили, или должны быть возвращены все профили. Если источник данных поддерживает дополнительные возможности поиска, такие как символы-шаблоны, чтобы обеспечить расширенные возможности поиска для имен пользователей. Результаты, возвращенные **FindInactiveProfilesByUserName** метод ограничены индекса страницы и значения размера страницы. Значение размера страницы указывает максимальное число **ProfileInfo** объектов, включаемых в **ProfileInfoCollection**. Значение индекса страницы указывает страницу результатов для возвращения, где 1 означает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеющим значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения и значение индекса страницы равно 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Когда метод возвращает общее число записей значение равно 13. |
| Метод GetNumberOfInActiveProfiles | Принимает в качестве входных **ProfileAuthenticationOption** значение и **DateTime** объекта и возвращает количество всех профилей в источнике данных, в которых дата последнего действия меньше или равно указанной  **DateTime** и в которых имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывающее, установлено ли только анонимные профили, только профили, или все профили для подсчета. |

### <a name="applicationname"></a>ApplicationName

Поскольку поставщики профилей хранят сведения о профиле отдельно для каждого приложения, необходимо убедиться, что схема данных включает имя приложения и что запросы и обновления также содержать имя приложения. Например, следующая команда используется для получения значения свойства из базы данных на основе имени пользователя и профиля анонимен и гарантирует, что **ApplicationName** значение включается в запрос.

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>Темы ASP.NET

## <a name="what-are-aspnet-20-themes"></a>Что такое темы ASP.NET 2.0

Одним из самых важных аспектов веб-приложения является согласованного внешнего вида и поведения на сайте. Обычно разработчики ASP.NET 1.x использовать каскадные таблицы стилей (CSS) для реализации согласованного внешнего вида и поведения. ASP.NET 2.0 темы значительно повышают эффективность CSS так, как они дают возможность определить внешний вид элементов управления сервера ASP.NET, а также элементы HTML разработки ASP.NET. Темы ASP.NET могут применяться для отдельных элементов управления, на конкретную страницу или веб-приложения весь. При необходимости изображения темы использовать сочетание файлов CSS, файл обложки необязательный и дополнительный каталог образов. Файл обложки определяет внешний вид элементов управления сервера ASP.NET.

## <a name="where-are-themes-stored"></a>Где хранятся темы?

Место хранения темы отличается в зависимости от их области. Темы, которые могут быть применены к любому приложению, хранятся в следующей папке:

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

Темы, относящиеся к конкретному приложению хранится в приложении\_темы\&lt; Темы\_имя&gt; каталог в корневом каталоге веб-сайта.

> [!NOTE]
> Файл обложки следует изменять только свойства серверного элемента управления, которые влияют на внешний вид.

Глобальная тема — тема, которая может применяться для любого приложения или веб-сайт, на веб-сервере. Эти темы хранятся в каталоге ASP.NETClientfiles\Themes, который находится в каталоге v2.x.xxxxx по умолчанию. Кроме того, можно переместить файлы тем в aspnet\_клиента или системы\_web / /Themes/ [версия] [темы\_имя] папки в корневом каталоге веб-узла.

Темы конкретного приложения может применяться только к приложению, в которой находятся файлы. Эти файлы хранятся в приложении\_темы /&lt;темы\_имя&gt; каталог в корневом каталоге веб-сайта.

## <a name="the-components-of-a-theme"></a>Компоненты темы

Тема состоит из одного или нескольких файлов CSS, файл обложки необязательный и необязательный папку Images. CSS-файл может быть любое имя правильно (default.css или theme.css, т. д.) и должны находиться в корневом каталоге темы. CSS-файлы используются для определения обычных классов CSS и атрибуты для конкретного селекторов. Для применения одного из классов CSS к элементу страницы **CSSClass** используется свойство.

Файл обложки является XML-файл содержит определения свойств для ASP.NET серверных элементов управления. Код, приведенный ниже приведен пример файла обложки.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

**Рис. 1** ниже показан небольшой страницы ASP.NET, просматривать без тему. **На рисунке 2** показан тот же файл с тему. Цвета фона и цвета текста настраиваются через CSS-файл. Внешний вид кнопки и текстового поля настраиваются с помощью файла обложки, перечисленных выше.


![Без темы](profiles-themes-and-web-parts/_static/image1.gif)

**Рис. 1**: без темы


![Тема применяется](profiles-themes-and-web-parts/_static/image2.gif)

**На рисунке 2**: тема применяется


Файл обложки, перечисленных выше определяет обложку по умолчанию для всех элементов управления TextBox и элемента управления Button. Это означает, что каждый элемент управления TextBox и вставлен на страницу управления "Кнопка" будет иметь этот внешний вид. Можно также определить обложки, которая может применяться к конкретным экземплярам этих элементов управления с помощью **SkinID** свойству элемента управления.

В следующем примере кода определяет обложку для элемента управления Button. Управляет только кнопка с **SkinID** свойство **goButton** займет на внешний вид обложки.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

Может иметь только один обложки по умолчанию для каждого типа элемента управления сервера. Если вам нужны дополнительные обложки, следует использовать свойство SkinID.

## <a name="applying-themes-to-pages"></a>Применение тем на страницы

Тема может применяться с использованием одного из следующих методов:

- В &lt;страниц&gt; элемента в файле web.config
- В @Page директивы страницы
- Программным способом

## <a name="applying-a-theme-in-the-configuration-file"></a>Применение темы в файле конфигурации

Применение темы в файле конфигурации приложения, используйте следующий синтаксис:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

Здесь указывается имя темы должно соответствовать имени папки темы. Эта папка может быть либо в одном из расположений, указанных выше в этом курсе. При попытке применить тему, которая не существует, возникнет ошибка конфигурации.

## <a name="applying-a-theme-in-the-page-directive"></a>Применение темы в директиве Page

Также можно применить тему в директиве @ Page. Этот метод позволяет использовать тему для конкретной страницы.

Чтобы применить тему в @Page директива, используйте следующий синтаксис:

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

Опять же темы, указанные здесь должно соответствовать папке темы, как упоминалось ранее. Если попытаться применить тему, которая не существует, возникает сбой сборки. Visual Studio также выделите атрибут и уведомления, тема не существует.

## <a name="applying-a-theme-programmatically"></a>Применение темы программными средствами

Применение темы программными средствами, необходимо указать **темы** свойства для страницы в **страницы\_PreInit** метод.

Применение темы программными средствами, используйте следующий синтаксис:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

Это необходимо для применения темы в методе PreInit из-за жизненного цикла страницы. Если после этого применить его темы страницы будет уже были применены средой выполнения и изменения в этот момент уже слишком поздно жизненного цикла. Если применить тему, не существует, **HttpException** происходит. Когда тема применяется программными средствами, предупреждение возникает в том случае, если всех серверных элементов управления имеют указанное свойство SkinID. Это предупреждение предназначено для оповещения о том, что тема не применяется декларативно и может быть пропущено.

## <a name="exercise-1--applying-a-theme"></a>Упражнение 1: Применение темы

В этом упражнении вы научитесь применять темы ASP.NET на веб-сайт.

> [!IMPORTANT]
> Если используется Microsoft Word, чтобы ввести данные в файл обложки, убедитесь, что вы заменяете не регулярного кавычки парными. Парные приведет к проблемам с файлами обложки.

1. Создайте новый веб-узел ASP.NET.
2. Правой кнопкой мыши проект в обозревателе решений и выберите команду Добавить новый элемент.
3. Выберите файл веб-конфигурации в списке файлов и нажмите кнопку Добавить.
4. Правой кнопкой мыши проект в обозревателе решений и выберите команду Добавить новый элемент.
5. Выберите файл обложки и нажмите кнопку Добавить.
6. Нажмите "Да" при появлении запроса, если нужно поместить файл внутри приложения youd\_папки темы.
7. Правой кнопкой мыши папку SkinFile внутри приложения\_темы папку в обозревателе решений и выберите команду Добавить новый элемент.
8. Выберите таблицу стилей в списке файлов и нажмите кнопку Добавить. Теперь у вас есть все файлы, необходимые для реализации новой темы. Однако Visual Studio имя папки темы SkinFile. Щелкните правой кнопкой мыши на эту папку и измените имя на CoolTheme.
9. Откройте файл SkinFile.skin и добавьте следующий код в конец файла: 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. Сохраните файл SkinFile.skin.
11. Откройте StyleSheet.css.
12. Замените весь текст в нем следующим кодом: 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. Сохраните файл StyleSheet.css.
14. Откройте страницу Default.aspx.
15. Добавьте текстовое поле и кнопку.
16. Сохраните страницу. Теперь перейдите на страницу Default.aspx. Оно должно отображать как обычные веб-форму.
17. Откройте файл web.config.
18. Добавьте следующий код непосредственно под открывающей `<system.web>` тег: 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Сохраните файл web.config. Теперь перейдите на страницу Default.aspx. Должно появиться с темой применения.
20. Если он не открыт, откройте страницу Default.aspx в Visual Studio.
21. Нажмите кнопку.
22. Изменение **SkinID** свойства goButton. Обратите внимание, что Visual Studio предоставляет раскрывающийся список с допустимыми значениями SkinID для элемента управления Button.
23. Сохраните страницу. Теперь снова просмотрите страницу в браузере. Кнопки теперь должно появиться сообщение «go» и должен быть шире внешний вид.

С помощью **SkinID** свойства, можно легко настроить разные обложки для различных экземпляров определенного типа серверного элемента управления.

## <a name="the-stylesheettheme-property"></a>Свойство StyleSheetTheme

Итак мы обсуждали только применяя темы, с помощью свойства темы. При использовании свойства темы, файл обложки будут переопределять любые декларативной настройки для серверных элементов управления. Например в упражнении 1 указан SkinID «goButton» для элемента управления Button и, изменения текста кнопки «go». Вы могли заметить, что свойство текста кнопки в конструкторе было задано значение «Кнопка», но используемое темы. Темы, всегда будут переопределять любые параметры свойств в конструкторе.

Если вы хотите иметь возможность переопределять свойства, определенные в файле обложки темы с свойства указаны в конструкторе, можно использовать **StyleSheetTheme** вместо свойства темы. Свойство StyleSheetTheme является таким же, как свойства темы, но не переопределяет все явным образом параметры свойств как свойства темы.

Чтобы увидеть это в действии, откройте файл web.config в упражнении 1 из проекта и измените &lt;страниц&gt; элемент следующее:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

Теперь перейдите на страницу Default.aspx и вы увидите этот элемент управления имеет свойство текст «Button» еще раз. Это, так как свойству Text значение с goButton SkinID переопределяет параметр явные свойства в конструкторе.

## <a name="overriding-themes"></a>Переопределение темы

Глобальные темы можно переопределить с помощью схемы с тем же именем в приложении\_темы папке приложения. Тем не менее тема не применяется в случае переопределения в значение true. Если среда выполнения обнаруживает файлы тем в приложении\_папку темы, она будет применяться темы, с помощью этих файлов и будут игнорировать глобальной темы.

Свойство StyleSheetTheme переопределяемым и может быть переопределен в коде следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>Веб-части

Веб-части ASP.NET — это интегрированный набор элементов управления для создания веб-сайтов, которые позволяют пользователям изменять содержимое, внешний вид и поведение веб-страниц непосредственно из браузера. Изменения могут применяться ко всем пользователям на сайте или отдельными пользователями. Когда пользователи изменяют страниц и элементов управления, параметры можно сохранить, чтобы сохранить личные настройки пользователя будущих сеансах, называемую персонализации. Эти возможности веб-частей означают, что разработчики могут предоставить конечным пользователям настраивать веб-приложения динамически, без вмешательства разработчика или администратора.

Набор элементов управления веб-частей разработчик может разрешить конечным пользователям:

- Настройте содержимое страницы. Пользователи могут добавлять новые элементы управления веб-части на страницу, удалить их, скрыть их или свести к минимуму их как обычные окна.
- Персонализируйте разметку страницы. Пользователи перетащите элемент управления веб-частей в другую зону на странице, или изменить его внешний вид, свойства и поведение.
- Экспорт и импорт элементов управления. Пользователей можно импортировать и экспортировать параметры управления веб-части используйте на других страницах или узлах, сохраняя свойства, внешний вид и даже данные в элементах управления. Это уменьшает данных входа и конфигурации зависящих от пользователей.
- Создайте соединения. Пользователи могут устанавливать подключения между элементами управления, чтобы, например, элемент управления диаграммы может отобразить график для данных в элементе управления биржевых. Пользователи могут настраивать не только само подключение, но внешний вид и подробные сведения о том, как элемент управления диаграммы отображает данные.
- Управление и настраивать параметры на уровне сайта. Авторизованных пользователей можно настроить параметры на уровне веб-узла, определяют доступ на сайте или на страницу, установить на основе ролей доступ к элементам управления и т. д. Например пользователь в роли администратора может задать элемент управления веб-частей, общим для всех пользователей и запретить пользователям, не являющимся администраторами, персонализировать общего элемента управления.

Как правило будет работать с веб-частей в одном из трех способов: Создание страниц, использующих элементы управления веб-частей, создание веб-частей или завершенных веб-приложений, таких как портал.

## <a name="page-development"></a>Страница разработки

Страница разработчики могут использовать средства визуального проектирования, таких как Microsoft Visual Studio 2005 для создания страниц, использующих веб-части. Одно из преимуществ в с помощью средства, такие как Visual Studio, набор элементов управления веб-частей предоставляет возможности и перетащите Создание и настройка элементов управления веб-частей в визуальном конструкторе. Например, можно перетащить зоны веб-частей или элемент управления редактора веб-частей, в область конструктора с помощью конструктора и настройте элемента вправо в конструкторе с помощью пользовательского интерфейса, предоставляемые веб-части набора элементов управления. Это может ускорить разработку приложений веб-частей и уменьшить объем кода, который необходимо написать.

## <a name="control-development"></a>Разработка элемента управления

Можно использовать любой существующий элемент управления ASP.NET, как элемент управления веб-частей, включая стандартные веб-сервера управления, пользовательских серверных элементов управления и пользовательские элементы управления. Для максимального программного управления среды можно также создать пользовательские элементы управления веб-частей, которые являются производными от класса веб-части. Для отдельных разработки элемента управления веб-частей будет обычно либо создать пользовательский элемент управления и использовать его как элемент управления веб-частей либо разработать пользовательский элемент управления веб-частей.

В качестве примера разработки пользовательского элемента управления веб-частей, для создания элемента управления для предоставления функциональные возможности, предоставляемые других элементов управления сервера ASP.NET, которые могут быть полезны в пакет как настраиваемых элементов управления веб-частей: календари, списки, финансовой информации Новости, калькуляторы, элементы управления форматированным текстом для обновления содержимого, редактируемой сетки, подключения к базам данных, диаграммы, которые динамически обновлять их отображает или погоде и передаются сведения. Если с элементом управления содержит визуальный конструктор, затем любой разработчик страницы с помощью Visual Studio можно просто перетащить элемент управления в зоне веб-частей и настройте его во время разработки без необходимости написания дополнительного кода.

Персонализация является основой функции веб-частей. Он позволяет пользователям изменять--или персонализации макета, внешнего вида и поведения элементов управления веб-частей на странице. Персонализированные параметры: они сохраняются не только во время текущего сеанса браузера (как и в случае с состоянием представления), но также в долговременном хранилище, чтобы параметры пользователя сохраняются для будущих сеансов браузера также. Персонализация включена по умолчанию для страниц веб-частей.

Структурных компонентов пользовательского интерфейса, основанных на персонализации и обеспечивают базовую структуру и службы, необходимые для всех элементов управления веб-частей. Один компонент структурных пользовательского интерфейса, необходимые на каждой странице веб-частей является элемент управления WebPartManager. Никогда не отображается этот элемент управления имеет критической задачи координации всех элементов управления веб-частей на странице. Например он отслеживает все веб-частей. Он управляет веб-части зоны (регионы, содержащих элементы управления веб-частей на странице) и элементы управления, присутствующие в какие зоны. Он также отслеживает и управления для различных режимов отображения страницы могут быть в таких, как просматривать, подключения, изменения или каталога, и применения параметров персонализации для всех пользователей или отдельных пользователей. Наконец он инициирует и отслеживание связей между элементами управления веб-частей.

Второй тип структурных компонентов пользовательского интерфейса — зоны. Зона играет роль диспетчера макета страницы веб-частей. Они содержат и упорядочения элементов управления, производных от класса части (элементы управления части) и обеспечивают возможность модульной разметки страницы с горизонтальной или вертикальной ориентацией. Зоны также обеспечивают общий и согласованный элементы пользовательского интерфейса (например, верхний и нижний колонтитулы стиля, заголовок, стиль границы, кнопки действий и т. д) для каждого элемента управления, содержащихся в них; Эти общие элементы называются хром-элемента управления. Специализированные типы зон используются в различных режимов отображения и элементов управления. Основные управления веб-частей ниже в разделе описываются различные типы зон.

Элементы управления веб-части интерфейса пользователя, из которых являются производными от **часть** классов, образующих основной пользовательский Интерфейс на странице веб-частей. Набор элементов управления веб-частей является гибким и включительно в параметрах она дает по созданию таких элементов. Помимо создания собственных пользовательских элементов управления веб-частей, можно также использовать существующие серверные элементы управления ASP.NET, пользовательские элементы управления или пользовательских серверных элементов управления как элементы управления веб-частей. В следующем разделе описываются основные элементы управления, которые чаще всего используется для создания страниц веб-частей.

## <a name="web-parts-essential-controls"></a>Веб-частей, основные элементы управления

Слишком большой набор элементов управления веб-частей, но некоторые элементы управления имеют большое значение, поскольку они необходимы для веб-частей для работы, или они являются элементами управления, наиболее часто используемые на страницах веб-частей. Как приступить к использованию веб-частей, а также создание основных страниц веб-частей, бывает полезно знакомы основные элементы управления веб-частей, описанных в следующей таблице.

| **Управлять веб-частей** | **Описание** |
| --- | --- |
| WebPartManager | Управляет всеми элементами управления веб-частей на странице. Один (и только один) **WebPartManager** элемент управления является обязательным для всех страниц веб-частей. |
| CatalogZone | Содержит элементы управления CatalogPart. Этот тип зоны используется для создания каталога, из которых пользователи могут выбирать элементы управления, чтобы добавить на страницу управления веб-частей. |
| EditorZone | Содержит элементы управления EditorPart. Используйте эту зону, чтобы пользователи могли изменять и настраивать элементы управления веб-частей на странице. |
| WebPartZone | Содержит и предоставляет всей разметки для элементов управления веб-части, составляющие основной пользовательский Интерфейс страницы. Используйте эту зону, каждый раз при создании страниц с элементами управления веб-частей. Страницы могут содержать один или несколько зон. |
| ConnectionsZone | Содержит элементы управления WebPartConnection и предоставляет пользовательский Интерфейс для управления подключениями. |
| Веб-части (GenericWebPart) | Основной пользовательский интерфейс; Большинство элементов управления веб-частей интерфейса попадают в эту категорию. Для максимального программного управления, можно создать пользовательские элементы управления веб-частей, которые являются производными от базового **веб-часть** элемента управления. Можно также использовать существующие серверные элементы управления, пользовательские элементы управления и пользовательские элементы управления, как элементы управления веб-частей. Каждый раз, когда любой из этих элементов управления, помещаются в зоне, **WebPartManager** управления автоматически заключает их с **GenericWebPart** элементов управления во время выполнения, чтобы их могли использовать функциональности веб-частей. |
| CatalogPart | Содержит список доступных элементов управления веб-частей, которые пользователи могут добавлять на страницу. |
| WebPartConnection | Создает соединение между двумя элементами управления веб-частей на странице. Соединение определяет один из элементов управления веб-частей как поставщик (данных), а другой — как получатель. |
| EditorPart | Служит базовым классом для элементов управления специализированный редактор. |
| Элементы управления EditorPart (AppearanceEditorPart, LayoutEditorPart, BehaviorEditorPart и PropertyGridEditorPart) | Позволяет пользователям самостоятельно настраивать различные аспекты управления веб-части интерфейса пользователя на странице |

## <a name="lab-create-a-web-part-page"></a>Лаборатория: Создайте страницу веб-частей

В этой лабораторной работы вы создадите страницу веб-частей, будет хранить данные через профилей ASP.NET.

### <a name="creating-a-simple-page-with-web-parts"></a>Создать простую страницу с веб-частями

В этой части пошагового руководства создайте страницу, которая использует элементы управления веб-частей для отображения статического содержимого. Первый шаг при работе с веб-частей является создание страницы с двумя обязательными элементами структуры. Во-первых страницы должен управления WebPartManager для отслеживания и координации всех элементов управления веб-частей. Во-вторых веб-странице требуется один или несколько зон, которые являются составными элементами управления, которые содержат веб-части или других серверных элементов управления и занимающие определенную область страницы.

> [!NOTE]
> Необходимо выполнять никаких действий для включения персонализации веб-частей; она включена по умолчанию для набора элементов управления веб-частей. При первом запуске страницы веб-частей на узле, ASP.NET устанавливает поставщик персонализации по умолчанию для хранения параметров персонализации пользователя. Дополнительные сведения о персонализации см. Общие сведения о персонализации веб частей.


### <a name="to-create-a-page-for-containing-web-parts-controls"></a>Чтобы создать страницу, содержащую элементы управления веб-частей

1. Закройте страницу по умолчанию и добавьте новую страницу на узел с именем WebPartsDemo.aspx.
2. Переключитесь в **разработки** представления.
3. Из **представление** меню, убедитесь, что **Невизуальные элементы управления** и **сведения** выбраны параметры, чтобы можно было видеть макет теги и элементы управления, которые не имеют пользовательского интерфейса.
4. Поместите курсор перед  **&lt;div&gt;**  теги в рабочую область конструирования и нажмите клавишу ВВОД, чтобы добавить новую строку. Поместите курсор перед символом новой строки, нажмите кнопку **формат блока** раскрывающемся списке элемента управления меню и выберите **заголовок 1** параметр. В заголовке, добавьте текст **демонстрационной страницы**.
5. Из **веб-части** вкладки панели элементов перетащите **WebPartManager** на страницу, расположив его сразу после знака новой строки и перед  **&lt;div&gt;**  тегов.   
  
 **WebPartManager** управления не создает никаких выходных данных, он отображается как серые поля в области конструктора.
6. Поместите курсор в пределах  **&lt;div&gt;**  тегов.
7. В **макета** меню, нажмите кнопку **вставить таблицу**и создать новую таблицу с одной строкой и тремя столбцами. Нажмите кнопку **свойства ячейки** кнопку, выберите **верхней** из **вертикальное выравнивание** раскрывающегося списка выберите **ОК**и нажмите кнопку **ОК** еще раз, чтобы создать таблицу.
8. Перетащите элемент управления WebPartZone в левый столбец таблицы. Щелкните правой кнопкой мыши **WebPartZone** управления, выберите **свойства**и задайте следующие свойства:   
  
 Идентификатор: SidebarZone   
  
 HeaderText: боковой панели
9. Перетащите второй **WebPartZone** control в средний столбец таблицы и задайте следующие свойства:   
  
 Идентификатор: MainZone   
  
 HeaderText: Main
10. Сохраните файл.

Теперь страница имеет две зоны, которыми можно управлять отдельно. Однако у зон имеет любое содержимое, поэтому создание содержимого — следующий шаг. В этом пошаговом руководстве работать с элементами управления веб-частей, которые отображают только статическое содержимое.

Макет зоны веб-частей задается  **&lt;zonetemplate&gt;**  элемента. В шаблон зоны можно добавить любой элемент управления ASP.NET, будь то пользовательский элемент управления веб-частей, пользовательский элемент управления или существующий серверный элемент управления. Обратите внимание, что здесь используется элемент управления Label, в который просто добавляется статический текст. При размещении обычного серверного элемента управления в **WebPartZone** зоны, ASP.NET рассматривает его как элемент управления веб-частей во время выполнения, что дает возможность функции веб-частей на элементе управления.

**Чтобы создать содержимое основной зоны**

1. В **разработки** Просмотр, перетащите **метка** управления из **Стандартная** вкладки области элементов в область содержимого зоны которого **идентификатор** свойство имеет значение MainZone.
2. Переключитесь в **источника** представления. Обратите внимание, что  **&lt;zonetemplate&gt;**  был добавлен элемент программы-оболочки для **метка** элемента управления в MainZone.
3. Добавьте атрибут с именем **заголовок** для  **&lt;asp: label&gt;**  элемент и присвойте ему значение содержимого. Удалите текст = атрибут «Label» из  **&lt;asp: label&gt;**  элемента. Между открывающим и закрывающим тегами элемента  **&lt;asp: label&gt;**  элемента, добавьте текст, таких как **Добро пожаловать в домашнюю страницу** внутри пары  **&lt;h2 &gt;**  теги элементов. Код должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. Сохраните файл.

Создайте пользовательский элемент управления, который также может быть добавлен как элемент управления веб-части на страницу.

### <a name="to-create-a-user-control"></a>Создание пользовательского элемента управления

1. Добавьте новый пользовательский элемент управления Web на сайт в качестве элемента управления поиска. Снимите флажок, чтобы **поместить исходный код в отдельном файле**. Добавьте его в том же каталоге, что страница WebPartsDemo.aspx и назовите его SearchUserControl.ascx.   
  
    > [!NOTE]
    > Пользовательский элемент управления для этого пошагового руководства не реализует функциональность поиска; он используется только для демонстрации возможностей веб-частей.
2. Переключитесь в **разработки** представления. Из **Стандартная** вкладки панели элементов перетащите элемент управления TextBox на страницу.
3. Поместите курсор после только что добавленного текстовое поле и нажмите клавишу ВВОД, чтобы добавить новую строку.
4. Перетащите элемент управления Button на страницу в новой строке под текстовым полем, который был только что добавлен.
5. Переключитесь в **источника** представления. Убедитесь, что исходный код для пользовательского элемента управления выглядит как в следующем примере. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. Сохраните и закройте файл.

Теперь можно добавить элементы управления веб-частей в зону боковой панели. В зону боковой панели добавляются два элемента управления, одна из которых содержит список ссылок, а другой — пользовательский элемент управления, созданный в предыдущей процедуре. Связи добавляются в качестве стандартного **метка** серверного элемента управления, подобно тому, как вы создали статический текст основной зоны. Хотя отдельные серверные элементы управления, содержащиеся в пользовательский элемент управления, могут содержаться непосредственно в зоне (как элемент управления метки), в этом случае они не являются. Вместо этого они являются частью пользовательского элемента управления, созданный в предыдущей процедуре. Это показан обычный способ упаковки любых элементов управления и дополнительных функциональных возможностей в пользовательский элемент управления, и затем ссылаться на этот элемент управления в зоне, что элемент управления веб-частей.

Во время выполнения в наборе элементов управления веб-частей создает оболочку для обоих элементов управления с помощью элементов управления GenericWebPart. Когда **GenericWebPart** управления создает оболочку для элемента управления, элемент управления Универсальная часть является родительского элемента управления и доступ к серверному элементу управления через свойство ChildControl родительского элемента управления. Такое использование элементов управления Универсальная часть включает стандартные серверным элементам управления иметь поведение и атрибуты элементов управления веб-частей, которые являются производными от **веб-части** класса.

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>Добавление элементов управления веб-частей в зону боковой панели

1. Откройте страницу WebPartsDemo.aspx.
2. Переключитесь в **разработки** представления.
3. Перетащите элемент управления на странице пользователя вы создали, SearchUserControl.ascx, из **обозревателе решений** в зону которого **идентификатор** свойство имеет значение SidebarZone и поместите его существует.
4. Сохраните страницу WebPartsDemo.aspx.
5. Переключитесь в **источника** представления.
6. Внутри  **&lt;asp: webpartzone&gt;**  добавьте элемент для SidebarZone над ссылку на пользовательский элемент управления,  **&lt;asp: label&gt;**  элемент с автономной ссылки, как показано в следующем примере. Кроме того, добавьте **заголовок** для тег пользовательского элемента управления со значением атрибута **поиска**, как показано. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. Сохраните и закройте файл.

Теперь можно проверить на странице, перейдя в браузере. На странице отображаются две зоны. На следующем снимке экрана показана страница.

**Веб-частей демонстрационной страницы с двумя зонами**


![Снимок экрана пошагового руководства 1 частям VS Web](profiles-themes-and-web-parts/_static/image3.gif)

**Рис. 3**: веб-частям VS 1 пошагового руководства экрана


В заголовке окна каждого элемента управления отображается стрелка вниз, предоставляющий доступ к меню доступных действий, которые можно выполнять в элементе управления. Щелкните меню команд для одного из элементов управления, а затем нажмите кнопку **свернуть** verb и обратите внимание, что элемент управления сворачивается. В меню команд, выберите пункт **восстановить**, и элемент управления возвращается до нормального размера.

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>Предоставление пользователям возможности редактировать страницы и изменение макета

Веб-части позволяет пользователям изменять макет элементов управления веб-частей, перетаскивая их в одном часовом поясе в другой. Помимо возможности перемещения **веб-части** элементов управления в одном часовом поясе в другую, можно разрешить пользователям редактировать различные свойства элементов, в том числе их внешний вид, макет и поведение. Набор элементов управления веб-частей обеспечивает базовые функции редактирования для **веб-части** элементов управления. Несмотря на то, что вы не будет сделано в данном пошаговом руководстве, можно также создать пользовательский редактор элементов управления, позволяющих пользователям редактировать возможности **веб-части** элементов управления. Как и изменение расположения **веб-часть** элемента управления, изменяя свойства элемента управления зависит от персонализации ASP.NET, чтобы сохранить изменения, внесенные пользователем.

В этой части пошагового руководства можно предоставить возможность пользователям редактировать основные характеристики любого **веб-части** управления на странице. Чтобы включить эти функции, можно добавить другой пользовательский элемент управления на страницу вместе с  **&lt;asp: editorzone&gt;**  элемент и двумя элементами управления.

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>Чтобы создать пользовательский элемент управления, позволяющий изменять макет страницы

1. В Visual Studio на **файл** последовательно выберите пункты **New** подменю и нажмите кнопку **файл** параметр.
2. В **Добавление нового элемента** диалогового окна выберите **веб-элемент управления пользователя**. Имя нового файла DisplayModeMenu.ascx. Снимите флажок, чтобы **поместить исходный код в отдельном файле**.
3. Нажмите кнопку Добавить, чтобы создать новый элемент управления.
4. Переключитесь в **источника** представления.
5. Удалить весь существующий код в новый файл и вставьте следующий код. Этот код пользовательского элемента управления использует возможности набора элементов управления веб-частей, позволяющие изменять представление или режим отображения страницы, а также позволяет изменять внешний вид и макет страницы находятся в определенных режимах отображения. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. Сохраните файл, нажав кнопку Сохранить значок на панели инструментов или выбрав **Сохранить** на **файл** меню.

### <a name="to-enable-users-to-change-the-layout"></a>Чтобы пользователи могли изменять макет

1. Откройте страницу WebPartsDemo.aspx и переключитесь в **разработки** представления.
2. Поместите курсор в **разработки** сразу после просмотра **WebPartManager** элемента управления, который был добавлен ранее. Добавьте перехода на следующую строку после текста, таким образом, что пустая строка после **WebPartManager** элемента управления. Поместите курсор на пустую строку.
3. Перетащите пользовательский элемент управления, созданный (файл с именем DisplayModeMenu.ascx) в WebPartsDemo.aspx страницы и поместите его на пустую строку.
4. Перетащите элемент управления EditorZone из **веб-части** области элементов в оставшейся открытой ячейке таблицы на странице WebPartsDemo.aspx.
5. Из **веб-части** раздел панели элементов перетащите элемент управления AppearanceEditorPart и LayoutEditorPart в **EditorZone** элемента управления.
6. Переключитесь в **источника** представления. Итоговый код в ячейке таблицы должен иметь примерно следующий код. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. Сохраните файл WebPartsDemo.aspx. Вы создали пользовательский элемент управления, позволяющий изменять режим отображения и макета страницы и ссылка на элемент управления на основной веб-странице.

Теперь можно проверить возможность редактировать страницы и изменять макет.

### <a name="to-test-layout-changes"></a>Чтобы проверить изменение макета

1. Загрузите страницу в браузере.
2. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **изменить**. Отображаются заголовки зон.
3. Перетащите **Мои ссылки** управления за его заголовок из зоны боковой панели в нижнюю часть зоны Main. Страница должна выглядеть как на следующем снимке экрана.

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>Веб-страницы демонстрационной части с элементом управления Мои ссылки перемещен


![Снимок экрана пошагового руководства 2 частям VS Web](profiles-themes-and-web-parts/_static/image4.gif)

**Рис. 4**: веб-частям VS 2 пошагового руководства экрана


1. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **Обзор**. Страница обновится, имена зон исчезнут и **Мои ссылки** управления остается в прежнем месте.
2. Для демонстрации функциональности персонализации, закройте браузер и загрузите страницу. Внесенные изменения сохраняются для будущих сеансов браузера.
3. Из **режим отображения** последовательно выберите пункты **изменить**.   
  
 Каждый элемент управления на странице теперь отображается со стрелкой вниз в заголовке окна, который содержит раскрывающееся меню команд.
4. Щелкните стрелку, чтобы отобразить меню команд на **Мои ссылки** элемента управления. Нажмите кнопку **изменить** команды.   
  
 **EditorZone** элемент управления, отображение EditorPart управляет был добавлен.
5. В **внешний вид** часть элемента управления edit, изменение **заголовок** в Избранное, используйте **рамки** раскрывающегося списка для выбора **только заголовок**, а затем нажмите кнопку **применить**. На следующем снимке экрана показана страница в режиме редактирования.

### <a name="web-parts-demo-page-in-edit-mode"></a>Веб-частей демонстрационной страницы в режиме редактирования


![Снимок экрана пошагового руководства 3 Web частям VS](profiles-themes-and-web-parts/_static/image5.gif)

**Рис. 5**: веб-частям VS 3 пошагового руководства экрана


1. Нажмите кнопку **режим отображения** и выбрать пункт **Обзор** для возврата в режим просмотра.
2. Элемент управления теперь имеет обновленный заголовок и без границы, как показано на следующем снимке экрана.

### <a name="edited-web-parts-demo-page"></a>Измененные страницы демонстрационной части Web


![Снимок экрана пошагового руководства 4 Web частям VS](profiles-themes-and-web-parts/_static/image6.gif)

**Рис. 4**: веб-частям VS 4 пошагового руководства экрана


### <a name="adding-web-parts-at-run-time"></a>Добавление веб-частей во время выполнения

Также можно разрешить пользователям добавлять элементы управления веб-частей на своей странице во время выполнения. Чтобы сделать это, настройте в странице каталог веб-частей, который содержит список элементов управления веб-частей, которые требуется сделать доступными для пользователей.

**Чтобы разрешить пользователям добавлять веб-части во время выполнения**

1. Откройте страницу WebPartsDemo.aspx и переключитесь в **разработки** представления.
2. Из **веб-части** вкладки панели элементов перетащите элемент управления CatalogZone в правом столбце таблицы, ниже **EditorZone** элемента управления.   
  
 Оба элемента управления может быть в той же ячейке таблицы, так как они не отображаются в то же время.
3. В панели «Свойства» присвойте строке **добавить веб-части** на свойство HeaderText **CatalogZone** элемента управления.
4. Из **веб-части** раздел панели элементов перетащите элемент управления DeclarativeCatalogPart в области содержимого **CatalogZone** элемента управления.
5. Щелкните стрелку в правом верхнем углу **DeclarativeCatalogPart** управления для предоставления его меню "задачи", а затем выберите **редактирование шаблонов**.
6. Из **Стандартная** панели элементов перетащите **FileUpload** управления и **календаря** управления в **WebPartsTemplate** раздел **DeclarativeCatalogPart** управления.
7. Переключитесь в **источника** представления. Проверьте исходный код из  **&lt;asp: catalogzone&gt;**  элемента. Обратите внимание, что **DeclarativeCatalogPart** управления содержит  **&lt;webpartstemplate&gt;**  элемент с двух заключенными серверных элементов управления, которые можно добавить на страницу в каталоге.
8. Добавить **заголовок** свойство для каждого из элементов управления, добавленных в каталог с помощью показано строковое значение для каждого названия в следующем примере кода. Несмотря на то, что заголовок не является свойством, которое можно установить для этих двух серверных элементов управления во время разработки, при добавлении этих элементов управления к **WebPartZone** зоны из каталога во время выполнения, они каждая из которых заключена с  **GenericWebPart** элемента управления. Это позволяет им в качестве элементов управления веб-частей, поэтому они будут отображать заголовки.   
  
 Код для двух элементов управления, содержащихся в **DeclarativeCatalogPart** управления должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. Сохраните страницу.

Теперь можно проверить каталог.

### <a name="to-test-the-web-parts-catalog"></a>Для тестирования веб-части каталога

1. Загрузите страницу в браузере.
2. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **каталога**.   
  
 Каталог с именем **добавить веб-части** отображается.
3. Перетащите **Мое избранное** управления из основной зоны обратно в верхнюю часть зоны боковой панели и поместите его существует.
4. В **добавить веб-части** каталога, установите оба флажка, а затем выберите **Main** из раскрывающегося списка, содержащего доступных зон.
5. Нажмите кнопку **добавить** в каталоге. Элементы управления добавляются в зону Main. Если требуется, можно добавить несколько экземпляров элемента управления из каталога на страницу.   
  
 На следующем снимке экрана показана страница с элементом управления загрузки файлов и календарем в зоне Main. 

![Элементы управления, добавленные из каталога основной зоны](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **Обзор**. Каталог исчезает, и страница обновляется.
7. Закройте браузер. Загрузите страницу еще раз. Внесенные изменения сохраняются.
