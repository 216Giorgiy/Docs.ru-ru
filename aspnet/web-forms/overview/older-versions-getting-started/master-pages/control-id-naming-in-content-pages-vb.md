---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
title: Контролировать именование идентификатор в страницах содержимого (VB) | Документы Microsoft
author: rick-anderson
description: Показано, как элементы управления ContentPlaceHolder служат в качестве контейнера именования и таким образом, чтобы программным образом, работа с элементом управления, сложно (через FindConrol)...
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2008
ms.topic: article
ms.assetid: dbb024a6-f043-4fc5-ad66-56556711875b
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
msc.type: authoredcontent
ms.openlocfilehash: 288afbb6851e23de4725f9e6351ae12ccecefaa5
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
---
<a name="control-id-naming-in-content-pages-vb"></a>Идентификатор элемента управления, именование в страницах содержимого (Visual Basic)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить код](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_VB.zip) или [скачать PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_VB.pdf)

> Показано, как элементы управления ContentPlaceHolder служат в качестве контейнера именования и таким образом, чтобы программным образом, работа с элементом управления, сложно (через FindConrol). Анализирует этой проблемы и способы их устранения. Также описывается программный доступ к результирующее значение ClientID.


## <a name="introduction"></a>Вступление

Все серверные элементы управления ASP.NET включают `ID` свойство, которое однозначно определяет элемент управления и представляет собой средство, с помощью которого элемент управления программными средствами доступен в классе кода. Аналогичным образом, может включать элементы в документ HTML `id` атрибут, который уникально идентифицирует элемент; эти `id` значения часто используются в клиентский сценарий программно ссылаться на конкретный элемент HTML. Учитывая это, возможно предполагается, что при подготовке к просмотру серверного элемента управления ASP.NET в формат HTML, его `ID` значение используется как `id` значение отрисовываемого элемента HTML. Это не обязательно так потому, что в некоторых случаях один управления с одним `ID` значение может появиться несколько раз в создаваемой разметки. Рассмотрите возможность управления GridView, который включает TemplateField с веб-управления Label с `ID` значение `ProductName`. Если GridView привязан к источнику данных во время выполнения, эта метка повторяется один раз для каждой строки в GridView. Друг к просмотру потребностей метки уникальный `id` значение.

Для обработки таких сценариев, ASP.NET позволяет обозначено как контейнеры именования некоторые элементы управления. Контейнер именования служит в качестве нового `ID` пространства имен. Иметь их готовый для просмотра всех серверных элементов управления, находящихся в контейнере именования `id` с префиксом `ID` именования контейнерного элемента управления. Например `GridView` и `GridViewRow` классы представляют собой контейнеры именования. Следовательно, элемент управления Label, определенные в GridView TemplateField с `ID` `ProductName` Получает отображаемый `id` значение `GridViewID_GridViewRowID_ProductName`. Поскольку *GridViewRowID* уникален для каждой строки GridView, итоговый `id` значения должны быть уникальными.

> [!NOTE]
> [ `INamingContainer` Интерфейс](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) используется для указания конкретного элемента управления сервера ASP.NET должна работать для использования в качестве контейнера именования. `INamingContainer` Интерфейс не буквам методы, которые необходимо реализовать серверного элемента управления; вместо этого он используется в качестве маркера. При формировании кода HTML, если элемент управления реализует этот интерфейс затем ASP.NET engine автоматически добавляет его `ID` значение для его дочерних элементов к просмотру `id` значений атрибута. Этот процесс является более подробно в шаге 2.


Об именах контейнеров не только изменить создаваемые `id` значение атрибута, но также влияет на как элемент управления может программным способом сослаться из класса с выделенным кодом страницы ASP.NET. `FindControl("controlID")` Метод является распространенным программным образом ссылок на веб-элемент управления. Однако `FindControl` не проникновение через контейнеров именования. Следовательно, нельзя напрямую использовать `Page.FindControl` метод для ссылки на элементы управления в элементе управления GridView или других контейнера именования.

Как вы surmised, главные страницы и ContentPlaceHolders реализуются как контейнеры именования. В этом учебнике мы изучаем главных страниц влияют на HTML-элемент `id` значения и способа программным путем ссылки на веб-элементы управления внутри страницы содержимого с помощью `FindControl`.

## <a name="step-1-adding-a-new-aspnet-page"></a>Шаг 1: Добавление новой страницы ASP.NET

Для демонстрации концепции, описанные в этом учебнике, добавим новую страницу ASP.NET на сайте. Создание новой страницы содержимого с именем `IDIssues.aspx` в корневой папке, привязав его к `Site.master` главной страницы.


![Добавление содержимого страницы IDIssues.aspx к корневой папке](control-id-naming-in-content-pages-vb/_static/image1.png)

**На рисунке 01**: Добавление страницы содержимого `IDIssues.aspx` к корневой папке


Visual Studio автоматически создает элемент управления содержимым для каждого из четырех ContentPlaceHolders главной страницы. Как отмечалось в [ *несколько и содержимого по умолчанию* ](multiple-contentplaceholders-and-default-content-vb.md) «учебник», если отсутствует элемент управления содержимым вместо этого создается ContentPlaceHolder содержимого главной страницы по умолчанию. Поскольку `QuickLoginUI` и `LeftColumnContent` ContentPlaceHolders содержат разметку соответствующего значения по умолчанию для этой страницы, действуйте и удалить их соответствующие элементы управления содержимым из `IDIssues.aspx`. На этом этапе декларативная разметка страницы содержимого должен выглядеть следующим образом:


[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample1.aspx)]

В [ *указанием заголовка, мета-теги и другие заголовки HTML на главной странице* ](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md) учебника мы создали пользовательского базового класса страницы (`BasePage`), автоматически настраивает заголовок страницы, если это не задан явно. Для `IDIssues.aspx` странице использовать эту функциональность, классов кода страницы должен быть производным от `BasePage` класса (а не `System.Web.UI.Page`). Измените определение класса с выделенным кодом, чтобы он выглядел следующим образом:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample2.vb)]

Наконец, обновите `Web.sitemap` файл, чтобы включить запись для этого нового занятия. Добавить `<siteMapNode>` и присвойте его `title` и `url` атрибуты «Управления идентификатор именования проблемы» и `~/IDIssues.aspx`соответственно. После установления это дополнение к `Web.sitemap` файла должна выглядеть следующим образом:


[!code-xml[Main](control-id-naming-in-content-pages-vb/samples/sample3.xml)]

Как показано на рис. 2, новые записи карты сайта в `Web.sitemap` немедленно отражаются в разделе занятий в левом столбце.


![Раздел занятий теперь содержит ссылку на &quot;проблем именования идентификатор элемента управления&quot;](control-id-naming-in-content-pages-vb/_static/image2.png)

**На рисунке 02**: раздел занятий теперь содержит ссылку на «Проблем именования идентификатор элемента управления»


## <a name="step-2-examining-the-renderedidchanges"></a>Шаг 2: Проверка создаваемые`ID`изменения

Чтобы лучше понять изменения ASP.NET engine вносит в готовом для просмотра `id` управляет значения сервера, можно добавить несколько веб-элементы управления для `IDIssues.aspx` и затем просмотреть кода HTML, отправляемого в браузер. В частности, введите текст «Введите ваш возраст:» следуют TextBox веб-элемент управления. Дополнительные вниз на странице добавьте кнопку веб-элемент управления и веб-управления Label. Значение текстового поля `ID` и `Columns` свойства `Age` и 3 соответственно. Настроить кнопку `Text` и `ID` свойства на «Отправить» и `SubmitButton`. Очистить метки `Text` и установите его `ID` для `Results`.

На этом этапе содержимого элемента управления должна выглядеть следующим образом:


[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample4.aspx)]

На рисунке 3 показана страница при просмотре с помощью конструктора Visual Studio.


[![На этой странице доступны три веб-элементов управления: текстовое поле, кнопку и метку](control-id-naming-in-content-pages-vb/_static/image4.png)](control-id-naming-in-content-pages-vb/_static/image3.png)

**На рисунке 03**: страница включает в себя три веб-элементов управления: текстовое поле, кнопку и метку ([Просмотр полноразмерное изображение](control-id-naming-in-content-pages-vb/_static/image5.png))


Перейдите на страницу с помощью браузера, а затем просмотрите исходный код HTML. Как разметка, ниже показан `id` значения HTML-элементов для элементов управления текстового поля, кнопки и Web метки представляют собой сочетание `ID` значения веб-элементов управления и `ID` значения именования контейнеров на странице.


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample5.html)]

Как отмечалось ранее в этом учебнике, главной страницы и ее ContentPlaceHolders выступать в качестве контейнеров именования. Следовательно, оба contribute создаваемые `ID` значения вложенных элементов управления. Использовать текстовое поле `id` атрибута, например: `ctl00_MainContent_Age`. Помните, что элемент управления TextBox `ID` значение было `Age`. Предваряется управления ContentPlaceHolder `ID` значение `MainContent`. Кроме того, это значение добавляется префикс с главной страницы `ID` значение `ctl00`. В итоге получается `id` значение атрибута, состоящих из `ID` значения главной страницы, элемент управления ContentPlaceHolder и самого текстового поля.

Рис. 4 показано такое поведение. Чтобы определить, создаваемые `id` из `Age` текстовое поле, начинающиеся с `ID` значение элемента управления TextBox `Age`. Затем постепенно вверх по иерархии элементов управления. В каждом контейнера именования (эти узлы персиковым цветом), префикс к просмотру текущего `id` с контейнера именования `id`.


![Атрибутов id готовые для просмотра, на основе на значения Идентификаторов контейнеров именования](control-id-naming-in-content-pages-vb/_static/image6.png)

**На рисунке 04**: к просмотру `id` атрибуты расположены на основе `ID` значения контейнеров именования


> [!NOTE]
> Как уже говорилось, `ctl00` часть создаваемые `id` атрибут представляет `ID` значение главной страницы, но может возникнуть вопрос этого `ID` появляется значение. Мы не был указан в любом месте в нашей главной страницы или страницы содержимого. Большинство серверных элементов управления на странице ASP.NET добавляются явным образом с помощью декларативной разметку страницы. `MainContent` Управления ContentPlaceHolder был явно указан в разметке `Site.master`; `Age` был определен TextBox `IDIssues.aspx`элемента разметки. Можно указать `ID` значения для этих типов элементов управления в окне «Свойства» или с помощью декларативного синтаксиса. Другие элементы управления, такие как главной страницы, не определенные в декларативной разметкой. Следовательно их `ID` значения должен быть автоматически создан для нас. Задает обработчик ASP.NET `ID` значения во время выполнения для этих элементов управления, идентификаторы которых явно не задан. Она использует шаблон именования `ctlXX`, где *XX* — последовательно увеличивающийся целочисленное значение.


Поскольку master страницы самого служит в роли контейнера именования веб-элементов управления, определенных на главной странице также изменили готовый для просмотра `id` значений атрибута. Например `DisplayDate` метки, мы добавили в главной страницы в [ *создание макета-узла с главными страницами* ](creating-a-site-wide-layout-using-master-pages-vb.md) учебник содержит следующие визуализации разметки:


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample6.html)]

Обратите внимание, что `id` атрибута включает оба главной страницы `ID` значение (`ctl00`) и `ID` значение элемента управления Label (`DateDisplay`).

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a>Шаг 3: Программного обращения к веб-элементы управления через`FindControl`

Каждый элемент управления сервера ASP.NET включает `FindControl("controlID")` метода поиска потомков элемента управления для элемента управления с именем *controlID*. Если такой элемент найден, возвращается; Если соответствующий элемент не найден, `FindControl` возвращает `Nothing`.

`FindControl` полезно в сценариях, где требуется доступ к элементу управления, но не имеет прямой ссылки на него. При работе с веб-элементы управления, такие как GridView, например, элементы управления внутри элемента GridView поля определяются один раз в декларативного синтаксиса, но во время выполнения создается экземпляр элемента управления для каждой строки в GridView. Таким образом существуют средства, которые создаются во время выполнения, но не требуются прямые ссылки доступен из кода класса. Поэтому необходимо использовать `FindControl` для программной работы с конкретного элемента управления внутри элемента GridView полей. (Дополнительные сведения об использовании `FindControl` элементы управления внутри шаблонов данных веб-элемента управления, в разделе [форматирование на основе по данным](../../data-access/custom-formatting/custom-formatting-based-upon-data-vb.md).) Этот же сценарий возникает, когда динамическое добавление веб-элементов управления на веб-форму, раздела подробно [создание динамических данных пользовательские интерфейсы с](https://msdn.microsoft.com/library/aa479330.aspx).

Для демонстрации использования `FindControl` метод для поиска элементов управления на странице содержимого создайте обработчик событий для `SubmitButton` `Click` событие. В обработчике событий добавьте следующий код, который программными средствами ссылается `Age` текстовое поле и `Results` метки с помощью `FindControl` метода, а затем отображает сообщение в `Results` на основе ввода пользователя.

> [!NOTE]
> Конечно, не нужно использовать `FindControl` ссылки на элементы управления Label и текстовое поле для этого примера. Мы может ссылаться на них непосредственно через их `ID` значений свойств. Я использую `FindControl` здесь, чтобы продемонстрировать, что происходит при использовании `FindControl` из страницы содержимого.


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample7.vb)]

Хотя синтаксис, используемый для вызова `FindControl` метод немного отличается в двух первых строк `SubmitButton_Click`, они семантически эквивалентны. Напомним, что все серверные элементы управления ASP.NET включают `FindControl` метод. Сюда входят `Page` класс, от которого все ASP.NET кода должны быть производными от. Таким образом, вызов `FindControl("controlID")` эквивалентно вызову `Page.FindControl("controlID")`, при условии, что еще не переопределен `FindControl` метод в классе кода или другого базового класса.

После ввода этого кода, посетите `IDIssues.aspx` через браузер, введите ваш возраст и нажмите кнопку «Отправить». При нажатии кнопки «Отправить» `NullReferenceException` возникает (см. рис. 5).


[![Возникает исключение NullReferenceException](control-id-naming-in-content-pages-vb/_static/image8.png)](control-id-naming-in-content-pages-vb/_static/image7.png)

**На рисунке 05**: A `NullReferenceException` возникает ([Просмотр полноразмерное изображение](control-id-naming-in-content-pages-vb/_static/image9.png))


Если установить точку останова в `SubmitButton_Click` обработчик событий, вы увидите, что оба вызовы `FindControl` возвращают `Nothing`. `NullReferenceException` Возникает, когда предпринимается попытка получить доступ к `Age` текстового поля `Text` свойство.

Проблема заключается в том `Control.FindControl` поиск выполняется только *управления*его потомков, которые находятся в том же контейнере именования. Так как новый контейнер именования вызов составляют главной страницы `Page.FindControl("controlID")` никогда не пронизывающая объект главной страницы `ctl00`. (Для просмотра иерархии элементов управления, как показано на рис. 4 указывают Назад `Page` объект в качестве родительского объекта главной страницы `ctl00`.) Таким образом `Results` метки и `Age` не найдены текстовое поле и `ResultsLabel` и `AgeTextBox` присваиваются значения от `Nothing`.

Существует два способа решения для этой проблемы: мы можете детализировать углублением одного контейнера именования раз в соответствующий элемент управления; или можно создать собственную `FindControl` метод, который пронизывающая именования контейнеров. Давайте рассмотрим каждый из этих параметров.

### <a name="drilling-into-the-appropriate-naming-container"></a>Детализируя контейнер соответствующих имен

Для использования `FindControl` ссылка `Results` метки или `Age` в текстовое поле, нам потребуется вызвать `FindControl` от предка элемента управления в том же контейнере именования. Как показано на рис. 4, `MainContent` управления ContentPlaceHolder является единственным предком `Results` или `Age` , находится в том же контейнере именования. Другими словами, вызов `FindControl` метод `MainContent` управления, как показано в приведенном ниже фрагменте кода правильно возвращает ссылку на `Results` или `Age` элементов управления.


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample8.vb)]

Тем не менее, мы не может работать с `MainContent` ContentPlaceHolder из класса с выделенным кодом нашу страницу содержимого с помощью синтаксиса выше, так как определено ContentPlaceHolder на главной странице. Вместо этого необходимо использовать `FindControl` для получения ссылки на `MainContent`. Замените код в `SubmitButton_Click` обработчик событий следующие изменения:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample9.vb)]

При посещении страницы через браузер, введите ваш возраст и нажмите кнопку «Отправить» `NullReferenceException` возникает. Если установить точку останова в `SubmitButton_Click` обработчик событий, вы увидите, что это исключение возникает при попытке вызова `MainContent` объекта `FindControl` метод. `MainContent` Объект равен `Nothing` из-за `FindControl` метод не может найти объект с именем «Тегу». Основную причину совпадает с `Results` метки и `Age` элемента управления TextBox: `FindControl` начинается поиск в верхней части иерархии элементов управления и не проникновение именования контейнеров, но `MainContent` ContentPlaceHolder — на главной странице, который представляет собой контейнер именования.

Прежде чем мы можем использовать `FindControl` для получения ссылки на `MainContent`, необходимо сначала ссылку на элемент управления главной страницы. После получения ссылки на главную страницу, мы можем получить ссылку на `MainContent` ContentPlaceHolder через `FindControl` и из него, ссылки на `Results` метки и `Age` текстового поля (опять же, с помощью `FindControl`). Но, как получить ссылку на главную страницу? Изучая `id` атрибуты в создаваемой разметки это очевидно, главной страницы `ID` значение `ctl00`. Таким образом, мы используем `Page.FindControl("ctl00")` для получения ссылки на главную страницу, затем использовать этот объект для получения ссылки на `MainContent`, и т. д. В следующем фрагменте показано следующую логику:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample10.vb)]

Хотя этот код будет работать наверняка, предполагается, что автоматически сформированные главной страницы `ID` всегда будет `ctl00`. Никогда не рекомендуется делать предположения о значениях автоматически.

К счастью, доступном через ссылку на главную страницу `Page` класса `Master` свойство. Таким образом, вместо того чтобы использовать `FindControl("ctl00")` для получения ссылки главной страницы, чтобы получить доступ к `MainContent` ContentPlaceHolder, можно вместо этого использовать `Page.Master.FindControl("MainContent")`. Обновление `SubmitButton_Click` обработчик событий следующим кодом:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample11.vb)]

На этот раз посетив страницу через браузер, введите ваш возраст и нажав кнопку «Отправить» отображает сообщение в `Results` метки, как ожидалось.


[![Возраста пользователя отображается в метке](control-id-naming-in-content-pages-vb/_static/image11.png)](control-id-naming-in-content-pages-vb/_static/image10.png)

**На рисунке 06**: возраста пользователя отображается в метке ([Просмотр полноразмерное изображение](control-id-naming-in-content-pages-vb/_static/image12.png))


### <a name="recursively-searching-through-naming-containers"></a>Рекурсивный поиск в контейнерах именования

Причина в предыдущем примере ссылка на `MainContent` управления ContentPlaceHolder на главной странице и затем `Results` метки и `Age` элементы управления TextBox с `MainContent`, поскольку `Control.FindControl` только метод выполняет поиск в пределах *управления*контейнера именования элемента. Наличие `FindControl` остаются в контейнере имен имеет смысл в большинстве случаев, так как два элемента управления в двух разных контейнерах именования может иметь такую же `ID` значения. Рассмотрим случай GridView, который определяет метку веб-элемент управления с именем `ProductName` в одном из его TemplateFields. При привязке данных к GridView во время выполнения, `ProductName` метка создается для каждой строки в GridView. Если `FindControl` поиск всех имен контейнеров и мы вызывается `Page.FindControl("ProductName")`, какой экземпляр Label должно `FindControl` возврата? `ProductName` Метки в первой строке GridView? Один в последней строке?

Так что наличие `Control.FindControl` поиска просто *управления*именования элемента контейнера имеет смысл в большинстве случаев. Но в других случаях, например с выходом (США), где у нас есть уникальный `ID` во всех контейнерах именования и хотите избежать необходимости тщательно ссылаться каждого контейнера именования в иерархии элементов управления, доступ к элементу управления. Наличие `FindControl` тип variant, рекурсивно выполняет делает все контейнеры именования определения слишком. К сожалению .NET Framework не включает такой метод.

Хорошо то, что можно создавать собственные `FindControl` метод, рекурсивно выполняет поиск всех имен контейнеров. Фактически, с помощью *методы расширения* мы можно добавить `FindControlRecursive` метод `Control` класс сопровождающее своих существующих `FindControl` метод.

> [!NOTE]
> Методы расширения являются нового компонента для C# 3.0 и Visual Basic 9, которые являются языки, которые поставляются вместе с .NET Framework версии 3.5 и Visual Studio 2008. Иными словами методы расширения позволяют разработчикам создавать новый метод для существующего типа класса через специальный синтаксис. Дополнительные сведения об этой функции, полезные ссылки моей статье [расширение функции базового типа с помощью методов расширения](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).


Чтобы создать метод расширения, добавьте новый файл `App_Code` папку с именем `PageExtensionMethods.vb`. Добавьте метод расширения с именем `FindControlRecursive` в качестве входного значения, `String` параметр с именем `controlID`. Для правильной работы методов расширения, крайне важно, чтобы класс помечается как `Module` и что методы расширения стоять `<Extension()>` атрибута. Кроме того, все методы расширения необходимо принять в качестве первого параметра объект типа, к которому применяется метод расширения.

Добавьте следующий код в `PageExtensionMethods.vb` файл для определения это `Module` и `FindControlRecursive` метода расширения:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample12.vb)]

Этот код в месте, вернуться к `IDIssues.aspx` класса с выделенным кодом и закомментируйте текущей страницы `FindControl` вызовы методов. Замените вызовы `Page.FindControlRecursive("controlID")`. Что такое аккуратно о методах расширения — они отображаются в раскрывающихся списках IntelliSense. Как показано на рис. 7, при вводе `Page` и нажмите клавишу периода, `FindControlRecursive` метод включен в IntelliSense раскрывающемся вместе с другой `Control` методы класса.


[![Методы расширения, включенные в IntelliSense раскрывающийся список](control-id-naming-in-content-pages-vb/_static/image14.png)](control-id-naming-in-content-pages-vb/_static/image13.png)

**На рисунке 07**: методы расширения, включенные в IntelliSense раскрывающимися списками ([Просмотр полноразмерное изображение](control-id-naming-in-content-pages-vb/_static/image15.png))


Введите следующий код в `SubmitButton_Click` обработчика событий, а затем, посетив страницу, введите ваш возраст и нажав кнопку «Отправить». Как показано обратно на рис. 6, результат будет сообщение, «Are возраст лет!»


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample13.vb)]

> [!NOTE]
> Нельзя использовать методы расширения, так как методы расширения являются новой для C# 3.0 и Visual Basic 9, если вы используете Visual Studio 2005. Вместо этого необходимо реализовать `FindControlRecursive` метод во вспомогательном классе. [Рик Штраль](http://www.west-wind.com/WebLog/default.aspx) такой пример содержится в своем блоге [мазерный страниц ASP.NET и `FindControl` ](http://www.west-wind.com/WebLog/posts/5127.aspx).


## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a>Шаг 4: С использованием правильного`id`значения в клиентский сценарий атрибута

Как отмечено во введении этого учебника, веб-элемент управления к просмотру `id` атрибут часто используется в клиентский сценарий программно ссылаться на конкретный элемент HTML. Например, следующий JavaScript ссылается на HTML-элемента с его `id` и отображает его значение в модальное окно сообщения:


[!code-csharp[Main](control-id-naming-in-content-pages-vb/samples/sample14.cs)]

Напомним, что в ASP.NET страниц, не включайте контейнера именования, отрисовываемого элемента HTML `id` атрибут идентична веб-элемента управления `ID` значение свойства. По этой причине привлекательным жестко в `id` значения атрибутов в код JavaScript. То есть, если известно, требуется доступ к `Age` веб-управления TextBox через клиентский сценарий, сделать это через вызов `document.getElementById("Age")`.

Проблема этого подхода заключается в том при использовании главных страниц (или других контейнерных элементов управления именования) отображаемого HTML-кода `id` не путать с веб-элемента управления `ID` свойство. Ваш первый наклон возможно, посетите веб-сайт с помощью браузера и просмотреть исходный код для определения фактического `id` атрибута. Если известно, создаваемые `id` значение, можно было вставить его в вызов `getElementById` доступ к элементу HTML, необходимые для работы с посредством клиентского скрипта. Такой подход не является идеальным, так как некоторые изменения на страницу иерархии элементов управления или изменения `ID` именования элементов управления приведут к изменению результата `id` атрибутов, тем самым критические код JavaScript.

Хорошо то, что `id` значение атрибута, который подготавливается к просмотру доступен в коде на стороне сервера с помощью веб-элемента управления [ `ClientID` свойства](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx). Это свойство следует использовать для определения `id` атрибута значение, используемое в клиентского скрипта. Например, чтобы добавить функцию JavaScript на страницу, при вызове отображает значение `Age` текстовое поле в модальное окно сообщения, добавьте следующий код в `Page_Load` обработчик событий:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample15.vb)]

Этот код вставляет значения `Age` текстового поля `ClientID` свойство в вызов JavaScript `getElementById`. Если эту страницу через браузер и просмотреть исходный код HTML, вы увидите следующий код JavaScript:


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample16.html)]

Обратите внимание как правильное `id` значение атрибута `ctl00_MainContent_Age`, отображается в вызове `getElementById`. Поскольку это значение вычисляется во время выполнения, он работает независимо от того, последующие изменения в иерархии элементов управления страницы.

> [!NOTE]
> В этом примере JavaScript просто показано, как добавить функцию JavaScript, которая правильно ссылается на элемент HTML, отображаемый серверным элементом управления. Для использования этой функции необходимо создавать дополнительные JavaScript для вызова функции, при загрузке документа или процесс некоторых специальных действий пользователя. Дополнительные сведения об этих и щелкните ссылку, чтение [работа с клиентский сценарий](https://msdn.microsoft.com/library/aa479302.aspx).


## <a name="summary"></a>Сводка

Некоторые серверные элементы управления ASP.NET являются контейнерами именования, что влияет на создаваемые `id` атрибут значения своих дочерних элементов управления, а также область элементов управления canvassed по `FindControl` метод. Зависимости от того, главные страницы самой главной страницы и ее элементы управления ContentPlaceHolder именования контейнеров. Следовательно, нужно поместить д немного больше усилий, чтобы программно обращаться к элементам управления в страницу содержимого с помощью `FindControl`. В этом учебнике мы рассмотрели два метода: детализации в элемент управления ContentPlaceHolder и при вызове метода его `FindControl` метода; и накат собственных `FindControl` реализацию, рекурсивно ищет все контейнеры именования.

Помимо проблем серверные контейнеры именования вводят в зависимости от того, ссылки на веб-элементы управления существуют проблемы на стороне клиента. В случае отсутствия контейнеров именования, веб-элемент управления `ID` значение свойства и подготовки к просмотру `id` значения атрибута являются одним так же. Но с добавлением контейнера именования, создаваемые `id` атрибута включает в себя `ID` значения веб-элемента управления и именования контейнеров в происхождение иерархии элементов управления. Эти вопросы именования имеют не проблему-до тех пор, пока используется веб-элемента управления `ClientID` свойства, чтобы определить, создаваемые `id` значения в сценарии клиентский атрибута.

Программирование довольны!

### <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения по темам, рассматриваемые в этом учебнике см. в следующих ресурсах:

- [Главные страницы ASP.NET и `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [Создание динамических данных пользовательские интерфейсы](https://msdn.microsoft.com/library/aa479330.aspx)
- [Расширение функциональных возможностей базового типа с помощью методов расширения](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [Практическое руководство: Ссылки содержимого страницы мастера ASP.NET](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [Главной страницы: Советы, рекомендации и ловушек](http://www.odetocode.com/articles/450.aspx)
- [Работа с клиентского скрипта](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор по ASP/ASP.NET и основатель 4GuysFromRolla.com, работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 3.5 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Скотт может быть достигнута по [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com) или через его блог по [ http://ScottOnWriting.NET ](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Благодарности

Этот учебник ряд прошел проверку многие полезные рецензентов. Основными редакторами этого учебника были Зак Джонс и Suchi Barnerjee. Объясняются моих последующих статей для MSDN? Если Да, напишите мне по [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com).

> [!div class="step-by-step"]
> [Назад](urls-in-master-pages-vb.md)
> [Вперед](interacting-with-the-master-page-from-the-content-page-vb.md)
