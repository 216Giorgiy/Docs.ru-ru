---
uid: web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
title: Максимальную производительность с платформой Entity Framework 4.0 в 4 веб-приложение ASP.NET | Документы Microsoft
author: tdykstra
description: Этот учебник ряд строится на веб-приложение Contoso университета, созданный Приступая к работе с рядами учебника Entity Framework 4.0. I...
ms.author: aspnetcontent
manager: wpickett
ms.date: 01/26/2011
ms.topic: article
ms.assetid: 4e43455e-dfa1-42db-83cb-c987703f04b5
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
msc.type: authoredcontent
ms.openlocfilehash: b85645eebf2822b33df944692736ea9d9b69b9aa
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30891416"
---
<a name="maximizing-performance-with-the-entity-framework-40-in-an-aspnet-4-web-application"></a>Повышение производительности с платформой Entity Framework 4.0 в 4 веб-приложение ASP.NET
====================
по [Tom Dykstra](https://github.com/tdykstra)

> Этот учебник ряд основан на веб-приложение Contoso университета, созданный [Приступая к работе с Entity Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started) учебника рядов. Если не была завершена ранее учебники, в качестве отправной точки для этого учебника вы можете [загрузить приложение](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) , будет создана. Вы также можете [загрузить приложение](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) , создаваемый для завершения учебника ряда. Если у вас есть вопросы о учебники, их можно разместить [форум по ASP.NET Entity Framework](https://forums.asp.net/1227.aspx).


В предыдущем учебнике вы узнали, как обрабатывать конфликты параллелизма. Этот учебник показывает параметры для повышения производительности веб-приложения ASP.NET, использующего платформу Entity Framework. Мы рассмотрим несколько методов для увеличения производительности или Диагностика проблем с производительностью.

Сведения, представленные в следующих разделах будут полезны в самых разных сценариях:

- Эффективно Загрузите связанные данные.
- Управления состоянием просмотра.

Сведения, представленные в следующих разделах может быть полезно при наличии отдельных запросов, наличие проблем с производительностью:

- Используйте `NoTracking` параметр слияния.
- Предварительная компиляция запросов LINQ.
- Проверьте запрос команды, отправляемые в базу данных.

Сведения, представленные в следующем разделе потенциально полезно для приложений, которые имеют очень большие объемы данных модели:

- Заранее создавать представления.

> [!NOTE]
> Производительность веб-приложения зависит от многих факторов, включая размер данных, запросов и ответов, скорость передачи запросов к базе данных, сколько запросов на сервере можно поместить в очередь и насколько быстро она может обслуживать их и даже эффективность любого библиотеки клиентских сценариев, который может использоваться. Если важна производительность в приложении или тестирования или взаимодействие показывает, что производительность приложения не подходит, необходимо следовать обычного протокола для настройки производительности. Измерения для обнаружения возникновения узких мест производительности, а затем адреса областей, которые будут иметь наибольшее влияние на общую производительность приложения.
> 
> Этот раздел посвящен в основном способами, в которой можно повысить производительность, в частности платформы Entity Framework в ASP.NET. Здесь подсказки полезны в том случае, если выяснится, что доступ к данным — одна из узкие места производительности в приложении. За исключением того, как уже отмечалось, методы, которые описаны здесь не должна считаться &quot;рекомендации&quot; в целом, многие из них подходят только в исключительных ситуациях или адрес очень определенным типам узких мест производительности.


Чтобы начать работу с учебником, запустите Visual Studio и откройте веб-приложение Contoso университета, велась работа в предыдущем учебнике.

## <a name="efficiently-loading-related-data"></a>Эффективно загрузка связанных данных

Существует несколько способов, что платформа Entity Framework можно загрузить связанные данные в свойства навигации сущности:

- *Отложенная загрузка*. При первом чтении сущности связанные данные не извлекаются. Однако при первой попытке доступа к свойству навигации необходимые для этого свойства навигации данные извлекаются автоматически. Это приведет к несколько запросов, отправляемые в базу данных — один для самой сущности и один каждый раз, что связанные данные для сущности необходимо извлечь. 

    [![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)

*Безотложная загрузка*. При чтении сущности связанные данные извлекаются вместе с ней. Обычно такая загрузка представляет собой одиночный запрос с соединением, который получает все необходимые данные. Безотложная загрузка задаются с помощью `Include` метода, как вы уже видели в этих учебниках.

[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)

- *Явная загрузка*. Это похоже на отложенную загрузку, за исключением того, что явно получать взаимосвязанные данные в коде; Это не происходит автоматически при доступе к свойству навигации. Загрузить связанные данные вручную с помощью `Load` метод свойства навигации для коллекций, либо можно использовать `Load` метод ссылочное свойство для свойств, содержащий один объект. (Например, следует вызвать `PersonReference.Load` метод, чтобы загрузить `Person` свойство навигации `Department` сущности.)

    [![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)

Так как они не извлекают немедленно значения свойств, отложенную загрузку и явная загрузка также оба называются *отложенная загрузка*.

Отложенная загрузка — контексте объекта, который был создан конструктором по умолчанию. При открытии *SchoolModel.Designer.cs* файл, определяющий класс контекста объекта, вы найдете трех методов конструктора и каждой из них включает следующую инструкцию:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample1.cs)]

Как правило если известно, необходимо связанных данных для каждой сущности, полученного, упреждающая загрузка обеспечивает наивысшую производительность, из-за одного запроса, отправляемые в базу данных обычно более эффективно, чем отдельные запросы для каждой сущности, которые получены. С другой стороны, если необходимо получить доступ к свойствам навигации сущности только редко или только для небольших набора сущностей, отложенную загрузку или явная загрузка может быть эффективнее, поскольку упреждающую бы получить больше данных, чем необходимо.

В веб-приложении отложенную загрузку может быть сравнительно мало пользы в любом случае, поскольку действия пользователя, которые влияют на потребность в связанных данных выполняются в браузере, не имеет подключения к контексту объекта, который страницы к просмотру. С другой стороны Если databind элемента управления обычно известно, какие данные требуется и поэтому, как правило, наилучшим образом выберите упреждающую или отложенной загрузки на основе возможности подходить для каждого сценария.

Кроме того элемент управления с привязкой к данным может использовать объект сущности после удаления контекст объекта. В этом случае произойдет сбой попытка отложенной загрузки свойства навигации. Снят появляется сообщение об ошибке: &quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;

`EntityDataSource` Элемента управления по умолчанию отключает отложенную загрузку. Для `ObjectDataSource` управления используется в учебнике текущей (или если вы доступ к контексту объекта из кода страницы), существует несколько способов, чтобы отложенная загрузка отключена по умолчанию. Ее можно отключить при создании экземпляра контекста объекта. Например, добавьте следующую строку в метод конструктора `SchoolRepository` класса:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample2.cs)]

Для приложения Contoso университета вносятся автоматически отключить отложенную загрузку, чтобы это свойство не нужно задавать всякий раз, когда создается экземпляр контекста контекста объекта.

Откройте *SchoolModel.edmx* данные модели, щелкните область конструктора и затем в панели «Свойства» задайте **включена отложенная загрузка** свойства `False`. Сохраните и закройте модели данных.

[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)

## <a name="managing-view-state"></a>Управление состоянием представления

Для обеспечения функций обновления, веб-страницу ASP.NET при отображении страницы следует хранить исходные значения свойств сущности. Во время обработки элемент управления обратной передачи можно повторно создать исходное состояние сущности и сущности вызвать `Attach` метод до применения изменений и вызов `SaveChanges` метод. По умолчанию элементы управления данными веб-форм ASP.NET позволяет хранить исходные значения состояния представления. Тем не менее состояние представления может повлиять на производительность, поскольку она хранится в скрытых полей, которые может существенно увеличить размер страницы, передаваемые из браузера.

Методы для управления состояние представления или альтернативные варианты, такие как состояние сеанса не уникальные для платформы Entity Framework, поэтому этот учебник не перейти в этом разделе подробно. Дополнительные сведения см. по ссылкам в конце учебника.

Однако версии 4 ASP.NET предлагает новый способ работы с состояния представления, которое каждый разработчик ASP.NET Web Forms приложений следует иметь в виду: `ViewStateMode` свойство. Это новое свойство можно задать на уровне страницы или элемента управления и позволяет отключить состояние представления для страницы по умолчанию и включать его только для элементов управления, которым она необходима.

Для приложений, когда производительность критически важна рекомендуется всегда отключите состояние просмотра на уровне страниц и включить его только для элементов управления, которые их используют. Размер состояния просмотра страницы университета Contoso бы значительно возрасти этим методом, но чтобы увидеть, как это работает, мы сделаем это *Instructors.aspx* страницы. Эта страница содержит много элементов управления, включая `Label` элемента управления, имеющего состояние просмотра отключено. Фактически, ни один из элементов управления на этой странице необходимо иметь представление состояния включена. ( `DataKeyNames` Свойство `GridView` управления определяет состояния, которая должна сохраняться между обратными передачами данных, но эти значения сохраняются в состоянии элемента управления, которое не влияет `ViewStateMode` свойство.)

`Page` Директивы и `Label` разметку элемента управления, в настоящее время, аналогичный следующему примеру:

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample3.aspx)]

Внесите следующие изменения:

- Добавить `ViewStateMode="Disabled"` для `Page` директивы.
- Удалить `ViewStateMode="Disabled"` из `Label` элемента управления.

Разметка теперь приведенной в следующем примере:

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample4.aspx)]

Состояние просмотра отключено для всех элементов управления. При добавлении элемента управления, который требуется использовать состояние представления позже все, что нужно сделать — включить `ViewStateMode="Enabled"` атрибутов для этого элемента управления.

## <a name="using-the-notracking-merge-option"></a>С помощью параметра слияния NoTracking

Когда контекста объекта извлекает строки базы данных и создает объекты сущности, представляющие их, по умолчанию он также отслеживает этих объектов сущностей, используя его диспетчер состояния объекта. Эти данные отслеживания действует как кэш и используется, если вы обновили сущность. Так как веб-приложения обычно короткоживущего объекта контекста экземпляра, запросы часто возвращают данные, которые не должны отслеживаться, так как контекст объекта, который считывает их будет удалена, прежде чем любые элементы, которые он считывает повторно использовать или обновлена.

В Entity Framework, можно указать, отслеживает ли контексту объекта объектов сущностей, задав *merge-параметр*. Можно задать параметр слияния для отдельных запросов, или для наборов сущностей. Если устанавливается для набора сущностей, это означает, что задается параметром слияния по умолчанию для всех запросов, созданных для этого набора сущностей.

Для приложения Contoso университета не требуется отслеживания для любого набора сущностей, к которым будет обращаться из репозитория, поэтому можно установить параметр слияния `NoTracking` для этих наборов сущностей, при создании экземпляра контекста объекта в классе репозитория. (Обратите внимание, что в этом учебнике параметр слияния не будет заметно влияет на производительность приложения. `NoTracking` Скорее всего сделать улучшение производительности наблюдаемого только в определенных сценариях больших данных.)

В папке DAL откройте *SchoolRepository.cs* и добавьте метод конструктор, который задает параметр слияния для репозитория обращается к наборы сущностей:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample5.cs)]

## <a name="pre-compiling-linq-queries"></a>Предварительно компиляции запросов LINQ

В первый раз, выполняющая Entity Framework запроса Entity SQL в течение жизненного цикла данного `ObjectContext` экземпляра, потребуется некоторое время для компиляции запроса. Результат компиляции кэшируется, что означает, что при последующем выполнении запроса гораздо быстрее. Запросы LINQ выполните той же модели, за исключением того, что некоторые действия, необходимые для компиляции запроса выполняется каждый раз при выполнении запроса. Другими словами для запросов LINQ, по умолчанию не все результаты компиляции кэшируются.

При наличии запроса LINQ, который планируется выполнять несколько раз в жизни контекста объекта, можно написать код, в результате все результаты компиляции кэшироваться при первом запуске запроса LINQ.

Как иллюстрация, вы сможете сделать это для двух `Get` методы в `SchoolRepository` класс, один из которых не принимает никаких параметров ( `GetInstructorNames` метод) и та, которая требует параметра ( `GetDepartmentsByAdministrator` метода). Эти методы, как они используются теперь фактически не требуется скомпилировать, поскольку они не являются запросы LINQ:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample6.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample7.cs)]

Тем не менее, можно опробовать скомпилированных запросов, будет продолжить как если бы они были записаны как следующие запросы LINQ:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample8.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample9.cs)]

Можно изменить код в этих методах что показанный выше и запустить приложение, чтобы убедиться, что он работает, прежде чем продолжить. Однако приведенные ниже инструкции перейти непосредственно в создании предварительно скомпилированного версий.

Создайте файл класса в *DAL* папки, назовите его *SchoolEntities.cs*и замените существующий код следующим кодом:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample10.cs)]

Этот код создает разделяемый класс, расширяющий класс контекста автоматически создаваемый объект. Разделяемый класс включает в себя два скомпилированные запросы LINQ с помощью `Compile` метод `CompiledQuery` класса. Он также создает методы, которые можно использовать для вызова запросов. Сохраните и закройте файл.

Далее в *SchoolRepository.cs*, измените существующий `GetInstructorNames` и `GetDepartmentsByAdministrator` методов репозитория класса, чтобы они вызывать скомпилированные запросы:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample11.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample12.cs)]

Запустите *Departments.aspx* страницу, чтобы убедиться, что он работает, как раньше. `GetInstructorNames` Метод вызывается для заполнения раскрывающегося списка администраторов и `GetDepartmentsByAdministrator` метод вызывается при нажатии кнопки **обновление** для проверки того, что не инструктора является администратором из более чем одной отдел.

[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)

Вы уже предварительно скомпилированных запросов в приложении университета Contoso только для того, чтобы узнать, как сделать это, не потому, что он позволяет улучшить значительно производительность. Предварительная компиляция запросов LINQ добавить уровень сложности кода, таким образом, убедитесь, что можно сделать только для запросов, которые фактически представляют узкие места производительности в приложении.

## <a name="examining-queries-sent-to-the-database"></a>Изучение запросы, отправляемые в базу данных

При изучении проблем с производительностью, иногда полезно знать точный команды SQL, Entity Framework, отправляет в базу данных. Если вы работаете с `IQueryable` объекта, один из способов сделать это является использование `ToTraceString` метода.

В *SchoolRepository.cs*, измените код в `GetDepartmentsByName` метод в соответствии со следующим примером:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample13.cs)]

`departments` Переменной должен быть приведен к `ObjectQuery` только потому, что `Where` создает метод в конце предыдущей строки `IQueryable` объекта; без `Where` метод, что приведение было бы не нужно.

Установите точку останова на `return` строки, а затем запустите *Departments.aspx* страницы в отладчике. При попадании в точку останова, изучите `commandText` переменных в **локальные** окно и используйте средство визуализации текста (значок лупы в **значение** столбец) для отображения его значения в **Визуализации текста** окна. Вы можете увидеть вся команда SQL, полученный в результате этого кода:

[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)

В качестве альтернативы функция IntelliTrace в Visual Studio Ultimate позволяет просмотреть команды SQL, созданные платформой Entity Framework, не требуется изменять код или даже установить точку останова.

> [!NOTE]
> Следующие процедуры можно выполнить только в том случае, если вы используете Visual Studio Ultimate.


Восстановить исходный код в `GetDepartmentsByName` метода, а затем выполните *Departments.aspx* страницы в отладчике.

В Visual Studio, выберите **отладки** меню, затем **IntelliTrace**, а затем **события IntelliTrace**.

[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)

В **IntelliTrace** окно, нажмите кнопку **прервать все**.

[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)

**IntelliTrace** окна отображает список последних событий:

[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)

Нажмите кнопку **ADO.NET** строки. Он разворачивается для отображения вы текст команды:

[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)

Вся команда текстовую строку можно скопировать в буфер обмена из **локальные** окна.

Предположим, что вы работали с базой данных с несколько таблиц, связей и столбцов, чем простой `School` базы данных. Может оказаться, что запрос, который получает все сведения, необходимые в одном `Select` инструкции, содержащей несколько `Join` предложений становится слишком сложной для эффективной работы. В этом случае вы можете переключиться с eager загрузки для явной загрузки для упрощения запроса.

Например, попробуйте изменить код в `GetDepartmentsByName` метод в *SchoolRepository.cs*. В настоящее время в том, что метод имеет запрос объектов с `Include` методы для `Person` и `Courses` свойства навигации. Замените `return` инструкции с кодом, который выполняется явная загрузка, как показано в следующем примере:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample14.cs)]

Запустите *Departments.aspx* в отладчике и проверьте **IntelliTrace** окна, как вы делали раньше. Где возникла одного запроса до, вы увидите длинную последовательность из них.

[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)

Щелкните первый **ADO.NET** строки, чтобы увидеть, что произошло с сложного запроса можно просматривать ранее.

[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)

Запрос из отделов стала простой `Select` запроса нет `Join` предложение, но его следует отдельных запросов, извлекающих связанных курсов и администратором, с помощью набора двух запросов для каждого отдела возвращенных исходного запрос.

> [!NOTE]
> Если оставить отложенной загрузки включен, шаблон, который можно увидеть ниже, с помощью того же запроса повторяться много раз может быть вызвано отложенную загрузку. Шаблон, который вы обычно хотите избежать — отложенная загрузка связанных данных для каждой строки таблицы первичного. Если вы убедились, что одно соединение запрос слишком сложен для эффективности, обычно будет возможность повысить производительность в таких случаях путем изменения основного запроса для использования безотложной загрузкой.


## <a name="pre-generating-views"></a>Предварительно создание представлений

Когда `ObjectContext` сначала создается объект в новый домен приложения, Entity Framework создает набор классов, используемых для доступа к базе данных. Эти классы называются *представления*, и при наличии очень большой модели данных, создание этих представлений можно отложить ответа веб-сайта на первый запрос для страницы, после инициализации нового домена приложения. Эта задержка первого запроса можно уменьшить путем создания представлений во время компиляции, а не во время выполнения.

> [!NOTE]
> Если приложение не имеет очень большой модели данных, или если у нее большой модели данных, но не является критическим проблемы с производительностью, которые влияют на первом запросе страницы после перезапуска IIS, этот раздел можно пропустить. Создание не происходит каждый раз при создании экземпляра представления `ObjectContext` объекта, так как представления, кэшируются в домене приложения. Таким образом Если часто перезапуск приложения в IIS, очень небольшое число запросов страниц очень выгодно заранее сформированные представления.


Можно предварительно создать представления, используя *EdmGen.exe* средство командной строки или с помощью *преобразования текстовых шаблонов* шаблонов (T4). В этом учебнике будет использоваться шаблон T4.

В *DAL* папки, добавьте в файл с помощью **текстового шаблона** шаблона (под **Общие** узел в **установленные шаблоны** списка), и назовите его *SchoolModel.Views.tt*. Замените существующий код в файле следующим кодом:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample15.cs)]

Этот код формирует представления для *.edmx* файл, расположенный в той же папке, что и шаблон и как файл шаблона, который имеет то же имя. Например, если имя файла шаблона *SchoolModel.Views.tt*, он будет искать файл модели данных с именем *SchoolModel.edmx*.

Сохраните файл, а затем щелкните правой кнопкой мыши файл в **обозревателе решений** и выберите **запустить пользовательский инструмент**.

[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)

Visual Studio создает файл кода, создает представления, который называется *SchoolModel.Views.cs* на основе шаблона. (Вы могли заметить, что создается файл кода, даже в том случае, прежде чем выбрать **запустить пользовательский инструмент**, сразу после сохранения файла шаблона.)

[![Image01](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)

Теперь можно запустить приложение и убедиться, что он работает, как раньше.

Дополнительные сведения о заранее сформированные представления см. следующие ресурсы:

- [Как: заранее создать представления для повышения производительности запросов](https://msdn.microsoft.com/library/bb896240.aspx) на веб-сайте MSDN. Описание способов использования `EdmGen.exe` средство командной строки для предварительного формирования представления.
- [Изолирование производительности с помощью предкомпилированный/предварительное-generated представлений в Entity Framework 4](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx) в блоге Windows Server AppFabric группа консультантов по.

На этом завершается введение в повышение производительности в веб-приложение ASP.NET, использующего платформу Entity Framework. Дополнительные сведения см. в следующих ресурсах:

- [Вопросы производительности (Entity Framework)](https://msdn.microsoft.com/library/cc853327.aspx) на веб-сайте MSDN.
- [Сообщения, связанные с производительностью, блоге группы разработчиков Entity Framework](https://blogs.msdn.com/b/adonet/archive/tags/performance/).
- [EF параметры слияния и скомпилированные запросы](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx). Запись блога, объясняющее непредсказуемого поведения скомпилированных запросов и слияния такие параметры, как `NoTracking`. Если вы планируете использовать скомпилированные запросы или работают с ними параметров слияния в приложении, сначала прочтите следующее.
- [Сущности, связанной с Framework публикации в блоге данных и моделирование группа консультантов по](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/). Включает в себя записи об скомпилированных запросов и обнаружить проблемы с производительностью с помощью профилировщика Visual Studio 2010.
- [Entity Framework форум потока с рекомендации по увеличению производительности очень сложных запросов](https://social.msdn.microsoft.com/Forums/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6).
- [Управления состоянием ASP.NET](https://msdn.microsoft.com/library/z1hkazw7.aspx).
- [С помощью платформы Entity Framework и ObjectDataSource: пользовательское разбиение по страницам](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx). Запись блога, созданный в приложении ContosoUniversity, созданных в этих учебниках объясняется, как реализовать разбиение по страницам в *Departments.aspx* страницы.

Следующее руководство рассматриваются некоторые важные улучшения на платформу Entity Framework, которые появились в версии 4.

> [!div class="step-by-step"]
> [Назад](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
> [Вперед](what-s-new-in-the-entity-framework-4.md)
