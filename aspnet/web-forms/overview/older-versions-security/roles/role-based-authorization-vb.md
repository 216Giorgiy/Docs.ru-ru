---
uid: web-forms/overview/older-versions-security/roles/role-based-authorization-vb
title: "Ролевая авторизация (VB) | Документы Microsoft"
author: rick-anderson
description: "Этот учебник запускает рассматриваются как framework ролей связывает роли пользователя с его контекста безопасности. Затем он проверяет применение URL-адрес на основе ролей..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/24/2008
ms.topic: article
ms.assetid: 83b4f5a4-4f5a-4380-ba33-f0b5c5ac6a75
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-security/roles/role-based-authorization-vb
msc.type: authoredcontent
ms.openlocfilehash: 331282dfa3c05dd4bd6fef19dcfe7e5c0adad84d
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="role-based-authorization-vb"></a>Ролевая авторизация (Visual Basic)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить код](http://download.microsoft.com/download/6/0/3/6032582f-360d-4739-b935-38721fdb86ea/VB.11.zip) или [скачать PDF](http://download.microsoft.com/download/6/0/3/6032582f-360d-4739-b935-38721fdb86ea/aspnet_tutorial11_RoleAuth_vb.pdf)

> Этот учебник запускает рассматриваются как framework ролей связывает роли пользователя с его контекста безопасности. Затем он проверяет применение правил на основе ролей для авторизации URL-адрес. После того, что мы рассмотрим использование декларативные и программные средства для изменения данных, которые отображаются и функциональные возможности, предлагаемые страницы ASP.NET.


## <a name="introduction"></a>Вступление

В <a id="_msoanchor_1"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-vb.md) учебника мы узнали, как использование авторизации URL-адреса для указания, какие удалось посещаемые определенным набором страниц. С немного усилий разметки в `Web.config`, мы удалось указание ASP.NET, чтобы только прошедшие проверку подлинности пользователи посетить страницу. Мы можете или определяют, что был разрешен только пользователям Tito и Боб, указывают, что всем вошедшим пользователям, за исключением Sam было разрешено.

В дополнение к авторизации URL-адреса мы также рассмотрели декларативные и программные способы управления отображаемые данные и функциональные возможности, предлагаемые на основе пользователя посещении страницы. В частности мы создали страницу, в списке содержимое текущего каталога. Любой пользователь может посетите эту страницу, но только пользователи, прошедшие проверку подлинности, может просматривать содержимое файлов и только Tito может удалить файлы.

Применение правил авторизации на основе пользователя по может достигнуть кошмаром бухгалтерского учета. Более простого в сопровождении подходом является использование авторизации на основе ролей. Хорошие новости является столь же работы средств в своем распоряжении, для применения правила авторизации хорошо с ролями, как и для учетных записей пользователей. Правила авторизации URL-адреса можно указать ролям, а не пользователей. Элемент управления LoginView, который отображает другой выход для пользователей, прошедших проверку подлинности и анонимный, можно настроить для отображать различное содержимое на основе ролей вошедшего пользователя. И API ролей включает методы для определения роли пользователя, вошедшего в систему.

Этот учебник запускает рассматриваются как framework ролей связывает роли пользователя с его контекста безопасности. Затем он проверяет применение правил на основе ролей для авторизации URL-адрес. После того, что мы рассмотрим использование декларативные и программные средства для изменения данных, которые отображаются и функциональные возможности, предлагаемые страницы ASP.NET. Давайте начнем!

## <a name="understanding-how-roles-are-associated-with-a-users-security-context"></a>Основные сведения о том, как роли связанные с контекстом безопасности пользователя

Каждый раз, когда запрос входит в конвейере ASP.NET она связана с контекстом безопасности, который включает информацию, идентифицирующую запрашивающей стороне. При использовании проверки подлинности форм, билет проверки подлинности используется в качестве токен удостоверения. Как уже говорилось в <a id="_msoanchor_2"> </a> [ *Общие сведения для проверки подлинности форм* ](../introduction/an-overview-of-forms-authentication-vb.md) и <a id="_msoanchor_3"> </a> [ *форм Настройка проверки подлинности и дополнительные разделы* ](../introduction/forms-authentication-configuration-and-advanced-topics-vb.md) учебники, `FormsAuthenticationModule` отвечает за определение удостоверение запрашивающей стороны, это делается во время [ `AuthenticateRequest` событий](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx).

Если обнаруживается билет проверки подлинности допустимых, не истек срок действия, `FormsAuthenticationModule` декодирует его, чтобы выяснить, удостоверение запрашивающей. Он создает новую `GenericPrincipal` и назначает этот параметр, чтобы `HttpContext.User` объекта. Цель субъекта, такие как `GenericPrincipal`, требуется определить имя авторизованного пользователя и что она принадлежит роли. Этой цели наблюдается благодаря тому, что все объекты principal имеют `Identity` свойство и `IsInRole(roleName)` метод. `FormsAuthenticationModule`, Однако не заинтересован в записи сведения о ролях и `GenericPrincipal` он создает объект не соответствует ни одной роли.

Если платформа роли включена, [ `RoleManagerModule` ](https://msdn.microsoft.com/library/system.web.security.rolemanagermodule.aspx) шагов HTTP-модуля после `FormsAuthenticationModule` и идентифицирует авторизованного пользователя роли во время [ `PostAuthenticateRequest` событий](https://msdn.microsoft.com/library/system.web.httpapplication.postauthenticaterequest.aspx), который срабатывает после `AuthenticateRequest` событий. Если запрос отправлен с прошедшим проверку пользователем `RoleManagerModule` перезаписывает `GenericPrincipal` объект, созданный `FormsAuthenticationModule` и заменяет его с помощью [ `RolePrincipal` объекта](https://msdn.microsoft.com/library/system.web.security.roleprincipal.aspx). `RolePrincipal` Класс использует API ролей, чтобы определить, какие роли, которым принадлежит пользователь.

На рисунке 1 показан рабочий процесс конвейера ASP.NET, при использовании проверки подлинности форм и ролей framework. `FormsAuthenticationModule` Выполняется первым, определяет пользователя через свой билет проверки подлинности и создает новую `GenericPrincipal` объекта. Далее, `RoleManagerModule` шагов и перезаписывает `GenericPrincipal` объекта с `RolePrincipal` объекта.

Если анонимный пользователь посещает сайт, ни `FormsAuthenticationModule` ни `RoleManagerModule` создает объект субъекта.


[![События конвейера ASP.NET для прошедшего проверку подлинности пользователя при использовании проверки подлинности форм и ролей Framework](role-based-authorization-vb/_static/image2.png)](role-based-authorization-vb/_static/image1.png)

**Рис. 1**: события конвейера ASP.NET для проверки подлинности пользователя при использование проверки подлинности форм и ролей Framework ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image3.png))


### <a name="caching-role-information-in-a-cookie"></a>Сведений о ролях в файле Cookie

`RolePrincipal` Объекта `IsInRole(roleName)` вызовы метода `Roles`.`GetRolesForUser` Для получения роли для пользователя, чтобы определить, является ли пользователь членом *roleName*. При использовании `SqlRoleProvider`, это приводит к роли базы данных хранилища в запросе. При использовании ролей правил авторизации URL-адрес `RolePrincipal` `IsInRole` метод будет вызываться при каждом запросе к странице, защищен правила авторизации URL-адрес на основе ролей. А не найти сведения о роли в базе данных при каждом запросе `Roles` framework включает в себя возможность кэшировать роли пользователя в файле cookie.

Если платформа роли настроен для кэша роли пользователя в файле cookie `RoleManagerModule` создает куки-файл во время конвейера ASP.NET [ `EndRequest` событие](https://msdn.microsoft.com/library/system.web.httpapplication.endrequest.aspx). Этот файл cookie используется в последующих запросах в `PostAuthenticateRequest`, который является при `RolePrincipal` создан объект. Если файл cookie является допустимым и не истек, данные в файле cookie анализируется и используется для заполнения ролей пользователя, предотвращая `RolePrincipal` от необходимости вызова `Roles` класса для определения ролей пользователя. На рисунке 2 показан этот рабочий процесс.


[![Сведения о роли пользователя могут храниться в файле Cookie для повышения производительности](role-based-authorization-vb/_static/image5.png)](role-based-authorization-vb/_static/image4.png)

**На рисунке 2**: пользователя роли хранятся в файле Cookie для повышения производительности ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image6.png))


По умолчанию механизм роли кэша cookie отключен. Его можно включить с помощью `<roleManager>`; разметку настройки в `Web.config`. Мы рассмотрели использование [ `<roleManager>` элемент](https://msdn.microsoft.com/library/ms164660.aspx) для указания поставщиков ролей в <a id="_msoanchor_4"> </a> [ *Создание и управление ролями* ](creating-and-managing-roles-vb.md) учебника Поэтому этот элемент необходимо иметь в своем приложении `Web.config` файла. Параметры роли кэша cookie задаются в виде атрибутов `<roleManager>`; элемент и не включаются, представленные в таблице 1.

> [!NOTE]
> Параметры конфигурации, перечисленных в таблице 1 укажите свойства результирующего файла cookie кэша роли. Дополнительные сведения о файлы cookie, как они работают и их различные свойства чтения [этого учебника файлы cookie](http://www.quirksmode.org/js/cookies.html).


| **Свойство** | **Описание** |
| --- | --- |
| `cacheRolesInCookie` | Логическое значение, указывающее, используется ли кэширование куки-файлов. По умолчанию — `false`. |
| `cookieName` | Имя файла cookie кэша роли. Значение по умолчанию — «. ASPXROLES». |
| `cookiePath` | Путь к файлу cookie имя роли. Атрибут пути позволяет разработчику ограничить область куки-файла в определенном каталоге иерархию. Значение по умолчанию — «/», информирующий браузер для отправки файла cookie билет проверки подлинности на любой запрос, выполненных в домене. |
| `cookieProtection` | Указывает, какие методы используются для защиты файла cookie кэша роли. Допустимые значения: `All` (по умолчанию); `Encryption`; `None`; и `Validation`. Вернуться к шагу 3 <a id="_anchor_5"> </a> [ *настройки проверки подлинности форм и дополнительные разделы* ](../introduction/forms-authentication-configuration-and-advanced-topics-vb.md) учебника Дополнительные сведения об этих уровнях защиты. |
| `cookieRequireSSL` | Логическое значение, указывающее, требуется ли SSL-соединение для передачи файла cookie проверки подлинности. Значение по умолчанию — `false`. |
| `cookieSlidingExpiration` | Логическое значение, указывающее ли время ожидания cookie сбрасывается каждый раз пользователь посещает сайт во время одного сеанса. Значение по умолчанию — `false`. Это значение применяется только при `createPersistentCookie` равно `true`. |
| `cookieTimeout` | Время в минутах, после которого истекает срок действия файла cookie билет проверки подлинности. Значение по умолчанию — `30`. Это значение применяется только при `createPersistentCookie` равно `true`. |
| `createPersistentCookie` | Логическое значение указывает, является ли файл cookie кэша роли файла cookie сеанса или постоянный файл cookie. Если `false` (по умолчанию), используется файла cookie сеанса, который удаляется при закрытии. Если `true`, будет использоваться постоянный файл cookie, срок его действия истечет `cookieTimeout` число минут после его создания или после предыдущего посещение, в зависимости от значения `cookieSlidingExpiration`. |
| `domain` | Указывает значение домена файла cookie. Значение по умолчанию — пустая строка, которая заставляет браузер использовать домен, из которого он был выдан (например, www.yourdomain.com). В этом случае файл cookie будет **не** отправляться, когда создание запросов для дочерних доменов, например admin.yourdomain.com. Если требуется куки-файл должен быть передан на все дочерние домены необходимо настроить `domain` атрибут, указав для нее значение «yourdomain.com». |
| `maxCachedResults` | Указывает максимальное число имен ролей, которые хранятся в файле cookie. Значение по умолчанию — 25. `RoleManagerModule` Не создает файл cookie для пользователей, принадлежащих более `maxCachedResults` ролей. Следовательно `RolePrincipal` объекта `IsInRole` будет использовать метод `Roles` класса для определения ролей пользователя. Причина `maxCachedResults` существует, поскольку многие агенты пользователя не разрешено куки-файлы размером более 4 096 байт. Таким образом это ограничение предназначена для снижения вероятности которых превышает это ограничение. Если имеются роли с очень длинными именами, может потребоваться следует рассмотреть возможность указания меньшую `maxCachedResults` значением; contrariwise, при наличии имен ролей слишком короткий, вы, вероятно, это значение можно увеличить. |

**Таблица 1**: параметры конфигурации роли кэша Cookie

Настройка приложения на использование файлов cookie непостоянные роль кэша. Для этого обновления `<roleManager>` элемент в `Web.config` включать следующие атрибуты, связанные с куки-файл:

[!code-xml[Main](role-based-authorization-vb/samples/sample1.xml)]

Я обновил `<roleManager>`; элемент, добавив три атрибута: `cacheRolesInCookie`, `createPersistentCookie`, и `cookieProtection`. Установив `cacheRolesInCookie` для `true`, `RoleManagerModule` теперь автоматически будет кэшировать роли пользователя в файле cookie, вместо того чтобы найти сведения о роли пользователя при каждом запросе. Явно задать `createPersistentCookie` и `cookieProtection` атрибуты `false` и `All`соответственно. Технически нет необходимости Указание того, что значения этих атрибутов, так как только назначена их значения по умолчанию, но я поместите их здесь, чтобы сделать его явным образом очистить сохраняемые файлы cookie не используется и что файл cookie и шифруется и проверки.

Это все, чтобы он! Исходя из этого платформа ролей будет кэшировать роль пользователя в файлах cookie. Если пользователя браузер не поддерживает файлы cookie или если их файлов cookie удалена или утеряна, то каким-либо образом, это не проблема — `RolePrincipal` объекта будет просто использовать `Roles` класса в случае, объекты cookie не (или один из уже недействительны или просрочены) был доступен.

> [!NOTE]
> Шаблоны корпорации Майкрософт &amp; группы рекомендаций не рекомендует использовать файлы Cookie роли постоянного кэша. Поскольку владение роли кэша cookie достаточно доказать, членство в роли, если злоумышленник может каким-либо образом получить доступ к куки-файл является допустимым пользователем он может олицетворять этого пользователя. Увеличивается вероятность того, что это происходит, если куки-файл сохраняется в браузере пользователя. Дополнительные сведения об этой рекомендации безопасности, а также другие вопросы безопасности, см. [список вопросов безопасности для ASP.NET 2.0](https://msdn.microsoft.com/library/ms998375.aspx).


## <a name="step-1-defining-role-based-url-authorization-rules"></a>Шаг 1: Определение правила авторизации URL-адрес на основе ролей

Как было сказано в <a id="_msoanchor_6"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-vb.md) учебнике Авторизация URL-адреса предоставляет средства для ограничения доступа к набор страниц пользователя по пользователю или роли, роли основы. Правила авторизации URL-адрес выраженная в `Web.config` с помощью [ `<authorization>` элемент](https://msdn.microsoft.com/library/8d82143t.aspx) с `<allow>` и `<deny>` дочерних элементов. Дополнительно к правилам авторизации, связанный с пользователем, описанных в предыдущих учебниках каждого `<allow>` и `<deny>` дочерний элемент может также включать:

- Определенной роли
- Разделенный запятыми список ролей

Например правила авторизации URL-адрес предоставления доступа пользователям этих ролей администраторов и руководителей, но запретить доступ для всех других пользователей:

[!code-xml[Main](role-based-authorization-vb/samples/sample2.xml)]

`<allow>` Элемента выше разметки в том, что роли «Администраторы» и «руководители разрешены; `<deny>`; указывает элемент, *все* пользователям будет запрещен.

Настроим приложение, чтобы `ManageRoles.aspx`, `UsersAndRoles.aspx`, и `CreateUserWizardWithRoles.aspx` страницы доступны только для этих пользователей в роли "Администраторы", пока `RoleBasedAuthorization.aspx` страницы будут оставаться доступными для всех посетителей.

Чтобы сделать это, начните с добавления `Web.config` файл `Roles` папки.


[![Добавьте файл Web.config в каталог роли](role-based-authorization-vb/_static/image8.png)](role-based-authorization-vb/_static/image7.png)

**Рис. 3**: добавление `Web.config` файл `Roles` каталога ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image9.png))


Добавьте следующую разметку конфигурации, чтобы `Web.config`:

[!code-xml[Main](role-based-authorization-vb/samples/sample3.xml)]

`<authorization>` Элемент в `<system.web>` раздел указывает только пользователям в роли "Администраторы" могут получить доступ к ресурсам ASP.NET в `Roles` каталога. `<location>` Элемент определяет дополнительный набор правил авторизации URL-адрес для `RoleBasedAuthorization.aspx` странице, чтобы разрешить всем пользователям перейти на страницу.

После сохранения изменений для `Web.config`, войдите в систему как пользователь, не находится в роли "Администраторы" и попытайтесь посетите один из защищенных страниц. `UrlAuthorizationModule` Обнаружит имеет разрешение на запрошенный ресурс; следовательно, `FormsAuthenticationModule` вы будете перенаправлены на страницу входа. Страница входа затем вы будете перенаправлены к `UnauthorizedAccess.aspx` страницу (см. рис. 4). Этот последний перенаправления со страницы входа для `UnauthorizedAccess.aspx` происходит из-за кода добавлена на страницу входа на шаге 2 <a id="_msoanchor_7"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-vb.md) учебника. В частности, перенаправление на страницу входа любой прошедший проверку пользователь для `UnauthorizedAccess.aspx` Если строка запроса содержит `ReturnUrl` параметра, как этот параметр указывает, получен пользователя на страницу входа при попытке просмотра страницы, он не был разрешения для просмотра.


[![Только пользователи в роли "Администраторы" могут просматривать защищенные страницы](role-based-authorization-vb/_static/image11.png)](role-based-authorization-vb/_static/image10.png)

**Рис. 4**: только пользователям в роли "Администраторы" можно просматривать страницы защищенных ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image12.png))


Выйдите из системы и войдите в систему как пользователь в роли "Администраторы". Теперь должны иметь возможность просматривать три защищенные страницы.


[![Посетите Tito UsersAndRoles.aspx страницы так как он находится в роли "Администраторы"](role-based-authorization-vb/_static/image14.png)](role-based-authorization-vb/_static/image13.png)

**Рис. 5**: посетите Tito `UsersAndRoles.aspx` страницы так как он находится в роли "Администраторы" ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image15.png))


> [!NOTE]
> При указании правила авторизации URL-адрес — для ролей и пользователей — важно Имейте в виду, что правила, проанализированных поочередно, сверху вниз. Как только соответствие найдено, пользователю разрешен или запрещен доступ, в зависимости от Если искомый элемент был найден в `<allow>` или `<deny>` элемент. **Если совпадение не найдено, пользователю предоставляется доступ.** Следовательно, если вы хотите ограничить доступ для одного или нескольких учетных записей пользователей, важно использовать `<deny>` элемент как последний элемент в конфигурации авторизации URL-адрес. **Если правил авторизации URL-адрес не включают**`<deny>`**элемента, все пользователи будут иметь доступ.** Более подробное описание на как анализируются правил авторизации URL-адреса, обращаться к «обсуждается `UrlAuthorizationModule` использует правила авторизации для предоставления или запрета доступа» раздела <a id="_msoanchor_8"> </a> [  *Авторизация на основе пользователя* ](../membership/user-based-authorization-vb.md) учебника.


## <a name="step-2-limiting-functionality-based-on-the-currently-logged-in-users-roles"></a>Шаг 2: Ограничивает использование функции на основе ролей текущего выполнившего вход пользователя

Делает авторизации URL-адрес, он просто указать грубым авторизации правила это состояние какая удостоверения разрешены и какие из них запрещен просмотр определенной страницы (или все страницы в папке и ее вложенных папок). Однако в некоторых случаях можно разрешить всем пользователям на странице, но ограничивает возможности страницы на основе ролей посещение пользователей. Это может вызвать Отображение или скрытие данных на основе роли пользователя или предложения дополнительные функциональные возможности для пользователей, принадлежащих к определенной роли.

Можно реализовать такие правила авторизации на основе ролей высокогранулированных декларативно и программно (либо через сочетание двух). В следующем разделе вы узнаете, как реализовать авторизацию декларативный высокогранулированных посредством элемента управления LoginView. После этого мы рассмотрим программные методы. Прежде чем можно взглянуть на применение правил авторизации высокогранулированных, тем не менее, мы сначала необходимо создать страницы, функциональные возможности которых зависит от роли пользователя, посетив его.

Давайте создадим страница, на которой перечислены все учетные записи пользователей в системе в элементе управления GridView. GridView будет включать имя пользователя, адрес электронной почты, Дата последнего входа и комментарии о пользователе каждого пользователя. Помимо отображения сведения о каждом пользователе, GridView включают изменение и удаление возможности. Изначально, она будет создана эта страница с редактирование и удаление функциональные возможности, доступные для всех пользователей. В разделах «Использование управления LoginView» и «Программным образом ограничивая функциональные возможности» будет показано, как включить или отключить эти функции на основе роли посещение пользователя.

> [!NOTE]
> Страницы ASP.NET, которое мы сборки используется элемент управления GridView для отображения учетных записей пользователей. С момента этого учебника посвящены форм проверки подлинности, авторизации, учетные записи пользователей и ролей я не хочу тратить много времени, посвященные внутренней работы элемента управления GridView. Этот учебник обеспечивает определенные пошаговые инструкции по настройке этой страницы, он не подробно рассмотрены почему были внесены некоторые варианты или иметь определенных свойств влияет на выводимых данных. Полное тестирование элемента управления GridView, см. Мои  *[работа с данными в ASP.NET 2.0](../../data-access/index.md)*  учебника рядов.


Сначала откройте `RoleBasedAuthorization.aspx` страницы в `Roles` папки. Перетащите элемент управления GridView с этих страниц на конструктор и задайте его `ID` для `UserGrid`. Позже будет написать код, вызывающий `Membership`.`GetAllUsers` метод и привязывает итоговый `MembershipUserCollection` объекта к GridView. `MembershipUserCollection` Содержит `MembershipUser` объект для каждой учетной записи пользователя в системе; `MembershipUser` объекты имеют свойства, такие как `UserName`,`Email`,`LastLoginDate` и т. д.

Прежде чем мы написать код, который связывает учетные записи пользователей в сетку, давайте сначала определить GridView поля. В смарт-теге элемента GridView, щелкните ссылку «Правка столбцов» для запуска диалогового окна поля (см. рис. 6). Здесь, снимите флажок «автоматически создавать поля» в левом нижнем углу. Поскольку мы хотим этот GridView, чтобы включить редактирование и удаление возможностей, добавить CommandField и задать его `ShowEditButton` и `ShowDeleteButton` свойства в значение True. Добавьте четыре поля для отображения `UserName`, `Email`, `LastLoginDate`, и `Comment` свойства. Используйте поле BoundField для двух свойств только для чтения (`UserName` и `LastLoginDate`) и TemplateFields два изменяемых полей (`Email` и `Comment`).

У первого отображения BoundField `UserName` свойство; набор его `HeaderText` и `DataField` свойства «Username». Это поле не будет доступно для редактирования, поэтому его `ReadOnly` значение True. Настройка `LastLoginDate` BoundField, установив его `HeaderText` «Последнего входа» и его `DataField` для «LastLoginDate». Давайте форматирование выходных данных этого BoundField отображается только дата (вместо даты и времени). Чтобы сделать это, задайте этот BoundField `HtmlEncode` свойству значение False и его `DataFormatString` свойство для «{0: d}». Кроме того, задать `ReadOnly` значение True.

Задать `HeaderText` свойства двух TemplateFields «Email» и «Примечания».


[![GridView полей можно настроить с помощью диалогового окна полей](role-based-authorization-vb/_static/image17.png)](role-based-authorization-vb/_static/image16.png)

**Рис. 6**: GridView поля может быть настроена через поля-диалоговое ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image18.png))


После этого необходимо определить `ItemTemplate` и `EditItemTemplate` «Email» и «Комментарий» TemplateFields. Добавьте веб-управления Label к каждому `ItemTemplates` и привязать их `Text` свойства `Email` и `Comment` свойства, соответственно.

Для «Email» TemplateField, текстовое поле с именем `Email` для его `EditItemTemplate` и привязать его `Text` свойства `Email` свойства с помощью двухсторонней привязкой данных. Добавление RequiredFieldValidator и RegularExpressionValidator для `EditItemTemplate` чтобы убедиться, что посетитель, изменив свойство электронной почты ввел допустимый адрес электронной почты. Для TemplateField «Комментарий», добавьте многострочного текстового поля с именем `Comment` для его `EditItemTemplate`. Задать текстовое поле `Columns` и `Rows` свойства 40 и 4, соответственно, а затем привязать его `Text` свойства `Comment` свойства с помощью двухсторонней привязкой данных.

После настройки этих TemplateFields, их должна выглядеть следующим образом:

[!code-aspx[Main](role-based-authorization-vb/samples/sample4.aspx)]

Если изменение или удаление учетной записи пользователя, нам нужно знать его `UserName` значение свойства. Присвоить свойству `DataKeyNames` свойство «Username», чтобы эта информация доступна через GridView `DataKeys` коллекции.

Наконец, добавьте на страницу элемент управления ValidationSummary и задать его `ShowMessageBox` равным True и его `ShowSummary` свойству значение False. С этими параметрами управления ValidationSummary отображает предупреждения клиентских, если пользователь пытается изменить учетную запись пользователя с адресом электронной почты отсутствует или недопустим.

[!code-aspx[Main](role-based-authorization-vb/samples/sample5.aspx)]

Успешно завершена декларативная разметка эту страницу. Теперь нам является привязка набор учетных записей пользователей к GridView. Добавьте метод с именем `BindUserGrid` для `RoleBasedAuthorization.aspx` классе кода страницы, который привязывает `MembershipUserCollection` возвращенных `Membership.GetAllUsers` для `UserGrid` GridView. Вызовите этот метод из `Page_Load` обработчик событий при первом посещении страницы.

[!code-vb[Main](role-based-authorization-vb/samples/sample6.vb)]

Этот код в месте перейдите на страницу с помощью браузера. Как показано на рис. 7, вы увидите GridView, вывод сведений о каждой учетной записи пользователя в системе.


[![UserGrid GridView выводит сведения о каждом пользователе в системе](role-based-authorization-vb/_static/image20.png)](role-based-authorization-vb/_static/image19.png)

**Рис. 7**: `UserGrid` GridView перечислены сведения о каждый пользователь в системе ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image21.png))


> [!NOTE]
> `UserGrid` GridView перечислены все пользователи в невыгружаемом страничном интерфейс. Этот интерфейс простую сетку не подходит для сценариев, где имеется несколько десятков или нескольких пользователей. Один вариант — настроить для включения постраничного просмотра в GridView. `Membership.GetAllUsers` Метод имеет две перегрузки: та, которая не принимает входные параметры и возвращает всех пользователей, а второй принимает целочисленные значения для индекса страницы и размера страницы и возвращает только определенное подмножество пользователей. Вторая перегрузка может использоваться для более эффективно страницы, то пользователи, так как он возвращает только нужного подмножества учетных записей пользователей вместо *все* из них. Если вы имеете дело с тысячами учетных записей пользователей, может потребоваться интерфейс на основе фильтра, в один из них только те пользователи, имена которых начинается с выделенного символа, например. [ `Membership.FindUsersByName` Метод](https://msdn.microsoft.com/library/system.web.security.membership.findusersbyname.aspx) идеально подходит для создания интерфейса пользователя на основе фильтра. Мы рассмотрим построения такой интерфейс в будущем учебника.


Элемент управления GridView предоставляет встроенные редактирование и удаление поддержки, когда элемент управления привязан к элементу управления источником данных правильно настроен, например SqlDataSource или ObjectDataSource. `UserGrid` GridView, однако имеет его программно привязана к данным; таким образом, необходимо написать код для выполнения следующих двух задач. В частности, вам потребуется создавать обработчики событий для элемента GridView `RowEditing`, `RowCancelingEdit`, `RowUpdating`, и `RowDeleting` событий, которые запускаются при щелчке элемента GridView изменить "Отмена", обновление, или удалить кнопки.

Начните с создания обработчиков событий для элемента GridView `RowEditing`, `RowCancelingEdit`, и `RowUpdating` событий и затем добавьте следующий код:

[!code-vb[Main](role-based-authorization-vb/samples/sample7.vb)]

`RowEditing` И `RowCancelingEdit` обработчики событий просто присвоить свойству `EditIndex` свойство и затем повторную привязку пользователем учетных записей в сетке. Интересные вещи происходит в `RowUpdating` обработчика событий. Этот обработчик событий начинается за счет того, что данные, является допустимым и затем извлекает `UserName` значение изменяемого учетной записи из `DataKeys` коллекции. `Email` И `Comment` текстовые поля в двух TemplateFields `EditItemTemplate` s будут использоваться далее программными средствами. Их `Text` свойства содержат измененного электронный адрес и комментарий.

Чтобы обновить учетную запись пользователя с помощью API членства необходимо сначала получить информацию о пользователе, что выполняется через вызов `Membership.GetUser(userName)`. Возвращенный `MembershipUser` объекта `Email` и `Comment` свойства затем обновляются значения, введенные в двух текстовых полей из интерфейса редактирования. Наконец, эти изменения сохраняются с помощью вызова [ `Membership.UpdateUser` ](https://msdn.microsoft.com/library/system.web.security.membership.updateuser.aspx). `RowUpdating` Обработчик события завершения путем возврата GridView с его интерфейсом до редактирования.

Создайте `RowDeleting` RowDeleting обработчик событий и затем добавьте следующий код:

[!code-vb[Main](role-based-authorization-vb/samples/sample8.vb)]

Обработчик событий выше начинает с получения `UserName` значение из элемента GridView `DataKeys` коллекции; в этом `UserName` значение затем передается в класс членства [ `DeleteUser` метод](https://msdn.microsoft.com/library/system.web.security.membership.deleteuser.aspx). `DeleteUser` Метод удаляет учетную запись пользователя из системы, включая связанные членства данные (например, какие роли этот пользователь принадлежит). После удаления пользователя, сетка `EditIndex` имеет значение -1 (если пользователь щелкнул Delete, пока другая строка была в режиме редактирования) и `BindUserGrid` вызывается метод.

> [!NOTE]
> Кнопка "Удалить" не требует каких-либо подтверждения от пользователя перед удалением учетной записи пользователя. Я рекомендую добавить определенные виды подтверждение пользователя, чтобы уменьшить вероятность случайного удаления учетной записи. Одним из самых простых способов подтверждение действия является через диалоговое окно подтверждения на стороне клиента. Дополнительные сведения об этом приеме см. в разделе [Добавление подтверждения клиентских при удалении](https://asp.net/learn/data-access/tutorial-42-vb.aspx).


Убедитесь, что эта страница работает ожидаемым образом. Вы сможете изменить адрес электронной почты любого пользователя и комментарий, а также для удаления любой учетной записи пользователя. Поскольку `RoleBasedAuthorization.aspx` страница доступна для всех пользователей, любой пользователь, — даже анонимных пользователей — посетите эту страницу и редактировать и удалять учетные записи пользователей! Давайте обновите эту страницу, чтобы только пользователи в роли руководителями и администраторов можно изменить адрес электронной почты пользователя и комментарий, и только администраторы могут удалять учетную запись пользователя.

В разделе «Использование управления LoginView» анализирует с помощью элемента управления LoginView отображаются инструкции, относящиеся к роли пользователя. Если пользователь в роли администратора о посещении этой страницы, будет показано инструкции о том, как изменять и удалять пользователей. Если пользователь в роли руководителями достигает эту страницу, мы рассмотрим инструкции по изменению пользователей. И если посетитель анонимна или не находится в роли администраторов или менеджер, отобразится сообщение о том, что их нельзя изменять или удалять учетные записи пользователей. В разделе «Программным образом ограничивая функциональные возможности» мы напишем код, который программным путем Отображение или скрытие кнопки изменения и удаления, на основе роли пользователя.

### <a name="using-the-loginview-control"></a>С помощью элемента управления LoginView

Как видно в предыдущих учебных элемента управления LoginView может использоваться для отображения различных интерфейсов для прошедших проверку подлинности и анонимных пользователей, но элемента управления LoginView может также использоваться для отображения разных разметки на основе ролей пользователей. Чтобы отобразить различные инструкции на основе роли посещение пользователя воспользуемся элемента управления LoginView.

Начните с добавления LoginView выше `UserGrid` GridView. Как говорилось ранее, элемента управления LoginView имеет два встроенных шаблонов: `AnonymousTemplate` и `LoggedInTemplate`. Введите краткое сообщение в обоих этих шаблонов, пользователю не удается изменить или удалить данные о пользователях.

[!code-aspx[Main](role-based-authorization-vb/samples/sample9.aspx)]

В дополнение к `AnonymousTemplate` и `LoggedInTemplate`, может включать элемент управления LoginView *группы ролей*, являющиеся шаблонов для конкретных ролей. Каждый RoleGroup содержит одно свойство, `Roles`, указывает, какие RoleGroup применяется к роли. `Roles` Может быть установлено для одной роли (например, «Администраторы») или разделенный запятыми список ролей (например, «Администраторы, руководители»).

Для управления групп ролей, щелкните ссылку «Изменить группы ролей» смарт-теге элемента управления на отображение редактора коллекции RoleGroup. Добавьте две новые группы ролей. Задать первый RoleGroup `Roles` свойство «Администраторы», а для «Руководители» второй.


[![Управление шаблонами LoginView конкретных ролей через редактор коллекции RoleGroup](role-based-authorization-vb/_static/image23.png)](role-based-authorization-vb/_static/image22.png)

**Рис. 8**: управления LoginView определенных шаблонов через редактор коллекции RoleGroup ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image24.png))


Нажмите кнопку ОК, чтобы закрыть редактор коллекции RoleGroup; Это обновляет LoginView декларативная разметка для включения `<RoleGroups>` статьи с `<asp:RoleGroup>` дочерний элемент для каждого RoleGroup определенные редактор коллекции RoleGroup. Кроме того, в раскрывающемся списке «Представления» перечислить в смарт-тег LoginView - что было указано изначально просто `AnonymousTemplate` и `LoggedInTemplate` — теперь включает также добавлены группы ролей.

Изменение группы ролей таким образом, пользователи с ролью менеджер отображаемые инструкции по изменению учетных записей пользователей, пока пользователи в роли "Администраторы" отображаются инструкции для изменения и удаления. После внесения этих изменений, ваш LoginView должна выглядеть следующим образом.

[!code-aspx[Main](role-based-authorization-vb/samples/sample10.aspx)]

После внесения этих изменений, сохраните страницу и посетите через браузер. Сначала перейдите на страницу как анонимный пользователь. Должно быть показано сообщение, «вы вошли в систему. Поэтому нельзя изменять или удалять данные о пользователях.» Войдите в систему как прошедшего проверку подлинности пользователя, но один, который не является ни в роли руководители и администраторы не. Это время должно появиться сообщение «вы не является членом роли Менеджер или Администраторы. Поэтому нельзя изменять или удалять данные о пользователях.»

Затем войдите как пользователь, являющийся членом роли Менеджер. Это время, вы увидите руководителями конкретных ролей сообщений (см. рис. 9). И при входе в качестве пользователя в роли администраторов конкретных ролей должно появиться сообщение (см. рис. 10) администраторов.


[![Bruce отображается сообщение конкретных ролей руководителями](role-based-authorization-vb/_static/image26.png)](role-based-authorization-vb/_static/image25.png)

**Рис. 9**: Bruce отображается сообщение конкретных ролей руководителями ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image27.png))


[![Tito отображается сообщение конкретных ролей администраторов](role-based-authorization-vb/_static/image29.png)](role-based-authorization-vb/_static/image28.png)

**Рис. 10**: Tito отображается сообщение конкретных ролей администраторов ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image30.png))


Как снимки экрана в иллюстрациях 9 и 10 Показать LoginView отображает только один шаблон, даже если применяется несколько шаблонов. Bruce и Tito записываются в пользователей, но LoginView отображает только сопоставления RoleGroup и не `LoggedInTemplate`. Кроме того Tito принадлежит к роли администраторов и руководителей, но элемента управления LoginView отображает шаблон конкретных ролей администраторов вместо руководителями один.

Рис. 11 показан рабочий процесс, используемые элементом управления LoginView, чтобы определить, какой шаблон для подготовки к просмотру. Обратите внимание, если имеется более одного RoleGroup указан, шаблон LoginView отрисовывал *первый* RoleGroup, который соответствует. Другими словами Если мы помещен RoleGroup руководителями как первый RoleGroup и администраторов в секунду, затем при Tito посещении этой страницы он бы увидеть сообщения руководителей.


[![Рабочий процесс управления LoginView определить, какой шаблон отрисовки](role-based-authorization-vb/_static/image32.png)](role-based-authorization-vb/_static/image31.png)

**Рис. 11**: элемент управления LoginView рабочего процесса для определения как шаблон для отрисовки ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image33.png))


### <a name="programmatically-limiting-functionality"></a>Ограничивает функции программным способом

Пока элемента управления LoginView отображает различные инструкции на основе роли пользователя, посетив страницу, кнопки изменения и отмены остаются видимыми для всех. Нам нужно программное скрытие кнопки Edit и Delete для анонимных пользователей и пользователей, которым назначена роль администраторов ни руководителей. Нам нужно скрыть кнопку удаления для всех, кто не имеет прав администратора. Для этого мы напишем большой объем кода, ссылающийся на программно изменить CommandField и удаление элементов управления LinkButton и наборов их `Visible` свойства `False`при необходимости.

Чтобы программно обращаться к элементам управления в CommandField проще всего сначала преобразуйте его в шаблон. Для этого щелкните ссылку «Правка столбцов» смарт-теге элемента GridView, выберите в списке полей текущего CommandField и щелкните ссылку «Преобразовать это поле в TemplateField». Это включает CommandField в TemplateField с `ItemTemplate` и `EditItemTemplate`. `ItemTemplate` Содержит изменения и удаления элементов управления LinkButton при `EditItemTemplate` содержит обновление и Отмена элементов управления LinkButton.


[![Преобразовать CommandField в TemplateField](role-based-authorization-vb/_static/image35.png)](role-based-authorization-vb/_static/image34.png)

**Рис. 12**: преобразование CommandField в TemplateField ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image36.png))


Обновление, редактирование и удаление элементов управления LinkButton в `ItemTemplate`, установка их `ID` значения для свойств `EditButton` и `DeleteButton`соответственно.

[!code-aspx[Main](role-based-authorization-vb/samples/sample11.aspx)]

Каждый раз, когда данные привязаны к GridView, GridView перечисляет записи в его `DataSource` свойства и создает соответствующий `GridViewRow` объекта. Когда каждый `GridViewRow` создается объект `RowCreated` событие. Для скрытия кнопки Edit и Delete для неавторизованных пользователей, необходимо создать обработчик событий для этого события и программно ссылаться на изменение и удаление элементов управления LinkButton, установка их `Visible` свойства соответствующим образом.

Создайте обработчик событий `RowCreated` событий и затем добавьте следующий код:

[!code-vb[Main](role-based-authorization-vb/samples/sample12.vb)]

Имейте в виду, что `RowCreated` событие вызывается для *все* строк GridView, включая заголовок, нижний колонтитул, интерфейс страничного навигатора и т. д. Требуется только программно ссылаться изменение и удаление элементов управления LinkButton при работе со строкой данных не в режиме редактирования (так как строки в режиме редактирования кнопки обновление и Отмена вместо Edit и Delete). Эта проверка обрабатывается `If` инструкции.

При работе с строку данных, которая не находится в режиме редактирования, изменение и удаление элементов управления LinkButton ссылки и их `Visible` свойства задаются на основании логического значения, возвращаемые методом `User` объекта `IsInRole(roleName)` метод. `User` Объект ссылается на основной, созданные `RoleManagerModule`; следовательно, `IsInRole(roleName)` метод использует API ролей, чтобы определить, принадлежит ли текущий пользователь *roleName*.

> [!NOTE]
> Можно было бы использовать класс ролей напрямую, заменяя вызов `User.IsInRole(roleName)` вызовом [ `Roles.IsUserInRole(roleName)` метод](https://msdn.microsoft.com/library/system.web.security.roles.isuserinrole.aspx). Я решил использовать объект principal `IsInRole(roleName)` метод в этом примере так как он является более эффективным, чем непосредственно с использованием API ролей. Ранее в этом учебнике мы настроен диспетчер ролей для кэша роли пользователя в файле cookie. Это кэшированных данных куки-файл используется только при участника `IsInRole(roleName)` метод вызывается; прямые вызовы API ролей всегда включает обращение к хранилищу ролей. Даже если роли в файле cookie не кэшируются, при вызове метода объект principal `IsInRole(roleName)` метод обычно более эффективен, поскольку при ее вызове для первый раз во время запроса кэширует результаты. API ролей, с другой стороны, не выполнять кэширование. Поскольку `RowCreated` событие вызывается один раз для каждой строки в GridView, с помощью `User.IsInRole(roleName)` включает в себя только одно обращение к хранилищу ролей, в то время как `Roles.IsUserInRole(roleName)` требует *N* приема-передачи, где *N* — количество учетных записей пользователей, которые отображаются в сетке.


«Изменить» `Visible` свойству `True` при посещении этой страницы пользователь находится в роли администраторов или руководителями; в противном случае он равен `False`. Кнопка удаления `Visible` свойству `True` только в том случае, если пользователь находится в роли "Администраторы".

Проверьте эту страницу через браузер. При посещении страницы как анонимный посетителя или имени пользователя, не администратора или администратора CommandField пуст; по-прежнему существует, но как тонкой серебряный без изменения или удаления кнопок.

> [!NOTE]
> Можно скрыть CommandField полностью при отличном от администратора и без прав администратора посетив страницу. Я это поле оставить в качестве упражнения для модуля чтения.


[![Изменить и удалить кнопок скрыты для руководителей не и не являющиеся администраторами](role-based-authorization-vb/_static/image38.png)](role-based-authorization-vb/_static/image37.png)

**Рис. 13**: изменение и удаление кнопки скрыты для руководителей не и не являющиеся администраторами ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image39.png))


Если пользователь, который принадлежит к роли Менеджер (но не к роли "Администраторы") посещает, он видит «изменить».


[![Хотя кнопку Изменить доступный для руководителей, скрыто кнопку Удалить](role-based-authorization-vb/_static/image41.png)](role-based-authorization-vb/_static/image40.png)

**Рис. 14**: во время изменения Button она становится доступной для руководителей, скрытые кнопку Удалить ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image42.png))


И при посещении администратор, у нее есть доступ к кнопкам Edit и Delete.


[![Изменение и удаление кнопки, доступной только для администраторов](role-based-authorization-vb/_static/image44.png)](role-based-authorization-vb/_static/image43.png)

**Рис. 15**: изменение и удаление кнопки, доступной только для администраторов ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image45.png))


## <a name="step-3-applying-role-based-authorization-rules-to-classes-and-methods"></a>Шаг 3: Применение правил авторизации на основе ролей для классов и методов

На шаге 2, более изменение возможности для пользователей в роли руководителями и администраторов и удаление только возможности для администраторов. Это выполнялось, скрывая элементы интерфейса пользователя для неавторизованных пользователей через программный методы. Такие меры не гарантируют, что неавторизованный пользователь сможет выполнять привилегированные действия. Может содержать элементы пользовательского интерфейса, которые будут добавлены позже мы забыли скрыть для неавторизованных пользователей. Или злоумышленник может обнаружить иным способом для получения страницы ASP.NET для выполнения нужного метода.

Использовать, чтобы гарантировать, что определенную часть функциональные возможности не доступны для неавторизованный пользователь имеет для оформления класса или метода с [ `PrincipalPermission` атрибут](https://msdn.microsoft.com/library/system.security.permissions.principalpermissionattribute.aspx). Когда среда выполнения .NET используется класс или выполняет одну из его методов, он проверяет, чтобы обеспечить разрешение текущего контекста безопасности. `PrincipalPermission` Атрибут предоставляет механизм, по которому можно определить эти правила.

Мы рассмотрели использование `PrincipalPermission` атрибут обратно в <a id="_msoanchor_9"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-vb.md) учебника. В частности, мы узнали, как для оформления в GridView `SelectedIndexChanged` и `RowDeleting` обработчик событий, чтобы они может быть выполнена только проверки подлинности пользователей и Tito, соответственно. `PrincipalPermission` Атрибут точно так же работает с ролями.

Давайте демонстрируют использование `PrincipalPermission` атрибута в GridView `RowUpdating` и `RowDeleting` обработчики событий для запрета выполнения несанкционированных пользователей. Нам нужно всего лишь добавить соответствующий атрибут поверх каждого определения функции:

[!code-vb[Main](role-based-authorization-vb/samples/sample13.vb)]

Атрибут для `RowUpdating` обработчика событий указывает, что только пользователи с ролями администраторов или менеджер может выполнять обработчика событий, где и как атрибут в `RowDeleting` обработчик событий ограничивает выполнение для пользователей в Администраторы роль.


> [!NOTE]
> `PrincipalPermission` Атрибут представлен как класс в `System.Security.Permissions` пространства имен. Не забудьте добавить `Imports System.Security.Permissions` инструкции в верхней части файл класса кода программной части для импорта этого пространства имен.


Если каким-либо образом, администратор предпринимает попытку выполнить `RowDeleting` обработчика событий или если не администратора или без прав администратора попытка выполнения `RowUpdating` обработчик событий вызывает среды выполнения .NET `SecurityException`.


[![Если контекст безопасности не авторизован для выполнения метода, вызывается исключение SecurityException](role-based-authorization-vb/_static/image47.png)](role-based-authorization-vb/_static/image46.png)

**На рисунке 16**: Если контекст безопасности не авторизован для выполнения метода, `SecurityException` выдается ([Просмотр полноразмерное изображение](role-based-authorization-vb/_static/image48.png))


Помимо страниц ASP.NET многие приложения также имеют архитектуру, которая включает в себя различных уровнях, например бизнес-логики и уровней доступа к данным. Эти слои обычно реализуется в виде библиотеки классов и предоставляют классы и методы для выполнения бизнес-логики и связанные данные функции. `PrincipalPermission` Атрибут полезен для применения правила авторизации на эти слои также.

Дополнительные сведения об использовании `PrincipalPermission` атрибут, чтобы определить правила авторизации для классов и методов, ознакомьтесь с [Скотт Гатри](https://weblogs.asp.net/scottgu/)в записи блога [добавления правила авторизации для бизнеса и слои с помощью `PrincipalPermissionAttributes` ](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx).

## <a name="summary"></a>Сводка

В этом учебнике мы рассмотрели способы указания крупных и высокогранулированных правил авторизации на основании ролей пользователя. ASP. NET URL-адрес авторизации позволяет разработчику указать, какие удостоверения разрешен или запрещен доступ к страницах. Как мы видели в <a id="_msoanchor_10"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-vb.md) учебника, авторизация URL-адреса, правила могут быть применены на основе пользователя по. Они могут также применяться для каждой роли, роли, как было показано на первом шаге этого учебника.

Правила авторизации высокогранулированных может применяться декларативно или программно. На шаге 2 мы рассматривали отображают разные выходные данные на основе ролей посещение пользователей с помощью компонента управления LoginView группы ролей. Также мы рассматривали способов для программного определения принадлежности пользователя определенной роли, а также как настроить функциональных возможностей страницы соответствующим образом.

Программирование довольны!

### <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения по темам, рассматриваемые в этом учебнике см. в следующих ресурсах:

- [Добавление правила авторизации для бизнеса и уровни данных с помощью`PrincipalPermissionAttributes`](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx)
- [Изучение ASP.NET 2.0 членства, ролей и профиля: работа с ролями](http://aspnet.4guysfromrolla.com/articles/121405-1.aspx)
- [Список вопросов безопасности для ASP.NET 2.0](https://msdn.microsoft.com/library/ms998375.aspx)
- [Техническая документация для `<roleManager>` элемента](https://msdn.microsoft.com/library/ms164660.aspx)

### <a name="about-the-author"></a>Об авторе

Скотт Митчелл, автор нескольких ASP/ASP.NET и основатель 4GuysFromRolla.com, работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга —  *[диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)*. Скотт может быть достигнута по [ mitchell@4guysfromrolla.com ](mailto:mitchell@4guysfromrolla.com) или через его блог по [http://ScottOnWriting.NET](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Особая благодарность

Этот учебник ряд прошел проверку многие полезные рецензентов. Основными редакторами этого учебника включают Банерджи Suchi и Мерфи Тереза д. Объясняются моих последующих статей для MSDN? Если Да, напишите мне по[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)

>[!div class="step-by-step"]
[Назад](assigning-roles-to-users-vb.md)
