---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: "Реализация оптимистической блокировки (C#) | Документы Microsoft"
author: rick-anderson
description: "Для веб-приложения, который позволяет нескольким пользователям изменять данные есть риск, что два пользователя могут редактирование те же данные одновременно. В этом tutori..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/17/2006
ms.topic: article
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: a19e6c320838849e10d2aa397a23a0ee906bac22
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="implementing-optimistic-concurrency-c"></a>Реализация оптимистической блокировки (C#)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) или [скачать PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)

> Для веб-приложения, который позволяет нескольким пользователям изменять данные есть риск, что два пользователя могут редактирование те же данные одновременно. В этом учебнике мы будем реализации управления оптимистичным параллелизмом для обработки этого риска.


## <a name="introduction"></a>Вступление

Для веб-приложений, которые позволяют пользователям просматривать данные только или те, которые имеют только один пользователь может изменять данные отсутствует вероятность случайной перезаписи изменения, выполненные другой двух одновременных пользователей. Для веб-приложений, которые позволяют нескольким пользователям обновлять или удалять данные тем не менее, есть вероятность конфликта одновременно работающих пользователей изменений одного пользователя. Без применения политики параллелизма на месте при двух пользователей одновременно изменяют одну запись, пользователя, который фиксирует изменения последним, переопределяет изменения, внесенные первым.

Например предположим, что два пользователя, Цзисунь и Сэм, одновременно открыли страницу приложения, позволяющего посетителям обновлять и удалять продукты с помощью элемента управления GridView. И нажмите кнопку «Изменить» в GridView, в то время. Цзисунь изменяет название продукта на «Чай» и нажимает кнопку обновления. Конечным результатом становится `UPDATE` отправляемая базу данных, которая задает *все* обновляемые полей продукта (несмотря на то, что Цзисунь изменил только одно поле `ProductName`). На данный момент времени база данных содержит значения «Чай» категория напитков, сведения о поставщике экзотические жидкостей и так далее для этого продукта. Тем не менее, на экране Сэма GridView по-прежнему показывает название продукта в редактируемой строке GridView как «Chai». Через несколько секунд после Цзисунь изменения были зафиксированы, Сэм обновляет категорию для приправы и последнее обновление. В результате `UPDATE` инструкции, отправляемые в базу данных, задает имя продукта «, «Chai `CategoryID` соответствующий идентификатор категории Напитки и т. д. Изменения названия продукта Цзисунь были перезаписаны. Рис. 1 графически представлен ряд событий.


[![Если два пользователя одновременно обновить запись существует s потенциальных для одного пользователя s изменений перезаписать другие устройства](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)

**Рис. 1**: при двух пользователей одновременно обновление существует запись s потенциал для одного пользователя s изменений перезаписать другие устройства ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image3.png))


Аналогично при открытии страницы двух пользователей, один пользователь может быть обновлять запись, если она удалена другим пользователем. Или между при загрузке страницы и щелкнув "Удалить", могут быть изменены другим пользователем содержимое этой записи.

Существует три [управления параллелизмом](http://en.wikipedia.org/wiki/Concurrency_control) возможные стратегии:

- **Ничего не делать** -при одновременно работающих пользователей или изменении этой же записи, позволяют последней фиксации win (по умолчанию)
- [**Оптимистический параллелизм** ](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) -Предположим, хотя может быть конфликты параллелизма время сейчас или позже, большая часть времени такие конфликты не возникают; таким образом, если конфликт возникает, просто информировать пользователей, их изменения. Невозможно сохранить, поскольку другой пользователь изменил тех же данных
- **Пессимистичный параллелизм** -предполагают, что конфликты параллелизма широко распространены и пользователей не устраивает простое выполняется сообщать их изменения не были сохранены из-за одновременных действий другого пользователя; таким образом, когда пользователь начинает обновление записи, его блокировки , тем самым предотвращая другим пользователям изменять или удалять записи до сохранения изменений

Все наши руководства сих используется стратегия разрешения параллелизма по умолчанию — а именно, мы сообщим win последняя запись. В этом учебнике мы рассмотрим, как реализовать управление оптимистичным параллелизмом.

> [!NOTE]
> Не рассматриваются примеры пессимистичного параллелизма в данной серии учебных курсов. Пессимистичный параллелизм используется редко, поскольку такие блокировки, если не правильно освобождаться, можно предотвратить обновление данных другим пользователям. Например если пользователь блокирует запись для редактирования и выполняет за предыдущий день разблокировку, ни один другой пользователь будет иметь возможность обновления этой записи после завершения его обновления и возвращает исходное пользователя. Таким образом в ситуациях, где используется пессимистичный параллелизм, есть обычно истечения времени ожидания, если достигнут, Отмена блокировки. Билет продаж веб-сайтов, который блокирует определенное место короткий промежуток времени, пока пользователь завершает процесс заказа, является примером управление пессимистичным параллелизмом.


## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a>Шаг 1: Просмотрев как оптимистичного параллелизма реализуется

Управление оптимистичным параллелизмом работает за счет того, что запись обновляемой или удаляемой имеет те же значения, как и при запуске процесса обновления или удаления. Например при нажатии кнопки «изменить» в изменяемого элемента управления GridView, запись чтения из базы данных и отображения значений в текстовые поля и другие веб-элементов управления. Эти исходные значения сохраняются в GridView. Позже после пользователь делает своих изменений и нажимает кнопку обновления, исходные и новые значения отправляются уровня бизнес-логики, а затем вниз до уровня доступа к данным. Уровень доступа к данным выполнить инструкцию SQL, только обновить запись, если исходный пользователь начал редактирование значения совпадают со значениями по-прежнему в базе данных. На рисунке 2 показана эта последовательность событий.


[![Для инструкции Update или Delete для успешного выполнения и установка исходных значений должно быть равно текущими значениями базы данных](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)

**На рисунке 2**: для обновления или удаления выполняются успешно, исходные значения должен быть равен текущими значениями базы данных ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image6.png))


Существуют различные подходы к реализации оптимистичного параллелизма (см. [в статье](http://peterbromberg.net/) [Optmistic параллелизма обновление логики](http://www.eggheadcafe.com/articles/20050719.asp) для кратко рассмотрим несколько параметров). Типизированный набор данных ADO.NET предоставляет одну реализацию, которая может быть настроена с помощью простой установки флажка. Включение оптимистичного параллелизма для адаптера таблицы в наборе данных типизированных дополняет `UPDATE` и `DELETE` инструкции, чтобы включить сравнение всех исходных значений в `WHERE` предложения. Следующие `UPDATE` инструкции, например, обновляет имя и цену продукта, только в том случае, если текущие значения базы данных равны значениям, которые изначально были получены при обновлении записи в GridView. `@ProductName` И `@UnitPrice` параметры содержат новые значения, введенные пользователем, в то время как `@original_ProductName` и `@original_UnitPrice` содержат значения, которые изначально были загружены в GridView, если была нажата кнопка "Изменить":


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> Это `UPDATE` упрощена для удобства чтения. На практике `UnitPrice` вернуть `WHERE` предложение будет несколько сложнее, поскольку `UnitPrice` может содержать `NULL` и проверка `NULL = NULL` всегда возвращает значение False (вместо этого необходимо использовать `IS NULL`).


Помимо использования другой базовой `UPDATE` инструкции настройки адаптера таблицы для использования оптимистичного параллелизма также изменяет подписи его DB прямой методы. Вспомните наш первый Учебник [ *Создание слой доступа к данным*](../introduction/creating-a-data-access-layer-cs.md), непосредственные методы DB были те, которые принимает список скалярных значений в качестве входных параметров (вместо того чтобы DataRow строгой типизацией или Экземпляр объекта DataTable). При использовании оптимистичного параллелизма, DB прямой `Update()` и `Delete()` включают входные параметры для исходных значений, а также. Кроме того, код в пакете с помощью МЕТОДА обновить шаблон ( `Update()` перегрузки метода, которые принимают объектов DataRow и таблицы данных, а не скалярных значений) также необходимо изменить.

Чем расширить существующий класс адаптеры таблиц TableAdapter DAL для использования оптимистичного параллелизма (который может возникнуть необходимость в изменении МЕТОДА для размещения), давайте вместо этого создать новый типизированный набор данных с именем `NorthwindOptimisticConcurrency`, в котором мы добавим `Products` TableAdapter, использует оптимистический параллелизм. После этого мы создадим `ProductsOptimisticConcurrencyBLL` класс уровня бизнес-логики с соответствующими изменениями для поддержки DAL оптимистичного параллелизма. После этого фундамента мы будем готовы к созданию страницы ASP.NET.

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a>Шаг 2: Создание слой доступа к данным, поддерживающего оптимистичный параллелизм

Чтобы создать новый типизированный набор данных, щелкните правой кнопкой мыши `DAL` папку внутри `App_Code` папки и добавить новый набор данных с именем `NorthwindOptimisticConcurrency`. Как мы видели в первом руководстве, это так будет добавлен новый адаптер таблицы типизированного набора данных, автоматический запуск мастера настройки адаптера таблицы. На первом экране мы предложат указать базу данных, подключиться - подключиться к одной базе данных Northwind с помощью `NORTHWNDConnectionString` из `Web.config`.


[![Подключиться к одной и той же базе данных "Борей"](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)

**Рис. 3**: подключиться к одной и той же базе данных Northwind ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image9.png))


Далее мы предлагается способ запроса данных: посредством инструкции SQL ad-hoc новую хранимую процедуру или существующую хранимую процедуру. Так как мы использовали нерегламентированные запросы SQL в исходном DAL, используйте этот параметр, здесь также.


[![Укажите данные, получаемые с помощью инструкции SQL Ad-Hoc](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)

**Рис. 4**: укажите данные для извлечения с помощью инструкции SQL Ad-Hoc ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image12.png))


На следующем экране введите SQL-запрос для получения сведений о продукте. Используем точно того же запроса SQL, используемое для `Products` TableAdapter исходном DAL, возвращающий все `Product` столбцы, а также имена поставщика и категории продуктов:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]


[![Использовать один и тот же запрос SQL из адаптера таблицы продуктов в исходный DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)

**Рис. 5**: использовать один и тот же запрос SQL из `Products` TableAdapter в исходный DAL ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image15.png))


Перед переходом к следующему экрану, нажмите кнопку Дополнительно. Чтобы этот адаптер таблицы используют управление оптимистичным параллелизмом, просто установите флажок «Использовать оптимистичный параллелизм».


[![Включить управление оптимистичным параллелизмом, проверка &quot;использовать оптимистическую блокировку&quot; флажок](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)

**Рис. 6**: включить управление оптимистичным параллелизмом, установив флажок «Использовать оптимистичный параллелизм» ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image18.png))


Наконец необходимо укажите адаптер для использования шаблонов доступа к данным, которые заполнить таблицу данных и вернуть таблицу данных; также указывать, что должна быть создана непосредственные методы DB. Измените имя метода для возврата шаблон DataTable из GetData на GetProducts таким образом, чтобы соглашениям об именовании, которые были использованы в исходном DAL.


[![У адаптера таблицы, которые используют все шаблоны доступа к данным](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)

**Рис. 7**: У TableAdapter используют всех шаблонов доступа к данным ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image21.png))


По завершении работы мастера конструктор DataSet будет включать строго типизированной `Products` DataTable и TableAdapter. Теперь пора переименовать DataTable из `Products` для `ProductsOptimisticConcurrency`, это можно сделать, щелкнув правой кнопкой мыши на панели заголовка объекта DataTable и выбрав переименование в контекстном меню.


[![Таблицы данных и адаптеров таблиц были добавлены к типизированному набору данных](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)

**Рис. 8**: DataTable и адаптера таблиц были добавлены к типизированному DataSet ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image24.png))


Чтобы увидеть различия между `UPDATE` и `DELETE` запросы между `ProductsOptimisticConcurrency` адаптера таблицы (с использованием оптимистичного параллелизма) и TableAdapter продуктов (который не), щелкните в TableAdapter и перейдите в окно «Свойства». В `DeleteCommand` и `UpdateCommand` свойств `CommandText` подсвойства видно фактический синтаксис SQL, который отправляется в базу данных при вызове update или delete связанные методы DAL. Для `ProductsOptimisticConcurrency` TableAdapter `DELETE` используется инструкция является:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

В то время как `DELETE` для TableAdapter продукта в исходном DAL намного проще:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

Как видите, `WHERE` предложения в `DELETE` для TableAdapter, использующего оптимистичный параллелизм включает сравнение между различными `Product` таблицы текущих значений столбцов и исходные значения во время GridView (или DetailsView и FormView) последнего заполнения. Поскольку все поля, отличный от `ProductID`, `ProductName`, и `Discontinued` может иметь `NULL` значения, дополнительные параметры и проверки включаются для правильного сравнения `NULL` значения в `WHERE` предложения.

Мы не будет добавлять любые дополнительные таблицы данных в наборе данных оптимистической поддержкой параллелизма в этом учебнике как нашу страницу ASP.NET предоставляет только обновления и удаления информации о продукте. Однако нам по-прежнему необходимо добавить `GetProductByProductID(productID)` метод `ProductsOptimisticConcurrency` адаптера таблицы.

Для этого щелкните правой кнопкой мыши строку заголовка TableAdapter (область непосредственно над `Fill` и `GetProducts` имена методов) и в контекстном меню выберите команду Добавить запрос. Запустится мастер настройки запроса адаптера таблицы. Как с начальной настройки TableAdapter, попробовать создать `GetProductByProductID(productID)` метод, с помощью инструкции SQL ad-hoc (см. рис. 4). Поскольку `GetProductByProductID(productID)` метод возвращает сведения об определенном продукте, указать, что этот запрос `SELECT` тип, возвращающей строки запроса.


[![Тип запроса, как пометить &quot;SELECT, возвращающая строки&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)

**Рис. 9**: пометьте этот тип запроса, как «`SELECT` , возвращающая строки» ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image27.png))


На следующем экране мы появится предложение SQL-запрос для использования с предварительно загруженных запрос по умолчанию адаптера таблицы. Дополните существующий запрос предложение `WHERE ProductID = @ProductID`, как показано на рис. 10.


[![Добавить предложение WHERE предложений, чтобы предварительно загруженных запрос для возврата определенной записи продукта](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)

**Рис. 10**: добавление `WHERE` предложение в Pre-Loaded запрос для возврата определенной записи продукта ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image30.png))


Наконец, измените имена, созданный метод `FillByProductID` и `GetProductByProductID`.


[![Переименуйте методы FillByProductID и GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)

**Рис. 11**: переименовать методы `FillByProductID` и `GetProductByProductID` ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image33.png))


После завершения работы мастера, элемент управления TableAdapter включает два метода для получения данных: `GetProducts()`, возвращающий *все* продуктов; и `GetProductByProductID(productID)`, которая возвращает указанный продукт.

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a>Шаг 3: Создание слой бизнес-логики для DAL оптимистичного параллелизма включен

Существующий класс `ProductsBLL` класс содержит примеры использования DB прямой шаблонов и пакетного обновления. `AddProduct` Метод и `UpdateProduct` используют схему пакетного обновления, передавая `ProductRow` экземпляр метод обновления адаптера таблицы. `DeleteProduct` Метод, с другой стороны, использует непосредственной схемы, вызывающий `Delete(productID)` метод.

С помощью нового `ProductsOptimisticConcurrency` TableAdapter, DB прямой методы теперь требуется, чтобы исходные значения также можно передать в. Например `Delete` метод теперь ожидает десять входных параметров: исходный `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, и `Discontinued`. Он использует значения дополнительных входных параметров в `WHERE` предложения `DELETE` инструкция, введенная в базу данных только для удаления указанной записи, если текущие значения базы данных соответствуют оригинальным.

Хотя сигнатуру метода для адаптера таблицы `Update` метод, используемый в шаблоне пакета обновления не изменился, имеет код, необходимый для записи исходных и новых значений. Таким образом а не пытайтесь использовать DAL оптимистичного параллелизма включен с существующим классом `ProductsBLL` , создадим новый класс уровня бизнес-логики для работы с новым DAL.

Добавьте класс с именем `ProductsOptimisticConcurrencyBLL` для `BLL` папку внутри `App_Code` папки.


![Добавить класс ProductsOptimisticConcurrencyBLL в папку уровень бизнес-ЛОГИКИ](implementing-optimistic-concurrency-cs/_static/image34.png)

**Рис. 12**: добавление `ProductsOptimisticConcurrencyBLL` класс в папку уровень бизнес-ЛОГИКИ


Добавьте следующий код в `ProductsOptimisticConcurrencyBLL` класса:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

Обратите внимание, использование `NorthwindOptimisticConcurrencyTableAdapters` инструкции до начала объявления класса. `NorthwindOptimisticConcurrencyTableAdapters` Пространство имен содержит `ProductsOptimisticConcurrencyTableAdapter` класс, предоставляющий методы DAL. Также вы найдете перед объявлением класса `System.ComponentModel.DataObject` атрибут, который указывает, что этот класс включается в мастере ObjectDataSource раскрывающегося списка в Visual Studio.

`ProductsOptimisticConcurrencyBLL` `Adapter` Предоставляет быстрый доступ к экземпляру компонента `ProductsOptimisticConcurrencyTableAdapter` класса и соответствует шаблону, используемых в исходных классах BLL (`ProductsBLL`, `CategoriesBLL`и так далее). Наконец `GetProducts()` метод просто вызывает DAL `GetProducts()` метод и возвращает `ProductsOptimisticConcurrencyDataTable` заполненный `ProductsOptimisticConcurrencyRow` экземпляра для всех записей в базе данных.

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a>Удаление продукта с помощью непосредственной схемы с оптимистичным параллелизмом

При использовании непосредственной схемы для DAL, использует оптимистический параллелизм, методы должны передаваться исходного и новое значения. Для удаления, отсутствуют новые значения, поэтому только исходные значения должны передаваться в. В нашем МЕТОДА, необходимо принять все исходные параметры в качестве входных параметров. Рассмотрим `DeleteProduct` метод в `ProductsOptimisticConcurrencyBLL` класс использовать непосредственным методом базы данных. Это означает, что этот метод должен принимать во всех полях данных десять продукта в качестве входных параметров и передавать их DAL, как показано в следующем коде:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

Если исходные значения - значения, загруженных последнего в GridView (или DetailsView и FormView) - отличаются от значений в базе данных, при нажатии кнопки «Удалить» `WHERE` предложение будет соответствовать любой записи базы данных и нет записей будут затронуты. Таким образом его `Delete` метод будет возвращать `0` , а МЕТОД `DeleteProduct` метод будет возвращать `false`.

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a>Обновление продукта с помощью шаблона пакета обновления с поддержкой оптимистичного параллелизма

Как уже отмечалось ранее, его `Update` метод для обновления конфигурации пакета имеет ту же сигнатуру метода, независимо от того, работает ли оптимистичного параллелизма. А именно `Update` метод ожидает DataRow, массив DataRow, DataTable или типизированным набором данных. Существуют дополнительные входные параметры для указания исходных значений. Это обусловлено тем, DataTable отслеживает исходные и измененные значения для его DataRow(s). Когда DAL выпускает его `UPDATE` инструкции `@original_ColumnName` параметров заполняются DataRow исходные значения, тогда как `@ColumnName` параметров заполняются DataRow измененные значения.

В `ProductsBLL` класса (с использованием наш исходный, отличных от оптимистичного параллелизма DAL), при использовании шаблона пакетного обновления для обновления информации о продукте код выполняет следующую последовательность событий:

1. Чтение информации о продукте текущей базы данных в `ProductRow` экземпляра с помощью адаптера таблицы `GetProductByProductID(productID)` метод
2. Назначение новых значений для `ProductRow` из этапа 1
3. Вызов метода `Update` метод, передавая `ProductRow` экземпляра

Эту последовательность действий, однако не будет правильно поддерживать оптимистичный параллелизм поскольку `ProductRow` заполняется в шаге 1 заполняется непосредственно из базы данных, это означает, что исходные значения, используемые DataRow, которые в настоящее время существует в базы данных, а не те, которые были привязаны к GridView в начале процесса редактирования. Вместо этого при с помощью оптимистичного параллелизма поддержкой DAL, нам нужно изменить `UpdateProduct` перегруженных версий метода для выполнения следующих шагов:

1. Чтение информации о продукте текущей базы данных в `ProductsOptimisticConcurrencyRow` экземпляра с помощью адаптера таблицы `GetProductByProductID(productID)` метод
2. Назначьте *исходного* значения `ProductsOptimisticConcurrencyRow` из этапа 1
3. Вызовите `ProductsOptimisticConcurrencyRow` экземпляра `AcceptChanges()` метод, который указывает, что DataRow, текущие значения являются «исходными»
4. Назначьте *новый* значения `ProductsOptimisticConcurrencyRow` экземпляра
5. Вызов метода `Update` метод, передавая `ProductsOptimisticConcurrencyRow` экземпляра

Шаг 1 выполняется чтение всех текущих значений базы данных для определенной записи продукта. Этот шаг не требуется в перегрузке `UpdateProduct` , обновляющей *все* столбцы продукта (поскольку эти значения будут перезаписаны в шаге 2), но необходим для этих перегрузок, где только подмножество значений столбца передаются в качестве входные параметры. После назначения исходных значений `ProductsOptimisticConcurrencyRow` экземпляра, `AcceptChanges()` вызывается метод, который помечает DataRow текущие значения как исходные значения для использования в `@original_ColumnName` параметров в `UPDATE` инструкции. Далее назначены новые значения параметров `ProductsOptimisticConcurrencyRow` и, наконец, `Update` вызывается метод, передавая DataRow.

В следующем коде показано `UpdateProduct` перегрузку, которая принимает все данные о продуктах полей в качестве входных параметров. Пока не показано здесь, `ProductsOptimisticConcurrencyBLL` входит в состав для этого учебника также содержит класс `UpdateProduct` перегрузку, которая принимает в качестве входных параметров только название и цену продукта.


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a>Шаг 4: Передача значений исходные и новые страницы ASP.NET методы уровень бизнес-ЛОГИКИ

DAL и уровень бизнес-ЛОГИКИ завершения все, что остается только для создания страницы ASP.NET, которые могут использоваться логику оптимистичного параллелизма, встроенной в системе. В частности данные веб-управления (GridView, DetailsView и FormView) необходимо помните, что исходные значения и ObjectDataSource должен передавать оба набора значений уровня бизнес-логики. Кроме того страница ASP.NET должна быть настроена таким образом, для правильной обработки нарушений параллелизма.

Сначала откройте `OptimisticConcurrency.aspx` страницы в `EditInsertDelete` папки и добавление элемента управления GridView в конструктор, установив его `ID` свойства `ProductsGrid`. В смарт-теге элемента GridView, попробовать создать новый элемент управления ObjectDataSource с именем `ProductsOptimisticConcurrencyDataSource`. Поскольку мы хотим этого ObjectDataSource использовал DAL с поддержкой оптимистичного параллелизма, настройте его для использования `ProductsOptimisticConcurrencyBLL` объекта.


[![Не используется элемент управления ObjectDataSource ProductsOptimisticConcurrencyBLL объекта](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)

**Рис. 13**: для использования ObjectDataSource `ProductsOptimisticConcurrencyBLL` объекта ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image37.png))


Выберите `GetProducts`, `UpdateProduct`, и `DeleteProduct` методов из раскрывающихся списков в мастере. Метод UpdateProduct используйте перегрузку, которая принимает все поля данных продукта.

## <a name="configuring-the-objectdatasource-controls-properties"></a>Настройка свойств элемента управления ObjectDataSource

По завершении работы мастера декларативная разметка ObjectDataSource должен выглядеть следующим образом:


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

Как видите, `DeleteParameters` коллекция содержит `Parameter` экземпляра для каждого из десяти входных параметров в `ProductsOptimisticConcurrencyBLL` класса `DeleteProduct` метод. Аналогичным образом `UpdateParameters` коллекция содержит `Parameter` экземпляра для каждого из входных параметров в `UpdateProduct`.

Для предыдущих учебников, в которых использовалось изменение данных, мы бы удалили ObjectDataSource `OldValuesParameterFormatString` свойство на этом этапе, поскольку это свойство указывает, что метод уровень бизнес-ЛОГИКИ ожидает, что значения должны быть переданы в старые (или исходные), а также новые значения. Кроме того значение этого свойства указывает названия входных параметров для исходных значений. Поскольку исходные значения передаются в МЕТОДА, выполните *не* удалите это свойство.

> [!NOTE]
> Значение `OldValuesParameterFormatString` должно соответствовать именам входного параметра в МЕТОДА, которые ожидают исходные значения. Поскольку эти параметры с именем `original_productName`, `original_supplierID`, и т. д., можно оставить `OldValuesParameterFormatString` значение свойства как `original_{0}`. Если, однако входные параметры методов уровень бизнес-ЛОГИКИ имена которых как `old_productName`, `old_supplierID`, и т. д., необходимо обновить `OldValuesParameterFormatString` свойства `old_{0}`.


Имеется один параметр последнее свойство, которое должно выполняться в порядке для ObjectDataSource верно передавал исходные значения в методы уровень бизнес-ЛОГИКИ. ObjectDataSource имеет [ConflictDetection свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) , могут быть назначены [одно из двух значений](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):

- `OverwriteChanges`-значение по умолчанию; уровень бизнес-ЛОГИКИ исходного входных параметров не отправляет исходные значения
- `CompareAllValues`-исходные значения передаются методам уровень бизнес-ЛОГИКИ; Выберите этот параметр при использовании оптимистичного параллелизма

Теперь пора установить `ConflictDetection` свойства `CompareAllValues`.

## <a name="configuring-the-gridviews-properties-and-fields"></a>Настройка свойств и полей в GridView

Со свойствами элемента управления ObjectDataSource правильно настроен давайте рассмотрим настройки GridView. Во-первых поскольку мы хотим GridView для поддержки, изменения и удаления, установите флажки Разрешить изменение и удаление включить смарт-теге элемента GridView. При этом будет добавлено CommandField которого `ShowEditButton` и `ShowDeleteButton` устанавливаются равными `true`.

При привязке к `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, GridView содержит поле для каждого из полей данных продукта. Хотя можно изменить такие GridView, взаимодействие с пользователем допустимо, но. `CategoryID` И `SupplierID` стояли будут отображаться как текстовые поля, поскольку требует от пользователя ввести соответствующую категорию и поставщика в качестве номера Идентификаторов. Будет существовать без форматирования для числовых полей и элементы управления проверки для обеспечения указано название продукта и его цену единиц на складе, единицы заказа и переупорядочивания значения уровня — как числовые значения, соответствующие и больше, чем или равно нулевое значение.

Как уже говорилось в *Добавление проверяющих элементов управления для редактирования и вставка интерфейсов* и *Настройка интерфейса изменения данных* учебники, пользовательский интерфейс можно настраивать путем заменив стояли TemplateFields. Изменения этого GridView и его интерфейс редактирования следующим образом:

- Удалить `ProductID`, `SupplierName`, и `CategoryName` стояли
- Преобразовать `ProductName` BoundField в TemplateField и добавлен элемент управления RequiredFieldValidation.
- Преобразовать `CategoryID` и `SupplierID` стояли для TemplateFields и настроил интерфейс редактирования для использования элементами управления DropDownList, а не текстовые поля. В этих TemplateFields `ItemTemplates`, `CategoryName` и `SupplierName` отображаются поля данных.
- Преобразовать `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, и `ReorderLevel` стояли TemplateFields и добавленных элементов управления CompareValidator.

Так как мы уже рассмотрели способы выполнения этих задач в предыдущих учебниках, я просто список окончательный декларативный синтаксис и реализации рекомендуется оставить.


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

Мы очень близко к необходимости полностью рабочий пример. Однако есть несколько тонкостей, которые незаметно и приведут к проблемам. Кроме того мы по-прежнему необходим интерфейс предупреждает пользователя о произошло нарушение параллелизма.

> [!NOTE]
> Чтобы данные веб-элемент управления для правильной передачи исходные значения ObjectDataSource (который передаются МЕТОДА), крайне важно, GridView `EnableViewState` свойству `true` (по умолчанию). Если вы отключите состояние просмотра, первоначальные значения теряются при обратной передаче.


## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a>Передача правильные исходные значения в элемент управления ObjectDataSource

Существует несколько проблем с тем, как настроена GridView. Если элемент управления ObjectDataSource `ConflictDetection` свойству `CompareAllValues` (как есть нашим), когда ObjectDataSource `Update()` или `Delete()` методы вызываются GridView (или DetailsView и FormView), ObjectDataSource пытается скопировать GridView исходные значения в соответствующие `Parameter` экземпляров. Вернуться на рис. 2 графическое представление этого процесса.

В частности GridView присваиваются значения в инструкциях двухсторонней привязкой данных каждый раз, данные будут привязаны к GridView. Таким образом важно, необходимые исходные значения записывались через двусторонняя привязка к данным и что они предоставляются в преобразуемом формате.

Чтобы узнать, почему это важно, пора посетите нашу страницу в браузере. Как и ожидалось, GridView выводит список всех продуктов, с помощью кнопки Edit и Delete в левом столбце.


[![Продукты отображаются в элементе управления GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)

**Рис. 14**: продукты отображаются в элементе управления GridView ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image40.png))


Если нажать кнопку «Удалить» для любых продуктов `FormatException` возникает исключение.


[![Попытка удалить все результаты продукта в FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)

**Рис. 15**: попытка удалить никакие результаты продукта в `FormatException` ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image43.png))


`FormatException` Возникает, когда элемент управления ObjectDataSource пытается выполнить чтение в исходной коллекции `UnitPrice` значение. Поскольку `ItemTemplate` имеет `UnitPrice` в формате валюты (`<%# Bind("UnitPrice", "{0:C}") %>`), он включает символ валюты, например $19.95. `FormatException` Возникает при попытке преобразование этой строки в элемент управления ObjectDataSource `decimal`. Для решения этой проблемы, у нас есть несколько параметров:

- Удаление форматирования денежных единиц `ItemTemplate`. То есть вместо `<%# Bind("UnitPrice", "{0:C}") %>`, просто использовать `<%# Bind("UnitPrice") %>`. Недостатком этого является цена больше не отформатирован.
- Отображение `UnitPrice` в денежном формате `ItemTemplate`, но использовать `Eval` ключевое слово для выполнения этой задачи. Помните, что `Eval` выполняет односторонние привязки данных. По-прежнему требуется предоставить `UnitPrice` значение для исходных значений, поэтому нам по-прежнему остается оператор двусторонняя привязка к данным в `ItemTemplate`, но это может быть помещен в веб-управления Label, `Visible` свойству `false`. В шаблоне ItemTemplate можно использовать следующую разметку:


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- Удаление форматирования денежных единиц `ItemTemplate`, с использованием `<%# Bind("UnitPrice") %>`. В GridView `RowDataBound` обработчик событий, программный доступ веб-метки элемента управления в течение которого `UnitPrice` значение отображается и задать его `Text` отформатированную версию.
- Оставьте `UnitPrice` в формате валюты. В GridView `RowDeleting` обработчика событий, замените существующее исходное `UnitPrice` значение ($19.95) с фактическим десятичным значением с помощью `Decimal.Parse`. Мы узнали, как выполнить команду, аналогичную в `RowUpdating` обработчик событий в [ *обработки уровень бизнес-ЛОГИКИ и исключения уровня DAL на странице ASP.NET* ](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) учебника.

В данном примере я решил во втором подходе добавление скрытых Web метки элемент управления `Text` свойство является двусторонней данными, привязанными к значению `UnitPrice` значение.

После решения этой проблемы, попробуйте нажать кнопку «Удалить» для любого продукта еще раз. Это время, вы сможете получить `InvalidOperationException` при попытке вызова МЕТОДА ObjectDataSource `UpdateProduct` метод.


[![ObjectDataSource не удается найти метод с параметрами входные данные, ему нужно отправить](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)

**На рисунке 16**: ObjectDataSource не удается найти метод с параметрами входные данные, ему нужно отправить ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image46.png))


Видите сообщение об исключении, было ясно, что элемент управления ObjectDataSource может вызвать МЕТОД `DeleteProduct` метод, который включает в себя `original_CategoryName` и `original_SupplierName` входные параметры. Это вызвано `ItemTemplate` s для `CategoryID` и `SupplierID` TemplateFields в настоящее время содержит двусторонней привязки инструкции с `CategoryName` и `SupplierName` полей данных. Вместо этого мы должны включать `Bind` инструкции с `CategoryID` и `SupplierID` полей данных. Для этого замените существующие инструкции привязки с `Eval` инструкций и затем добавить метки скрытые элементы управления которого `Text` свойства привязаны к `CategoryID` и `SupplierID` полей данных, с помощью двусторонняя привязка к данным, как показано ниже:


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

Эти изменения которые теперь может успешно удалить или изменить сведения о продукте! На шаге 5 мы рассмотрим способы проверки обнаружения нарушений параллелизма. Но пока потратьте несколько минут и попробуйте обновить и удалить несколько записей, чтобы убедиться, что обновления и удаления для одного пользователя работает должным образом.

## <a name="step-5-testing-the-optimistic-concurrency-support"></a>Шаг 5: Тестирование поддержки оптимистичного параллелизма

Чтобы убедиться, что нарушений параллелизма, обнаруженных (а не результирующие в автоматической перезаписи данных), нам нужно открыть два окна обозревателя на эту страницу. В обоих экземплярах обозревателя нажмите кнопку «Изменить» для товара. Затем в одном из браузеров, измените имя на «Чай» и нажмите кнопку обновления. Обновление должен завершиться успешно и вернуться в состояние до редактирования с «Чай» как новое имя продукта GridView.

В другом экземпляре окна браузера название продукта текстовое поле по-прежнему отображается «Chai». В этом втором окне обозревателя обновления `UnitPrice` для `25.00`. Без поддержки оптимистичного параллелизма обновления во втором экземпляре обозревателя изменится имя продукта обратно на «Chai», тем самым перезаписать изменения, внесенные в первом экземпляре браузера. При оптимистичного параллелизма, тем не менее, щелкнув кнопку обновления на втором экземпляре обозревателя приведет к [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).


[![Если обнаружено нарушение параллелизма, вызывается исключение DBConcurrencyException](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)

**Рисунок 17**: обнаружена при нарушение параллелизма `DBConcurrencyException` выдается ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image49.png))


`DBConcurrencyException` Возникает только при использовании DAL пакетного обновления шаблона. Исключение не вызывалось непосредственной схемы, он просто указывает, что строки не были затронуты. Чтобы проиллюстрировать это, возвращают установим для элемента управления GridView в состояние до редактирования. Затем в первом экземпляре обозревателя, нажмите кнопку "Изменить" измените название продукта с «Чай» к «Chai» и нажмите кнопку обновления. Во втором окне браузера нажмите кнопку Удалить для товара.

После нажатия на кнопку удаления, обратной передаче страницы, GridView вызывает элемент управления ObjectDataSource `Delete()` метод и ObjectDataSource вызывает `ProductsOptimisticConcurrencyBLL` класса `DeleteProduct` , передавая исходные значения. Исходный `ProductName` для второго экземпляра обозревателя равно «Чай», который не совпадает с текущим `ProductName` значение в базе данных. Поэтому `DELETE` инструкция выполняется в базе данных, не изменяет строки, так как отсутствует запись в базе данных, `WHERE` удовлетворяет предложения. `DeleteProduct` Возвращает метод `false` и ObjectDataSource привязываются к GridView.

С точки зрения конечного пользователя, нажав кнопку удаления для чай во второе окно браузера вызвал мерцание экрана и, при приходящие обратно, продукт будет по-прежнему существует, несмотря на то, что теперь указано как «Chai» (Изменение названия продукта первой веб-обозревателя экземпляр). При нажатии кнопки «Удалить» еще раз, операция удаления будет успешно завершена, как GridView исходного `ProductName` значение («Chai») теперь соответствует значение в базе данных.

В обоих случаях взаимодействие с пользователем далеко от идеала. Нам явно не требуется для отображения пользователю работать с мелкими деталями `DBConcurrencyException` исключение при использовании шаблона пакетного обновления. И поведения при использовании непосредственной схемы находится несколько запутанным не удалось выполнить команду пользователей, однако отсутствуют признаки точный причин.

Чтобы исправить эти две проблемы, можно создать метку веб-элементов управления на странице, которые предоставляют объяснение для причины update или delete не удалось. Для обновления конфигурации пакета, можно определить ли `DBConcurrencyException` возникло исключение в обработчике событий последующего уровня элемента GridView, отображать предупреждение при необходимости. Для прямого метода DB можно проверить возвращаемое значение метода, уровень бизнес-ЛОГИКИ (который является `true` если изменена одна строка, `false` в противном случае) и при необходимости отображать информационное сообщение.

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a>Шаг 6: Добавление информационных сообщений и их отображения в случае одновременного нарушения

Когда происходит нарушение параллелизма, поведения зависит от того, использование пакетного обновления DAL или непосредственной схемы базы данных. В этом руководстве используются оба шаблона с помощью шаблона обновления пакета, используемый для обновления и непосредственной схемы используется для удаления. Чтобы приступить к работе, добавим две метки веб-элементов управления на страницу, в которых объясняется, что нарушение параллелизма произошла при попытке удаления или обновления данных. Задать элемент управления Label `Visible` и `EnableViewState` свойства `false`; это приведет к их скрыты при всех, за исключением того, для тех, кто определенную страницу посещает where их `Visible` программным образом задано значение `true`.


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

В дополнение к параметру их `Visible`, `EnabledViewState`, и `Text` свойства, я также установил `CssClass` свойства `Warning`, что вызывает метку, отображаемую в больших, красный, курсив и полужирный шрифт. Этот класс `Warning` класс был определен и добавлены Styles.css обратно в *проверки события, связанные с вставки, обновления и удаления* учебника.

После добавления этих меток, конструктор в Visual Studio должен выглядеть примерно на рисунке 18.


[![Были добавлены два элемента управления Label на страницу](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)

**На рисунке 18**: две метки добавлены элементы управления на страницу ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image52.png))


С этими элементами управления Web метки на месте можно приступить к рассмотрению определения, когда произошло нарушение параллелизма, по которому соответствующие метки точки `Visible` свойству можно присвоить значение `true`, отображается информационное сообщение.

## <a name="handling-concurrency-violations-when-updating"></a>Обработка нарушений параллелизма при обновлении

Давайте сначала посмотрим, как обрабатывать нарушений параллелизма при использовании шаблона пакетного обновления. С момента подобные нарушения с пакетом обновления причина шаблон `DBConcurrencyException` исключение, необходимо добавить на страницу ASP.NET, чтобы определить код ли `DBConcurrencyException` исключение произошло во время процесса обновления. Если Да, должен отображать сообщение для пользователя о том, изменения не были сохранены, так как другой пользователь был изменен те же данные между при их запуске редактирование записи и нажатию кнопки "Обновить".

Как мы видели в *обработки уровень бизнес-ЛОГИКИ и исключения уровня DAL на странице ASP.NET* учебника, такие исключения может быть обнаружено и заблокированные в обработчиках событий последующего уровня веб-элемента управления. Следовательно, необходимо создать обработчик событий для элемента GridView `RowUpdated` событие, которое проверяет `DBConcurrencyException` исключения. Этот обработчик событий передается ссылка на любое исключение, возникшее во время процесса обновления, как показано в случае, когда обработчик кода ниже:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

В возникновении из `DBConcurrencyException` исключения, этот обработчик событий выводит `UpdateConflictMessage` метки элемента управления и указывает, что исключение было обработано. Этот код в месте при возникновении нарушения параллелизма при обновлении записи, пользовательские изменения будут потеряны, так как они бы к перезаписи изменений другого пользователя в то же время. В частности GridView возвращается в состояние до редактирования и связанных с текущей базой данных. Это обновит строки GridView с изменениями другого пользователя, которые ранее не были видны. Кроме того `UpdateConflictMessage` управления Label объясняется пользователю, что произошло. На рисунке 19 подробно эту последовательность событий.


[![Пользователь s обновления теряются в условиях нарушение параллелизма](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)

**На рисунке 19**: s пользователя, теряются обновлений в условиях нарушение параллелизма ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image55.png))


> [!NOTE]
> Кроме того, вместо того чтобы возвращать GridView в состояние до редактирования, можно оставить GridView в состоянии редактирования, задав `KeepInEditMode` свойство переданный `GridViewUpdatedEventArgs` необходимо присвоить значение true. При использовании подхода, тем не менее, необходимо выполнить повторную привязку данных к GridView (путем вызова его `DataBind()` метод), чтобы значения другого пользователя будут загружены в интерфейс редактирования. Код, можно загрузить с помощью этого учебника имеет эти две строки кода в `RowUpdated` обработчик событий закомментированы; просто раскомментируйте эти строки кода с целью GridView оставаться в режиме редактирования после нарушение параллелизма.


## <a name="responding-to-concurrency-violations-when-deleting"></a>Реакция на нарушения параллелизма при удалении

При непосредственной схемы базы данных может быть не исключение, вызываемое в случае одновременного нарушения. Вместо этого инструкция базы данных просто не изменяет запись, как предложение WHERE не соответствует ни одной записи. Все методы изменения данных, созданные в МЕТОДА, были разработаны таким образом, что они возвращают логическое значение, указывающее, было ли они изменяются в каждой записи. Таким образом, чтобы определить, если нарушение параллелизма при удалении записи, можно проверить возвращаемое значение метода `DeleteProduct` метод.

Можно проверить возвращаемое значение метода уровень бизнес-ЛОГИКИ в ObjectDataSource обработчики через `ReturnValue` свойство `ObjectDataSourceStatusEventArgs` объекта, передаваемого в обработчик событий. Так как мы будем рады получить определение возвращаемого значения из `DeleteProduct` метод, необходимо создать обработчик событий для элемента управления ObjectDataSource `Deleted` событий. `ReturnValue` Свойство относится к типу `object` и может быть `null` Если возникло исключение, и метод была прервана, прежде чем она может возвращать значение. Таким образом, нам необходимо убедиться, что `ReturnValue` свойство не `null` и является логическим значением. При условии, что эта проверка пройдена, мы покажем `DeleteConflictMessage` метки элемента управления, если `ReturnValue` — `false`. Это можно сделать с помощью следующего кода:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

В случае одновременного нарушения запрос пользователя на удаление отменяется. Обновляется GridView, отображающая изменений, внесенных пользователем, для этой записи с момента загрузки страницы, и он по щелчку кнопка "Удалить". Когда процесс подобных нарушений, `DeleteConflictMessage` метке, объяснением произошедшего (см. рис. 20).


[![В случае одновременного нарушения отменяется пользователя s Delete](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)

**Рис. 20**: удаление отменен в случае одновременного нарушения s пользователя ([Просмотр полноразмерное изображение](implementing-optimistic-concurrency-cs/_static/image58.png))


## <a name="summary"></a>Сводка

Возможности одновременного нарушения существуют во всех приложениях, который позволяет нескольким пользователям одновременно обновлять или удалять данные. Если подобные нарушения не учитываются, если два пользователя одновременно обновить те же данные, кто получает в последней записи «wins», перезапись другой пользователь изменяет изменения. Кроме того разработчики могут реализовывать оптимистичное или пессимистичное управление параллелизмом. Управление оптимистичным параллелизмом предполагает, что нарушений параллелизма происходят редко и просто не разрешает обновление или удаление команды, составляющей нарушение параллелизма. Управление пессимистичным параллелизмом предполагает, что параллельную обработку нарушений часты и просто отклонение одного пользователя, обновить или удалить команды является недопустимым. Управление пессимистичным параллелизмом обновление записи включает блокировки, тем самым предотвращая других пользователей, изменить или удалить запись, пока он заблокирован.

Типизированный набор данных в .NET предоставляет возможности для поддержки управления оптимистичного параллелизма. В частности `UPDATE` и `DELETE` , обращенные к базе данных включают все столбцы таблицы, обеспечивая таким образом, обновления или удаления возможен, только если текущие данные записи совпадает с исходными данными пользователь имел при выполнение обновления или удаления. После настройки DAL для поддержки оптимистичного параллелизма, уровень бизнес-ЛОГИКИ методы должны быть обновлены. Кроме того страница ASP.NET, которая вызывает МЕТОДА необходимо настроить таким образом, что элемент управления ObjectDataSource извлекает исходные значения из его веб-управления и передает их МЕТОДА.

Как было показано в этом учебнике, реализация управления оптимистичным параллелизмом в веб-приложении ASP.NET включает в себя обновления DAL и уровень бизнес-ЛОГИКИ и добавления поддержки на странице ASP.NET. Ли эта дополнительная работа разумной тратой времени и усилий зависит от приложения. При наличии редко одновременных пользователей, обновление данных, или данные, которые они обновляют отличается друг от друга, управление параллелизмом не является главным вопросом. Если, однако регулярно имеется несколько пользователей на сайте, работать с теми же данными, управление параллелизмом помогает предотвратить случайную перезапись другого лица одного пользователя обновления или удаления.

Программирование довольны!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

>[!div class="step-by-step"]
[Назад](customizing-the-data-modification-interface-cs.md)
[Вперед](adding-client-side-confirmation-when-deleting-cs.md)
