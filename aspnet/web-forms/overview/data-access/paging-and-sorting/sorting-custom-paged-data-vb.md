---
uid: web-forms/overview/data-access/paging-and-sorting/sorting-custom-paged-data-vb
title: Сортировка пользовательских данных (Visual Basic), разбитых на страницы | Документы Microsoft
author: rick-anderson
description: В предыдущем учебнике мы узнали, как реализовать пользовательское разбиение по страницам при presentating данных на веб-странице. В этом учебнике показано, как расширить приведенный выше...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 4823a186-caaf-4116-a318-c7ff4d955ddc
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/sorting-custom-paged-data-vb
msc.type: authoredcontent
ms.openlocfilehash: e144b434bd759c4253065e365b1337a3eca82fa7
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30883070"
---
<a name="sorting-custom-paged-data-vb"></a>Сортировка настраиваемый постраничных данных (Visual Basic)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_26_VB.exe) или [скачать PDF](sorting-custom-paged-data-vb/_static/datatutorial26vb1.pdf)

> В предыдущем учебнике мы узнали, как реализовать пользовательское разбиение по страницам при presentating данных на веб-странице. В этом учебнике показано, как расширить в предыдущем примере, чтобы включить поддержку сортировки пользовательское разбиение по страницам.


## <a name="introduction"></a>Вступление

По сравнению с разбиения на страницы по умолчанию, пользовательское разбиение по страницам можно повысить производительность разбиения данных несколько раз, что пользовательское разбиение по страницам фактически Выбор реализации подкачки при работе с большими объемами данных. Реализация пользовательское разбиение по страницам сложнее, чем реализации по умолчанию разбивка на страницы, тем не менее, особенно в том случае, если добавление сортировки в наборе. В этом учебнике мы расширим пример с предыдущим включите поддержку сортировки *и* пользовательское разбиение по страницам.

> [!NOTE]
> Поскольку этот учебник построен на основе предыдущим, до начала занять некоторое время для копирования декларативного синтаксиса в `<asp:Content>` элемент из предыдущего учебника s веб-страницы (`EfficientPaging.aspx`) и вставьте его между `<asp:Content>` элемент в `SortParameter.aspx` страницы. Ссылать на шаге 1 [Добавление проверяющих элементов управления для редактирования и вставка интерфейсов](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) учебника более подробное обсуждение репликация функциональные возможности одной страницы ASP.NET на другой.


## <a name="step-1-reexamining-the-custom-paging-technique"></a>Шаг 1: Уточнение пользовательский метод разбиения на страницы

Пользовательское разбиение по страницам для правильной работы, мы должен реализовать некоторые метод, который можно эффективно захватите определенного подмножества записей, заданных параметров запуска строка индекса и максимальное число строк. Существует множество методов, которые могут использоваться для достижения этой целью. В учебнике выше мы рассмотрели решения этой проблемы с помощью Microsoft SQL Server 2005 s новый `ROW_NUMBER()` Ранжирующая функция. Иными словами `ROW_NUMBER()` Ранжирующая функция назначает номер строки для каждой строки, возвращаемой запросом, сортируя заданный порядок сортировки. Затем соответствующий набор записей получается путем возвращения определенного раздела нумерованной результаты. Следующий запрос показывает, как можно использовать этот метод для возврата этих продуктов с номерами от 11 до 20 при ранжировании результатов в алфавитном порядке по `ProductName`:


[!code-sql[Main](sorting-custom-paged-data-vb/samples/sample1.sql)]

Этот метод хорошо подходит для постраничного просмотра, используя определенный порядок сортировки (`ProductName` сортируются в алфавитном порядке, в этом случае), но должно быть изменено для отображения результатов, отсортированных по выражение сортировки запроса. В идеальном случае приведенный выше запрос можно изменить, чтобы использовать параметр в `OVER` предложение, следующим образом:


[!code-sql[Main](sorting-custom-paged-data-vb/samples/sample2.sql)]

К сожалению, параметризованные `ORDER BY` предложения не допускаются. Вместо этого необходимо создать хранимую процедуру, которая принимает `@sortExpression` входного параметра, но использует один из следующих способов:

- Записи жестко запросы для каждого выражения сортировки, которые могут использоваться; затем с помощью `IF/ELSE` инструкции T-SQL, чтобы определить, какой запрос для выполнения.
- Используйте `CASE` инструкцию, чтобы предоставить динамический `ORDER BY` на основе выражений `@sortExpressio` n входной параметр; см. раздел используется для сортировки результатов запроса динамически раздела [Power SQL `CASE` инструкции](http://www.4guysfromrolla.com/webtech/102704-1.shtml) Для получения дополнительных сведений.
- Создать соответствующий запрос как строку в хранимой процедуре, а затем используйте [ `sp_executesql` системной хранимой процедуры](https://msdn.microsoft.com/library/ms188001.aspx) для выполнения динамических запросов.

Каждый из этих способов имеет свои недостатки. Первый параметр не как два других как сопровождения, поскольку оно требует создания запроса для каждого возможных выражения. Таким образом Если позже вы решите включить для добавления новой страницы и сортировки полей в GridView также необходимо будет вернуться назад и обновить хранимую процедуру. Второй подход имеет некоторые тонкости, описывающие возможны проблемы с производительностью при сортировке столбцов без строк базы данных также страдает от такие же проблемы удобство поддержки, как первое. И третий вариант, с использованием динамического SQL, возникает риск атаки путем внедрения кода SQL, если злоумышленник сможет выполнить хранимую процедуру, передав значения входного параметра по своему выбору.

Ни один из этих подходов является идеальным, я думаю, что третий параметр — наиболее подходящий из трех. С помощью динамического SQL он обеспечивает уровень гибкости, два других — нет. Кроме того атаке путем внедрения кода SQL можно воспользоваться только если злоумышленник имеет возможность выполнения хранимой процедуры, передавая во входных параметрах собственный. Поскольку параметризованные запросы используются DAL, ADO.NET будет защищать тех параметров, которые отправляются в базу данных через архитектуру, это означает, что уязвимость атаки путем внедрения кода SQL существует только если злоумышленник может напрямую выполнять хранимую процедуру.

Для реализации этой функции, создать новую хранимую процедуру в базе данных Northwind с именем `GetProductsPagedAndSorted`. Эта хранимая процедура должна принять три входных параметра: `@sortExpression`, входного параметра типа `nvarchar(100`), определяет, как должны сортироваться результаты и введенный сразу после `ORDER BY` текста в `OVER` предложения; и `@startRowIndex` и `@maximumRows`, же входных параметров два целочисленных из `GetProductsPaged` хранимой процедуры проверяется в предыдущем учебнике. Создание `GetProductsPagedAndSorted` хранимой процедуры, с помощью следующего сценария:


[!code-sql[Main](sorting-custom-paged-data-vb/samples/sample3.sql)]

Хранимая процедура запускается, проверьте значение для `@sortExpression` параметр был указан. Если он отсутствует, результаты сортируются по `ProductID`. Затем создается динамический SQL-запроса. Обратите внимание, что динамический SQL-запрос здесь немного отличается от наших предыдущих запросов, используемый для получения всех строк из таблицы Products. В предыдущих примерах были получены категории продукта s связанные имена s s и поставщика, используя вложенный запрос. Это было сделано в [Создание слой доступа к данным](../introduction/creating-a-data-access-layer-vb.md) учебника и было выполнено вместо `JOIN` s, так как адаптер таблицы не удается автоматически создать связанный insert, update и delete методы для таких запросы. `GetProductsPagedAndSorted` Хранимой процедуры, тем не менее, необходимо использовать `JOIN` s результаты упорядочиваются по имени категории или поставщика.

Этот динамический запрос построена путем объединения частей статический запрос и `@sortExpression`, `@startRowIndex`, и `@maximumRows` параметров. Поскольку `@startRowIndex` и `@maximumRows` целое число параметров, они должны быть преобразованы в nvarchars, чтобы правильно конкатенацию. После создания динамического SQL-запроса выполняется через `sp_executesql`.

Теперь пора проверить Эта хранимая процедура с разными значениями для `@sortExpression`, `@startRowIndex`, и `@maximumRows` параметров. В обозревателе сервера щелкните правой кнопкой мыши имя хранимой процедуры и выберите команду выполнить. Откроется диалоговое окно запустить хранимую процедуру, в котором можно ввести входные параметры (см. рис. 1). Чтобы отсортировать результаты по имени категории, используйте «категория» для `@sortExpression` значение параметра; для сортировки по названию компании поставщика s используйте CompanyName. После предоставления значения параметров, нажмите кнопку "ОК". Результаты отображаются в окне вывода. На рисунке 2 показаны результаты при ранжировании 11 по 20 возврат продуктов, при упорядочивании по `UnitPrice` в порядке убывания.


![Попробуйте различные значения для хранимых процедур s трех входных параметров](sorting-custom-paged-data-vb/_static/image1.png)

**Рис. 1**: попробуйте различные значения для хранимой процедуры s трех входных параметров


[![Хранимая процедура s результаты отображаются в окне вывода](sorting-custom-paged-data-vb/_static/image3.png)](sorting-custom-paged-data-vb/_static/image2.png)

**На рисунке 2**: s хранимая процедура результаты отображаются в окне вывода ([Просмотр полноразмерное изображение](sorting-custom-paged-data-vb/_static/image4.png))


> [!NOTE]
> При ранжировании результатов по заданному `ORDER BY` столбца в `OVER` предложение SQL Server нужно отсортировать результаты. Эта операция выполняется очень быстро, если имеется кластеризованный индекс для соответствующих столбцов, результаты упорядочиваются по или при наличии покрытия индекса, но может быть более высокие цены, в противном случае. Чтобы повысить производительность запросов, достаточно большой, рассмотрите возможность добавления некластеризованный индекс для столбца, по которому упорядочиваются результаты по. Ссылаться на [Ранжирующие функции и производительности в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) для получения дополнительных сведений.


## <a name="step-2-augmenting-the-data-access-and-business-logic-layers"></a>Шаг 2: Дополнения, доступ к данным и бизнес-логики уровни

С `GetProductsPagedAndSorted` хранимая процедура, созданная, следующим шагом является предоставляют средства для выполнения этой хранимой процедуры через архитектуру приложения. Это включает добавление соответствующий метод DAL и уровень бизнес-ЛОГИКИ. Позволяет начать с добавления метода DAL s. Откройте `Northwind.xsd` типизированного набора данных, щелкните правой кнопкой мыши `ProductsTableAdapter`и в контекстном меню выберите Добавить запрос. Как это делалось в предыдущем учебнике мы хотим настроить этот новый метод DAL, чтобы использовать существующую хранимую процедуру - `GetProductsPagedAndSorted`в данном случае. Запустите, указав, что требуется новый метод адаптера таблицы для использования существующей хранимой процедуры.


![Использовать существующую хранимую процедуру](sorting-custom-paged-data-vb/_static/image5.png)

**Рис. 3**: использовать существующую хранимую процедуру


Чтобы указать хранимой процедуры для использования, выберите `GetProductsPagedAndSorted` хранимую процедуру из раскрывающегося списка на следующем экране.


![Использовать GetProductsPagedAndSorted хранимой процедуры](sorting-custom-paged-data-vb/_static/image6.png)

**Рис. 4**: используйте GetProductsPagedAndSorted хранимой процедуры


Эта хранимая процедура возвращает набор записей, как его результаты таким образом, на следующем экране указывают возвращение табличных данных.


![Указывает, что хранимая процедура возвращает табличные данные](sorting-custom-paged-data-vb/_static/image7.png)

**Рис. 5**: Указывает, что хранимая процедура возвращает табличные данные


Наконец, DAL методы, которые используют оба заливки объект DataTable и возвращать шаблоны DataTable, именование методы `FillPagedAndSorted` и `GetProductsPagedAndSorted`соответственно.


![Выберите имена методов](sorting-custom-paged-data-vb/_static/image8.png)

**Рис. 6**: выберите имена методов


Теперь, мы хранить расширенные DAL, мы готов для включения для МЕТОДА. Откройте `ProductsBLL` и добавьте новый метод `GetProductsPagedAndSorted`. Этот метод должен принимать три входных параметра `sortExpression`, `startRowIndex`, и `maximumRows` и следует просто вызов DAL s `GetProductsPagedAndSorted` метод, следующим образом:


[!code-vb[Main](sorting-custom-paged-data-vb/samples/sample4.vb)]

## <a name="step-3-configuring-the-objectdatasource-to-pass-in-the-sortexpression-parameter"></a>Шаг 3: Настройка ObjectDataSource для передачи в параметр SortExpression

Дополнить DAL и уровень бизнес-ЛОГИКИ для включения методов, которые используют `GetProductsPagedAndSorted` является настройка ObjectDataSource в хранимую процедуру, все, что остается `SortParameter.aspx` страницы использовать новый метод уровень бизнес-ЛОГИКИ и передачи `SortExpression` на основе параметров столбец, который пользователь хочет сортировать результаты по.

Сначала измените ObjectDataSource s `SelectMethod` из `GetProductsPaged` для `GetProductsPagedAndSorted`. Это можно сделать с помощью мастера настройки источника данных из окна свойств или напрямую с помощью декларативного синтаксиса. Затем нужно указать значение для ObjectDataSource s [ `SortParameterName` свойства](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.sortparametername.aspx). Если это свойство задано, ObjectDataSource пытается передать в GridView s `SortExpression` свойства `SelectMethod`. В частности, элемент управления ObjectDataSource ищет входной параметр, имя которого равен значению `SortParameterName` свойство. Так как уровень бизнес-ЛОГИКИ s `GetProductsPagedAndSorted` метод имеет входной параметр выражения сортировки, с именем `sortExpression`, набор ObjectDataSource s `SortExpression` свойства sortExpression.

После внесения этих изменений два ObjectDataSource s должен выглядеть следующим образом:


[!code-aspx[Main](sorting-custom-paged-data-vb/samples/sample5.aspx)]

> [!NOTE]
> Как в предыдущем учебник обеспечить ObjectDataSource *не* включают входные параметры sortExpression, startRowIndex или maximumRows в его коллекции SelectParameters.


Чтобы включить сортировку в GridView, просто установите флажок Включить сортировку в GridView s смарт-тег, который задает GridView s `AllowSorting` свойства `true` в результате чего текст заголовка для каждого столбца отображаются как LinkButton. Когда пользователь щелкает один из заголовков элементов управления LinkButton, обратная передача и пройти следующие действия:

1. Обновления GridView его [ `SortExpression` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.gridview.sortexpression.aspx) значению `SortExpression` была нажата, ссылку на заголовок поля
2. ObjectDataSource вызывает s уровень бизнес-ЛОГИКИ `GetProductsPagedAndSorted` метод, передавая GridView s `SortExpression` свойство в качестве значения для метода s `sortExpression` входной параметр (вместе с необходимым `startRowIndex` и `maximumRows` значений входных параметров)
3. МЕТОДА вызывает DAL s `GetProductsPagedAndSorted` метод
4. Выполняет DAL `GetProductsPagedAndSorted` передача хранимой процедуры в `@sortExpression` параметра (вместе с `@startRowIndex` и `@maximumRows` значений входных параметров)
5. Хранимая процедура возвращает соответствующий набор данных для МЕТОДА, который возвращает его в элемент управления ObjectDataSource; Эти данные затем привязать к GridView, к просмотру в HTML и отправляет для конечного пользователя

На рисунке 7 показано первой страницы результатов при сортировке по `UnitPrice` в порядке возрастания.


[![Результаты сортируются по UnitPrice](sorting-custom-paged-data-vb/_static/image10.png)](sorting-custom-paged-data-vb/_static/image9.png)

**Рис. 7**: результаты сортируются по UnitPrice ([Просмотр полноразмерное изображение](sorting-custom-paged-data-vb/_static/image11.png))


Пока текущая реализация правильно можно сортировать результаты по название продукта, имя категории, количество за единицу и цена за единицу, чем для упорядочивания результатов поставщиком именем приводит к исключению среды выполнения (см. рис. 8).


![Попытка сортировать результаты по результаты поставщика в следующее исключение времени выполнения](sorting-custom-paged-data-vb/_static/image12.png)

**Рис. 8**: попытка сортировать результаты по результаты поставщика в следующее исключение времени выполнения


Это исключение возникает, так как `SortExpression` из GridView s `SupplierName` BoundField равно `SupplierName`. Тем не менее, имя поставщика s в `Suppliers` таблица называется фактически `CompanyName` мы активно псевдоним это имя столбца, как `SupplierName`. Тем не менее `OVER` предложения, используемые `ROW_NUMBER()` функции невозможно использовать псевдоним и действительное имя столбца. Таким образом, изменить `SupplierName` BoundField s `SortExpression` из «название», чтобы CompanyName (см. рис. 9). Как показано на рис. 10, после этого изменения результатов можно отсортировать по поставщику.


![Измените CompanyName SortExpression s BoundField «название»](sorting-custom-paged-data-vb/_static/image13.png)

**Рис. 9**: измените CompanyName SortExpression s BoundField «название»


[![Теперь результаты можно сортировать по поставщикам](sorting-custom-paged-data-vb/_static/image15.png)](sorting-custom-paged-data-vb/_static/image14.png)

**Рис. 10**: результаты теперь сортируется по поставщику ([Просмотр полноразмерное изображение](sorting-custom-paged-data-vb/_static/image16.png))


## <a name="summary"></a>Сводка

Пользовательская реализация разбиения на страницы, которые мы рассмотрели в предыдущем учебнике требуется указать порядок, по которому были результаты сортировки во время разработки. Иными словами это означает, что пользовательская реализация разбиения на страницы, которые мы реализовали может, в то же время предоставляет возможности сортировки. В этом учебнике мы позволяют обойти это ограничение, расширяя хранимой процедуры из первого включаемых `@sortExpression` входным параметром, с помощью которого могут быть упорядочены результаты.

После создания этого хранимой процедуры и создание новых методов DAL и уровень бизнес-ЛОГИКИ, мы были возможность реализовать GridView, предлагаемые как сортировка и пользовательское разбиение по страницам, настроив ObjectDataSource для передачи в GridView s текущий `SortExpression` свойства МЕТОДА `SelectMethod`.

Программирование довольны!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Благодарности

Этот учебник ряд прошел проверку многие полезные рецензентов. Основной рецензент этого учебника было Карлос Сантос. Объясняются моих последующих статей для MSDN? Если Да, напишите мне по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](efficiently-paging-through-large-amounts-of-data-vb.md)
> [Вперед](creating-a-customized-sorting-user-interface-vb.md)
