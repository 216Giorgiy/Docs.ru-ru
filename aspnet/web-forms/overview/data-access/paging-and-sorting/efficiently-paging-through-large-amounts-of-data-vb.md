---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: Эффективное разбиение больших объемов данных (Visual Basic) | Документы Microsoft
author: rick-anderson
description: Параметр разбиения на страницы по умолчанию элемента управления представления данных не подходит при работе с большими объемами данных, таких как его retriev базового элемента управления источника данных...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 00057f9bfd9b1c479e500ac591db694388a5d358
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
---
<a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="08671-103">Эффективное разбиение больших объемов данных (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="08671-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>
====================
<span data-ttu-id="08671-104">по [Скотт Митчелл](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="08671-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="08671-105">[Загрузить пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) или [скачать PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="08671-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="08671-106">Параметр разбиения на страницы по умолчанию элемента управления представления данных неприменим, при работе с большими объемами данных, поскольку его базовый источник данных получает все записи, несмотря на то, что отображается только подмножество данных.</span><span class="sxs-lookup"><span data-stu-id="08671-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="08671-107">В такой ситуации нужно включить пользовательское разбиения на страницы.</span><span class="sxs-lookup"><span data-stu-id="08671-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="08671-108">Вступление</span><span class="sxs-lookup"><span data-stu-id="08671-108">Introduction</span></span>

<span data-ttu-id="08671-109">Как уже говорилось в предыдущем учебнике разбиение по страницам можно реализовать одним из двух способов:</span><span class="sxs-lookup"><span data-stu-id="08671-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="08671-110">**Разбиение на страницы по умолчанию** может быть реализован просто установить параметр Включить разбиение на страницы в веб-элемент управления s данных смарт-тегов; тем не менее, при просмотре страницы данных, ObjectDataSource извлекает *всех* записей, даже Однако только их подмножество, отображаются на странице</span><span class="sxs-lookup"><span data-stu-id="08671-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="08671-111">**Пользовательское разбиение по страницам** повышает производительность по умолчанию разбиение по страницам путем извлечения только тех записей из базы данных, которые должны отображаться на странице данных, запрашиваемых пользователем; тем не менее, необходимо проделать некоторую дополнительную работу для реализации чем разбиение по страницам по умолчанию</span><span class="sxs-lookup"><span data-stu-id="08671-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="08671-112">Из-за Простота реализации достаточно лишь установить флажок и которые производится операция завершена успешно.</span><span class="sxs-lookup"><span data-stu-id="08671-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="08671-113">разбиение на страницы по умолчанию является привлекательным вариантом.</span><span class="sxs-lookup"><span data-stu-id="08671-113">default paging is an attractive option.</span></span> <span data-ttu-id="08671-114">Его н/д хранить подход получение всех записей, однако делает implausible выбор при разбиении на страницы с большими объемами данных или для сайтов с большим количеством одновременных пользователей.</span><span class="sxs-lookup"><span data-stu-id="08671-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="08671-115">В такой ситуации нужно включить пользовательское разбиение по страницам для обеспечения быстрого реагирования системы.</span><span class="sxs-lookup"><span data-stu-id="08671-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="08671-116">Пользовательское разбиение по страницам с проблемой является возможность создать запрос, который возвращает точный набор записей, необходимых для отдельной страницы данных.</span><span class="sxs-lookup"><span data-stu-id="08671-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="08671-117">К счастью Microsoft SQL Server 2005 предоставляет новое ключевое слово для ранжирование результатов, который позволит нам создать запрос, возвращающий нужное подмножество результатов.</span><span class="sxs-lookup"><span data-stu-id="08671-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="08671-118">В этом учебнике мы рассмотрим, как использовать это новое ключевое слово SQL Server 2005 реализовать пользовательское разбиение по страницам в элементе управления GridView.</span><span class="sxs-lookup"><span data-stu-id="08671-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="08671-119">Хотя пользовательский интерфейс для пользовательского разбиения идентично используемому по умолчанию, переход от одной страницы к другой пользовательское разбиение по страницам может быть несколько раз быстрее, чем разбиение на страницы по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="08671-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="08671-120">Рост производительности точное, выигрыш зависит от общее число страниц и нагрузку на сервер базы данных.</span><span class="sxs-lookup"><span data-stu-id="08671-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="08671-121">В конце этого учебника мы рассмотрим некоторые численные показатели, демонстрирующие эффективность пользовательского разбиения.</span><span class="sxs-lookup"><span data-stu-id="08671-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="08671-122">Шаг 1: Основные сведения о пользовательском процессе разбиения на страницы</span><span class="sxs-lookup"><span data-stu-id="08671-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="08671-123">При разбиении данных по страницам, точный записей, отображаемых на странице зависят от страницы запрашиваемых данных и количество записей, отображаемых на каждой странице.</span><span class="sxs-lookup"><span data-stu-id="08671-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="08671-124">Например предположим, мы хотим постраничного просмотра 81 наименования продуктов, по 10 продуктов на страницу.</span><span class="sxs-lookup"><span data-stu-id="08671-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="08671-125">При просмотре на первой странице, d хотим продуктов от 1 до 10. При просмотре на второй странице мы d интересовать продуктов 11 до 20 и т. д.</span><span class="sxs-lookup"><span data-stu-id="08671-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="08671-126">Существует три переменные, которые определяют, какие записи должны быть получены и просмотру интерфейс разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="08671-127">**Индекса первой строки** индекс первой строки в наборе данных для отображения; этот индекс может быть вычисляется путем умножения записей, отображаемых на каждой странице индекса страницы и добавление одного.</span><span class="sxs-lookup"><span data-stu-id="08671-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="08671-128">Например, если постраничного просмотра записей 10 одновременно, для первой страницы (с индексом 0), запуск индекс строки равно 0 \* 10 + 1 или 1; для второй страницы (с индексом 1) запустите индекс равен 1 \* 10 + 1 , или 11.</span><span class="sxs-lookup"><span data-stu-id="08671-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="08671-129">**Максимальное число строк** максимальное число записей, отображаемых на каждой странице.</span><span class="sxs-lookup"><span data-stu-id="08671-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="08671-130">Эта переменная называется максимальное число строк с момента последнего страницы может быть меньше записей, возвращаемых размер страницы.</span><span class="sxs-lookup"><span data-stu-id="08671-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="08671-131">Например разбиение по страницам по записям продуктов 81 10 на каждой странице, девятый и последней странице после только одна запись.</span><span class="sxs-lookup"><span data-stu-id="08671-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="08671-132">Страница не менее, покажет записей больше, чем значение максимального количества строк.</span><span class="sxs-lookup"><span data-stu-id="08671-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="08671-133">**Общее число записей** общее число страниц.</span><span class="sxs-lookup"><span data-stu-id="08671-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="08671-134">Во время этой переменной является t, необходимых для определения записи, которые необходимо получить для данной страницы, могут предписывать интерфейс разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="08671-135">Например при наличии списка из 81 продукта через интерфейс разбиения по страницам знает, для отображения номеров девять страниц в Интерфейсе постраничного просмотра.</span><span class="sxs-lookup"><span data-stu-id="08671-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="08671-136">С разбиением на страницы по умолчанию, запустите индекс строки вычисляется как произведение индекса страницы и размера страницы, плюс один, а максимальное число строк — просто размер страницы.</span><span class="sxs-lookup"><span data-stu-id="08671-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="08671-137">Поскольку разбиение на страницы по умолчанию получает все записи из базы данных при подготовке к просмотру на любой странице данных индекса для каждой строки известен, переход к строке начального индекса строки непростая задача.</span><span class="sxs-lookup"><span data-stu-id="08671-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="08671-138">Кроме того, доступны как общего числа записей s просто число записей в DataTable (или любой объект используется для хранения результатов базы данных).</span><span class="sxs-lookup"><span data-stu-id="08671-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="08671-139">Имея переменные начальный индекс строки и максимальное число строк, пользовательская реализация разбиения на страницы должны возвращать только нужного подмножества записей, начиная с запуска индекс строки и максимальное число строк, число записей после этого.</span><span class="sxs-lookup"><span data-stu-id="08671-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="08671-140">Пользовательское разбиение по страницам предоставляет две проблемы:</span><span class="sxs-lookup"><span data-stu-id="08671-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="08671-141">Нам необходимо найти эффективный способ связывания индекса строки с каждой строкой в всего набора, чтобы мы могли начать получать данные с указанного начального индекса строки данных</span><span class="sxs-lookup"><span data-stu-id="08671-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="08671-142">Требуется предоставить общее количество страниц</span><span class="sxs-lookup"><span data-stu-id="08671-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="08671-143">В следующих двух шагах мы изучим сценарий SQL, необходимые для ответа на эти две задачи.</span><span class="sxs-lookup"><span data-stu-id="08671-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="08671-144">Помимо скрипт SQL нам также нужно будет реализовать методы DAL и уровень бизнес-ЛОГИКИ.</span><span class="sxs-lookup"><span data-stu-id="08671-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="08671-145">Шаг 2: Возвращается общее количество страниц</span><span class="sxs-lookup"><span data-stu-id="08671-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="08671-146">Прежде чем мы рассмотрим, как для получения нужного подмножества записей для отображаемой страницы, позволяют s сначала посмотрим, как вернуть общее число страниц.</span><span class="sxs-lookup"><span data-stu-id="08671-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="08671-147">Эти сведения необходимы для правильной настройки пользовательского интерфейса постраничного просмотра.</span><span class="sxs-lookup"><span data-stu-id="08671-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="08671-148">Общее число записей, возвращаемых в результате запроса SQL могут быть получены с помощью [ `COUNT` агрегатной функции](https://msdn.microsoft.com/library/ms175997.aspx).</span><span class="sxs-lookup"><span data-stu-id="08671-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="08671-149">Например, чтобы определить общее число записей в `Products` таблице, можно использовать следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="08671-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="08671-150">Позволяет добавить метод DAL, представленной s.</span><span class="sxs-lookup"><span data-stu-id="08671-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="08671-151">В частности, мы создадим метод DAL с именем `TotalNumberOfProducts()` , выполняющего `SELECT` инструкции, описанной выше.</span><span class="sxs-lookup"><span data-stu-id="08671-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="08671-152">Сначала откройте `Northwind.xsd` файл типизированного набора данных в `App_Code/DAL` папки.</span><span class="sxs-lookup"><span data-stu-id="08671-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="08671-153">После этого щелкните правой кнопкой мыши `ProductsTableAdapter` в конструкторе и выберите Добавить запрос.</span><span class="sxs-lookup"><span data-stu-id="08671-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="08671-154">Как мы хранить в предыдущих занятий, это позволит нам для добавления нового метода DAL, при вызове будет выполняться на определенной инструкции SQL или хранимую процедуру.</span><span class="sxs-lookup"><span data-stu-id="08671-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="08671-155">С помощью метода TableAdapter в предыдущих учебниках, для этого класса, необязательно использовать нерегламентированные инструкции SQL.</span><span class="sxs-lookup"><span data-stu-id="08671-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![Использование инструкции SQL Ad-Hoc](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="08671-157">**Рис. 1**: использовать инструкцию SQL Ad-Hoc</span><span class="sxs-lookup"><span data-stu-id="08671-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="08671-158">На следующем экране можно указать тип создаваемого запроса.</span><span class="sxs-lookup"><span data-stu-id="08671-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="08671-159">Так как этот запрос будет возвращать одно скалярное значение общее количество записей в `Products` таблицы выберите `SELECT` возвращающий одной значение параметра.</span><span class="sxs-lookup"><span data-stu-id="08671-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![Настроить запрос для использования в инструкции SELECT, возвращающей одиночное значение](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="08671-161">**На рисунке 2**: настроить запрос для использования в инструкции SELECT, возвращающей одиночное значение</span><span class="sxs-lookup"><span data-stu-id="08671-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="08671-162">После выбора типа запроса, нужно ввести запрос.</span><span class="sxs-lookup"><span data-stu-id="08671-162">After indicating the type of query to use, we must next specify the query.</span></span>


![Использование SELECT COUNT(\*) из запроса продуктов](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="08671-164">**Рис. 3**: ВЫБЕРИТЕ СЧЕТЧИК использования (\*) FROM запроса продуктов</span><span class="sxs-lookup"><span data-stu-id="08671-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="08671-165">Наконец укажите имя для метода.</span><span class="sxs-lookup"><span data-stu-id="08671-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="08671-166">В качестве s упомянутой выше, позволяют использовать `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="08671-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![Имя метода DAL TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="08671-168">**Рис. 4**: имя метода DAL TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="08671-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="08671-169">После нажатия кнопки Готово, мастер добавит `TotalNumberOfProducts` метод DAL.</span><span class="sxs-lookup"><span data-stu-id="08671-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="08671-170">Скалярные возвращение в DAL возвращают типы, допускающие значение NULL, в случае, если в результате запроса SQL `NULL`.</span><span class="sxs-lookup"><span data-stu-id="08671-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="08671-171">Наш `COUNT` запрос, однако всегда будет возвращать значение, отличное от`NULL` значением; в любом случае, метод DAL возвращает неотрицательного целого.</span><span class="sxs-lookup"><span data-stu-id="08671-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="08671-172">Метод DAL мы также должны только метод в МЕТОДА.</span><span class="sxs-lookup"><span data-stu-id="08671-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="08671-173">Откройте `ProductsBLL` и добавьте `TotalNumberOfProducts` метод, который просто вызывает DAL s `TotalNumberOfProducts` метод:</span><span class="sxs-lookup"><span data-stu-id="08671-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="08671-174">DAL s `TotalNumberOfProducts` метод возвращает целое число, допускающие значение NULL, однако мы хранить созданные `ProductsBLL` класса s `TotalNumberOfProducts` метод, возвращающий обычное целочисленное значение.</span><span class="sxs-lookup"><span data-stu-id="08671-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="08671-175">Следовательно, необходимо иметь `ProductsBLL` класса s `TotalNumberOfProducts` метод возвращает значение в значение NULL целое число, возвращенное DAL s `TotalNumberOfProducts` метод.</span><span class="sxs-lookup"><span data-stu-id="08671-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="08671-176">Вызов `GetValueOrDefault()` возвращает значение обнуляемого целого, если он существует; Если неотрицательного целого `null`, тем не менее, он возвращает целочисленное значение по умолчанию — 0.</span><span class="sxs-lookup"><span data-stu-id="08671-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="08671-177">Шаг 3: Возврат точного подмножества записей</span><span class="sxs-lookup"><span data-stu-id="08671-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="08671-178">Теперь нам является создание методов DAL и уровень бизнес-ЛОГИКИ, принимающих строки начального индекса и максимальное количество строк в переменные уже было сказано ранее и возвращает соответствующие записи.</span><span class="sxs-lookup"><span data-stu-id="08671-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="08671-179">Перед этим, позволяют s сначала рассмотрим сценарий SQL.</span><span class="sxs-lookup"><span data-stu-id="08671-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="08671-180">Проблемой нам: мы должно иметь возможность присвоения индекса для каждой строки в результатах всего страниц, чтобы получить только те записи, начиная с запуска индекс строки (и максимальное число записей, число записей).</span><span class="sxs-lookup"><span data-stu-id="08671-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="08671-181">Это не запрос, если уже существует столбец в таблице базы данных, который служит в качестве индекса строки.</span><span class="sxs-lookup"><span data-stu-id="08671-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="08671-182">На первый взгляд может показаться `Products` таблицу s `ProductID` поле было бы достаточно как первый продукт был `ProductID` 1, второго — 2 и т. д.</span><span class="sxs-lookup"><span data-stu-id="08671-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="08671-183">Тем не менее удаление продукта оставляет промежуток в последовательности, отменив все этот подход.</span><span class="sxs-lookup"><span data-stu-id="08671-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="08671-184">Существует два общих способа эффективный способ связывания индекса строки с данными для постраничного просмотра, позволяя нужного подмножества записей, которые требуется получить.</span><span class="sxs-lookup"><span data-stu-id="08671-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="08671-185">**С помощью SQL Server 2005 s `ROW_NUMBER()` ключевое слово** опыта работы с SQL Server 2005 `ROW_NUMBER()` ключевое слово ранг связывается с каждой возвращенной записи в определенном порядке.</span><span class="sxs-lookup"><span data-stu-id="08671-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="08671-186">Присвоенные номера можно использовать в качестве индексов для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="08671-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="08671-187">**С помощью табличную переменную и `SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT` инструкции](https://msdn.microsoft.com/library/ms188774.aspx) может использоваться для указания запроса должны быть обработаны; количество записей [табличных переменных](http://www.sqlteam.com/item.asp?ItemID=9454) являются локальными переменными T-SQL, которые могут содержать табличные данные для [временные таблицы](http://www.sqlteam.com/item.asp?ItemID=2029).</span><span class="sxs-lookup"><span data-stu-id="08671-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="08671-188">Такой подход работает одинаково хорошо с Microsoft SQL Server 2005 и SQL Server 2000 (в то время как `ROW_NUMBER()` подход работает только с SQL Server 2005).</span><span class="sxs-lookup"><span data-stu-id="08671-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="08671-189">В данном случае для создания переменной таблицы, которая имеет `IDENTITY` и столбцами для первичных ключей таблицы, данные которых оповещается через.</span><span class="sxs-lookup"><span data-stu-id="08671-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="08671-190">Затем содержимое таблицы, данные которого оповещается через выводится в табличную переменную, присвоив индекс последовательные строки (через `IDENTITY` столбец) для каждой записи в таблице.</span><span class="sxs-lookup"><span data-stu-id="08671-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="08671-191">После заполнения табличной переменной `SELECT` оператором в табличную переменную, соединить с базовой таблицей, могут быть выполнены для отделения определенных записей.</span><span class="sxs-lookup"><span data-stu-id="08671-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="08671-192">`SET ROWCOUNT` Оператор используется для ограничения числа записей, которые должны быть помещены в дамп в табличную переменную.</span><span class="sxs-lookup"><span data-stu-id="08671-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="08671-193">Этот подход s эффективности основан на запрашиваемый номер страницы как `SET ROWCOUNT` присваивается значение начального индекса строки, а также максимальное число строк.</span><span class="sxs-lookup"><span data-stu-id="08671-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="08671-194">При работе с небольшими номерами страниц, например первый несколько страниц данных оказывается очень эффективно.</span><span class="sxs-lookup"><span data-stu-id="08671-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="08671-195">Тем не менее он демонстрирует разбиение по страницам сходной производительности по умолчанию при извлечении страницы перед завершением.</span><span class="sxs-lookup"><span data-stu-id="08671-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="08671-196">В этом руководстве реализуется с помощью пользовательского разбиения на страницы `ROW_NUMBER()` ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="08671-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="08671-197">Дополнительные сведения об использовании табличной переменной и `SET ROWCOUNT` методика, в разделе [более эффективным методом для разбиения на страницы через больших результирующих наборов](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="08671-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="08671-198">`ROW_NUMBER()` Ключевое слово ранг связанные с каждой записи возвращаются на номер, используя следующий синтаксис:</span><span class="sxs-lookup"><span data-stu-id="08671-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="08671-199">`ROW_NUMBER()` Возвращает числовое значение, указывающее ранг для каждой записи в соответствии с указанным порядком.</span><span class="sxs-lookup"><span data-stu-id="08671-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="08671-200">Например чтобы узнать номер для каждого продукта, начиная от наиболее ресурсоемких к меньшему, можно использовать следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="08671-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="08671-201">Рис. 5 показан этот запрос s результаты при его выполнении в окно запроса в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="08671-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="08671-202">Обратите внимание, что продукты упорядочены по цене, а также ранг цены для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="08671-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![Ранг цена входит в состав каждой записи возвращаются](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="08671-204">**Рис. 5**: содержится ранг цены для каждой записи возвращаются</span><span class="sxs-lookup"><span data-stu-id="08671-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="08671-205">`ROW_NUMBER()` только один из многих новых функций ранжирования доступна в SQL Server 2005.</span><span class="sxs-lookup"><span data-stu-id="08671-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="08671-206">Для более подробное описание того, `ROW_NUMBER()`, вместе с Ранжирующие функции чтения [возврат ранжированные результаты с Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="08671-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="08671-207">При ранжировании результатов по заданному `ORDER BY` столбца в `OVER` предложение (`UnitPrice`, в приведенном выше примере), SQL Server нужно отсортировать результаты.</span><span class="sxs-lookup"><span data-stu-id="08671-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="08671-208">Эта операция выполняется очень быстро, если имеется кластеризованный индекс для соответствующих столбцов, результаты упорядочиваются по, или при наличии покрытия индекса, но может быть более высокие цены, в противном случае.</span><span class="sxs-lookup"><span data-stu-id="08671-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="08671-209">Чтобы повысить производительность запросов, достаточно большой, рассмотрите возможность добавления некластеризованный индекс для столбца, по которому упорядочиваются результаты по.</span><span class="sxs-lookup"><span data-stu-id="08671-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="08671-210">В разделе [Ранжирующие функции и производительности в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) для просмотра более подробные сведения о производительности.</span><span class="sxs-lookup"><span data-stu-id="08671-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="08671-211">Возвращаемые сведения о рангах `ROW_NUMBER()` не может использоваться непосредственно в `WHERE` предложения.</span><span class="sxs-lookup"><span data-stu-id="08671-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="08671-212">Тем не менее, можно использовать производную таблицу для возвращения `ROW_NUMBER()` результат, который затем может использоваться в `WHERE` предложения.</span><span class="sxs-lookup"><span data-stu-id="08671-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="08671-213">Например, следующий запрос использует производную таблицу для возврата столбцов ProductName и UnitPrice вместе с `ROW_NUMBER()` результат, а затем используется `WHERE` предложений, чтобы только для возврата продуктов, ранг которого цены — от 11 до 20:</span><span class="sxs-lookup"><span data-stu-id="08671-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="08671-214">Расширение эту концепцию еще, могут использовать этот подход, чтобы получить страницу данных для заданных нужные значения начального строки индекса и максимальное число строк:</span><span class="sxs-lookup"><span data-stu-id="08671-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="08671-215">Как мы увидим далее в этом учебнике *`StartRowIndex`* предоставляемые ObjectDataSource индексируется начиная с нуля, тогда как `ROW_NUMBER()` значение, возвращаемое в SQL Server 2005, начинаются с 1.</span><span class="sxs-lookup"><span data-stu-id="08671-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="08671-216">Таким образом `WHERE` возвращает записи где `PriceRank` строго больше *`StartRowIndex`* и меньше или равно *`StartRowIndex`*  +  *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="08671-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="08671-217">Теперь, мы рассматриваются как хранить `ROW_NUMBER()` может быть используется для получения данных заданы значения начального строки индекса и максимальное число строк на одной странице, теперь необходимо реализовывать эту логику в виде методов DAL и уровень бизнес-ЛОГИКИ.</span><span class="sxs-lookup"><span data-stu-id="08671-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="08671-218">При создании этого запроса, нужно определить порядок, по которому результаты ранжируются; Разрешить s отсортировать продукты по их именам в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="08671-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="08671-219">Это означает, что собственную реализацию разбиения на страницы в этом учебнике мы не может создавать пользовательские разбитый на страницы отчет, не могут быть отсортированы.</span><span class="sxs-lookup"><span data-stu-id="08671-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="08671-220">В следующем уроке, мы рассмотрим как такие функциональные возможности могут быть предоставлены.</span><span class="sxs-lookup"><span data-stu-id="08671-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="08671-221">В предыдущем разделе мы создали метод DAL как нерегламентированные инструкции SQL.</span><span class="sxs-lookup"><span data-stu-id="08671-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="08671-222">К сожалению, синтаксического анализа T-SQL в Visual Studio, используемый t мастера TableAdapter как `OVER` используется синтаксис `ROW_NUMBER()` функции.</span><span class="sxs-lookup"><span data-stu-id="08671-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="08671-223">Таким образом необходимо создать этот метод DAL как хранимую процедуру.</span><span class="sxs-lookup"><span data-stu-id="08671-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="08671-224">Выберите из меню «Вид» (или нажмите сочетание клавиш Ctrl + Alt + S) в обозревателе сервера и разверните `NORTHWND.MDF` узла.</span><span class="sxs-lookup"><span data-stu-id="08671-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="08671-225">Чтобы добавить новую хранимую процедуру, правой кнопкой мыши узел хранимых процедур и выберите команду Добавить новую хранимую процедуру (см. рис. 6).</span><span class="sxs-lookup"><span data-stu-id="08671-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![Добавить новую хранимую процедуру для постраничный просмотр продуктов](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="08671-227">**Рис. 6**: добавить новую хранимую процедуру для постраничный просмотр продуктов</span><span class="sxs-lookup"><span data-stu-id="08671-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="08671-228">Эта хранимая процедура должна принять два целочисленных параметра - `@startRowIndex` и `@maximumRows` и использовать `ROW_NUMBER()` отсортированную по `ProductName` поля, возвращает только те строки, больше указанного `@startRowIndex` и меньше или равно `@startRowIndex`  +  `@maximumRow` s.</span><span class="sxs-lookup"><span data-stu-id="08671-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="08671-229">Введите следующий сценарий в новой хранимой процедуры и щелкните значок сохранения добавление хранимой процедуры в базе данных.</span><span class="sxs-lookup"><span data-stu-id="08671-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="08671-230">После создания хранимой процедуры занять некоторое время на ее тестирование. Щелкните правой кнопкой мыши `GetProductsPaged` хранимой процедуры имя в обозревателе серверов и выберите параметр Execute.</span><span class="sxs-lookup"><span data-stu-id="08671-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="08671-231">Visual Studio появится приглашение для ввода параметров `@startRowIndex` и `@maximumRow` s (см. рис. 7).</span><span class="sxs-lookup"><span data-stu-id="08671-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="08671-232">Попробуйте различные значения и изучите его результаты.</span><span class="sxs-lookup"><span data-stu-id="08671-232">Try different values and examine the results.</span></span>


![Введите значение для @startRowIndex и @maximumRows параметров](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="08671-234"><strong>Рис. 7</strong>: Введите значение для @startRowIndex и @maximumRows параметров</span><span class="sxs-lookup"><span data-stu-id="08671-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="08671-235">После выбора этих входных значений параметров, в окне вывода отображаются результаты.</span><span class="sxs-lookup"><span data-stu-id="08671-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="08671-236">На рисунке 8 показаны результаты при передаче в 10 для обоих `@startRowIndex` и `@maximumRows` параметров.</span><span class="sxs-lookup"><span data-stu-id="08671-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="08671-237">[![Возвращаются записи, будет выглядеть в второй страницы данных](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="08671-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="08671-238">**Рис. 8**: записи, будет выглядеть в второй страницы данных возвращаются ([Просмотр полноразмерное изображение](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="08671-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>


<span data-ttu-id="08671-239">С этим хранимая процедура, созданная, и мы готов для создания `ProductsTableAdapter` метод.</span><span class="sxs-lookup"><span data-stu-id="08671-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="08671-240">Откройте `Northwind.xsd` типизированного набора данных, щелкните правой кнопкой мыши в `ProductsTableAdapter`и выберите пункт Добавить запрос.</span><span class="sxs-lookup"><span data-stu-id="08671-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="08671-241">Вместо создания запроса с помощью инструкции SQL ad-hoc, создаете его с помощью существующей хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="08671-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![Создание метода DAL с использованием существующей хранимой процедуры](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="08671-243">**Рис. 9**: Создание метода DAL с использованием существующей хранимой процедуры</span><span class="sxs-lookup"><span data-stu-id="08671-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="08671-244">Далее мы предлагается выбрать хранимую процедуру для вызова.</span><span class="sxs-lookup"><span data-stu-id="08671-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="08671-245">Выбрать `GetProductsPaged` хранимую процедуру из раскрывающегося списка.</span><span class="sxs-lookup"><span data-stu-id="08671-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![Выберите GetProductsPaged хранимую процедуру из раскрывающегося списка](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="08671-247">**Рис. 10**: GetProductsPaged выберите хранимую процедуру из раскрывающегося списка</span><span class="sxs-lookup"><span data-stu-id="08671-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="08671-248">Далее экране необходимо какого рода данные возвращается хранимой процедурой: табличные данные, одно значение или значение отсутствует.</span><span class="sxs-lookup"><span data-stu-id="08671-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="08671-249">Поскольку `GetProductsPaged` хранимая процедура может возвращать несколько записей, указывают, что он возвращает табличные данные.</span><span class="sxs-lookup"><span data-stu-id="08671-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![Указывает, что хранимая процедура возвращает табличные данные](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="08671-251">**Рис. 11**: Указывает, что хранимая процедура возвращает табличные данные</span><span class="sxs-lookup"><span data-stu-id="08671-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="08671-252">И наконец укажите имена методов, которые вы хотите создать.</span><span class="sxs-lookup"><span data-stu-id="08671-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="08671-253">Как и в предыдущих учебных, загрузив и методы, с помощью обоих заливки объект DataTable и вернуть таблицу данных.</span><span class="sxs-lookup"><span data-stu-id="08671-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="08671-254">Имя первого метода `FillPaged` , а второй — `GetProductsPaged`.</span><span class="sxs-lookup"><span data-stu-id="08671-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![Имя методы FillPaged и GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="08671-256">**Рис. 12**: имя методы FillPaged и GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="08671-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="08671-257">Кроме создать метод DAL для возврата определенной страницы продуктов, также необходимо предоставить такую же функцию МЕТОДА.</span><span class="sxs-lookup"><span data-stu-id="08671-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="08671-258">Как и метод DAL уровень бизнес-ЛОГИКИ s GetProductsPaged метод должен принимать два входных значения целое число для указания начального индекса строки и максимальное число строк и должен возвращать только те записи, которые попадают в указанный диапазон.</span><span class="sxs-lookup"><span data-stu-id="08671-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="08671-259">Создайте метод уровень бизнес-ЛОГИКИ в классе ProductsBLL, что просто вызывает метод вниз в s DAL метод GetProductsPaged следующим образом:</span><span class="sxs-lookup"><span data-stu-id="08671-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="08671-260">Можно использовать любое имя для входных параметров метода s уровень бизнес-ЛОГИКИ, но, как мы увидим, решили использовать `startRowIndex` и `maximumRows` избавляет от лишнего время при настройке ObjectDataSource для использования этого метода.</span><span class="sxs-lookup"><span data-stu-id="08671-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="08671-261">Шаг 4: Настройка ObjectDataSource пользовательское разбиение по страницам</span><span class="sxs-lookup"><span data-stu-id="08671-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="08671-262">С помощью методов уровень бизнес-ЛОГИКИ и DAL для доступа к определенного подмножества данных мы готов для создания элемента управления GridView управлять этой страницы через его базовой записи, используя пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="08671-263">Сначала откройте `EfficientPaging.aspx` страницы в `PagingAndSorting` папке, добавьте на страницу элемент управления GridView и настройте его для использования нового элемента управления ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="08671-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="08671-264">В предыдущих курсах мы часто настраивали ObjectDataSource настроен на использование `ProductsBLL` класса s `GetProducts` метод.</span><span class="sxs-lookup"><span data-stu-id="08671-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="08671-265">Это время, однако мы будем использовать `GetProductsPaged` метод вместо этого после `GetProducts` возвращает *все* продуктов в базе данных в то время как `GetProductsPaged` возвращает определенного подмножества записей.</span><span class="sxs-lookup"><span data-stu-id="08671-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![Настройка ObjectDataSource можно использовать метод GetProductsPaged класса ProductsBLL s](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="08671-267">**Рис. 13**: Настройка ObjectDataSource можно использовать метод GetProductsPaged класса ProductsBLL s</span><span class="sxs-lookup"><span data-stu-id="08671-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="08671-268">Начиная с мы re Создание элемента управления GridView только для чтения пора установить метод раскрывающегося списка в инструкции INSERT, UPDATE и удаление вкладок (нет).</span><span class="sxs-lookup"><span data-stu-id="08671-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="08671-269">После этого мастер ObjectDataSource запрашивает источники `GetProductsPaged` метод s `startRowIndex` и `maximumRows` входных значений параметров.</span><span class="sxs-lookup"><span data-stu-id="08671-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="08671-270">Эти параметры фактически задается GridView автоматически, просто оставьте набор источника нет и нажмите "Готово".</span><span class="sxs-lookup"><span data-stu-id="08671-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![Оставьте источники ни один входной параметр](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="08671-272">**Рис. 14**: оставьте источники ни один входной параметр</span><span class="sxs-lookup"><span data-stu-id="08671-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="08671-273">После завершения работы мастера ObjectDataSource GridView будет содержать BoundField или CheckBoxField для каждого из полей данных продукта.</span><span class="sxs-lookup"><span data-stu-id="08671-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="08671-274">Вы можете настроить внешний вид s GridView по своему усмотрению.</span><span class="sxs-lookup"><span data-stu-id="08671-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="08671-275">Я решил отобразить только хранить `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, и `UnitPrice` стояли.</span><span class="sxs-lookup"><span data-stu-id="08671-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="08671-276">Кроме того настройте GridView для поддержки разбиения на страницы, установив флажок включения постраничного просмотра в смарт-тег.</span><span class="sxs-lookup"><span data-stu-id="08671-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="08671-277">После внесения этих изменений GridView и ObjectDataSource должна выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="08671-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="08671-278">При посещении страницы через браузер GridView то, где не требуется найти.</span><span class="sxs-lookup"><span data-stu-id="08671-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![GridView является не отображается](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="08671-280">**Рис. 15**: GridView является не отображается</span><span class="sxs-lookup"><span data-stu-id="08671-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="08671-281">GridView отсутствует, так как элемент управления ObjectDataSource используется 0 в качестве значения для обоих `GetProductsPaged` `startRowIndex` и `maximumRows` входные параметры.</span><span class="sxs-lookup"><span data-stu-id="08671-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="08671-282">Таким образом результирующий запрос SQL не возвращает ни одной записи, и поэтому GridView не отображается.</span><span class="sxs-lookup"><span data-stu-id="08671-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="08671-283">Чтобы исправить это, необходимо настроить элемент управления ObjectDataSource пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="08671-284">Это можно сделать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="08671-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="08671-285">**Набор ObjectDataSource s `EnablePaging` свойства `true`**  это значит, что ObjectDataSource, который необходимо передать `SelectMethod` два дополнительных параметра: один для указания начального индекса строки ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) и для указания максимального числа строк ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span><span class="sxs-lookup"><span data-stu-id="08671-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="08671-286">**Набор ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом** `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства указывают имена параметров, передаваемых в `SelectMethod` для пользовательского разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="08671-287">По умолчанию эти параметры имеют имена `startIndexRow` и `maximumRows`, являющееся, почему это происходит при создании `GetProductsPaged` метод в уровень бизнес-ЛОГИКИ, мы использовали такие значения входных параметров.</span><span class="sxs-lookup"><span data-stu-id="08671-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="08671-288">Если вы решили использовать разные имена параметров для МЕТОДА s `GetProductsPaged` метода, такие как `startIndex` и `maxRows`для примера, потребуется задать ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом (например, startIndex для `StartRowIndexParameterName` и maxRows для `MaximumRowsParameterName`).</span><span class="sxs-lookup"><span data-stu-id="08671-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="08671-289">**Набор ObjectDataSource s [ `SelectCountMethod` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) к имени метода, который возвращает общее число из записей выполняется в выгружаемом страничном через (`TotalNumberOfProducts`)** помните, что `ProductsBLL` класса s `TotalNumberOfProducts`метод возвращает общее число страниц с помощью метода DAL, который выполняет `SELECT COUNT(*) FROM Products` запроса.</span><span class="sxs-lookup"><span data-stu-id="08671-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="08671-290">Эти сведения необходимы ObjectDataSource для правильно отображения интерфейса постраничного просмотра.</span><span class="sxs-lookup"><span data-stu-id="08671-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="08671-291">**Удалить `startRowIndex` и `maximumRows` `<asp:Parameter>` элементы из s ObjectDataSource декларативная разметка** при настройке ObjectDataSource в мастере, Visual Studio автоматически добавляет два `<asp:Parameter>` элементов для `GetProductsPaged` метод s входных параметров.</span><span class="sxs-lookup"><span data-stu-id="08671-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="08671-292">Установив `EnablePaging` для `true`, эти параметры будут автоматически передаваться; если они также отображаются в декларативный синтаксис ObjectDataSource попытается передать *четыре* параметры `GetProductsPaged` метод и два параметра `TotalNumberOfProducts` метод.</span><span class="sxs-lookup"><span data-stu-id="08671-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="08671-293">Если вы забудете эти элементы `<asp:Parameter>` элементов при посещении страницы через браузер, вы получите сообщение об ошибке, например: *ObjectDataSource 'ObjectDataSource1» не удалось найти не групповой метод «TotalNumberOfProducts», который имеет параметры: startRowIndex, maximumRows*.</span><span class="sxs-lookup"><span data-stu-id="08671-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="08671-294">После внесения этих изменений, ObjectDataSource s должен выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="08671-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="08671-295">Обратите внимание, что `EnablePaging` и `SelectCountMethod` заданы свойства и `<asp:Parameter>` элементы будут удалены.</span><span class="sxs-lookup"><span data-stu-id="08671-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="08671-296">На рисунке 16 показано снимок экрана окна свойств после внесения этих изменений.</span><span class="sxs-lookup"><span data-stu-id="08671-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![Чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="08671-298">**На рисунке 16**: чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="08671-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="08671-299">После внесения этих изменений, посетите эту страницу через браузер.</span><span class="sxs-lookup"><span data-stu-id="08671-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="08671-300">Должно появиться в списке, 10 продуктов в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="08671-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="08671-301">Теперь пора пошаговый данных на одной странице за раз.</span><span class="sxs-lookup"><span data-stu-id="08671-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="08671-302">Хотя нет отличия с точки зрения конечного пользователя s по умолчанию и пользовательские разбиение по страницам, более эффективно пользовательское разбиение по страницам больших объемов данных как извлекает только те записи, которые должны отображаться для данной страницы.</span><span class="sxs-lookup"><span data-stu-id="08671-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="08671-303">[![Данные, упорядоченный по продукту s имени, является разбиением на страницы с помощью пользовательского разбиения на страницы](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="08671-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="08671-304">**Рисунок 17**: Data, упорядоченный по продукту s имени, является разбиением на страницы с помощью пользовательского разбиения на страницы ([Просмотр полноразмерное изображение](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="08671-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="08671-305">С пользовательское разбиение по страницам, значение, возвращаемое ObjectDataSource s количество страниц `SelectCountMethod` хранится в состоянии просмотра s GridView.</span><span class="sxs-lookup"><span data-stu-id="08671-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="08671-306">Другие переменные GridView `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` коллекции и т. д, хранятся в *управления состоянием*, которое сохраняется независимо от значения GridView s `EnableViewState` свойство.</span><span class="sxs-lookup"><span data-stu-id="08671-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="08671-307">Поскольку `PageCount` значение сохраняется во время обратной передачи, с помощью состояния представления, при использовании интерфейс постраничного просмотра, который содержит ссылку, чтобы перейти к последней странице, важно включить состояние просмотра s GridView.</span><span class="sxs-lookup"><span data-stu-id="08671-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="08671-308">(Если интерфейса постраничного просмотра не имеет прямой доступ к последней странице, вы можете отключить состояние представления).</span><span class="sxs-lookup"><span data-stu-id="08671-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="08671-309">Щелкнув ссылки на последнюю страницу вызывает обратную передачу и указывает, что для обновления GridView его `PageIndex` свойство.</span><span class="sxs-lookup"><span data-stu-id="08671-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="08671-310">При нажатии ссылки на последнюю страницу GridView назначает его `PageIndex` одно значение меньшее, чем `PageCount` свойство.</span><span class="sxs-lookup"><span data-stu-id="08671-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="08671-311">С состояние просмотра отключено `PageCount` теряется при обратной передаче и `PageIndex` вместо присваивается значение максимально допустимого целого числа.</span><span class="sxs-lookup"><span data-stu-id="08671-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="08671-312">Далее GridView пытается определить начальный индекс строки, умножая `PageSize` и `PageCount` свойства.</span><span class="sxs-lookup"><span data-stu-id="08671-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="08671-313">В результате `OverflowException` с момента продукта превышает размер целочисленное значение максимально допустимого.</span><span class="sxs-lookup"><span data-stu-id="08671-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="08671-314">Реализуйте пользовательское разбиение по страницам и сортировка</span><span class="sxs-lookup"><span data-stu-id="08671-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="08671-315">Реализацию текущего пользовательского разбиения на страницы требуется заказа, по которому страницам данных указать статически при создании `GetProductsPaged` хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="08671-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="08671-316">Тем не менее могут записанные, смарт-тег GridView s содержит флажок Включить сортировку, помимо возможности включить разбиение на страницы.</span><span class="sxs-lookup"><span data-stu-id="08671-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="08671-317">К сожалению Добавление поддержки сортировки к GridView с реализацию текущего пользовательского разбиения на страницы приводит лишь к сортировке записей на текущую просматриваемую страницу данных.</span><span class="sxs-lookup"><span data-stu-id="08671-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="08671-318">Например при настройке GridView также поддерживают разбиение на страницы и затем, при просмотре данных, первая страница сортировки по названию продукта по убыванию, он будет обратный порядок продуктов на странице 1.</span><span class="sxs-lookup"><span data-stu-id="08671-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="08671-319">Как показано на рисунке 18, продукт Carnarvon Tigers стал первым продуктом при сортировке в обратном алфавитном порядке, который пропускает 71 другие продукты, полученные после Carnarvon Tigers в алфавитном порядке; в сортировке, считаются только те записи, на первой странице.</span><span class="sxs-lookup"><span data-stu-id="08671-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="08671-320">[![Сортируются только данные отображаются на текущей странице](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="08671-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="08671-321">**На рисунке 18**: сортируется только данные отображаются на текущей странице ([Просмотр полноразмерное изображение](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="08671-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>


<span data-ttu-id="08671-322">Сортировка применяется только к текущей странице данных так, как сортировка происходит после получения данных из МЕТОДА s `GetProductsPaged` метод и этот метод возвращает только записи одной страницы.</span><span class="sxs-lookup"><span data-stu-id="08671-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="08671-323">Для правильной сортировки необходимо передать выражение сортировки для `GetProductsPaged` метод, чтобы упорядочить данные перед возвратом к заданной странице данных.</span><span class="sxs-lookup"><span data-stu-id="08671-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="08671-324">Мы рассмотрим, как это сделать в нашем следующем уроке.</span><span class="sxs-lookup"><span data-stu-id="08671-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="08671-325">Реализация пользовательского разбиения на страницы и удаление</span><span class="sxs-lookup"><span data-stu-id="08671-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="08671-326">Если вы включить функцию удаления в элементе управления GridView, данные которых отображаются с помощью настраиваемых способов разбиения на страницы, можно найти, при удалении последней записи с последней страницы GridView исчезает вместо того чтобы надлежащим образом уменьшить GridView s `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="08671-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="08671-327">Чтобы воспроизвести эту ситуацию, включите поддержку удаления учебника, который только что мы только что создали.</span><span class="sxs-lookup"><span data-stu-id="08671-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="08671-328">Перейдите на последней странице (страница 9), где должно появиться один продукт, так как мы постраничного просмотра 81 продуктов, 10 продуктов за раз.</span><span class="sxs-lookup"><span data-stu-id="08671-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="08671-329">Удалите этот продукт.</span><span class="sxs-lookup"><span data-stu-id="08671-329">Delete this product.</span></span>

<span data-ttu-id="08671-330">После удаления последнего продукта GridView *следует* автоматический переход на страницу восьмой и этот механизм корректно работает с разбиением на страницы по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="08671-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="08671-331">С пользовательское разбиение по страницам, однако после удаления последнего продукта на последней странице GridView просто исчезнет из экрана вообще.</span><span class="sxs-lookup"><span data-stu-id="08671-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="08671-332">Точная Причина *почему* это происходит, немного выходит за рамки данного руководства, в разделе [Удаление последней записи на последней странице из GridView с подкачкой страниц, пользовательские](http://scottonwriting.net/sowblog/posts/7326.aspx) низкоуровневые сведения относительно источника эту проблему.</span><span class="sxs-lookup"><span data-stu-id="08671-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="08671-333">В итоге он s связи следующую последовательность шагов, выполняемых в GridView, когда нажата кнопка "Удалить":</span><span class="sxs-lookup"><span data-stu-id="08671-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="08671-334">Удалить запись</span><span class="sxs-lookup"><span data-stu-id="08671-334">Delete the record</span></span>
2. <span data-ttu-id="08671-335">Получение записей для отображения для указанного `PageIndex` и `PageSize`</span><span class="sxs-lookup"><span data-stu-id="08671-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="08671-336">Убедитесь, что `PageIndex` не превышает количество страниц данных в источнике данных; если он автоматически уменьшения GridView s `PageIndex` свойство</span><span class="sxs-lookup"><span data-stu-id="08671-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="08671-337">Связывание соответствующей страницы данных к GridView с использованием записей, полученный на шаге 2</span><span class="sxs-lookup"><span data-stu-id="08671-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="08671-338">Проблема состоит в том что `PageIndex` использовавшейся перехватывая записей для отображения по-прежнему `PageIndex` последней страницы, последняя запись была удалена.</span><span class="sxs-lookup"><span data-stu-id="08671-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="08671-339">Таким образом, в шаге 2 *не* записи с момента последней страницы данных больше не содержит ни одной записи.</span><span class="sxs-lookup"><span data-stu-id="08671-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="08671-340">Затем, в шаге 3 GridView осознает, что его `PageIndex` больше, чем общее число страниц в источнике данных (с момента мы хранять удаляются последней записи на последней странице) и поэтому уменьшает его `PageIndex` свойство.</span><span class="sxs-lookup"><span data-stu-id="08671-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="08671-341">На шаге 4 GridView пытается выполнить привязку к данным, полученным на шаге 2; Тем не менее на шаге 2, не возвращено ни одной записи, поэтому в результате чего пустой GridView.</span><span class="sxs-lookup"><span data-stu-id="08671-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="08671-342">С разбиением на страницы по умолчанию, контактной t проблема, так как на шаге 2 *все* записи получены из источника данных.</span><span class="sxs-lookup"><span data-stu-id="08671-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="08671-343">Для устранения этой проблемы существует два способа.</span><span class="sxs-lookup"><span data-stu-id="08671-343">To fix this we have two options.</span></span> <span data-ttu-id="08671-344">Первым шагом является создание обработчика событий для GridView s `RowDeleted` обработчика событий, который определяет, сколько записей, отображаемых на странице, которая была удалена.</span><span class="sxs-lookup"><span data-stu-id="08671-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="08671-345">Если была только одна запись, а затем эта запись должна была быть последним, и нам необходимо уменьшения GridView s `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="08671-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="08671-346">Конечно, нам нужен только для обновления `PageIndex` Если операция удаления была выполнена успешно, которое можно получить, гарантируя, что `e.Exception` свойство `null`.</span><span class="sxs-lookup"><span data-stu-id="08671-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="08671-347">Такой подход работает, так как он обновляет `PageIndex` после шага 1, но до шага 2.</span><span class="sxs-lookup"><span data-stu-id="08671-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="08671-348">Таким образом в шаге 2, возвращается правильный набор записей.</span><span class="sxs-lookup"><span data-stu-id="08671-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="08671-349">Чтобы сделать это, используйте код, аналогичный следующему:</span><span class="sxs-lookup"><span data-stu-id="08671-349">To accomplish this, use code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="08671-350">Второе решение — создать обработчик событий для ObjectDataSource s `RowDeleted` событий и задать `AffectedRows` свойства со значением 1.</span><span class="sxs-lookup"><span data-stu-id="08671-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="08671-351">После удаления записи на шаге 1 (но до получения данных в шаге 2), обновляет GridView его `PageIndex` свойства, если одну или несколько строк, затронутых операцией.</span><span class="sxs-lookup"><span data-stu-id="08671-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="08671-352">Однако `AffectedRows` свойство не задано, элемент управления ObjectDataSource и поэтому этот шаг пропускается.</span><span class="sxs-lookup"><span data-stu-id="08671-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="08671-353">Чтобы это действие было выполнено является установка вручную `AffectedRows` свойства, если операция удаления завершилась успешно.</span><span class="sxs-lookup"><span data-stu-id="08671-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="08671-354">Это можно сделать с помощью следующего кода:</span><span class="sxs-lookup"><span data-stu-id="08671-354">This can be accomplished using code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="08671-355">Код для обоих этих обработчиков событий можно найти в класс кода программной части `EfficientPaging.aspx` примере.</span><span class="sxs-lookup"><span data-stu-id="08671-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="08671-356">Сравнение производительности по умолчанию и пользовательское разбиение по страницам</span><span class="sxs-lookup"><span data-stu-id="08671-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="08671-357">Так как пользовательское разбиение по страницам извлекает только необходимые записи, тогда как разбиение на страницы по умолчанию возвращает *всех* записей для каждой страницы отображается, его s снимите, что пользовательское разбиение по страницам является более эффективным, чем разбиение на страницы по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="08671-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="08671-358">Точно так же, но насколько эффективнее пользовательское разбиение по страницам?</span><span class="sxs-lookup"><span data-stu-id="08671-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="08671-359">Какие виды выигрыш в производительности может видеть путем перемещения от одного вида разбиения в пользовательское разбиение по страницам?</span><span class="sxs-lookup"><span data-stu-id="08671-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="08671-360">К сожалению, s не один размер подходит для всех ответить здесь.</span><span class="sxs-lookup"><span data-stu-id="08671-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="08671-361">Рост производительности зависит от множества факторов, наиболее Показательным два число страниц и нагрузки размещается база данных сервера и обмена данными между веб-сервер и сервер базы данных каналов.</span><span class="sxs-lookup"><span data-stu-id="08671-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="08671-362">Для небольших таблиц, состоящих из нескольких десятков записей разница в производительности может оказаться незначительной.</span><span class="sxs-lookup"><span data-stu-id="08671-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="08671-363">Для больших таблиц с сотен и тысяч строк однако разница в производительности может стать существенной.</span><span class="sxs-lookup"><span data-stu-id="08671-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="08671-364">В моей, статье [пользовательского разбиения на страницы в ASP.NET 2.0 с SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), содержит некоторые тесты производительности, нужно ли устанавливать на борьбу различия в производительности между этих двух способов постраничного просмотра таблицы базы данных с 50 000 записей.</span><span class="sxs-lookup"><span data-stu-id="08671-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="08671-365">В этих тестах я проверить время выполнения запроса на уровне SQL Server (с помощью [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) и на странице ASP.NET с помощью [функции трассировки ASP.NET s](https://msdn.microsoft.com/library/y13fw6we.aspx).</span><span class="sxs-lookup"><span data-stu-id="08671-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="08671-366">Имейте в виду, что эти тесты выполнялись на моем рабочем компьютере с одним активным пользователем и таким образом научными и не имитировать шаблонов нагрузки для типичных веб-сайта.</span><span class="sxs-lookup"><span data-stu-id="08671-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="08671-367">Независимо от того результаты показывают относительные различия во времени выполнения для экземпляра по умолчанию и пользовательское разбиение по страницам при работе с достаточно большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="08671-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="08671-368">**Средн. Длительность (сек.)**</span><span class="sxs-lookup"><span data-stu-id="08671-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="08671-369">**Считывает**</span><span class="sxs-lookup"><span data-stu-id="08671-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="08671-370">**Приложение SQL Profiler разбиения на страницы по умолчанию**</span><span class="sxs-lookup"><span data-stu-id="08671-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="08671-371">1.411</span><span class="sxs-lookup"><span data-stu-id="08671-371">1.411</span></span> | <span data-ttu-id="08671-372">383</span><span class="sxs-lookup"><span data-stu-id="08671-372">383</span></span> |
| <span data-ttu-id="08671-373">**Пользовательские приложения SQL Profiler разбиения на страницы**</span><span class="sxs-lookup"><span data-stu-id="08671-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="08671-374">0.002</span><span class="sxs-lookup"><span data-stu-id="08671-374">0.002</span></span> | <span data-ttu-id="08671-375">29</span><span class="sxs-lookup"><span data-stu-id="08671-375">29</span></span> |
| <span data-ttu-id="08671-376">**Трассировка ASP.NET разбиение на страницы по умолчанию**</span><span class="sxs-lookup"><span data-stu-id="08671-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="08671-377">2.379</span><span class="sxs-lookup"><span data-stu-id="08671-377">2.379</span></span> | <span data-ttu-id="08671-378">*N/A*</span><span class="sxs-lookup"><span data-stu-id="08671-378">*N/A*</span></span> |
| <span data-ttu-id="08671-379">**Пользовательские трассировку ASP.NET разбиения на страницы**</span><span class="sxs-lookup"><span data-stu-id="08671-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="08671-380">0.029</span><span class="sxs-lookup"><span data-stu-id="08671-380">0.029</span></span> | <span data-ttu-id="08671-381">*N/A*</span><span class="sxs-lookup"><span data-stu-id="08671-381">*N/A*</span></span> |


<span data-ttu-id="08671-382">Как видите, получения отдельной страницы данных в среднем требуется 354 меньше операций чтения и выполняемые в часть того времени.</span><span class="sxs-lookup"><span data-stu-id="08671-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="08671-383">На странице ASP.NET, пользовательские страницы был подготавливать к просмотру в близко к 1/100<sup>й</sup> времени, потребовавшегося при разбиении по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="08671-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="08671-384">В разделе [мою статью](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) Дополнительные сведения на основе этих результатов вместе с кодом и базы данных можно загрузить для воспроизведения этих тестов в собственной среде.</span><span class="sxs-lookup"><span data-stu-id="08671-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="08671-385">Сводка</span><span class="sxs-lookup"><span data-stu-id="08671-385">Summary</span></span>

<span data-ttu-id="08671-386">Разбиение на страницы по умолчанию является несложной реализации достаточно установить флажок Включить подкачки флажок в данных Web управления s смарт-тег, но эту простоту достигается за счет производительности.</span><span class="sxs-lookup"><span data-stu-id="08671-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="08671-387">С разбиением на страницы по умолчанию, когда пользователь запрашивает все страницы данных *все* записи, несмотря на то, что только небольшую часть из них могут быть показаны.</span><span class="sxs-lookup"><span data-stu-id="08671-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="08671-388">Для борьбы с снижению производительности, ObjectDataSource предлагает альтернативный подкачки параметр пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="08671-389">Хотя пользовательское разбиение по страницам улучшает работу разбиение по страницам s проблем с производительностью, получая только те записи, которые должны отображаться по умолчанию он s запрошены пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="08671-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="08671-390">Во-первых запрос должен быть записан, правильно (и эффективно) обращается к определенной нужного подмножества записей.</span><span class="sxs-lookup"><span data-stu-id="08671-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="08671-391">Это можно сделать несколькими способами; мы рассмотрели в этом учебнике — для использования нового SQL Server 2005 s `ROW_NUMBER()` позволяет ранжировать результаты, а для возврата только те результаты, индекс которых лежит в пределах указанного диапазона.</span><span class="sxs-lookup"><span data-stu-id="08671-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="08671-392">Кроме того необходимо добавить средства, позволяющие определить общее число страниц.</span><span class="sxs-lookup"><span data-stu-id="08671-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="08671-393">После создания этих методов DAL и уровень бизнес-ЛОГИКИ, нам также нужно настроить элемент управления ObjectDataSource таким образом, чтобы он может определить общее число страниц и корректно передавать значения начального строки индекса и максимальное число строк для МЕТОДА.</span><span class="sxs-lookup"><span data-stu-id="08671-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="08671-394">При реализации пользовательского разбиения на страницы требуется несколько этапов и не почти так же просто, как разбиение по умолчанию, пользовательское разбиение по страницам является фактором при разбиении на страницы с большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="08671-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="08671-395">Как проверить результаты продемонстрировали, пользовательская разбиения на страницы может пролить секунд от времени визуализации страницы ASP.NET и сделать более светлым нагрузку на сервер базы данных для одной или нескольких порядков.</span><span class="sxs-lookup"><span data-stu-id="08671-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="08671-396">Программирование довольны!</span><span class="sxs-lookup"><span data-stu-id="08671-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="08671-397">Об авторе</span><span class="sxs-lookup"><span data-stu-id="08671-397">About the Author</span></span>

<span data-ttu-id="08671-398">[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года.</span><span class="sxs-lookup"><span data-stu-id="08671-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="08671-399">Скотт — независимый консультант, trainer и записи.</span><span class="sxs-lookup"><span data-stu-id="08671-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="08671-400">Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="08671-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="08671-401">Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="08671-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="08671-402">[Назад](paging-and-sorting-report-data-vb.md)
> [Вперед](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="08671-402">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
