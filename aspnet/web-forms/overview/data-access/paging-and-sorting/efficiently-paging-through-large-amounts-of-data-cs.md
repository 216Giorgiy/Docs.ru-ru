---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: Эффективное разбиение больших объемов данных (C#) | Документы Microsoft
author: rick-anderson
description: Параметр разбиения на страницы по умолчанию элемента управления представления данных не подходит при работе с большими объемами данных, таких как его retriev базового элемента управления источника данных...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: ea1fd06f8eb7c53c3e9e7fb10c46974eb2af2acd
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30889661"
---
<a name="efficiently-paging-through-large-amounts-of-data-c"></a>Эффективное разбиение больших объемов данных (C#)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) или [скачать PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)

> Параметр разбиения на страницы по умолчанию элемента управления представления данных неприменим, при работе с большими объемами данных, поскольку его базовый источник данных получает все записи, несмотря на то, что отображается только подмножество данных. В такой ситуации нужно включить пользовательское разбиения на страницы.


## <a name="introduction"></a>Вступление

Как уже говорилось в предыдущем учебнике разбиение по страницам можно реализовать одним из двух способов:

- **Разбиение на страницы по умолчанию** может быть реализован просто установить параметр Включить разбиение на страницы в веб-элемент управления s данных смарт-тегов; тем не менее, при просмотре страницы данных, ObjectDataSource извлекает *всех* записей, даже Однако только их подмножество, отображаются на странице
- **Пользовательское разбиение по страницам** повышает производительность по умолчанию разбиение по страницам путем извлечения только тех записей из базы данных, которые должны отображаться на странице данных, запрашиваемых пользователем; тем не менее, необходимо проделать некоторую дополнительную работу для реализации чем разбиение по страницам по умолчанию

Из-за Простота реализации достаточно лишь установить флажок и которые производится операция завершена успешно. разбиение на страницы по умолчанию является привлекательным вариантом. Его н/д хранить подход получение всех записей, однако делает implausible выбор при разбиении на страницы с большими объемами данных или для сайтов с большим количеством одновременных пользователей. В такой ситуации нужно включить пользовательское разбиение по страницам для обеспечения быстрого реагирования системы.

Пользовательское разбиение по страницам с проблемой является возможность создать запрос, который возвращает точный набор записей, необходимых для отдельной страницы данных. К счастью Microsoft SQL Server 2005 предоставляет новое ключевое слово для ранжирование результатов, который позволит нам создать запрос, возвращающий нужное подмножество результатов. В этом учебнике мы рассмотрим, как использовать это новое ключевое слово SQL Server 2005 реализовать пользовательское разбиение по страницам в элементе управления GridView. Хотя пользовательский интерфейс для пользовательского разбиения идентично используемому по умолчанию, переход от одной страницы к другой пользовательское разбиение по страницам может быть несколько раз быстрее, чем разбиение на страницы по умолчанию.

> [!NOTE]
> Рост производительности точное, выигрыш зависит от общее число страниц и нагрузку на сервер базы данных. В конце этого учебника мы рассмотрим некоторые численные показатели, демонстрирующие эффективность пользовательского разбиения.


## <a name="step-1-understanding-the-custom-paging-process"></a>Шаг 1: Основные сведения о пользовательском процессе разбиения на страницы

При разбиении данных по страницам, точный записей, отображаемых на странице зависят от страницы запрашиваемых данных и количество записей, отображаемых на каждой странице. Например предположим, мы хотим постраничного просмотра 81 наименования продуктов, по 10 продуктов на страницу. При просмотре на первой странице, d хотим продуктов от 1 до 10. При просмотре на второй странице мы d интересовать продуктов 11 до 20 и т. д.

Существует три переменные, которые определяют, какие записи должны быть получены и просмотру интерфейс разбиения по страницам.

- **Индекса первой строки** индекс первой строки в наборе данных для отображения; этот индекс может быть вычисляется путем умножения записей, отображаемых на каждой странице индекса страницы и добавление одного. Например, если постраничного просмотра записей 10 одновременно, для первой страницы (с индексом 0), запуск индекс строки равно 0 \* 10 + 1 или 1; для второй страницы (с индексом 1) запустите индекс равен 1 \* 10 + 1 , или 11.
- **Максимальное число строк** максимальное число записей, отображаемых на каждой странице. Эта переменная называется максимальное число строк с момента последнего страницы может быть меньше записей, возвращаемых размер страницы. Например разбиение по страницам по записям продуктов 81 10 на каждой странице, девятый и последней странице после только одна запись. Страница не менее, покажет записей больше, чем значение максимального количества строк.
- **Общее число записей** общее число страниц. Во время этой переменной является t, необходимых для определения записи, которые необходимо получить для данной страницы, могут предписывать интерфейс разбиения по страницам. Например при наличии списка из 81 продукта через интерфейс разбиения по страницам знает, для отображения номеров девять страниц в Интерфейсе постраничного просмотра.

С разбиением на страницы по умолчанию, запустите индекс строки вычисляется как произведение индекса страницы и размера страницы, плюс один, а максимальное число строк — просто размер страницы. Поскольку разбиение на страницы по умолчанию получает все записи из базы данных при подготовке к просмотру на любой странице данных индекса для каждой строки известен, переход к строке начального индекса строки непростая задача. Кроме того, доступны как общего числа записей s просто число записей в DataTable (или любой объект используется для хранения результатов базы данных).

Имея переменные начальный индекс строки и максимальное число строк, пользовательская реализация разбиения на страницы должны возвращать только нужного подмножества записей, начиная с запуска индекс строки и максимальное число строк, число записей после этого. Пользовательское разбиение по страницам предоставляет две проблемы:

- Нам необходимо найти эффективный способ связывания индекса строки с каждой строкой в всего набора, чтобы мы могли начать получать данные с указанного начального индекса строки данных
- Требуется предоставить общее количество страниц

В следующих двух шагах мы изучим сценарий SQL, необходимые для ответа на эти две задачи. Помимо скрипт SQL нам также нужно будет реализовать методы DAL и уровень бизнес-ЛОГИКИ.

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a>Шаг 2: Возвращается общее количество страниц

Прежде чем мы рассмотрим, как для получения нужного подмножества записей для отображаемой страницы, позволяют s сначала посмотрим, как вернуть общее число страниц. Эти сведения необходимы для правильной настройки пользовательского интерфейса постраничного просмотра. Общее число записей, возвращаемых в результате запроса SQL могут быть получены с помощью [ `COUNT` агрегатной функции](https://msdn.microsoft.com/library/ms175997.aspx). Например, чтобы определить общее число записей в `Products` таблице, можно использовать следующий запрос:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

Позволяет добавить метод DAL, представленной s. В частности, мы создадим метод DAL с именем `TotalNumberOfProducts()` , выполняющего `SELECT` инструкции, описанной выше.

Сначала откройте `Northwind.xsd` файл типизированного набора данных в `App_Code/DAL` папки. После этого щелкните правой кнопкой мыши `ProductsTableAdapter` в конструкторе и выберите Добавить запрос. Как мы хранить в предыдущих занятий, это позволит нам для добавления нового метода DAL, при вызове будет выполняться на определенной инструкции SQL или хранимую процедуру. С помощью метода TableAdapter в предыдущих учебниках, для этого класса, необязательно использовать нерегламентированные инструкции SQL.


![Использование инструкции SQL Ad-Hoc](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

**Рис. 1**: использовать инструкцию SQL Ad-Hoc


На следующем экране можно указать тип создаваемого запроса. Так как этот запрос будет возвращать одно скалярное значение общее количество записей в `Products` таблицы выберите `SELECT` возвращающий одной значение параметра.


![Настроить запрос для использования в инструкции SELECT, возвращающей одиночное значение](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

**На рисунке 2**: настроить запрос для использования в инструкции SELECT, возвращающей одиночное значение


После выбора типа запроса, нужно ввести запрос.


![Использование SELECT COUNT(*) из запроса продуктов](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

**Рис. 3**: ВЫБЕРИТЕ СЧЕТЧИК использования (\*) FROM запроса продуктов


Наконец укажите имя для метода. В качестве s упомянутой выше, позволяют использовать `TotalNumberOfProducts`.


![Имя метода DAL TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

**Рис. 4**: имя метода DAL TotalNumberOfProducts


После нажатия кнопки Готово, мастер добавит `TotalNumberOfProducts` метод DAL. Скалярные возвращение в DAL возвращают типы, допускающие значение NULL, в случае, если в результате запроса SQL `NULL`. Наш `COUNT` запрос, однако всегда будет возвращать значение, отличное от`NULL` значением; в любом случае, метод DAL возвращает неотрицательного целого.

Метод DAL мы также должны только метод в МЕТОДА. Откройте `ProductsBLL` и добавьте `TotalNumberOfProducts` метод, который просто вызывает DAL s `TotalNumberOfProducts` метод:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

DAL s `TotalNumberOfProducts` метод возвращает целое число, допускающие значение NULL, однако мы хранить созданные `ProductsBLL` класса s `TotalNumberOfProducts` метод, возвращающий обычное целочисленное значение. Следовательно, необходимо иметь `ProductsBLL` класса s `TotalNumberOfProducts` метод возвращает значение в значение NULL целое число, возвращенное DAL s `TotalNumberOfProducts` метод. Вызов `GetValueOrDefault()` возвращает значение обнуляемого целого, если он существует; Если неотрицательного целого `null`, тем не менее, он возвращает целочисленное значение по умолчанию — 0.

## <a name="step-3-returning-the-precise-subset-of-records"></a>Шаг 3: Возврат точного подмножества записей

Теперь нам является создание методов DAL и уровень бизнес-ЛОГИКИ, принимающих строки начального индекса и максимальное количество строк в переменные уже было сказано ранее и возвращает соответствующие записи. Перед этим, позволяют s сначала рассмотрим сценарий SQL. Проблемой нам: мы должно иметь возможность присвоения индекса для каждой строки в результатах всего страниц, чтобы получить только те записи, начиная с запуска индекс строки (и максимальное число записей, число записей).

Это не запрос, если уже существует столбец в таблице базы данных, который служит в качестве индекса строки. На первый взгляд может показаться `Products` таблицу s `ProductID` поле было бы достаточно как первый продукт был `ProductID` 1, второго — 2 и т. д. Тем не менее удаление продукта оставляет промежуток в последовательности, отменив все этот подход.

Существует два общих способа эффективный способ связывания индекса строки с данными для постраничного просмотра, позволяя нужного подмножества записей, которые требуется получить.

- **С помощью SQL Server 2005 s `ROW_NUMBER()` ключевое слово** опыта работы с SQL Server 2005 `ROW_NUMBER()` ключевое слово ранг связывается с каждой возвращенной записи в определенном порядке. Присвоенные номера можно использовать в качестве индексов для каждой строки.
- **С помощью табличную переменную и `SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT` инструкции](https://msdn.microsoft.com/library/ms188774.aspx) может использоваться для указания запроса должны быть обработаны; количество записей [табличных переменных](http://www.sqlteam.com/item.asp?ItemID=9454) являются локальными переменными T-SQL, которые могут содержать табличные данные для [временные таблицы](http://www.sqlteam.com/item.asp?ItemID=2029). Такой подход работает одинаково хорошо с Microsoft SQL Server 2005 и SQL Server 2000 (в то время как `ROW_NUMBER()` подход работает только с SQL Server 2005).  
  
  В данном случае для создания переменной таблицы, которая имеет `IDENTITY` и столбцами для первичных ключей таблицы, данные которых оповещается через. Затем содержимое таблицы, данные которого оповещается через выводится в табличную переменную, присвоив индекс последовательные строки (через `IDENTITY` столбец) для каждой записи в таблице. После заполнения табличной переменной `SELECT` оператором в табличную переменную, соединить с базовой таблицей, могут быть выполнены для отделения определенных записей. `SET ROWCOUNT` Оператор используется для ограничения числа записей, которые должны быть помещены в дамп в табличную переменную.  
  
  Этот подход s эффективности основан на запрашиваемый номер страницы как `SET ROWCOUNT` присваивается значение начального индекса строки, а также максимальное число строк. При работе с небольшими номерами страниц, например первый несколько страниц данных оказывается очень эффективно. Тем не менее он демонстрирует разбиение по страницам сходной производительности по умолчанию при извлечении страницы перед завершением.

В этом руководстве реализуется с помощью пользовательского разбиения на страницы `ROW_NUMBER()` ключевое слово. Дополнительные сведения об использовании табличной переменной и `SET ROWCOUNT` методика, в разделе [более эффективным методом для разбиения на страницы через больших результирующих наборов](http://www.4guysfromrolla.com/webtech/042606-1.shtml).

`ROW_NUMBER()` Ключевое слово ранг связанные с каждой записи возвращаются на номер, используя следующий синтаксис:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

`ROW_NUMBER()` Возвращает числовое значение, указывающее ранг для каждой записи в соответствии с указанным порядком. Например чтобы узнать номер для каждого продукта, начиная от наиболее ресурсоемких к меньшему, можно использовать следующий запрос:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

Рис. 5 показан этот запрос s результаты при его выполнении в окно запроса в Visual Studio. Обратите внимание, что продукты упорядочены по цене, а также ранг цены для каждой строки.


![Ранг цена входит в состав каждой записи возвращаются](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

**Рис. 5**: содержится ранг цены для каждой записи возвращаются


> [!NOTE]
> `ROW_NUMBER()` только один из многих новых функций ранжирования доступна в SQL Server 2005. Для более подробное описание того, `ROW_NUMBER()`, вместе с Ранжирующие функции чтения [возврат ранжированные результаты с Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).


При ранжировании результатов по заданному `ORDER BY` столбца в `OVER` предложение (`UnitPrice`, в приведенном выше примере), SQL Server нужно отсортировать результаты. Эта операция выполняется очень быстро, если имеется кластеризованный индекс для соответствующих столбцов, результаты упорядочиваются по, или при наличии покрытия индекса, но может быть более высокие цены, в противном случае. Чтобы повысить производительность запросов, достаточно большой, рассмотрите возможность добавления некластеризованный индекс для столбца, по которому упорядочиваются результаты по. В разделе [Ранжирующие функции и производительности в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) для просмотра более подробные сведения о производительности.

Возвращаемые сведения о рангах `ROW_NUMBER()` не может использоваться непосредственно в `WHERE` предложения. Тем не менее, можно использовать производную таблицу для возвращения `ROW_NUMBER()` результат, который затем может использоваться в `WHERE` предложения. Например, следующий запрос использует производную таблицу для возврата столбцов ProductName и UnitPrice вместе с `ROW_NUMBER()` результат, а затем используется `WHERE` предложений, чтобы только для возврата продуктов, ранг которого цены — от 11 до 20:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

Расширение эту концепцию еще, могут использовать этот подход, чтобы получить страницу данных для заданных нужные значения начального строки индекса и максимальное число строк:


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> Как мы увидим далее в этом учебнике *`StartRowIndex`* предоставляемые ObjectDataSource индексируется начиная с нуля, тогда как `ROW_NUMBER()` значение, возвращаемое в SQL Server 2005, начинаются с 1. Таким образом `WHERE` возвращает записи где `PriceRank` строго больше *`StartRowIndex`* и меньше или равно *`StartRowIndex`*  +  *`MaximumRows`*.


Теперь, мы рассматриваются как хранить `ROW_NUMBER()` может быть используется для получения данных заданы значения начального строки индекса и максимальное число строк на одной странице, теперь необходимо реализовывать эту логику в виде методов DAL и уровень бизнес-ЛОГИКИ.

При создании этого запроса, нужно определить порядок, по которому результаты ранжируются; Разрешить s отсортировать продукты по их именам в алфавитном порядке. Это означает, что собственную реализацию разбиения на страницы в этом учебнике мы не может создавать пользовательские разбитый на страницы отчет, не могут быть отсортированы. В следующем уроке, мы рассмотрим как такие функциональные возможности могут быть предоставлены.

В предыдущем разделе мы создали метод DAL как нерегламентированные инструкции SQL. К сожалению, синтаксического анализа T-SQL в Visual Studio, используемый t мастера TableAdapter как `OVER` используется синтаксис `ROW_NUMBER()` функции. Таким образом необходимо создать этот метод DAL как хранимую процедуру. Выберите из меню «Вид» (или нажмите сочетание клавиш Ctrl + Alt + S) в обозревателе сервера и разверните `NORTHWND.MDF` узла. Чтобы добавить новую хранимую процедуру, правой кнопкой мыши узел хранимых процедур и выберите команду Добавить новую хранимую процедуру (см. рис. 6).


![Добавить новую хранимую процедуру для постраничный просмотр продуктов](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

**Рис. 6**: добавить новую хранимую процедуру для постраничный просмотр продуктов


Эта хранимая процедура должна принять два целочисленных параметра - `@startRowIndex` и `@maximumRows` и использовать `ROW_NUMBER()` отсортированную по `ProductName` поля, возвращает только те строки, больше указанного `@startRowIndex` и меньше или равно `@startRowIndex`  +  `@maximumRow` s. Введите следующий сценарий в новой хранимой процедуры и щелкните значок сохранения добавление хранимой процедуры в базе данных.


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

После создания хранимой процедуры занять некоторое время на ее тестирование. Щелкните правой кнопкой мыши `GetProductsPaged` хранимой процедуры имя в обозревателе серверов и выберите параметр Execute. Visual Studio появится приглашение для ввода параметров `@startRowIndex` и `@maximumRow` s (см. рис. 7). Попробуйте различные значения и изучите его результаты.


![Введите значение для @startRowIndex и @maximumRows параметров](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<strong>Рис. 7</strong>: Введите значение для @startRowIndex и @maximumRows параметров


После выбора этих входных значений параметров, в окне вывода отображаются результаты. На рисунке 8 показаны результаты при передаче в 10 для обоих `@startRowIndex` и `@maximumRows` параметров.


[![Возвращаются записи, будет выглядеть в второй страницы данных](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)

**Рис. 8**: записи, будет выглядеть в второй страницы данных возвращаются ([Просмотр полноразмерное изображение](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))


С этим хранимая процедура, созданная, и мы готов для создания `ProductsTableAdapter` метод. Откройте `Northwind.xsd` типизированного набора данных, щелкните правой кнопкой мыши в `ProductsTableAdapter`и выберите пункт Добавить запрос. Вместо создания запроса с помощью инструкции SQL ad-hoc, создаете его с помощью существующей хранимой процедуры.


![Создание метода DAL с использованием существующей хранимой процедуры](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

**Рис. 9**: Создание метода DAL с использованием существующей хранимой процедуры


Далее мы предлагается выбрать хранимую процедуру для вызова. Выбрать `GetProductsPaged` хранимую процедуру из раскрывающегося списка.


![Выберите GetProductsPaged хранимую процедуру из раскрывающегося списка](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

**Рис. 10**: GetProductsPaged выберите хранимую процедуру из раскрывающегося списка


Далее экране необходимо какого рода данные возвращается хранимой процедурой: табличные данные, одно значение или значение отсутствует. Поскольку `GetProductsPaged` хранимая процедура может возвращать несколько записей, указывают, что он возвращает табличные данные.


![Указывает, что хранимая процедура возвращает табличные данные](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

**Рис. 11**: Указывает, что хранимая процедура возвращает табличные данные


И наконец укажите имена методов, которые вы хотите создать. Как и в предыдущих учебных, загрузив и методы, с помощью обоих заливки объект DataTable и вернуть таблицу данных. Имя первого метода `FillPaged` , а второй — `GetProductsPaged`.


![Имя методы FillPaged и GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

**Рис. 12**: имя методы FillPaged и GetProductsPaged


Кроме создать метод DAL для возврата определенной страницы продуктов, также необходимо предоставить такую же функцию МЕТОДА. Как и метод DAL уровень бизнес-ЛОГИКИ s GetProductsPaged метод должен принимать два входных значения целое число для указания начального индекса строки и максимальное число строк и должен возвращать только те записи, которые попадают в указанный диапазон. Создайте метод уровень бизнес-ЛОГИКИ в классе ProductsBLL, что просто вызывает метод вниз в s DAL метод GetProductsPaged следующим образом:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

Можно использовать любое имя для входных параметров метода s уровень бизнес-ЛОГИКИ, но, как мы увидим, решили использовать `startRowIndex` и `maximumRows` избавляет от лишнего время при настройке ObjectDataSource для использования этого метода.

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a>Шаг 4: Настройка ObjectDataSource пользовательское разбиение по страницам

С помощью методов уровень бизнес-ЛОГИКИ и DAL для доступа к определенного подмножества данных мы готов для создания элемента управления GridView управлять этой страницы через его базовой записи, используя пользовательское разбиение по страницам. Сначала откройте `EfficientPaging.aspx` страницы в `PagingAndSorting` папке, добавьте на страницу элемент управления GridView и настройте его для использования нового элемента управления ObjectDataSource. В предыдущих курсах мы часто настраивали ObjectDataSource настроен на использование `ProductsBLL` класса s `GetProducts` метод. Это время, однако мы будем использовать `GetProductsPaged` метод вместо этого после `GetProducts` возвращает *все* продуктов в базе данных в то время как `GetProductsPaged` возвращает определенного подмножества записей.


![Настройка ObjectDataSource можно использовать метод GetProductsPaged класса ProductsBLL s](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

**Рис. 13**: Настройка ObjectDataSource можно использовать метод GetProductsPaged класса ProductsBLL s


Начиная с мы re Создание элемента управления GridView только для чтения пора установить метод раскрывающегося списка в инструкции INSERT, UPDATE и удаление вкладок (нет).

После этого мастер ObjectDataSource запрашивает источники `GetProductsPaged` метод s `startRowIndex` и `maximumRows` входных значений параметров. Эти параметры фактически задается GridView автоматически, просто оставьте набор источника нет и нажмите "Готово".


![Оставьте источники ни один входной параметр](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

**Рис. 14**: оставьте источники ни один входной параметр


После завершения работы мастера ObjectDataSource GridView будет содержать BoundField или CheckBoxField для каждого из полей данных продукта. Вы можете настроить внешний вид s GridView по своему усмотрению. Я решил отобразить только хранить `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, и `UnitPrice` стояли. Кроме того настройте GridView для поддержки разбиения на страницы, установив флажок включения постраничного просмотра в смарт-тег. После внесения этих изменений GridView и ObjectDataSource должна выглядеть следующим образом:


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

При посещении страницы через браузер GridView то, где не требуется найти.


![GridView является не отображается](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

**Рис. 15**: GridView является не отображается


GridView отсутствует, так как элемент управления ObjectDataSource используется 0 в качестве значения для обоих `GetProductsPaged` `startRowIndex` и `maximumRows` входные параметры. Таким образом результирующий запрос SQL не возвращает ни одной записи, и поэтому GridView не отображается.

Чтобы исправить это, необходимо настроить элемент управления ObjectDataSource пользовательское разбиение по страницам. Это можно сделать следующим образом:

1. **Набор ObjectDataSource s `EnablePaging` свойства `true`**  это значит, что ObjectDataSource, который необходимо передать `SelectMethod` два дополнительных параметра: один для указания начального индекса строки ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) и для указания максимального числа строк ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).
2. **Набор ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом** `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства указывают имена параметров, передаваемых в `SelectMethod` для пользовательского разбиения по страницам. По умолчанию эти параметры имеют имена `startIndexRow` и `maximumRows`, являющееся, почему это происходит при создании `GetProductsPaged` метод в уровень бизнес-ЛОГИКИ, мы использовали такие значения входных параметров. Если вы решили использовать разные имена параметров для МЕТОДА s `GetProductsPaged` метода, такие как `startIndex` и `maxRows`для примера, потребуется задать ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом (например, startIndex для `StartRowIndexParameterName` и maxRows для `MaximumRowsParameterName`).
3. **Набор ObjectDataSource s [ `SelectCountMethod` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) к имени метода, который возвращает общее число из записей выполняется в выгружаемом страничном через (`TotalNumberOfProducts`)** помните, что `ProductsBLL` класса s `TotalNumberOfProducts`метод возвращает общее число страниц с помощью метода DAL, который выполняет `SELECT COUNT(*) FROM Products` запроса. Эти сведения необходимы ObjectDataSource для правильно отображения интерфейса постраничного просмотра.
4. **Удалить `startRowIndex` и `maximumRows` `<asp:Parameter>` элементы из s ObjectDataSource декларативная разметка** при настройке ObjectDataSource в мастере, Visual Studio автоматически добавляет два `<asp:Parameter>` элементов для `GetProductsPaged` метод s входных параметров. Установив `EnablePaging` для `true`, эти параметры будут автоматически передаваться; если они также отображаются в декларативный синтаксис ObjectDataSource попытается передать *четыре* параметры `GetProductsPaged` метод и два параметра `TotalNumberOfProducts` метод. Если вы забудете эти элементы `<asp:Parameter>` элементов при посещении страницы через браузер, вы получите сообщение об ошибке, например: *ObjectDataSource 'ObjectDataSource1» не удалось найти не групповой метод «TotalNumberOfProducts», который имеет параметры: startRowIndex, maximumRows*.

После внесения этих изменений, ObjectDataSource s должен выглядеть следующим образом:


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

Обратите внимание, что `EnablePaging` и `SelectCountMethod` заданы свойства и `<asp:Parameter>` элементы будут удалены. На рисунке 16 показано снимок экрана окна свойств после внесения этих изменений.


![Чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

**На рисунке 16**: чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource


После внесения этих изменений, посетите эту страницу через браузер. Должно появиться в списке, 10 продуктов в алфавитном порядке. Теперь пора пошаговый данных на одной странице за раз. Хотя нет отличия с точки зрения конечного пользователя s по умолчанию и пользовательские разбиение по страницам, более эффективно пользовательское разбиение по страницам больших объемов данных как извлекает только те записи, которые должны отображаться для данной страницы.


[![Данные, упорядоченный по продукту s имени, является разбиением на страницы с помощью пользовательского разбиения на страницы](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)

**Рисунок 17**: Data, упорядоченный по продукту s имени, является разбиением на страницы с помощью пользовательского разбиения на страницы ([Просмотр полноразмерное изображение](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))


> [!NOTE]
> С пользовательское разбиение по страницам, значение, возвращаемое ObjectDataSource s количество страниц `SelectCountMethod` хранится в состоянии просмотра s GridView. Другие переменные GridView `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` коллекции и т. д, хранятся в *управления состоянием*, которое сохраняется независимо от значения GridView s `EnableViewState` свойство. Поскольку `PageCount` значение сохраняется во время обратной передачи, с помощью состояния представления, при использовании интерфейс постраничного просмотра, который содержит ссылку, чтобы перейти к последней странице, важно включить состояние просмотра s GridView. (Если интерфейса постраничного просмотра не имеет прямой доступ к последней странице, вы можете отключить состояние представления).


Щелкнув ссылки на последнюю страницу вызывает обратную передачу и указывает, что для обновления GridView его `PageIndex` свойство. При нажатии ссылки на последнюю страницу GridView назначает его `PageIndex` одно значение меньшее, чем `PageCount` свойство. С состояние просмотра отключено `PageCount` теряется при обратной передаче и `PageIndex` вместо присваивается значение максимально допустимого целого числа. Далее GridView пытается определить начальный индекс строки, умножая `PageSize` и `PageCount` свойства. В результате `OverflowException` с момента продукта превышает размер целочисленное значение максимально допустимого.

## <a name="implement-custom-paging-and-sorting"></a>Реализуйте пользовательское разбиение по страницам и сортировка

Реализацию текущего пользовательского разбиения на страницы требуется заказа, по которому страницам данных указать статически при создании `GetProductsPaged` хранимой процедуры. Тем не менее могут записанные, смарт-тег GridView s содержит флажок Включить сортировку, помимо возможности включить разбиение на страницы. К сожалению Добавление поддержки сортировки к GridView с реализацию текущего пользовательского разбиения на страницы приводит лишь к сортировке записей на текущую просматриваемую страницу данных. Например при настройке GridView также поддерживают разбиение на страницы и затем, при просмотре данных, первая страница сортировки по названию продукта по убыванию, он будет обратный порядок продуктов на странице 1. Как показано на рисунке 18, продукт Carnarvon Tigers стал первым продуктом при сортировке в обратном алфавитном порядке, который пропускает 71 другие продукты, полученные после Carnarvon Tigers в алфавитном порядке; в сортировке, считаются только те записи, на первой странице.


[![Сортируются только данные отображаются на текущей странице](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)

**На рисунке 18**: сортируется только данные отображаются на текущей странице ([Просмотр полноразмерное изображение](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))


Сортировка применяется только к текущей странице данных так, как сортировка происходит после получения данных из МЕТОДА s `GetProductsPaged` метод и этот метод возвращает только записи одной страницы. Для правильной сортировки необходимо передать выражение сортировки для `GetProductsPaged` метод, чтобы упорядочить данные перед возвратом к заданной странице данных. Мы рассмотрим, как это сделать в нашем следующем уроке.

## <a name="implementing-custom-paging-and-deleting"></a>Реализация пользовательского разбиения на страницы и удаление

Если вы включить функцию удаления в элементе управления GridView, данные которых отображаются с помощью настраиваемых способов разбиения на страницы, можно найти, при удалении последней записи с последней страницы GridView исчезает вместо того чтобы надлежащим образом уменьшить GridView s `PageIndex`. Чтобы воспроизвести эту ситуацию, включите поддержку удаления учебника, который только что мы только что создали. Перейдите на последней странице (страница 9), где должно появиться один продукт, так как мы постраничного просмотра 81 продуктов, 10 продуктов за раз. Удалите этот продукт.

После удаления последнего продукта GridView *следует* автоматический переход на страницу восьмой и этот механизм корректно работает с разбиением на страницы по умолчанию. С пользовательское разбиение по страницам, однако после удаления последнего продукта на последней странице GridView просто исчезнет из экрана вообще. Точная Причина *почему* это происходит, немного выходит за рамки данного руководства, в разделе [Удаление последней записи на последней странице из GridView с подкачкой страниц, пользовательские](http://scottonwriting.net/sowblog/posts/7326.aspx) низкоуровневые сведения относительно источника эту проблему. В итоге он s связи следующую последовательность шагов, выполняемых в GridView, когда нажата кнопка "Удалить":

1. Удалить запись
2. Получение записей для отображения для указанного `PageIndex` и `PageSize`
3. Убедитесь, что `PageIndex` не превышает количество страниц данных в источнике данных; если он автоматически уменьшения GridView s `PageIndex` свойство
4. Связывание соответствующей страницы данных к GridView с использованием записей, полученный на шаге 2

Проблема состоит в том что `PageIndex` использовавшейся перехватывая записей для отображения по-прежнему `PageIndex` последней страницы, последняя запись была удалена. Таким образом, в шаге 2 *не* записи с момента последней страницы данных больше не содержит ни одной записи. Затем, в шаге 3 GridView осознает, что его `PageIndex` больше, чем общее число страниц в источнике данных (с момента мы хранять удаляются последней записи на последней странице) и поэтому уменьшает его `PageIndex` свойство. На шаге 4 GridView пытается выполнить привязку к данным, полученным на шаге 2; Тем не менее на шаге 2, не возвращено ни одной записи, поэтому в результате чего пустой GridView. С разбиением на страницы по умолчанию, контактной t проблема, так как на шаге 2 *все* записи получены из источника данных.

Для устранения этой проблемы существует два способа. Первым шагом является создание обработчика событий для GridView s `RowDeleted` обработчика событий, который определяет, сколько записей, отображаемых на странице, которая была удалена. Если была только одна запись, а затем эта запись должна была быть последним, и нам необходимо уменьшения GridView s `PageIndex`. Конечно, нам нужен только для обновления `PageIndex` Если операция удаления была выполнена успешно, которое можно получить, гарантируя, что `e.Exception` свойство `null`.

Такой подход работает, так как он обновляет `PageIndex` после шага 1, но до шага 2. Таким образом в шаге 2, возвращается правильный набор записей. Чтобы сделать это, используйте код, аналогичный следующему:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

Второе решение — создать обработчик событий для ObjectDataSource s `RowDeleted` событий и задать `AffectedRows` свойства со значением 1. После удаления записи на шаге 1 (но до получения данных в шаге 2), обновляет GridView его `PageIndex` свойства, если одну или несколько строк, затронутых операцией. Однако `AffectedRows` свойство не задано, элемент управления ObjectDataSource и поэтому этот шаг пропускается. Чтобы это действие было выполнено является установка вручную `AffectedRows` свойства, если операция удаления завершилась успешно. Это можно сделать с помощью следующего кода:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

Код для обоих этих обработчиков событий можно найти в класс кода программной части `EfficientPaging.aspx` примере.

## <a name="comparing-the-performance-of-default-and-custom-paging"></a>Сравнение производительности по умолчанию и пользовательское разбиение по страницам

Так как пользовательское разбиение по страницам извлекает только необходимые записи, тогда как разбиение на страницы по умолчанию возвращает *всех* записей для каждой страницы отображается, его s снимите, что пользовательское разбиение по страницам является более эффективным, чем разбиение на страницы по умолчанию. Точно так же, но насколько эффективнее пользовательское разбиение по страницам? Какие виды выигрыш в производительности может видеть путем перемещения от одного вида разбиения в пользовательское разбиение по страницам?

К сожалению, s не один размер подходит для всех ответить здесь. Рост производительности зависит от множества факторов, наиболее Показательным два число страниц и нагрузки размещается база данных сервера и обмена данными между веб-сервер и сервер базы данных каналов. Для небольших таблиц, состоящих из нескольких десятков записей разница в производительности может оказаться незначительной. Для больших таблиц с сотен и тысяч строк однако разница в производительности может стать существенной.

В моей, статье [пользовательского разбиения на страницы в ASP.NET 2.0 с SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), содержит некоторые тесты производительности, нужно ли устанавливать на борьбу различия в производительности между этих двух способов постраничного просмотра таблицы базы данных с 50 000 записей. В этих тестах я проверить время выполнения запроса на уровне SQL Server (с помощью [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) и на странице ASP.NET с помощью [функции трассировки ASP.NET s](https://msdn.microsoft.com/library/y13fw6we.aspx). Имейте в виду, что эти тесты выполнялись на моем рабочем компьютере с одним активным пользователем и таким образом научными и не имитировать шаблонов нагрузки для типичных веб-сайта. Независимо от того результаты показывают относительные различия во времени выполнения для экземпляра по умолчанию и пользовательское разбиение по страницам при работе с достаточно большими объемами данных.


|  | **Средн. Длительность (сек.)** | **Считывает** |
| --- | --- | --- |
| **Приложение SQL Profiler разбиения на страницы по умолчанию** | 1.411 | 383 |
| **Пользовательские приложения SQL Profiler разбиения на страницы** | 0.002 | 29 |
| **Трассировка ASP.NET разбиение на страницы по умолчанию** | 2.379 | *N/A* |
| **Пользовательские трассировку ASP.NET разбиения на страницы** | 0.029 | *N/A* |


Как видите, получения отдельной страницы данных в среднем требуется 354 меньше операций чтения и выполняемые в часть того времени. На странице ASP.NET, пользовательские страницы был подготавливать к просмотру в близко к 1/100<sup>й</sup> времени, потребовавшегося при разбиении по умолчанию. В разделе [мою статью](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) Дополнительные сведения на основе этих результатов вместе с кодом и базы данных можно загрузить для воспроизведения этих тестов в собственной среде.

## <a name="summary"></a>Сводка

Разбиение на страницы по умолчанию является несложной реализации достаточно установить флажок Включить подкачки флажок в данных Web управления s смарт-тег, но эту простоту достигается за счет производительности. С разбиением на страницы по умолчанию, когда пользователь запрашивает все страницы данных *все* записи, несмотря на то, что только небольшую часть из них могут быть показаны. Для борьбы с снижению производительности, ObjectDataSource предлагает альтернативный подкачки параметр пользовательское разбиение по страницам.

Хотя пользовательское разбиение по страницам улучшает работу разбиение по страницам s проблем с производительностью, получая только те записи, которые должны отображаться по умолчанию он s запрошены пользовательское разбиение по страницам. Во-первых запрос должен быть записан, правильно (и эффективно) обращается к определенной нужного подмножества записей. Это можно сделать несколькими способами; мы рассмотрели в этом учебнике — для использования нового SQL Server 2005 s `ROW_NUMBER()` позволяет ранжировать результаты, а для возврата только те результаты, индекс которых лежит в пределах указанного диапазона. Кроме того необходимо добавить средства, позволяющие определить общее число страниц. После создания этих методов DAL и уровень бизнес-ЛОГИКИ, нам также нужно настроить элемент управления ObjectDataSource таким образом, чтобы он может определить общее число страниц и корректно передавать значения начального строки индекса и максимальное число строк для МЕТОДА.

При реализации пользовательского разбиения на страницы требуется несколько этапов и не почти так же просто, как разбиение по умолчанию, пользовательское разбиение по страницам является фактором при разбиении на страницы с большими объемами данных. Как проверить результаты продемонстрировали, пользовательская разбиения на страницы может пролить секунд от времени визуализации страницы ASP.NET и сделать более светлым нагрузку на сервер базы данных для одной или нескольких порядков.

Программирование довольны!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

> [!div class="step-by-step"]
> [Назад](paging-and-sorting-report-data-cs.md)
> [Вперед](sorting-custom-paged-data-cs.md)
