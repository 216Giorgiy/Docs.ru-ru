---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: Кэширование данных в архитектуре (C#) | Документы Microsoft
author: rick-anderson
description: В предыдущем учебнике мы узнали, как применение кэширования на уровне представления. В этом учебнике рассказано, как пользоваться преимуществами наших многоуровневой архитектуре систем обеспечения...
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 9ca91ecdaed536fe69196e0f726138590d7a9b77
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
ms.locfileid: "30879222"
---
<a name="caching-data-in-the-architecture-c"></a>Кэширование данных в архитектуре (C#)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить пример приложения](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) или [скачать PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)

> В предыдущем учебнике мы узнали, как применение кэширования на уровне представления. В этом учебнике рассказано, как использовать преимущества наших многоуровневой архитектуры для кэширования данных на уровне бизнес-логики. Для этого, расширяя архитектуру, чтобы включить кэширование слой.


## <a name="introduction"></a>Вступление

Как было показано в предыдущем учебнике, кэширование данных s ObjectDataSource сложнее, чем установка нескольких свойств. К сожалению ObjectDataSource применяется кэширование на уровне представления, который тесно связывает политики кэширования со страницы ASP.NET. Одной из причин для создания многоуровневой архитектуры является предоставление таких связей к повреждению. Уровня бизнес-логики для экземпляра отделяет бизнес-логики на страницах ASP.NET, во время доступа к данным отделяет сведения о данных для доступа. Это разделение бизнес логику и данные, данные доступа предпочтительнее, частично, так как его и система становится более читаемым, более простого в сопровождении и более гибкие, чтобы изменить. Он также позволяет набора знаний домена и подразделения разработчик, работающий на t уровень представления данных необходимо ознакомиться со сведениями о s базы данных для выполнения своей работы. Отделение от уровня представления политику кэширования предоставляет аналогичные преимуществ.

В этом учебнике будет дополнить нашей архитектуры для включения *кэширования слоев* (или CL сокращенно), использует политике кэширования. Кэширование слоя будет включать `ProductsCL` класс, который предоставляет доступ к информации о продукте с помощью таких методов, как `GetProducts()`, `GetProductsByCategoryID(categoryID)`и так далее, что при вызове будет первой попытке получения данных из кэша. Если кэш пуст, эти методы вызывают соответствующие `ProductsBLL` метод в МЕТОДА, который в свою очередь будет получать данные из DAL. `ProductsCL` Методы кэшировать данные, полученные из МЕТОДА перед возвращением.

Как показано на рис. 1, CL находится между презентации и уровни бизнес-логики.


![Кэширование слоя (CL) — еще один уровень в наш архитектуры](caching-data-in-the-architecture-cs/_static/image1.png)

**Рис. 1**: кэширование слоя (CL) — еще один уровень в наш архитектуры


## <a name="step-1-creating-the-caching-layer-classes"></a>Шаг 1: Создание классов кэширования слоев

В этом учебнике мы создадим простой CL с отдельным классом `ProductsCL` , имеющий ограниченное число методов. Создание слоя полное кэширование для всего приложения требуется создание `CategoriesCL`, `EmployeesCL`, и `SuppliersCL` классы, а также предоставлять метод в этих классах, кэширование слой для каждого метода доступа или изменения данных в МЕТОДА. Как и уровень бизнес-ЛОГИКИ и DAL, уровень кэширования в идеальном случае должен быть реализован как отдельный проект библиотеки классов; Тем не менее, мы будем реализовывать как класс в `App_Code` папки.

Несколько классов четко отдельных CL от классов DAL и уровень бизнес-ЛОГИКИ, s позволяют создать новую вложенную папку в `App_Code` папки. Щелкните правой кнопкой мыши `App_Code` в обозревателе решений, выберите новую папку и имя новой папки `CL`. После создания этой папки, добавьте в него новый класс с именем `ProductsCL.cs`.


![Добавить новую папку с именем CL и класс с именем ProductsCL.cs](caching-data-in-the-architecture-cs/_static/image2.png)

**На рисунке 2**: добавить новую папку с именем `CL` и класс с именем `ProductsCL.cs`


`ProductsCL` Класс должен включать один и тот же набор методов доступа и изменения данных, обнаруженных в его соответствующий класс уровня бизнес-логики (`ProductsBLL`). Вместо создания все эти методы позволяют s просто построения несколько здесь, чтобы понять закономерности используемые CL. В частности, мы добавим `GetProducts()` и `GetProductsByCategoryID(categoryID)` методы в шаге 3 и `UpdateProduct` перегрузки на шаге 4. Можно добавить оставшихся `ProductsCL` методы и `CategoriesCL`, `EmployeesCL`, и `SuppliersCL` классы в свободное время.

## <a name="step-2-reading-and-writing-to-the-data-cache"></a>Шаг 2: Чтение и запись в кэше данных

ObjectDataSource, рассмотренных в предыдущем учебнике внутри функции кэширования использует кэш данных ASP.NET для хранения данных, из МЕТОДА. Кэш данных можно получить программным путем из классов кода страницы ASP.NET или из классов в s архитектура веб-приложения. Для чтения и записи в кэш данных из кода класс s страницы ASP.NET, используйте следующий шаблон:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

[ `Cache` Класса](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [ `Insert` метод](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) имеет несколько перегрузок. `Cache["key"] = value` и `Cache.Insert(key, value)` являются синонимами и как добавить элемент в кэш, используя указанный ключ без определенного истечения срока действия. Как правило требуется указать срока действия при добавлении элемента в кэш, либо в качестве зависимости и зависимости времени истечения срока действия. Используйте один из других `Insert` перегрузок метода s, чтобы предоставляют сведения с учетом зависимостей или время истечения срока действия.

Уровень кэширования s методы, необходимо сначала проверить, если запрошенные данные в кэше и если да, верните ее оттуда. Если запрошенные данные не в кэше, необходимо вызвать соответствующий метод уровень бизнес-ЛОГИКИ. Его возвращаемое значение следует кэшировать и возвращается, как показано на следующей схеме.


![Методы s кэширование уровень возвращает данные из кэша, если оно доступно s](caching-data-in-the-architecture-cs/_static/image3.png)

**Рис. 3**: методы s слоя кэширования возвращает данные из кэша, если он s доступно


Последовательность, показаны на рис. 3 выполняется в классах CL, используя следующий шаблон:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

Здесь *тип* — это тип данных, хранимых в кэше `Northwind.ProductsDataTable`, например сетям *ключ* ключ, который уникально идентифицирует элемент кэша. Если элемент с указанным *ключ* не находится в кэше, затем *экземпляр* будет `null` и данные будут получены из соответствующего метода уровень бизнес-ЛОГИКИ и добавлены в кэш. К моменту `return instance` достигается, *экземпляр* содержит ссылку на данные, либо из кэша или из МЕТОДА.

Обязательно используйте шаблон выше, при доступе к данным из кэша. Следующий шаблон, который на первый взгляд выглядит эквивалентной содержит небольшое различие, который представляет состояние гонки. Состояние гонки трудно отлаживать из-за обнаруживать себя время от времени их трудно воспроизвести.


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

Разность в этом втором фрагмент неправильный код, а не хранить ссылку на кэшированный элемент в локальной переменной, кэш данных осуществляется непосредственно в условном операторе *и* в `return`. Предположим, при достижении этого кода `Cache["key"]` не является`null`, но перед `return` инструкция исчерпана, система исключает *ключ* из кэша. В этом редком случае вернет код `null` преимущества, а не объект принадлежит к ожидаемому типу.

> [!NOTE]
> Кэш данных является потокобезопасным, поэтому вам не нужно синхронизировать доступ к потокам для простых операций чтения или записи t. Тем не менее если необходимо выполнить несколько операций с данными в кэше, должен быть атомарной, вы несете ответственность для реализации блокировки или другие механизмы для обеспечения потокобезопасности. В разделе [синхронизации доступа к кэшу ASP.NET](http://www.ddj.com/184406369) для получения дополнительной информации.


Элемент может быть программно исключена из кэша данных с помощью [ `Remove` метод](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) следующим образом:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a>Шаг 3: Возвращение сведения о продукте из`ProductsCL`класса

Для этого учебника позволяют реализовать два метода для возвращения сведения о продукте из s `ProductsCL` класса: `GetProducts()` и `GetProductsByCategoryID(categoryID)`. LIKE с `ProductsBL` класс уровня бизнес-логики `GetProducts()` метод в CL возвращает сведения обо всех продуктах, как `Northwind.ProductsDataTable` объекта, пока `GetProductsByCategoryID(categoryID)` возвращает все продукты из указанной категории.

В следующем коде показано часть методов в `ProductsCL` класса:


[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

Во-первых, обратите внимание, `DataObject` и `DataObjectMethodAttribute` атрибуты, применяемые к классу и методы. Эти атрибуты предоставляют сведения о мастере s ObjectDataSource, позволяющее определить, какие классы и методы должны отображаться на шагах s. Поскольку CL классов и методов, будет осуществляться с ObjectDataSource на уровне представления данных, добавлены эти атрибуты, чтобы улучшить взаимодействие во время разработки. Обращаться к [Создание слой бизнес-логики](../introduction/creating-a-business-logic-layer-cs.md) учебника более тщательной описание этих атрибутов и их последствия.

В `GetProducts()` и `GetProductsByCategoryID(categoryID)` методы, данные, возвращенные из `GetCacheItem(key)` метод назначается локальной переменной. `GetCacheItem(key)` Метод, который мы изучим вскоре возвращает какой-либо элемент из кэша на основе указанных *ключ*. Если данные не найдена в кэше, он извлекается из соответствующего `ProductsBLL` методу класса, а затем добавлено в кэш с помощью `AddCacheItem(key, value)` метод.

`GetCacheItem(key)` И `AddCacheItem(key, value)` методы взаимодействия с кэшем данных, чтение и запись значений соответственно. `GetCacheItem(key)` Метода является более простой из них. Он просто возвращает значение из класса кэша с использованием переданного *ключ*:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

`GetCacheItem(key)` не используйте *ключ* значение, как указано, но вместо этого вызывает `GetCacheKey(key)` метод, возвращающий *ключ* с ProductsCache - префиксом. `MasterCacheKeyArray`, Содержащий строку ProductsCache, также используется `AddCacheItem(key, value)` метод, как будет показано моментально.

От класса фонового кода ASP.NET страницы s, кэш данных может осуществляться с использованием `Page` класса s [ `Cache` свойство](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)и позволяет использовать синтаксис, подобный `Cache["key"] = value`, как описано в шаге 2. Из класса в архитектуре, кэш данных может осуществляться с помощью `HttpRuntime.Cache` или `HttpContext.Current.Cache`. [Питер Джонсон](https://weblogs.asp.net/pjohnson/default.aspx)в записи блога [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) заметки небольшое повышение производительности с помощью `HttpRuntime` вместо `HttpContext.Current`; следовательно, `ProductsCL` использует `HttpRuntime`.

> [!NOTE]
> Если вашей архитектуры реализуется с помощью проектов библиотек классов, то необходимо добавить ссылку на `System.Web` сборки для использования [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) и [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) классы.


Если элемент не найден в кэше, `ProductsCL` класса s методы получения данных из МЕТОДА и добавьте его в кэш с помощью `AddCacheItem(key, value)` метод. Чтобы добавить *значение* в кэш можно использовать следующий код, который использует 60 секунд времени истечения срока действия:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

`DateTime.Now.AddSeconds(CacheDuration)` Указывает на основе времени окончания срока действия 60 секунд в будущем while [ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) указывает, выполняется ли s не скользящий срок действия. При этом `Insert` перегруженный метод имеет входные параметры для обоих является абсолютным и скользящего срока действия, можно предоставить только один из них. При попытке задать промежуток времени и абсолютное время `Insert` метод вызывает исключение `ArgumentException` исключение.

> [!NOTE]
> Эта реализация `AddCacheItem(key, value)` метод в настоящее время имеет недостатки. Мы решения и решения этих проблем на шаге 4.


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a>Шаг 4: Делает недействительными кэш при Data — изменены через архитектура

А также методы получения данных уровень кэширования должен содержать те же методы, как уровень бизнес-ЛОГИКИ для вставки, обновления и удаления данных. Способы изменения данных CL s не изменяйте кэшированные данные, но вместо этого вызовите метод изменения соответствующих данных для уровень бизнес-ЛОГИКИ s и затем делают кэш недействительным. Как упоминалось в предыдущем учебнике это аналогично поведению ObjectDataSource применяется при включении его функции кэширования и его `Insert`, `Update`, или `Delete` методы вызываются.

Следующие `UpdateProduct` перегрузка показано, как реализовать методы изменения данных в CL:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

Вызывается изменения соответствующих данных метод уровня бизнес-логики, но перед его ответ возвращается необходимо сделать недействительным кэш. К сожалению, кэш не очевидные поскольку `ProductsCL` класса s `GetProducts()` и `GetProductsByCategoryID(categoryID)` методы добавляют элементы в кэш с разными ключами и `GetProductsByCategoryID(categoryID)` метод добавляется элемент разного кэша для каждого уникальный *categoryID*.

Что делает недействительными кэш, нам нужно удалить *все* элементов, которые могут быть добавлены с `ProductsCL` класса. Это можно сделать, связав *зависимости кэша* с каждым элементом, добавленных в кэш в `AddCacheItem(key, value)` метод. В общем случае зависимость кэша может быть другого элемента в кэше, файл в файловой системе или данные из базы данных Microsoft SQL Server. При изменении зависимостей или удаляется из кэша, элементы кэша, связанного с ним автоматически извлекается из кэша. В этом учебнике требуется создать еще один элемент в кэше, который выступает в качестве зависимости в кэше для всех элементов, добавленных с помощью `ProductsCL` класса. Таким образом, все эти элементы можно удалить из кэша, просто удалив зависимостей кэша.

Обновления позволяют s `AddCacheItem(key, value)` метод, чтобы каждый элемент добавлен в кэш через этот метод связан с зависимостей кэша:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

`MasterCacheKeyArray` является массивом строк, содержащий одно значение ProductsCache. Во-первых элемент кэша добавляется в кэш и назначить текущую дату и время. Если этот элемент кэша уже существует, она обновляется. Затем создается зависимость кэша. [ `CacheDependency` Класса](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s конструктор имеет несколько перегрузок, но использованному здесь требуется два `string` массива входных данных. Первый указывает набор файлов, которые будут использоваться в качестве зависимости. Поскольку мы не хотите нежелательно использовать все файловые зависимости, значение `null` используется для первого входного параметра. Второй входной параметр указывает набор ключей кэша для использования в качестве зависимости. Здесь мы указываем нашей одна зависимость `MasterCacheKeyArray`. `CacheDependency` Затем передается в `Insert` метод.

Для этого изменения `AddCacheItem(key, value)`, invaliding кэша заключается в удалении зависимости.


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a>Шаг 5: Вызов слоя кэширования из уровня представления

Кэширование слоя s классы и методы можно использовать для работы с данными с помощью методик, мы хранять проверяются на протяжении этих учебников. Чтобы продемонстрировать работу с кэшированными данными, сохранить изменения в `ProductsCL` класса, а затем откройте `FromTheArchitecture.aspx` страницы в `Caching` папку и добавьте элемент управления GridView. В смарт-теге s GridView создайте новый элемент управления ObjectDataSource. На первом шаге мастера s вы увидите `ProductsCL` классов как один из вариантов в раскрывающемся списке.


[![Класс ProductsCL включен в раскрывающемся списке объекта бизнеса](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)

**Рис. 4**: `ProductsCL` класс включен в раскрывающемся списке объекта бизнеса ([Просмотр полноразмерное изображение](caching-data-in-the-architecture-cs/_static/image6.png))


После выбора `ProductsCL`, нажмите кнопку Далее. Раскрывающегося списка на вкладке «SELECT» имеет два элемента - `GetProducts()` и `GetProductsByCategoryID(categoryID)` и вкладку обновление имеет отдельное `UpdateProduct` перегрузки. Выберите `GetProducts()` метод на вкладке SELECT и `UpdateProducts` метод на вкладку обновления и нажмите кнопку Готово.


[![В раскрывающемся списке указаны перечислены методы класса ProductsCL s](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)

**Рис. 5**: `ProductsCL` методы класса s, перечислены в раскрывающемся списке указаны ([Просмотр полноразмерное изображение](caching-data-in-the-architecture-cs/_static/image9.png))


По завершении работы мастера Visual Studio установит ObjectDataSource s `OldValuesParameterFormatString` свойства `original_{0}` и добавьте соответствующие поля в GridView. Изменение `OldValuesParameterFormatString` свойства его значение по умолчанию `{0}`и настроить для поддержки разбиения на страницы, сортировку и редактирование GridView. Поскольку `UploadProducts` перегруженный метод, используемый с CL принимает только имя продукта s и цену, ограничить GridView, чтобы только эти поля являются изменяемыми.

В предыдущем учебнике мы определили GridView, чтобы включить поля для `ProductName`, `CategoryName`, и `UnitPrice` поля. Вы можете реплицировать этот формат и структуру, в этом случае к GridView и ObjectDataSource s декларативный должна выглядеть следующим образом:


[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

На этом этапе у нас есть страницы, использующей уровень кэширования. Чтобы просмотреть кэш в действии, установите точки останова в `ProductsCL` класса s `GetProducts()` и `UpdateProduct` методы. Перейдите на страницу в браузере и пошагового выполнения кода, пока сортировки и разбиения на страницы для просмотра данных из кэша. Затем обновите запись и обратите внимание, что кэш становится недействительным, и, следовательно, он извлекается из МЕТОДА когда привязываются к GridView.

> [!NOTE]
> Уровень кэширования, предоставленные в этой статье для загрузки не завершена. Он содержит только один класс `ProductsCL`, который только спортивные небольшое число методов. Кроме того, на одной странице ASP.NET использует CL (`~/Caching/FromTheArchitecture.aspx`) все остальные по-прежнему ссылаться МЕТОДА напрямую. Если планируется использование CL в приложении, все вызовы от уровня представления следует перейдите CL, которое потребует, CL s классы и методы рассматриваются эти классы и методы в момент используется уровень представления данных МЕТОДА.


## <a name="summary"></a>Сводка

Во время кэширования могут применяться на уровне представления данных с помощью ASP.NET 2.0 s SqlDataSource и элементы управления ObjectDataSource, в идеале кэширование обязанности бы делегировать отдельный уровень в архитектуре. В этом учебнике мы создали слой кэширование, в котором находится между уровнем представления данных и уровня бизнес-логики. Уровень кэширования необходимо было предоставить тот же набор классов и методов, которые существуют в МЕТОДА и вызываются из уровня представления.

Примеры кэширования слоев, мы изучена в этом и предыдущем учебники короткая *реактивный загрузки*. При загрузке реактивный, данные загружаются в кэш только в том случае, если запрос на получение данных и данных отсутствует в кэше. Данные также могут быть *заранее загрузить* в кэш, метод, загружает данные в кэше, прежде чем это действительно необходимо. В следующем уроке мы рассмотрим пример упреждающего загрузки, когда мы рассмотрим, как для хранения статических значений в кэш при запуске приложения.

Программирование довольны!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Благодарности

Этот учебник ряд прошел проверку многие полезные рецензентов. Основной рецензент этого учебника было Murph Тереза д. Объясняются моих последующих статей для MSDN? Если Да, напишите мне по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](caching-data-with-the-objectdatasource-cs.md)
> [Вперед](caching-data-at-application-startup-cs.md)
