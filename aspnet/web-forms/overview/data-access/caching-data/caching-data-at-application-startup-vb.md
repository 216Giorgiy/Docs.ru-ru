---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
title: "Кэширование данных при запуске приложения (Visual Basic) | Документы Microsoft"
author: rick-anderson
description: "В любой веб-приложения некоторые данные будут часто использоваться и некоторые данные будут использоваться редко. Мы можем улучшить производительность приложения в нашем ASP.NET..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 84afe4ac-cc53-4f2e-a867-27eaf692c2df
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
msc.type: authoredcontent
ms.openlocfilehash: 5b84b797bf0c9670ac65a5384b6d95d5df3827eb
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="caching-data-at-application-startup-vb"></a>Кэширование данных при запуске приложения (Visual Basic)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать PDF](caching-data-at-application-startup-vb/_static/datatutorial60vb1.pdf)

> В любой веб-приложения некоторые данные будут часто использоваться и некоторые данные будут использоваться редко. Мы можем улучшить производительность приложения ASP.NET с помощью загрузки часто используемых данных, этот способ называется заранее. Этот учебник демонстрирует один подход к упреждающего загрузки, которая является для загрузки данных в кэш при запуске приложения.


## <a name="introduction"></a>Вступление

Два предыдущих учебниках рассматривали кэширования данных в презентации и слои кэширования. В [кэширование данных с помощью ObjectDataSource](caching-data-with-the-objectdatasource-vb.md), мы рассмотрели использование ObjectDataSource s, кэширование функций для кэширования данных на уровне представления данных. [Кэширование данных в архитектуре](caching-data-in-the-architecture-vb.md) проверить кэширования в новый, отдельный уровень кэширования. Оба этих учебников используются *реактивный загрузки* при работе с кэшем данных. При загрузке реактивный, при каждом запросе данных система сначала проверяет его s в кэше. В противном случае он извлекает данные из исходного источника, например базы данных, а затем сохраняет его в кэше. Главным преимуществом реактивный загрузки является его Простота реализации. Одним из ее недостатки является его неравномерной производительность различных запросов. Представьте себе страницы, использующей уровень кэширования из предыдущего учебника для отображения сведений о продукте. Когда эта страница посетит в первый раз или посетит в первый раз после извлекается из-за нехватки памяти или достигнут указанный срок действия кэшированных данных, данные должны извлекаться из базы данных. Таким образом эти запросы пользователей займет больше времени, чем запросы пользователей, которые могут быть получены с кэшем.

*Загрузка упреждающего* предоставляет кэш альтернативные стратегии управления, позволяет сгладить производительность различных запросов путем загрузки перед ним кэшированные данные, необходимые. Как правило упреждающее загрузки использует какой-либо процесс, который периодически проверяет или уведомляется, после обновления в базовые данные. Затем этот процесс обновляет кэш, чтобы сохранить новую. Упреждающее загрузки особенно полезна в тех случаях, если базовые данные поступают из подключения к базе данных медленно, веб-службы или другого источника данных, особенно медленным. Но этот подход к загрузке упреждающего сложнее, для его выполнения требуется создание, управление и развертывание процесса для проверки изменений и обновления кэша.

Другого вида упреждающего загрузки и типом, который в этом учебнике мы будем изучать загружает данные в кэш при запуске приложения. Этот подход особенно полезен для кэширования статических данных, например записи в таблицах базы данных поиска.

> [!NOTE]
> Более подробное рассмотрение различия между проактивное и реактивное загрузки, а также списки специалистов, недостатков и рекомендации по реализации, см. в разделе [управление содержимое кэша](https://msdn.microsoft.com/library/ms978503.aspx) раздел [ Кэширование руководство по архитектуре для приложений .NET Framework](https://msdn.microsoft.com/library/ms978498.aspx).


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a>Шаг 1: Определение данных в кэш при запуске приложения

Примеры кэширования, с помощью реактивный загрузке мы рассмотрели предыдущие два учебника работу с данными, может периодически изменять и не долго exorbitantly для создания. Но если кэшированные данные никогда не изменяется, срок действия, используемые реактивный загрузки является избыточным. Аналогичным образом Если выполняется кэширование данных занимает очень много времени для создания, затем этих пользователей, которых запросы поиска очищать кэш будет выдержать длительное время ожидания при базовых данных извлекаются. Рассмотрите возможность кэширования статические данные и данные, которые принимает слишком долго для создания при запуске приложения.

Базы данных имеют много динамической, часто изменяющиеся значения, большинство также создать изрядное статических данных. Например практически все модели данных имеют один или несколько столбцов, содержащих определенное значение из основного набора вариантов. Объект `Patients` таблицы базы данных может иметь `PrimaryLanguage` столбец, значения которого набор может быть английский, испанский, французский, русский, японский и т. д. Очень часто этих типов столбцов реализуются с помощью *таблиц подстановки*. Вместо того чтобы хранить строки английский или французский в `Patients` , второй таблицы создается таблица с, как правило, двумя столбцами - уникальный идентификатор и строковое описание - запись для каждого возможного значения. `PrimaryLanguage` Столбца в `Patients` таблице хранятся соответствующие уникальный идентификатор в таблице уточняющих запросов. На рис. 1 patient John Doe s основной язык — английский, а Джонсон Ed s — русский.


![В таблице языков предназначена Уточняющий запрос таблицы в таблице сведений о пациентах](caching-data-at-application-startup-vb/_static/image1.png)

**Рис. 1**: `Languages` таблица предназначена Уточняющий запрос таблицы `Patients` таблицы


Пользовательский интерфейс для редактирования или для создания нового пациента включит в раскрывающемся списке допустимых языков, заполняет ее записи в `Languages` таблицы. Без кэширования, каждый раз, этот интерфейс является посетил система должна запрос `Languages` таблицы. Это затратные и ненужных так как значения таблицы подстановки очень редко изменяются вообще.

Нам удалось кэшировать `Languages` данных, используя те же техники реактивный загрузке проверяются в предыдущих учебниках. Тем не менее, реагирующий загрузка использует срока действия на основе времени, которой не требуется для статических поиск таблицы данных. Во время кэширования с помощью реактивный загрузки будет лучше, чем отсутствие кэширования вообще, лучше будет заблаговременного данные таблицы подстановки в кэш при запуске приложения.

В этом учебнике мы рассмотрим данные таблицы подстановки кэша и другие сведения о статических.

## <a name="step-2-examining-the-different-ways-to-cache-data"></a>Шаг 2: Проверка различные способы для кэширования данных

Сведения могут кэшироваться программным способом в приложении ASP.NET, с помощью различных подходов. Мы хранять уже изучили, как использовать кэш данных в предыдущих учебниках. Кроме того, объекты можно программно кэшировать с помощью *статические члены* или *состояние приложения*.

При работе с классом, обычно класса необходимо сначала создать экземпляры можно получить доступ к его членам. Например для вызова метода от одного из классов в нашем уровня бизнес-логики, необходимо сначала создать экземпляр класса:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample1.vb)]

Прежде чем мы можно вызвать *SomeMethod* или работы с *SomeProperty*, сначала необходимо создать экземпляр класса с помощью `New` ключевое слово. *SomeMethod* и *SomeProperty* связаны с конкретным экземпляром. Время существования этих членов привязывается к времени существования их связанного объекта. *Статические члены*, с другой стороны, переменные, свойства и методы, которые являются общими для *все* экземпляры класса и, следовательно, имеют время жизни, при условии, что и класс. Статические члены, обозначаются с помощью ключевого слова `Shared`.

Помимо статические элементы данных могут кэшироваться использования состояния приложения. Каждое приложение ASP.NET поддерживает коллекцию имя/значение, s, общими для всех пользователей и страницы приложения. Эта коллекция может осуществляться с использованием [ `HttpContext` класса](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) s [ `Application` свойство](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)и использования из кода класса страницы s ASP.NET следующим образом:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample2.vb)]

Кэш данных предоставляет гораздо более широкие API для кэширования данных, предоставляя механизмы для кэше на основе времени и зависимостей, приоритеты элемента кэша и т. д. Статические члены и состояния приложения таких компонентов, необходимо вручную добавить разработчиком страницы. При кэшировании данных при запуске приложения в течение времени существования приложения, однако преимущества s кэш данных, получается. В этом учебнике мы рассмотрим код, который использует все три метода для кэширования статических данных.

## <a name="step-3-caching-thesupplierstable-data"></a>Шаг 3: Кэширование`Suppliers`таблицы данных

Northwind, таблицы базы данных мы хранять реализован для даты не включают все традиционные Уточняющий запрос таблицы. Четыре DataTables реализован в DAL все таблицы модели, значения которого не являются статическими. Вместо того чтобы тратить время, чтобы добавить новую таблицу данных DAL новый класс и методы для МЕТОДА, для этого учебника просто позволить s представьте, что `Suppliers` таблицу s данные являются статическими. Таким образом мы кэшировать эти данные при запуске приложения.

Чтобы начать, создайте новый класс с именем `StaticCache.cs` в `CL` папки.


![Создайте класс StaticCache.vb в папке CL](caching-data-at-application-startup-vb/_static/image2.png)

**На рисунке 2**: создание `StaticCache.vb` в класс `CL` папки


Необходимо добавить метод, который загружает данные во время запуска в хранилище соответствующие кэша, а также методы, возвращающие данные из этого кэша.


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample3.vb)]

Приведенный выше код использует статическая переменная-член, `suppliers`, для хранения результатов `SuppliersBLL` класса s `GetSuppliers()` метод, который вызывается из `LoadStaticCache()` метод. `LoadStaticCache()` Метод должен вызываться во время запуска приложения s. После загрузки данных при запуске приложения можно вызвать любой страницы, которая требуется для работы с данными о поставщиках `StaticCache` класса s `GetSuppliers()` метод. Таким образом вызов к базе данных для получения поставщиков происходит только один раз, при запуске приложения.

Вместо использования статической переменной-члена как хранилище кэша, можно было бы также использовать состояние приложения или в кэше данных. В следующем коде показано класс retooled использовать состояние приложения:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample4.vb)]

В `LoadStaticCache()`, сведения о поставщиках хранятся в переменной приложения *ключ*. Он s возвращаются в виде соответствующего типа (`Northwind.SuppliersDataTable`) из `GetSuppliers()`. Хотя можно получить состояние приложения в классах кода страниц ASP.NET с помощью `Application("key")`, в архитектуре, необходимо использовать `HttpContext.Current.Application("key")` для получения текущего `HttpContext`.

Аналогичным образом кэш данных может использоваться как хранилище кэша, как показано в следующем коде:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample5.vb)]

Чтобы добавить элемент в кэш данных и без срока действия на основе времени, используйте `System.Web.Caching.Cache.NoAbsoluteExpiration` и `System.Web.Caching.Cache.NoSlidingExpiration` значения в качестве входных параметров. Данная конкретная перегрузка кэш данных s `Insert` был выбран метод, чтобы указать, мы *приоритет* элемента кэша. Приоритет используется, чтобы определить, какие элементы нужно удалить из кэша, когда не хватает доступной памяти. Здесь мы используем приоритет `NotRemovable`, который гарантирует, что этот элемент кэша выиграл t очистку.

> [!NOTE]
> Этот учебник s загрузки реализует `StaticCache` подход переменной статический член класса. Код для методов кэша состояния и данных приложения находится в комментарии в файле класса.


## <a name="step-4-executing-code-at-application-startup"></a>Шаг 4: Выполнение кода при запуске приложения

Для выполнения кода при первом запуске веб-приложения, необходимо создать специальный файл с именем `Global.asax`. Этот файл может содержать обработчики событий для приложения-, сеанс- и события на уровне запроса, который здесь где можно добавить код, который будет выполняться при каждом запуске приложения.

Добавить `Global.asax` файл web s корневой каталог приложения, щелкнув правой кнопкой мыши имя проекта веб-сайта в Visual Studio s обозревателе решений и выбрав команду Добавить новый элемент. В диалоговом окне Добавление нового элемента выберите тип элемента глобальный класс приложения и нажмите кнопку "Добавить".

> [!NOTE]
> Если у вас уже есть `Global.asax` в вашем проекте глобальный класс приложения, тип элемента не будет отображаться в диалоговом окне Добавление нового элемента.


[![Добавьте его в корневую папку веб-приложения s](caching-data-at-application-startup-vb/_static/image4.png)](caching-data-at-application-startup-vb/_static/image3.png)

**Рис. 3**: добавление `Global.asax` файла в ваш веб-приложение s корневой каталог ([Просмотр полноразмерное изображение](caching-data-at-application-startup-vb/_static/image5.png))


Значение по умолчанию `Global.asax` файл шаблона содержит пять методов на стороне сервера `<script>` тег:

- **`Application_Start`**выполняется при первом запуске веб-приложения
- **`Application_End`**выполняется, когда приложение завершает работу
- **`Application_Error`**выполняется всегда, когда приложение встречает необработанное исключение
- **`Session_Start`**выполняется, когда создается новый сеанс
- **`Session_End`**выполняется, когда сеанс истек или прервана

`Application_Start` Обработчик событий вызывается только один раз во время жизненного цикла приложения s. Приложение запускается в первый раз ресурса ASP.NET запросе от приложения и продолжает работать до перезапуска приложения, что может произойти, изменяя содержимое `/Bin` папки, изменение `Global.asax`, изменение содержимое в `App_Code` папки или изменение `Web.config` файл, другими причинами. Ссылаться на [Общие сведения о жизненном цикле приложения ASP.NET](https://msdn.microsoft.com/library/ms178473.aspx) более подробные сведения о жизненном цикле приложения.

Для этих учебников нам требуется только добавить код для `Application_Start` метод, поэтому теперь можете удалить остальные. В `Application_Start`, просто вызвать `StaticCache` класса s `LoadStaticCache()` метод, который будет загружен и кэшировать информацию поставщика:


[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample6.aspx)]

Все, что s — его! При запуске приложения `LoadStaticCache()` метод захватите сведения о поставщиках из МЕТОДА и сохранить его в переменной статического элемента (или хранить независимо от кэша, вы в итоге использование в `StaticCache` класса). Чтобы проверить это, установите точку останова `Application_Start` метод и запустите приложение. Обратите внимание, что останова при запуске приложения. Последующие запросы, но не вызывают `Application_Start` для выполнения метода.


[![Использовать точки останова в убедитесь, что обработчик событий Application_Start является выполняемой](caching-data-at-application-startup-vb/_static/image7.png)](caching-data-at-application-startup-vb/_static/image6.png)

**Рис. 4**: использовать точку останова, чтобы проверить, `Application_Start` обработчик событий — выполняемой ([Просмотр полноразмерное изображение](caching-data-at-application-startup-vb/_static/image8.png))


> [!NOTE]
> Если не нажать `Application_Start` останова при первом запуске отладки, это означает, что приложение уже запущена. Принудительный перезапуск, изменив приложения вашей `Global.asax` или `Web.config` файлы, а затем повторите попытку. Можно просто добавить (или удалить) пустую строку в конце один из этих файлов, чтобы быстро перезапустить приложение.


## <a name="step-5-displaying-the-cached-data"></a>Шаг 5: Отображение всех кэшированных данных

На этом этапе `StaticCache` класс имеет версию поставщика данных, кэшированных при запуске приложения, можно получить с помощью его `GetSuppliers()` метод. Для работы с данными от уровня представления можно использовать элемент управления ObjectDataSource или программный вызов `StaticCache` класса s `GetSuppliers()` метода из кода класса страницы s ASP.NET. Разрешить s рассмотреть использование элементов управления ObjectDataSource и GridView для отображения информации кэшированных поставщика.

Сначала откройте `AtApplicationStartup.aspx` страницы в `Caching` папки. Перетащите элемент управления GridView с панели элементов в конструктор параметр его `ID` свойства `Suppliers`. Затем из GridView s смарт-тегов выберите Создание нового ObjectDataSource с именем `SuppliersCachedDataSource`. Настройка ObjectDataSource для использования `StaticCache` класса s `GetSuppliers()` метод.


[![Настройка ObjectDataSource с помощью класса StaticCache](caching-data-at-application-startup-vb/_static/image10.png)](caching-data-at-application-startup-vb/_static/image9.png)

**Рис. 5**: Настройка ObjectDataSource для использования `StaticCache` класса ([Просмотр полноразмерное изображение](caching-data-at-application-startup-vb/_static/image11.png))


[![Метод GetSuppliers() используется для получения кэшированных поставщика данных](caching-data-at-application-startup-vb/_static/image13.png)](caching-data-at-application-startup-vb/_static/image12.png)

**Рис. 6**: использование `GetSuppliers()` метод для извлечения данных в кэше поставщика ([Просмотр полноразмерное изображение](caching-data-at-application-startup-vb/_static/image14.png))


По завершении работы мастера Visual Studio автоматически добавит стояли для каждого поля данных в `SuppliersDataTable`. К GridView и ObjectDataSource s должна выглядеть следующим образом:


[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample7.aspx)]

Рис. 7 показана страница при просмотре через браузер. Выходные данные одинаково мы убрали данные из МЕТОДА s `SuppliersBLL` класса, но с использованием `StaticCache` класса возвращает данные поставщика в виде кэшированных при запуске приложения. Можно установить точки останова `StaticCache` класса s `GetSuppliers()` метод для проверки этого поведения.


[![Данные в кэше поставщиков отображается в элементе управления GridView](caching-data-at-application-startup-vb/_static/image16.png)](caching-data-at-application-startup-vb/_static/image15.png)

**Рис. 7**: в кэше данных поставщика отображается в элементе управления GridView ([Просмотр полноразмерное изображение](caching-data-at-application-startup-vb/_static/image17.png))


## <a name="summary"></a>Сводка

Большинство каждая модель данных содержит изрядное статические данные, обычно реализуется в виде таблиц подстановки. Поскольку эта информация является статическим, s здесь нет необходимости постоянного доступа к базе данных каждый раз, эти данные должны отображаться. Кроме того, из-за его статического характера при кэшировании данных существует s срока действия не требуются. В этом учебнике мы узнали, как такие данные и кэшировать его в кэш данных, состояние приложения и с помощью статической переменной-члена. Эта информация кэшируется при запуске приложения и остается в кэше на протяжении существования приложения s.

В этом учебнике и последние два мы рассмотрели хранять кэширования данных в течение всего времени существования s приложения, а также с помощью кэше на основе времени. При кэшировании данных базы данных, однако может быть меньше, чем идеальным решением на основе времени окончания срока действия. Вместо того чтобы периодически очистки кэша, будет оптимальным решением будет удалить кэшированного элемента только при изменении основной базы данных. Выполнение идеальных возможна за счет использования зависимости кэша SQL, которые будет рассмотрен в следующем учебном курсе.

Программирование довольны!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Благодарности

Этот учебник ряд прошел проверку многие полезные рецензентов. Основными редакторами этого учебника были Мерфи Тереза д и Зак Джонс. Объясняются моих последующих статей для MSDN? Если Да, напишите мне по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

>[!div class="step-by-step"]
[Назад](caching-data-in-the-architecture-vb.md)
[Вперед](using-sql-cache-dependencies-vb.md)
