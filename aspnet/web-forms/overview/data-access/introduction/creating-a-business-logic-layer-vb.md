---
uid: web-forms/overview/data-access/introduction/creating-a-business-logic-layer-vb
title: "Создание уровня бизнес-логики (VB) | Документы Microsoft"
author: rick-anderson
description: "В этом учебнике мы рассмотрим способы централизации бизнес-правила в слой бизнес логики (МЕТОД), выступающем в качестве посредника для обмена данными между t..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/31/2010
ms.topic: article
ms.assetid: 142e5181-29ce-4bb9-907b-2a0becf7928b
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/introduction/creating-a-business-logic-layer-vb
msc.type: authoredcontent
ms.openlocfilehash: 7722ed54e333515f641f1c1adf647c4ec08dfb6b
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2017
---
<a name="creating-a-business-logic-layer-vb"></a>Создание уровня бизнес-логики (Visual Basic)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить пример приложения](http://download.microsoft.com/download/5/d/7/5d7571fc-d0b7-4798-ad4a-c976c02363ce/ASPNET_Data_Tutorial_2_VB.exe) или [скачать PDF](creating-a-business-logic-layer-vb/_static/datatutorial02vb1.pdf)

> В этом учебнике будет показано, как централизовать бизнес-правила в слой бизнес логики (МЕТОД), выступающем в качестве посредника для обмена данными между уровнем представления данных и DAL.


## <a name="introduction"></a>Вступление

Уровень доступа к данным (DAL) создан в [первом учебнике](creating-a-data-access-layer-vb.md) четко разделяет данные доступа логики от логики представления. Однако хотя DAL четко отделяет сведения о данных для доступа из уровень представления, не обеспечивают все бизнес-правила, которые могут применяться. Например, в нашем приложении мы может потребоваться запретить `CategoryID` или `SupplierID` поля `Products` таблицы, если для `Discontinued` поле имеет значение 1, или может потребоваться для применения правил стаж запрещения в ситуациях, когда Сотрудник управляет тем, кто был принят на работу после их. Другим распространенным сценарием является авторизации может быть только пользователи в определенной роли, могут удалять продукты или можно изменить `UnitPrice` значение.

В этом учебнике будет показано, как для централизации этих бизнес-правила в слой бизнес логики (МЕТОД), выступающем в качестве посредника для обмена данными между уровнем представления данных и DAL. В реальном приложении уровень бизнес-ЛОГИКИ должен быть реализован как отдельный проект библиотеки классов; Однако для этих учебников реализуется МЕТОДА как ряд классов в нашем `App_Code` папки для упрощения структуры проекта. Рис. 1 показаны архитектуры связи между уровнем представления, уровень бизнес-ЛОГИКИ и DAL.


![МЕТОДА отделяет уровень представления от уровня доступа к данным и налагает бизнес-правила](creating-a-business-logic-layer-vb/_static/image1.png)

**Рис. 1**: МЕТОДА отделяет уровень представления от уровня доступа к данным и налагает бизнес-правила


Вместо создания отдельных классов для реализации нашей [бизнес-логики](http://en.wikipedia.org/wiki/Business_logic), мы также удалось разместить эту логику непосредственно в типизированный набор данных в разделяемые классы. Пример создания и расширения типизированного набора данных обращаться к первой учебника.

## <a name="step-1-creating-the-bll-classes"></a>Шаг 1: Создание классов уровень бизнес-ЛОГИКИ

Наш уровень бизнес-ЛОГИКИ будет состоять из четырех классов, по одному для каждого адаптера таблицы в DAL; Каждый из этих классов уровень бизнес-ЛОГИКИ будет иметь методы для извлечения, вставки, обновления и удаления из соответствующего TableAdapter в слое DAL, применяющие соответствующие бизнес-правила.

Для большей четкости разделения классов, связанных с DAL и уровень бизнес-ЛОГИКИ, давайте создадим две вложенные папки в `App_Code` папке `DAL` и `BLL`. Просто щелкните правой кнопкой мыши `App_Code` папки в обозревателе решений и выберите новую папку. После создания этих двух папок, переместите типизированного набора данных, созданные в первом руководстве в `DAL` вложенную папку.

Создайте четыре файла класса уровень бизнес-ЛОГИКИ в `BLL` вложенную папку. Для этого щелкните правой кнопкой мыши `BLL` вложенную папку, выберите команду Добавить новый элемент и выберите шаблон класса. Назовите четыре класса `ProductsBLL`, `CategoriesBLL`, `SuppliersBLL`, и `EmployeesBLL`.


![Добавьте четыре новых класса в папку App_Code](creating-a-business-logic-layer-vb/_static/image2.png)

**На рисунке 2**: Добавьте четыре новых классов для `App_Code` папки


Далее добавим методы для всех классов, чтобы просто перенести методы, определенные для адаптеров таблиц из первого руководства. Теперь эти методы будут вызывать метод непосредственно в DAL; впоследствии мы вернемся для добавления необходимых бизнес-логика.

> [!NOTE]
> Если вы используете Visual Studio Standard Edition или более поздней версии (то есть вы *не* с помощью Visual Web Developer), при необходимости можно создать визуально с помощью классов [конструктор классов](https://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_vstechart/html/clssdsgnr.asp). Ссылаться на [блога конструктор класса](https://blogs.msdn.com/classdesigner/default.aspx) Дополнительные сведения об этой новой функции в Visual Studio.


Для `ProductsBLL` класса, необходимо добавить целых семь методов:

- `GetProducts()`Возвращает все продукты
- `GetProductByProductID(productID)`Возвращает продукт с указанным Идентификатором продукта
- `GetProductsByCategoryID(categoryID)`Возвращает все продукты указанной категории
- `GetProductsBySupplier(supplierID)`Возвращает все продукты указанного поставщика
- `AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)`Вставляет новый продукт в базе данных с использованием значений переданное; Возвращает `ProductID` значение поля
- `UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)`обновляет существующий продукт в базе данных, используя переданные значения; Возвращает `True` Если точно одна строка была обновлена, `False` в противном случае
- `DeleteProduct(productID)`Удаляет указанный продукт из базы данных

ProductsBLL.vb


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample1.vb)]

Методы, которые просто возвращают данные `GetProducts`, `GetProductByProductID`, `GetProductsByCategoryID`, и `GetProductBySuppliersID` довольно просты, как они напрямую обращаются к слою DAL. Хотя в некоторых сценариях может быть бизнес-правила, которые должны быть реализованы на этом уровне (например, правила авторизации на основе текущего пользователя или роли, к которой принадлежит пользователь), мы просто оставим эти методы, как-является. Для этих методов после этого МЕТОДА служит в качестве прокси-сервера, через который уровень представления обращается к данным из уровня доступа к данным.

`AddProduct` И `UpdateProduct` методы и принимают в качестве параметров значения различных полей продукта и добавить новый продукт или обновить существующий, соответственно. Поскольку многие из `Product` столбцы таблицы могут принимать `NULL` значения (`CategoryID`, `SupplierID`, и `UnitPrice`, Вот некоторые из них), для тех входных параметров `AddProduct` и `UpdateProduct` , сопоставленные с такого использования столбцов [типы nullable](https://msdn.microsoft.com/en-us/library/1t3y8s4s(v=vs.80).aspx). Типы, допускающие значения NULL не знакомы с .NET 2.0 и дают, указывающее, является ли тип значения должен, вместо этого быть `Nothing`. См. [Пол Вик](http://www.panopticoncentral.net/)в записи блога [истинности о типы Nullable и VB](http://www.panopticoncentral.net/archive/2004/06/04/1180.aspx) и технической документации по [Nullable](https://msdn.microsoft.com/en-US/library/b3h38hb0%28VS.80%29.aspx) структуры для получения дополнительной информации.

Все три метода возвращают логическое значение, указывающее, была ли строка вставки, обновления или удалить, поскольку операция не может привести к затронутые строки. Например, если разработчик страницы вызывает `DeleteProduct` передав `ProductID` для несуществующего продукта, `DELETE` инструкция выполняется в базе данных не оказывает влияния и, следовательно, `DeleteProduct` метод будет возвращать `False`.

Обратите внимание, что при добавлении нового продукта или обновлении существующего мы перевода в полях продукта новые или измененные как список скалярных значений, в отличие от принятия `ProductsRow` экземпляра. Такой подход был выбран, так как `ProductsRow` класс является производным от ADO.NET `DataRow` класс, который не имеет конструктор по умолчанию. Чтобы создать новый `ProductsRow` экземпляра, необходимо сначала создать `ProductsDataTable` экземпляра, а затем вызвать его `NewProductRow()` метод (который мы делаем в `AddProduct`). Этот недостаток начинает себя проявлять при обращении ко вставки и обновления продуктов с помощью ObjectDataSource. Иными словами элемент управления ObjectDataSource попытается создать экземпляр входных параметров. Если требуется, чтобы метод уровень бизнес-ЛОГИКИ `ProductsRow` экземпляра, ObjectDataSource попытается создать ее, но ошибкой из-за отсутствия конструктора без параметров по умолчанию. Дополнительные сведения по этой проблеме см. следующие два форумах по ASP.NET: [ObjectDataSources обновление с наборами данных Strongly-Typed](https://forums.asp.net/1098630/ShowPost.aspx), и [проблему с ObjectDataSource и набор данных Strongly-Typed](https://forums.asp.net/1048212/ShowPost.aspx).

Далее, в обоих `AddProduct` и `UpdateProduct`, код создает `ProductsRow` экземпляра и заполняется только переданные значения. При присвоении значений DataColumns DataRow возможны различные проверки уровня полей. Поэтому вставка вручную переданных значений обратно в строку DataRow позволяет обеспечить правильность данных, передаваемых в метод уровень бизнес-ЛОГИКИ. К сожалению строго типизированные классы DataRow, созданную Visual Studio следует использовать типы, допускающие значение NULL. Скорее чтобы указать, что конкретный объект DataColumn в DataRow должно соответствовать `NULL` базы данных необходимо использовать `SetColumnNameNull()` метода.

В `UpdateProduct` сначала загружается в продукт с помощью `GetProductByProductID(productID)`. Хотя может показаться необязательным обращением к базе данных, будет подтвердить оправдан в будущих учебниках, посвященные оптимистичного параллелизма этого обращения. Чтобы убедиться, что случайно двух пользователей, которые одновременно работают на тех же данных не перезаписать изменения, выполненные другой методика оптимистичного параллелизма. Захват записи целиком также упрощает создание методов обновления в МЕТОДА, изменяющих только подмножество столбцов DataRow. При изучении `SuppliersBLL` мы рассмотрим этот пример класса.

Наконец, обратите внимание, что `ProductsBLL` класс имеет [DataObject атрибут](https://msdn.microsoft.com/en-us/library/system.componentmodel.dataobjectattribute.aspx) применяемый к нему ( `[System.ComponentModel.DataObject]` непосредственно предшествующий оператор class в верхней части файла) и методы имеют [ Атрибуты DataObjectMethodAttribute](https://msdn.microsoft.com/en-us/library/system.componentmodel.dataobjectmethodattribute.aspx). `DataObject` Помечает класс как объект, подходящий для привязки к [управления ObjectDataSource](https://msdn.microsoft.com/en-us/library/9a4kyhcx.aspx), тогда как `DataObjectMethodAttribute` указывает назначение метода. Как будет видно в будущих учебниках, ObjectDataSource ASP.NET 2.0 позволяет легко декларативно доступа к данным из класса. Чтобы отфильтровать список возможных классов для привязки к в мастере ObjectDataSource, по умолчанию только классы, помеченные как `DataObjects` отображаются в раскрывающемся списке мастера. `ProductsBLL` Класса будет работать точно так же без этих атрибутов, но их добавления для упрощения работы в мастере ObjectDataSource.

## <a name="adding-the-other-classes"></a>Добавление других классов

С `ProductsBLL` полный класс, по-прежнему необходимо добавить классы для работы с категорий, поставщиков и сотрудников. Теперь пора создайте следующие классы и методы, с помощью понятия из предыдущего примера:

- **CategoriesBLL.cs**

    - `GetCategories()`
    - `GetCategoryByCategoryID(categoryID)`
- **SuppliersBLL.cs**

    - `GetSuppliers()`
    - `GetSupplierBySupplierID(supplierID)`
    - `GetSuppliersByCountry(country)`
    - `UpdateSupplierAddress(supplierID, address, city, country)`
- **EmployeesBLL.cs**

    - `GetEmployees()`
    - `GetEmployeeByEmployeeID(employeeID)`
    - `GetEmployeesByManager(managerID)`

Следует отметить один метод является `SuppliersBLL` класса `UpdateSupplierAddress` метод. Этот метод предоставляет интерфейс для обновления только сведения о адрес поставщика. На внутреннем уровне этот метод считывает в `SupplierDataRow` для указанного `supplierID` (с помощью `GetSupplierBySupplierID`), задает его свойства, связанные с адресом и затем вызывает `SupplierDataTable` `Update` метод. `UpdateSupplierAddress` Метод следующим образом:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample2.vb)]

См. в этой статье загрузки для Завершенная реализация классов уровень бизнес-ЛОГИКИ.

## <a name="step-2-accessing-the-typed-datasets-through-the-bll-classes"></a>Шаг 2: Доступ к типизированных наборов данных с помощью классов уровень бизнес-ЛОГИКИ

В первом руководстве мы видели примеры работы непосредственно с типизированным набором данных программным путем, но с добавлением наших классов уровень бизнес-ЛОГИКИ, уровень представления должны работать вместо него. В `AllProducts.aspx` примера в первом руководстве, `ProductsTableAdapter` использовался для привязки списка продуктов к GridView, как показано в следующем коде:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample3.vb)]

Для использования нового МЕТОДА классов, все, необходимо изменить, является просто в первой строке кода замените `ProductsTableAdapter` объекта с `ProductBLL` объекта:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample4.vb)]

Классы уровень бизнес-ЛОГИКИ может осуществляться с использованием ObjectDataSource также декларативно (что может типизированного набора данных). Мы будем рассматривать ObjectDataSource более подробно в следующих учебниках.


[![Список продуктов, отображаемый в GridView](creating-a-business-logic-layer-vb/_static/image4.png)](creating-a-business-logic-layer-vb/_static/image3.png)

**Рис. 3**: список продуктов, отображаемый в элементе управления GridView ([Просмотр полноразмерное изображение](creating-a-business-logic-layer-vb/_static/image5.png))


## <a name="step-3-adding-field-level-validation-to-the-datarow-classes"></a>Шаг 3: Добавление проверки уровня полей к классам DataRow

Проверки на уровне полей являются проверками, которые относятся к значениям свойств бизнес-объектов при вставке или обновлении. Некоторые правила проверки уровня полей для продуктов, включают в себя:

- `ProductName` Поле должно содержать 40 символов длиной не более
- `QuantityPerUnit` Поле должно быть 20 символов, длиной не более
- `ProductID`, `ProductName`, И `Discontinued` поля являются обязательными, но все остальные поля являются необязательными
- `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, И `ReorderLevel` поля должны быть больше или равно нулю

Эти правила могут и должны быть выражены на уровне базы данных. Ограничение символов на `ProductName` и `QuantityPerUnit` определяются типы данных этих столбцов в `Products` таблицы (`nvarchar(40)` и `nvarchar(20)`соответственно). Поля, являются ли обязательных и необязательных выражаются Если столбец таблицы базы данных позволяет `NULL` s. Четыре [проверочные ограничения](https://msdn.microsoft.com/en-us/library/ms188258.aspx) существует, убедитесь, что только значения больше или равно нулю можно выполняете его в `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, или `ReorderLevel` столбцов.

Помимо применения этих правил в базе данных они также применяется на уровне набора данных. На самом деле для каждого объекта DataTable набора DataColumns уже записали длины поля и является ли значение обязательными или необязательными. Для просмотра существующих проверки уровня полей автоматически предоставляется, перейдите в конструкторе наборов данных, выберите поле из одного из DataTable, а затем перейдите в окно «Свойства». Как показано на рис. 4, `QuantityPerUnit` DataColumn в `ProductsDataTable` имеет максимальную длину 20 символов и разрешить `NULL` значения. При попытке задать `ProductsDataRow` `QuantityPerUnit` длиннее 20 символов строки значение свойства `ArgumentException` будет создано.


[![DataColumn выполняет базовую проверку на уровне полей](creating-a-business-logic-layer-vb/_static/image7.png)](creating-a-business-logic-layer-vb/_static/image6.png)

**Рис. 4**: DataColumn обеспечивает базовую уровня полей проверку ([Просмотр полноразмерное изображение](creating-a-business-logic-layer-vb/_static/image8.png))


К сожалению, мы не может указать проверок границ, например `UnitPrice` значение должно быть больше или равно нулю, в окне «Свойства». Чтобы предоставить такой тип проверки уровня полей необходимо создать обработчик событий для объекта DataTable [ColumnChanging](https://msdn.microsoft.com/en-us/library/system.data.datatable.columnchanging%28VS.80%29.aspx) событий. Как упоминалось в [предыдущего учебника](creating-a-data-access-layer-vb.md), объекты DataSet, DataTables и DataRow, созданные типизированного набора данных, которые могут быть расширены за счет использования разделяемых классов. При использовании этого метода можно создать `ColumnChanging` обработчик событий для `ProductsDataTable` класса. Начните с создания класса в `App_Code` папку с именем `ProductsDataTable.ColumnChanging.vb`.


[![Добавьте новый класс в папку App_Code](creating-a-business-logic-layer-vb/_static/image10.png)](creating-a-business-logic-layer-vb/_static/image9.png)

**Рис. 5**: добавьте новый класс `App_Code` папку ([Просмотр полноразмерное изображение](creating-a-business-logic-layer-vb/_static/image11.png))


Создайте обработчик событий для `ColumnChanging` событие, которое гарантирует, что `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, и `ReorderLevel` значения столбцов (если не `NULL`) больше, чем или равно нулю. Если любой из таких столбцов выходит за пределы диапазона, возникает исключение `ArgumentException`.

ProductsDataTable.ColumnChanging.vb


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample5.vb)]

## <a name="step-4-adding-custom-business-rules-to-the-blls-classes"></a>Шаг 4: Добавление пользовательских бизнес-правил к классам МЕТОДА

Помимо проверки уровня полей может быть высокого уровня пользовательских бизнес-правил, включают различные объекты или концепции которые невозможно выразить на уровне столбца, например:

- Если продукт снят, его `UnitPrice` не могут быть обновлены
- Сотрудника страну проживания должен быть таким же, как их manager страну проживания
- Продукт не поддерживается, если это единственный продукт, предоставляемый данным поставщиком

Классы уровень бизнес-ЛОГИКИ должен содержать проверки, обеспечивающие соблюдение приложения бизнес-правила. Эти проверки можно добавить непосредственно в методы, к которым они относятся.

Предположим, что наши бизнес-правилам, продукт не может быть помечена больше не поддерживаются, если он был единственным данного поставщика. То есть если продукта *X* был единственным было приобретено у поставщика *Y*, не удалось пометить *X* как больше не поддерживаются; Если, однако поставщика *Y*нам поставляется с тремя продуктами *A*, *B*, и *C*, можно помечать любые и все их них как более не поддерживается. Нечетное бизнес-правило, но бизнес-правила и здравый смысл не всегда совпадают!

Для принудительного применения этого бизнес-правила в `UpdateProducts` начнем путем проверки, если метод `Discontinued` было задано значение `True` и, если да, мы называем `GetProductsBySupplierID` определить, сколько продуктов было приобретено у поставщика этого продукта. Если только один продукт приобретается у этого поставщика, мы создаем `ApplicationException`.


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample6.vb)]

## <a name="responding-to-validation-errors-in-the-presentation-tier"></a>Реакция на ошибки проверки в слое представления

Если вызов МЕТОДА из уровня представления мы можно принять решение для обработки исключений, которые могут вызываться или оставить их передаваясь вверх к ASP.NET (который будет вызывать `HttpApplication`в `Error` событий). Для обработки исключения, при работе с МЕТОДА программным образом, можно использовать [Try... Catch](https://msdn.microsoft.com/en-us/library/fk6t46tz%28VS.80%29.aspx) блока, как показано в следующем примере:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample7.vb)]

Как мы увидим в будущих учебниках, обработка исключений, передаваясь вверх от МЕТОДА, при использовании данных веб-элемента управления для вставки, обновления или удаления данных может обрабатываться непосредственно в обработчике событий вместо необходимости включать код в `Try...Catch` блоков.

## <a name="summary"></a>Сводка

Приложение с правильной архитектурой сконструированных различных слоев, каждый из которых заключена конкретная роль. В первом учебнике этой серии статей, мы создали слой доступа к данным с помощью типизированных наборов данных; в этом учебнике мы создали слой бизнес-логики как ряд классов в нашем приложении `App_Code` папку, вызывают DAL. МЕТОДА реализует логику уровня полей и бизнес уровня для нашего приложения. Помимо создания отдельных МЕТОДА, как это делалось в этом учебнике, другой вариант — расширение методов элемента управления TableAdapter с помощью разделяемых классов. Тем не менее при использовании этого метода позволяет переопределить существующие методы, ни разделять слои DAL и наш уровень бизнес-ЛОГИКИ как подход, использованный в этой статье полностью.

DAL и уровень бизнес-ЛОГИКИ завершения мы готовы к процессу слоем представления. В [следующее руководство](master-pages-and-site-navigation-vb.md) мы занять краткое перенаправление из статьи о доступе к данным и определения согласованного макета страницы для использования во всех учебниках.

Программирование довольны!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи ASP/ASP.NET и основателя из [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Майкрософт с 1998 года. Скотт — независимый консультант, trainer и записи. Его последняя книга — [ *диспетчерами учат самостоятельно ASP.NET 2.0 в течение 24 часов*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он может быть достигнута по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Благодарности

Этот учебник ряд прошел проверку многие полезные рецензентов. Основными редакторами этого учебника были (Liz Shulok), Деннис Патерсона, Карлос Сантос и – Хилтон Гизнау. Объясняются моих последующих статей для MSDN? Если Да, напишите мне по [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

>[!div class="step-by-step"]
[Назад](creating-a-data-access-layer-vb.md)
[Вперед](master-pages-and-site-navigation-vb.md)
