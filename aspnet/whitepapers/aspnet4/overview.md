---
uid: whitepapers/aspnet4/overview
title: В ASP.NET 4 и Visual Studio 2010 Web Общие сведения о разработке | Документы Microsoft
author: rick-anderson
description: Этот документ предоставляет обзор новых возможностей для ASP.NET, включенные в пакет.NET Framework 4 и Visual Studio 2010.
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/10/2010
ms.topic: article
ms.assetid: d7729af4-1eda-4ff2-8b61-dbbe4fc11d10
ms.technology: ''
ms.prod: .net-framework
msc.legacyurl: /whitepapers/aspnet4
msc.type: content
ms.openlocfilehash: 6ce52c387ff835eda46bc1882b8b974889e2d4af
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/10/2018
ms.locfileid: "30899047"
---
<a name="aspnet-4-and-visual-studio-2010-web-development-overview"></a>В ASP.NET 4 и Visual Studio 2010 Web Общие сведения о разработке
====================
> Этот документ предоставляет обзор новых возможностей для ASP.NET, включенные в пакет.NET Framework 4 и Visual Studio 2010.
> 
> [Загрузите этот документ](https://download.microsoft.com/download/7/1/A/71A105A9-89D6-4201-9CC5-AD6A3B7E2F22/ASP_NET_4_and_Visual_Studio_2010_Web_Development_Overview.pdf)


**Содержание**

**[Основные службы](#0.2__Toc253429238 "_Toc253429238")**  
[Файл Web.config рефакторинг](#0.2__Toc253429239 "_Toc253429239")  
[Расширяемое кэширование вывода](#0.2__Toc253429240 "_Toc253429240")  
[Автоматический запуск веб-приложений](#0.2__Toc253429241 "_Toc253429241")  
[Окончательное перемещение страницы](#0.2__Toc253429242 "_Toc253429242")  
[Сжатие состояния сеанса](#0.2__Toc253429243 "_Toc253429243")  
[Расширение диапазона допустимых URL-адресов](#0.2__Toc253429244 "_Toc253429244")  
[Расширяемая проверка запросов](#0.2__Toc253429245 "_Toc253429245")  
[Кэширование объектов и расширяемость кэширования объектов](#0.2__Toc253429246 "_Toc253429246")  
[Расширяемый HTML, URL-адреса и кодировку заголовка HTTP](#0.2__Toc253429247 "_Toc253429247")  
[Наблюдение за производительностью для отдельных приложений в одном рабочем процессе](#0.2__Toc253429248 "_Toc253429248")  
[Multi-Targeting](#0.2__Toc253429249 "_Toc253429249")

**[Ajax](#0.2__Toc253429250 "_Toc253429250")**  
[jQuery включенные с помощью веб-форм и MVC](#0.2__Toc253429251 "_Toc253429251")  
[Поддержка сети доставки содержимого](#0.2__Toc253429252 "_Toc253429252")  
[Явные сценарии ScriptManager](#0.2__Toc253429253 "_Toc253429253")

**[Веб-формы](#0.2__Toc253429256 "_Toc253429256")**  
[Параметр мета-теги с помощью свойства Page.MetaDescription и Page.MetaKeywords](#0.2__Toc253429257 "_Toc253429257")  
[Включение состояния представления для отдельных элементов управления](#0.2__Toc253429258 "_Toc253429258")  
[Изменения возможностей браузера](#0.2__Toc253429259 "_Toc253429259")  
[Маршрутизация в ASP.NET 4](#0.2__Toc253429260 "_Toc253429260")  
[Задания идентификаторов клиента](#0.2__Toc253429261 "_Toc253429261")  
[Сохранение выбора строки в элементах управления данными](#0.2__Toc253429262 "_Toc253429262")  
[Элемент управления диаграммы для ASP.NET](#0.2__Toc253429263 "_Toc253429263")  
[Фильтрация данных с помощью элемента управления QueryExtender](#0.2__Toc253429264 "_Toc253429264")  
[Выражения кода в кодировке HTML](#0.2__Toc253429265 "_Toc253429265")  
[Изменение шаблонов проектов](#0.2__Toc253429266 "_Toc253429266")  
[Усовершенствования CSS](#0.2__Toc253429267 "_Toc253429267")  
[Скрытие элементов вокруг скрытые поля div](#0.2__Toc253429268 "_Toc253429268")  
[Внешняя таблица отрисовку элементах управления](#0.2__Toc253429269 "_Toc253429269")  
[Усовершенствования элемента управления ListView](#0.2__Toc253429270 "_Toc253429270")  
[CheckBoxList и улучшения свободу](#0.2__Toc253429271 "_Toc253429271")  
[Усовершенствования управления меню](#0.2__Toc253429272 "_Toc253429272")  
[Мастера и элементы управления CreateUserWizard 56](#0.2__Toc253429273 "_Toc253429273")

**[ASP.NET MVC](#0.2__Toc253429274 "_Toc253429274")**  
[Поддержка области](#0.2__Toc253429275 "_Toc253429275")  
[Поддержка проверки атрибута заметки к данным](#0.2__Toc253429276 "_Toc253429276")  
[Шаблонизированные вспомогательные объекты](#0.2__Toc253429277 "_Toc253429277")

**[Dynamic Data](#0.2__Toc253429278 "_Toc253429278")**  
[Включение платформы динамических данных для существующих проектов](#0.2__Toc253429279 "_Toc253429279")  
[Синтаксис декларативный элемент управления DynamicDataManager](#0.2__Toc253429280 "_Toc253429280")  
[Шаблоны сущностей](#0.2__Toc253429281 "_Toc253429281")  
[Новые шаблоны полей для URL-адреса и адреса электронной почты](#0.2__Toc253429282 "_Toc253429282")  
[Создание связи с элементом управления DynamicHyperLink](#0.2__Toc253429283 "_Toc253429283")  
[Поддержка наследования в модели данных](#0.2__Toc253429284 "_Toc253429284")  
[Поддержка многие ко многим связи (только для Entity Framework)](#0.2__Toc253429285 "_Toc253429285")  
[Новые атрибуты для управления отображением и поддержки перечислений](#0.2__Toc253429286 "_Toc253429286")  
[Улучшенная поддержка фильтров](#0.2__Toc253429287 "_Toc253429287")

**[Разработка Web усовершенствования для Visual Studio 2010](#0.2__Toc253429288 "_Toc253429288")**  
[Улучшенная совместимость CSS](#0.2__Toc253429289 "_Toc253429289")  
[HTML и JavaScript фрагменты](#0.2__Toc253429290 "_Toc253429290")  
[Усовершенствования IntelliSense для JavaScript](#0.2__Toc253429291 "_Toc253429291")

**[Веб-развертывания приложений с помощью Visual Studio 2010](#0.2__Toc253429292 "_Toc253429292")**  
[Веб-упаковки](#0.2__Toc253429293 "_Toc253429293")  
[Преобразования Web.config](#0.2__Toc253429294 "_Toc253429294")  
[Развертывание базы данных](#0.2__Toc253429295 "_Toc253429295")  
[Публикация одним щелчком для веб-приложений](#0.2__Toc253429296 "_Toc253429296")  
[Ресурсы](#0.2__Toc253429297 "_Toc253429297")

**[Disclaimer](#0.2__Toc253429298 "_Toc253429298")**

<a id="0.2__Toc224729018"></a><a id="0.2__Toc253429238"></a><a id="0.2__Toc243304612"></a>

## <a name="core-services"></a>Базовые службы

ASP.NET 4 содержит множество улучшений в базовых служб ASP.NET, например кэширование вывода и хранение состояния сеанса.

<a id="0.2__Toc243304613"></a><a id="0.2__Toc253429239"></a><a id="0.2__Toc224729019"></a>

### <a name="webconfig-file-refactoring"></a>Файл Web.config рефакторинга

`Web.config` Файл, содержащий конфигурацию для веб-приложения, значительно вырос за последние несколько версий платформы .NET Framework, будут добавлены новые возможности, такие как Ajax, маршрутизацию, а также интеграцию со службами IIS 7. Представляет собой труднее настройки или запуска нового веб-приложения без таких средств, как Visual Studio. Основные элементы конфигурации в платформы .NET Framework 4, были перемещены в `machine.config` файл и приложения теперь наследуют эти параметры. Это позволяет `Web.config` файл в приложениях ASP.NET 4 остается пустым или содержать только следующие строки, указывающие для Visual Studio версии framework, предназначен для приложения:

[!code-xml[Main](overview/samples/sample1.xml)]

<a id="0.2__Toc253429240"></a><a id="0.2__Toc243304614"></a>

### <a name="extensible-output-caching"></a>Расширяемое кэширование вывода

Со времени выпуска ASP.NET 1.0 кэширование вывода включил разработчикам хранить созданные выходные данные страницы, элементы управления и HTTP-ответы в памяти. При последующих запросах веб обработки содержимого быстрее, получая созданные выходные данные из памяти вместо повторное создание выходных данных с нуля. Однако такой подход имеет ограничение — сгенерированное содержимое всегда должно храниться в памяти и на серверах, где наблюдается большой объем трафика, память, занятая кэширование вывода может конкурировать с требованиями памяти из других частей веб-приложения.

В ASP.NET 4 добавляет точку расширяемости для кэширования выводимых данных, можно настроить один или несколько настраиваемых поставщиков кэша вывода. Поставщики кэша вывода могут использовать все механизмы хранения для хранения HTML-содержимого. Это делает возможным создание настраиваемых поставщиков кэша вывода для сохраняемости различных механизмов, которые могут включать локальных или удаленных дисках, Облачное хранилище и распределенных модулях кэширования.

Создание пользовательского поставщика кэша вывода как класс, производный от нового *System.Web.Caching.OutputCacheProvider* типа. Затем можно настроить поставщик в `Web.config` файла с помощью нового *поставщики* подразделе *outputCache* элемента, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample2.xml)]

По умолчанию в ASP.NET 4 все HTTP-ответы колонтитул страницы и элементы управления используют кэш вывода в памяти, как показано в предыдущем примере, где *defaultProvider* атрибута задано значение AspNetInternalProvider. Можно изменить поставщика кэша вывода по умолчанию, используемый для веб-приложения, указав имя другого поставщика *defaultProvider*.

Кроме того можно выбрать разные поставщики кэша вывода каждого элемента управления и каждого запроса. Самый простой способ выбрать другой поставщик кэша вывода для разных пользовательских элементов управления заключается в осуществлении декларативно с помощью нового *providerName* атрибута в директиве элемента управления, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample3.aspx)]

Указание другого поставщика кэша вывода для HTTP-запроса требует немного больше работы. Вместо декларативного указания службы, необходимо переопределить новый *GetOuputCacheProviderName* метод в `Global.asax` файл, чтобы программно указать, какой поставщик для определенного запроса. Следующий пример показывает, как это сделать.

[!code-csharp[Main](overview/samples/sample4.cs)]

С добавлением расширения поставщика кэша вывода ASP.NET 4 теперь можно применять более сложные и интеллектуальные стратегии кэширования выходных данных для веб-узлов. Например теперь имеется возможность кэшировать эти страницы «Первые 10» узла в памяти, во время кэширования страниц, которые создают меньший трафик на диске. Кроме того можно кэшировать все изменяющиеся комбинации для отображаемой страницы, но использовать распределенный кэш, чтобы освободить ресурсы памяти интерфейсных веб-серверов.

<a id="0.2__Toc224729020"></a><a id="0.2__Toc253429241"></a><a id="0.2__Toc243304615"></a>

### <a name="auto-start-web-applications"></a>Автоматический запуск веб-приложений

Некоторые веб-приложения необходимо загрузить большие объемы данных или инициализировать перед обработкой первого запроса. В более ранних версиях ASP.NET в подобных случаях приходилось разработать собственные методы «пробуждения» приложения ASP.NET и затем размещать код инициализации *приложения\_нагрузки* метод в `Global.asax` файл.

Новая функция масштабируемости с именем *автозапуска* , напрямую адресов доступен этот сценарий Если ASP.NET 4 работает со службами IIS 7.5 в Windows Server 2008 R2. Функция автозапуска позволяет управлять запуском пула приложений, инициализацией приложения ASP.NET и приемом HTTP-запросов.

> [!NOTE] 
> 
> Модуль прогрева приложений IIS для IIS 7.5
> 
> Группой IIS был выпущен первый тестовая бета-версия модуля прогрева приложения для IIS 7.5. Это делает прогрев приложениях даже проще, чем описано выше. Вместо написания специального кода, укажите URL-адреса ресурсов для выполнения до веб-приложение принимает запросы от сети. Этот период прогрева происходит во время запуска службы IIS (Если вы настроили пула приложений IIS как *AlwaysRunning*) и при перезапуске рабочего процесса IIS. Во время очистки старый рабочий процесс IIS продолжает выполнять запросы, пока не будет вновь порожденном рабочий процесс является полностью активированию, чтобы в приложениях, возникать не прерывается или других проблем из-за unprimed кэшей. Обратите внимание, что этот модуль работает с любой версии ASP.NET, начиная с версии 2.0.
> 
> Дополнительные сведения см. в разделе [Подготовка приложений](https://www.iis.net/extensions/applicationwarmup%20on%20the%20IIS.net) на сайте IIS.net. Пошаговое руководство показывает, как использовать функцию прогрева см. в разделе [Приступая к работе с модуль прогрева приложений IIS 7.5](https://www.iis.net/learn/manage) на сайте IIS.net.


Чтобы использовать функцию автозапуска, администратор служб IIS задает пул приложений в IIS 7.5 для автоматического запуска, используя следующую конфигурацию в `applicationHost.config` файла:

[!code-xml[Main](overview/samples/sample5.xml)]

Поскольку один пул приложений может содержать несколько приложений, можно указать отдельные приложения для автоматического запуска, используя следующую конфигурацию в `applicationHost.config` файла:

[!code-xml[Main](overview/samples/sample6.xml)]

При запуске сервера IIS 7.5 холодного запуска или при перезапуске отдельного пула приложений IIS 7.5 использует эти сведения в `applicationHost.config` файл, чтобы определить, какие приложения необходимо Web запускаться автоматически. Для каждого приложения, помеченные для автоматического запуска IIS 7.5 отправляет запрос ASP.NET 4 для запуска приложения в состоянии, в течение которого приложение временно не принимает HTTP-запросов. Если он находится в этом состоянии, ASP.NET создает экземпляр типа, определяемого *serviceAutoStartProvider* атрибут (как показано в предыдущем примере) и вызывает открытую точку входа.

При создании типа управляемого автозапуска с необходимая точка входа по *IProcessHostPreloadClient* интерфейс, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample7.cs)]

После инициализации ваш код выполняется в *предварительной* метод и метод возвращает, приложения ASP.NET будет готов к обработке запросов.

С добавлением автозапуска IIS.5 и ASP.NET 4 теперь имеют четко определенные подход для выполнения инициализации ресурсоемкие приложения до обработки первого HTTP-запроса. Например можно использовать новые функции автозапуска для инициализации приложения и сообщить подсистему балансировки нагрузки, что приложение не инициализирована и готова принимать трафик HTTP.

<a id="0.2__Toc224729021"></a><a id="0.2__Toc253429242"></a><a id="0.2__Toc243304616"></a>

### <a name="permanently-redirecting-a-page"></a>Окончательное перемещение страницы

Это распространенная операция в веб-приложений на страницы и другое содержимое вокруг с течением времени перемещаются, что может привести к накопление устаревших ссылок в поисковых системах. В ASP.NET, разработчики обрабатывают запросы на старые URL-адреса с помощью команды *Response.Redirect* метод переслать запрос на новый URL-адрес. Тем не менее *перенаправления* метод отправляет ответ HTTP 302 найден (Временное перенаправление), что приводит к дополнительных HTTP кругового пути при обращении пользователей к старые URL-адреса.

Добавляет новый ASP.NET 4 *RedirectPermanent* вспомогательный метод, который позволяет легко проблема HTTP 301 перемещено навсегда ответов, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample8.cs)]

URL-адрес, связанный с содержимым, которое позволяет избежать ненужных кругового пути, для временного перенаправления браузера сохранит поисковые системы и прочие агенты пользователя, которые распознают постоянное перенаправление.

<a id="0.2__Toc224729022"></a><a id="0.2__Toc253429243"></a><a id="0.2__Toc243304617"></a>

### <a name="shrinking-session-state"></a>Сжатие состояния сеанса

ASP.NET предоставляет два варианта по умолчанию для хранения состояния сеанса в веб-ферме: поставщик состояния сеанса, который вызывает сервер состояния сеанса вне процесса и поставщик состояния сеанса, который хранит данные в базе данных Microsoft SQL Server. Тем, что оба варианта хранения сведений о состоянии вне рабочего процесса веб-приложения, состояние сеанса должен сериализовать перед отправкой во внешнее хранилище. В зависимости от того, какой объем данных, разработчик сохраняет в состоянии сеанса размер сериализованных данных может возрасти.

В ASP.NET 4 появился новый параметр сжатия для обоих видов поставщики состояния сеанса вне процесса. Когда *compressionEnabled* имеет значение параметра конфигурации, показано в следующем примере *true*, ASP.NET будет сжатия (и распаковки) сериализованное состояние сеанса с помощью .NET Framework  *System.IO.Compression.GZipStream* класса.

[!code-xml[Main](overview/samples/sample9.xml)]

С добавлением нового атрибута для простой `Web.config` файла приложения с достаточного количества циклов ЦП на веб-серверах и добиться значительного уменьшения размера сериализованных данных состояния сеанса.

<a id="0.2__Toc253429244"></a><a id="0.2__Toc243304618"></a>

### <a name="expanding-the-range-of-allowable-urls"></a>Расширение диапазона допустимых URL-адресов

В ASP.NET 4 реализованы новые возможности увеличения размера URL-адреса приложения. Предыдущие версии ASP.NET ограниченного URL-адрес пути длиной до 260 символов, в зависимости от ограничения путь к файлу NTFS. В ASP.NET 4, вы можете увеличить (или уменьшить) этого ограничения для приложений, с использованием двух новых *httpRuntime* атрибуты конфигурации. В следующем примере показано эти новые атрибуты.

[!code-xml[Main](overview/samples/sample10.xml)]

Чтобы разрешить длиннее или короче пути (часть URL-адреса, который не поддерживает протокол, имя сервера и строки запроса), измените *[maxUrlLength](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.maxurllength.aspx)* атрибута. Чтобы разрешить строки длиннее или короче запросов, измените значение *[maxQueryStringLength](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.maxquerystringlength.aspx)* атрибута.

В ASP.NET 4 также позволяет настроить символы, которые используются при проверке символов URL-адрес. Когда ASP.NET находит недопустимый знак в пути, URL-адреса, он отклоняет запрос и выдает сообщение об ошибке HTTP 400. В предыдущих версиях ASP.NET проверки символов URL-адреса были ограничены на фиксированный набор символов. В ASP.NET 4 можно настроить набор допустимых символов с помощью нового *requestPathInvalidChars* атрибут *httpRuntime* элемента конфигурации, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample11.xml)]

По умолчанию <em>requestPathInvalidChars</em> атрибута определяет восемь символов как недопустимое. (В строке, которая назначается <em>requestPathInvalidChars</em> по умолчанию<em>,</em>меньше, чем (&lt;), больше (&gt;) и амперсанд (&amp;), символы в кодировке, так как `Web.config` файл представляет собой XML-файл.) При необходимости можно настроить набор недопустимых символов.

> [!NOTE]
> Обратите внимание, ASP.NET 4 всегда отклоняет URL-пути, содержащие символы в диапазоне от 0x00 до 0x1F ASCII, так как недопустимые символы URL-адрес, определенный в RFC 2396 пересматриваются ([http://www.ietf.org/rfc/rfc2396.txt](http://www.ietf.org/rfc/rfc2396.txt)). В версиях Windows Server под управлением IIS 6 или более поздней версии, драйвер устройства протокола http.sys автоматически отклоняет URL-адреса с использованием таких символов.


<a id="0.2__Toc253429245"></a><a id="0.2__Toc243304619"></a>

### <a name="extensible-request-validation"></a>Расширяемая проверка запросов

Проверка запросов ASP.NET выполняет входящие данные HTTP-запроса для строк, которые широко используются в атаках межсайтовых сценариев (XSS). При обнаружении потенциальных строк XSS проверка запросов помечает подозрительную строку и возвращает сообщение об ошибке. Встроенная проверка запросов возвращает ошибку, только в том случае, когда он находит наиболее распространенные строк, используемых в атаках XSS. Предыдущие попытки создания более сложные проверки XSS завершился слишком много ложных срабатываний. Однако клиентам может потребоваться проверка запросов, более строгую или наоборот, может возникнуть необходимость намеренно снизить XSS проверок для отдельных страниц или для некоторых типов запросов.

В ASP.NET 4 функция проверки запросов сделана расширяемой, чтобы можно было использовать логики проверки пользовательских запросов. Чтобы расширить проверку запросов, создайте класс, производный от нового *System.Web.Util.RequestValidator* тип и настроить приложение (в *httpRuntime* раздел `Web.config`файл) для использования пользовательского типа. Приведенный ниже показано, как настроить класс пользовательского проверку запросов:

[!code-xml[Main](overview/samples/sample12.xml)]

Новый *requestValidationType* атрибута необходима Стандартная строка идентификатор типа .NET Framework, указывает класс, который предоставляет проверку пользовательских запросов. Для каждого запроса ASP.NET вызывает пользовательский тип, для обработки каждой части входящие данные HTTP-запроса. Входящего URL-адреса всех заголовков HTTP (файлы cookie и пользовательские заголовки) и тела сообщения доступны для проверки с помощью класса проверки пользовательского запроса, подобную показанной в следующем примере:

[!code-csharp[Main](overview/samples/sample13.cs)]

Для случаев, где не требуется проверять часть входящего HTTP-данных, класс проверки запроса может переключиться на позволяют ASP.NET проверку по умолчанию запрос запуска, просто вызвав *базового. IsValidRequestString.*

<a id="0.2__Toc253429246"></a><a id="0.2__Toc243304620"></a>

### <a name="object-caching-and-object-caching-extensibility"></a>Кэширование объектов и расширяемость кэширования объектов

С момента первого выпуска, ASP.NET включила кэша мощные объектов в памяти (*System.Web.Caching.Cache*). Реализация кэша стала настолько популярной, используемый в веб-приложений. Однако это неудобно для приложения Windows Forms и WPF, чтобы включить ссылку на `System.Web.dll` просто для того, чтобы иметь возможность использовать кэш объектов ASP.NET.

Чтобы обеспечить доступность кэширования для всех приложений, .NET Framework 4 появилась новая сборка, новое пространство имен, некоторые базовые типы и конкретная реализация кэширования. Новый `System.Runtime.Caching.dll` сборка содержит новый API кэширования в *System.Runtime.Caching* пространства имен. Пространство имен включает два основных набора классов:

- Абстрактные типы, которые образуют основу для построения пользовательской реализации кэширования любого типа.
- Реализация кэша конкретных объектов в памяти ( *System.Runtime.Caching.MemoryCache* класса).

Новый *MemoryCache* класс очень похож на кэш ASP.NET, и он использует большую часть логики подсистемы внутренний кэш с ASP.NET. Несмотря на то что общедоступных API кэширования в *System.Runtime.Caching* были обновлены для поддержки разработки пользовательских реализаций кэша при использовании ASP.NET *кэша* объекта, вы найдете знакомы основные понятия в новые API.

Подробное обсуждение нового *MemoryCache* класс и поддерживающие базовые интерфейсы API, потребуется всего документа. Тем не менее приведенный ниже дает представление о принципах работы нового кэша API. Пример был написан для приложения Windows Forms, без какой-либо зависимостью на `System.Web.dll`.

[!code-csharp[Main](overview/samples/sample14.cs)]

<a id="0.2__Toc253429247"></a><a id="0.2__Toc243304621"></a>

### <a name="extensible-html-url-and-http-header-encoding"></a>Расширяемый HTML, URL-адреса и кодировку заголовка HTTP

В ASP.NET 4 можно создать пользовательские процедуры кодирования для следующих распространенных задач кодирования текста:

- HTML encoding.
- Кодировка URL-адрес.
- Кодировка атрибута HTML.
- Кодирование исходящих заголовков HTTP.

Можно создать пользовательский кодировщик путем наследования от нового *System.Web.Util.HttpEncoder* типа и последующей настройки ASP.NET для использования пользовательского типа в *httpRuntime* раздел `Web.config` файла, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample15.xml)]

После настройки пользовательского кодировщика ASP.NET автоматически вызывает реализацию пользовательского кодировщика всякий раз, когда открытых методов кодирования *System.Web.HttpUtility* или *System.Web.HttpServerUtility* классы называются. Это позволяет одной части веб-разработки команды создать пользовательский кодировщик, который реализует интенсивное кодирование символов, а остальная часть команды веб-разработки продолжается использование общедоступных API ASP.NET. Централизованная настройка пользовательского кодировщика в *httpRuntime* элемента, можно гарантировать, что все вызовы кодирования текста из общедоступных API ASP.NET, маршрутизируются через пользовательский кодировщик.

<a id="0.2__Toc253429248"></a><a id="0.2__Toc243304622"></a>

### <a name="performance-monitoring-for-individual-applications-in-a-single-worker-process"></a>Наблюдение за производительностью для отдельных приложений в одном рабочем процессе

Чтобы увеличить число веб-сайтов, которые могут быть размещены на одном сервере, многие поставщики услуг размещения выполнять несколько приложений ASP.NET в одном рабочем процессе. Однако если несколько приложений используют один общий рабочий процесс, трудно для администраторов сервера для идентификации отдельного приложения, который испытывает проблемы.

ASP.NET 4 поддерживает новые функции наблюдения за ресурсами, представленную в среде CLR. Чтобы включить эту функцию, можно добавить следующий фрагмент конфигурации XML для `aspnet.config` файла конфигурации.

[!code-xml[Main](overview/samples/sample16.xml)]

> [!NOTE]
> Примечание `aspnet.config` файл находится в каталоге, где установлена платформа .NET Framework. Это не `Web.config` файла.


Когда *appDomainResourceMonitoring* функция включена, две новые счетчики производительности доступны в категории производительности» приложения ASP.NET «: *% загруженности процессора управляемого* и  *Управляемой памяти используется*. Эти счетчики производительности использоваться новая функция управления ресурсами домена приложения среды CLR для отслеживания приблизительной загрузки ЦП и использования управляемой памяти по отдельным приложениям ASP.NET. В результате с ASP.NET 4 Администраторы получают более детальное представление потребления ресурсов отдельными приложениями, выполняющимися в одном рабочем процессе.

<a id="0.2__Toc253429249"></a><a id="0.2__Toc243304623"></a>

### <a name="multi-targeting"></a>Нацеливание на несколько версий

Можно создать приложение, предназначенное для конкретной версии платформы .NET Framework. В ASP.NET 4, новый атрибут в *компиляции* элемент `Web.config` файл позволяет ориентированных на .NET Framework 4 и более поздних версий. Если вы явно требуемой версии .NET Framework, и включить необязательные элементы в `Web.config` файла, например записи для *system.codedom*, эти элементы должны быть правильными для .NET Framework 4. (Если .NET Framework 4 не предназначенных явным образом, определяется на основе отсутствия записи в целевой версии .NET framework `Web.config` файл.)

В следующем примере показано использование *targetFramework* атрибута в *компиляции* элемент `Web.config` файла.

[!code-xml[Main](overview/samples/sample17.xml)]

Обратите внимание на следующее предназначенных для конкретной версии платформы .NET Framework:

- В пуле приложений .NET Framework 4, системе построения ASP.NET предполагает .NET Framework 4 как целевой объект, если `Web.config` файл не содержит *targetFramework* атрибута или если `Web.config` отсутствует файл. (Может потребоваться внести изменения кода в приложение, чтобы сделать ее выполняться в .NET Framework 4).
- При включении *targetFramework* атрибут и если *system.codeDom* элемент определен в `Web.config` файл, этот файл должен содержать правильные записи для .NET Framework 4.
- Если вы используете *aspnet\_компилятора* для предварительной компиляции приложения (например, в среде построения), необходимо использовать правильную версию *aspnet\_компилятора* Команда для целевой платформы. Используйте компилятор, поставляемый с .NET Framework 2.0 (% WINDIR%\Microsoft.NET\Framework\v2.0.50727) для компиляции в .NET Framework 3.5 и более ранних версиях. Компилятор, который поставляется с платформой .NET Framework 4 можно используете для компиляции приложения, созданные с помощью этой структуры или более поздних версиях.
- Во время выполнения, компилятор использует последние сборки .NET framework, установленных на компьютере (и, следовательно, в глобальном кэше СБОРОК). Если позже выполнено обновление для платформы (например, гипотетической версии 4.1 установлена), вы сможете использовать функции в более новой версии платформы, даже если *targetFramework* атрибут предназначен для более ранней версии (например, 4.0). (Тем не менее, во время разработки в Visual Studio 2010 или при использовании *aspnet\_компилятора* команды, с помощью новой функции платформы приведет к ошибкам компилятора).

<a id="0.2__Toc224729023"></a><a id="0.2__Toc253429250"></a><a id="0.2__Toc243304624"></a>

## <a name="ajax"></a>Ajax

<a id="0.2__Toc253429251"></a><a id="0.2__Toc243304625"></a>

### <a name="jquery-included-with-web-forms-and-mvc"></a>jQuery в комплекте с веб-формы и MVC

Шаблоны Visual Studio для веб-форм и MVC включает библиотеку jQuery с открытым исходным кодом. При создании нового веб-сайта или проекта, создается папка сценариев со следующими файлами 3:

- jQuery-1.4.1.js — удобное для восприятия, неминифицированная версия библиотеки jQuery.
- jQuery-14.1.min.js — уменьшенная версия библиотеки jQuery.
- jQuery-1.4.1-vsdoc.js-файл документации Intellisense для библиотеки jQuery.

При разработке приложения, включите unminified версии jQuery. Включите уменьшенный версии jQuery для производственных приложений.

Например на следующей странице веб-форм показывает, как можно использовать jQuery, чтобы изменить цвет фона для элемента управления ASP.NET TextBox на желтый, когда они имеют фокус.

[!code-aspx[Main](overview/samples/sample18.aspx)]

<a id="0.2__Toc253429252"></a><a id="0.2__Toc243304626"></a>

### <a name="content-delivery-network-support"></a>Поддержка сети доставки содержимого

Microsoft Ajax доставки содержимого сети (CDN) позволяет без труда добавлять на веб-приложений ASP.NET Ajax и jQuery сценариев. Например, можно запустить с помощью библиотеки jQuery, добавив `<script>` тег, чтобы на странице, которая ссылается на Ajax.microsoft.com следующим образом:

[!code-html[Main](overview/samples/sample19.html)]

Используя преимущества сети Microsoft Ajax CDN, может значительно повысить производительность приложений Ajax. Содержимое сети Microsoft Ajax CDN кэшируется на серверах, расположенных по всему миру. Кроме того сети Microsoft Ajax CDN позволяет браузерам повторно использовать файлы JavaScript для веб-сайтов, которые находятся в разных доменах.

Microsoft Ajax сеть доставки содержимого поддерживает SSL (HTTPS), на случай необходимости обслуживания веб-страницы, с помощью протокола SSL.

Реализует переход на резервный ресурс, если CDN недоступен. Проверьте этот резервный механизм.

Дополнительные сведения о сети Microsoft Ajax CDN, посетите следующий веб-сайт:

[https://www.asp.net/ajaxlibrary/CDN.ashx](../../ajax/cdn/overview.md)

ASP.NET ScriptManager поддерживает сети Microsoft Ajax CDN. Путем задания одного свойства, свойство EnableCdn можно получить все файлы JavaScript платформы ASP.NET из CDN:

[!code-aspx[Main](overview/samples/sample20.aspx)]

Свойство EnableCdn присвоено значение true, платформа ASP.NET получает всех файлов JavaScript платформы ASP.NET из сети CDN, включая все файлы JavaScript, используемый для проверки и UpdatePanel. Задание этого свойства один может иметь значительное влияние на производительность веб-приложения.

Можно задать путь CDN для файлов JavaScript с помощью указав. Свойство CdnPath указывает путь к CDN, когда свойство EnableCdn установлен в значение true:

[!code-csharp[Main](overview/samples/sample21.cs)]

<a id="0.2__Toc253429253"></a><a id="0.2__Toc243304627"></a>

### <a name="scriptmanager-explicit-scripts"></a>ScriptManager явную скриптов

В прошлом при использовании ASP.NET ScriptManger затем было необходимо загрузить всю монолитные библиотеки ASP.NET Ajax. Используя преимущества нового свойства ScriptManager.AjaxFrameworkMode, можно управлять точно загружаются какие компоненты библиотеки ASP.NET Ajax и загружать только те компоненты библиотеки ASP.NET Ajax, которая может потребоваться.

Свойство ScriptManager.AjaxFrameworkMode можно задать следующие значения:

- Включена — Указывает, элемент управления ScriptManager автоматически включает файле MicrosoftAjax.js скрипт, который представляет собой файл объединенных сценария каждого сценария framework core (устаревшее поведение).
- Отключена — Указывает, отключены ли все функции скрипта Microsoft Ajax и том, что элемент управления ScriptManager ссылается любых скриптов автоматически.
- Явные--Указывает, будет явным образом включать ссылки на скрипты для отдельных framework core сценария файла, который требуется на странице и, будет включать ссылки на необходимые зависимости.

Например если свойство AjaxFrameworkMode значение Explicit можно указать определенный сценарии компонента ASP.NET Ajax, которые требуются:

[!code-aspx[Main](overview/samples/sample22.aspx)]

<a id="0.2__The_DataView_Control"></a><a id="0.2__The_DataContext_and"></a><a id="0.2__Refactoring_the_Microsoft"></a><a id="0.2__Toc224729032"></a><a id="0.2__Toc253429256"></a><a id="0.2__Toc243304630"></a>

## <a name="web-forms"></a>Веб-формы

Web Forms был основной функцией в ASP.NET с момента выпуска ASP.NET 1.0. Множество улучшений, находящихся в этой области для ASP.NET 4, в том числе следующие:

- Возможность установки *meta* тегов.
- Больший контроль над состояния представления.
- Более простые способы работы с возможностями браузера.
- Поддержка использования маршрутизации ASP.NET с веб-форм.
- Больший контроль над созданных кодов.
- Возможность сохранения выбранных строк в элементах управления данными.
- Больший контроль над отображаемого HTML-кода в *FormView* и *ListView* элементов управления.
- Поддержка фильтрации для элементов управления источниками данных.

<a id="0.2__Toc224729033"></a><a id="0.2__Toc253429257"></a><a id="0.2__Toc243304631"></a>

### <a name="setting-meta-tags-with-the-pagemetakeywords-and-pagemetadescription-properties"></a>Параметр мета-теги с Page.MetaKeywords и Page.MetaDescription свойства

В ASP.NET 4 добавляет два свойства для *страницы* класса *MetaKeywords* и *MetaDescription*. Эти свойства представляют соответствующие *meta* теги на странице, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample23.aspx)]

Эти свойства работают так же, как страницы *заголовок* свойство. Они следуют следующим правилам.

1. При наличии не *meta* теги в *head* элемент, соответствующий имена свойств (то есть, имя = «ключевые слова» для *Page.MetaKeywords* и имя = «описание» для  *Page.MetaDescription*, это значит, что эти свойства не задано), *meta* теги будет добавлен на страницу при его отрисовке.
2. Если уже есть *meta* тегов с этими именами, эти свойства выступать в качестве методов для содержимого существующих тегов get и set.

Эти свойства можно задать во время выполнения, которая позволяет получать содержимое из базы данных или другого источника и которая позволяет задать теги динамически, описывающих рассчитан на определенной странице.

Можно также задать *ключевые слова* и *описание* свойства в *@ Page* директив в верхней части разметку страницы Web Forms, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample24.aspx)]

При этом будут переопределены *meta* содержимое (если таковые имеются) уже объявлен в странице тега.

Содержимое описания *meta* тег используются для улучшения поиска со списком предварительных версий в Google. (Дополнительные сведения см. в разделе [повысить фрагменты кода с помощью метаданных описание преобразование](http://googlewebmastercentral.blogspot.com/2007/09/improve-snippets-with-meta-description.html) Google мастеру центра блоге.) Google и поиска Windows Live не использовать содержимое ключевых слов для любого элемента, но может другие поисковые системы. Дополнительные сведения см. в разделе [советы ключевые слова Meta](http://www.searchengineguide.com/richard-ball/meta-keywords-a.php) на обработчик руководство по веб-сайт поиска.

Эти новые свойства — это простая функция, но можно сохранять из требования по добавлению их вручную или написать собственный код для создания *meta* тегов.

<a id="0.2__Toc224729034"></a><a id="0.2__Toc253429258"></a><a id="0.2__Toc243304632"></a>

### <a name="enabling-view-state-for-individual-controls"></a>Включение состояния представления для отдельных элементов управления

По умолчанию состояния просмотра включена для страницы с результатами, что каждый элемент управления на страницу потенциально сохраняет состояние представления, даже если он не является обязательным для приложения. Данные состояния представления включается в разметке, приводит к возникновению ошибки на страницу, а также увеличивает время, необходимое для отправки страницы клиенту и получения ответа. Хранение нескольких состояния представления, чем это требуется может привести к существенному снижению производительности. В более ранних версиях ASP.NET разработчикам может отключить состояние просмотра для отдельных элементов управления, чтобы сократить размер страницы, но было нужно явно для отдельных элементов управления. В ASP.NET 4 включают серверные элементы управления *ViewStateMode* свойство, которое позволяет отключить состояние представления по умолчанию и затем включите ее только для элементов управления, требующих этого на странице.

*ViewStateMode* свойство принимает перечисление, которое имеет три значения: *включено*, *отключено*, и *наследовать*. *Включить* позволяет просматривать состояние для данного элемента управления и любые его дочерние элементы, настроенные для *наследовать* или, ничего не установлен. *Отключенные* состояние просмотра отключено и *наследовать* указывает, что элемент управления использует *ViewStateMode* из родительского элемента управления.

В следующем примере показан способ *ViewStateMode* работает. Разметка и код для элементов управления, на следующей странице включают значения для *ViewStateMode* свойства:

[!code-aspx[Main](overview/samples/sample25.aspx)]

Как видите, этот код отключает состояния представления для элемента управления прототип 1. Значение этого свойства наследуется label1 дочернего элемента управления (*наследовать* является значением по умолчанию для *ViewStateMode* для элементов управления.) и поэтому сохраняет ни одно состояние представления. В элементе управления PlaceHolder2 *ViewStateMode* равно *включено*, поэтому данное свойство наследуется label2 и сохраняет состояние представления. При первой загрузке страницы *текст* свойства обоих *метка* элементы управления задана строка «[DynamicValue]».

Эти параметры действует так, при загрузке страницы в первый раз, выводятся следующие данные в браузере:

Отключено `: [DynamicValue]`

Включен:`[DynamicValue]`

После обратной передачи Однако выводятся следующие данные:

Отключено `: [DeclaredValue]`

Включен:`[DynamicValue]`

Управления label1 (которого *ViewStateMode* имеет значение *отключено*) не имеет сохраняется значение, оно было задано значение в коде. Однако управления label2 (которого *ViewStateMode* имеет значение *включено*) сохраняются состояния.

Можно также задать *ViewStateMode* в *@ Page* директив, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample26.aspx)]

*Страницы* класс является просто другим элементом управления; он действует в качестве родительского элемента управления для всех других элементов управления на странице. Значение по умолчанию *ViewStateMode* — *включено* для экземпляров *страницы*. Так как элементы управления в *наследовать*, элементы управления будут наследовать *включено* значение свойства, если не задать *ViewStateMode* на уровне страницы или элемента управления.

Значение *ViewStateMode* свойство определяет, если состояние представления поддерживается только в том случае, если *EnableViewState* свойству *true*. Если *EnableViewState* свойству *false*, состояние представления не будет поддерживаться даже в том случае, если *ViewStateMode* равно *включено*.

Рекомендуется использовать для этой функции — с *ContentPlaceHolder* элементов управления в главные страницы, где можно задать *ViewStateMode* для *отключено* для шаблона страницы, а затем включите ее по отдельности для *ContentPlaceHolder* элементов управления, которые в свою очередь содержать элементы управления, которые требуется просмотреть состояние.

<a id="0.2__Toc224729035"></a><a id="0.2__Toc253429259"></a><a id="0.2__Toc243304633"></a>

### <a name="changes-to-browser-capabilities"></a>Изменения возможностей браузера

ASP.NET определяет возможности браузера, который пользователь использует для просмотра веб-узла с помощью называемую *возможности браузера*. Представлены возможности браузера *HttpBrowserCapabilities* объекта (предоставляемые *Request.Browser* свойство). Например, можно использовать *HttpBrowserCapabilities* объектом, чтобы определить, поддерживает ли тип и версия текущего браузера определенную версию JavaScript. Можно также использовать *HttpBrowserCapabilities* объектом, чтобы определить, является ли, что запрос поступил от мобильного устройства.

*HttpBrowserCapabilities* объекта определяется в нескольких файлах определения браузера. Эти файлы содержат сведения о возможностях конкретного браузеров. В ASP.NET 4 этих файлах определения браузеров были обновлены, содержащие сведения о недавно введенные браузерах и устройствах, таких как Google Chrome, справочные материалы в смартфонов BlackBerry движения и Apple iPhone.

В следующем списке приведены браузера новые файлы определений:

- *blackberry.browser*
- *chrome.browser*
- *Default.browser*
- *firefox.browser*
- *gateway.browser*
- *generic.browser*
- *ie.browser*
- *iemobile.browser*
- *iphone.browser*
- *opera.browser*
- *safari.browser*

#### <a name="using-browser-capabilities-providers"></a>С помощью поставщики возможностей браузера

В ASP.NET версии 3.5 с пакетом обновления 1, можно определить возможности браузера, с одним из следующих способов:

- На уровне компьютера, создать или обновить `.browser` XML-файл в следующую папку:

- [!code-console[Main](overview/samples/sample27.cmd)]

- После определения возможности браузера, вы выполните следующую команду из командной строки Visual Studio для перестроения сборка возможностей браузера и добавить его в глобальный кэш сборок:

- [!code-console[Main](overview/samples/sample28.cmd)]

- Для отдельного приложения, создайте `.browser` файл в приложении `App_Browsers` папки.

Эти подходы требует изменения XML-файлов, и для изменения на уровне компьютера, необходимо перезапустить приложение после запуска aspnet\_regbrowsers.exe процесса.

В ASP.NET 4 добавлена функция под названием *поставщики возможностей браузера*. Как следует из названия, это предназначена для создания поставщика, который в свою очередь позволяет использовать собственный код для определения возможностей браузера.

На практике разработчики часто не определяют возможности пользовательского браузера. Файлы браузера являются трудно обновление, процесс обновления их является довольно сложной и XML-синтаксис `.browser` файлов может быть сложно использовать и определить. Что бы делает этот процесс намного проще — при наличии общего синтаксиса определения браузера или базы данных, которая содержит обновленные определения браузера или даже веб-службу для такой базы данных. Новая функция поставщиков возможностей браузера обеспечивает реализацию этих сценариев возможно и практические для сторонних разработчиков.

Существует два основных подхода для с помощью новой функции поставщика возможностей браузера ASP.NET 4: расширение возможностей браузера ASP.NET функциональной возможности определения или полной замены. В следующих разделах сначала как заменить функциональные возможности, а затем расширить его.

#### <a name="replacing-the-aspnet-browser-capabilities-functionality"></a>Замена функций возможности браузера ASP.NET

Чтобы полностью заменить функциональной возможности определения для браузера возможности ASP.NET, выполните следующие действия.

1. Создать класс поставщика, который является производным от *HttpCapabilitiesProvider* и переопределяющее *GetBrowserCapabilities* метода, как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample29.cs)]

    В данном примере кода создается класс *HttpBrowserCapabilities* объекта, указав только с именем браузера и установив эту возможность для MyCustomBrowser возможности.
2. Зарегистрируйте поставщик с приложением. 

    Чтобы использовать поставщик с помощью приложения, необходимо добавить *поставщика* атрибут *browserCaps* статьи `Web.config` или `Machine.config` файлов. (Можно также определить атрибуты поставщика в *расположение* элемент для определенных каталогов в приложении, например в папке для определенного мобильного устройства.) Следующий пример показывает, как задать *поставщика* атрибут в файле конфигурации:

    [!code-xml[Main](overview/samples/sample30.xml)]

    Другой способ зарегистрировать новое определение возможностей браузера является использование кода, как показано в следующем примере:

    [!code-csharp[Main](overview/samples/sample31.cs)]

    Этот код должен выполняться *приложения\_запустить* событие `Global.asax` файла. Любые изменения в *BrowserCapabilitiesProvider* класса должно произойти до выполнения любого кода в приложении, чтобы убедиться, что кэш остается в состоянии, допустимом для разрешенных *HttpCapabilitiesBase* объекта.

#### <a name="caching-the-httpbrowsercapabilities-object"></a>Кэширование объектов HttpBrowserCapabilities

В предыдущем примере имеется одна проблема, которая означает, что код будет работать при каждом вызове пользовательского поставщика для получения *HttpBrowserCapabilities* объекта. Это может произойти несколько раз во время выполнения каждого запроса. В примере кода для поставщика не очень много операций. Тем не менее, если код в настраиваемого поставщика выполняет значительный объем работы в заказ для получения *HttpBrowserCapabilities* объекта, это может повлиять на производительность. Чтобы предотвратить возникновение этой ситуации, можно кэшировать *HttpBrowserCapabilities* объекта. Выполните следующие действия.

1. Создайте класс, производный от *HttpCapabilitiesProvider*, такое как в следующем примере: 

    [!code-csharp[Main](overview/samples/sample32.cs)]

    В примере кода создает ключ кэша, вызвав метод BuildCacheKey, и он возвращает длину времени кэширования, вызвав метод GetCacheTime. Затем код добавляет Разрешить *HttpBrowserCapabilities* объекта в кэш. Объект можно получить из кэша и использовать повторно на последующие запросы, которые обеспечивают использование пользовательского поставщика.
2. Зарегистрируйте поставщик с приложением, как описано в предыдущей процедуре.

#### <a name="extending-aspnet-browser-capabilities-functionality"></a>Расширение функциональных возможностей возможности браузера ASP.NET

В предыдущем разделе рассматривались как для создания нового *HttpBrowserCapabilities* объекта в ASP.NET 4. Можно также расширить функциональность возможности браузера ASP.NET путем добавления новых определений возможностей браузера для тех, которые уже находятся в ASP.NET. Это можно сделать без использования XML-определений браузера. В следующей процедуре показан способ.

1. Создайте класс, производный от *HttpCapabilitiesEvaluator* и переопределяющее *GetBrowserCapabilities* метода, как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample33.cs)]

    Этот код сначала использует функциональность возможности браузера ASP.NET с целью определить браузер. Тем не менее, если браузер не определяется на основе данных, определенные в запросе (то есть, если *браузера* свойство *HttpBrowserCapabilities* объект имеет строку «Unknown»), этот код вызывает пользовательский поставщик (MyBrowserCapabilitiesEvaluator) для идентификации обозревателя.
2. Зарегистрируйте поставщик с приложением, как описано в предыдущем примере.

#### <a name="extending-browser-capabilities-functionality-by-adding-new-capabilities-to-existing-capabilities-definitions"></a>Расширение функциональных возможностей возможности браузера, добавление новых возможностей в существующие возможности определения

Помимо создания поставщика определение пользовательского обозревателя и динамического создания новых определений браузера можно расширить существующие определения браузер с дополнительными возможностями. Это позволяет использовать это определение, близок к цели, но не имеет только несколько возможностей. Для этого выполните следующие действия.

1. Создайте класс, производный от *HttpCapabilitiesEvaluator* и переопределяющее *GetBrowserCapabilities* метода, как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample34.cs)]

    В примере кода расширяет существующий ASP.NET *HttpCapabilitiesEvaluator* класс и возвращает *HttpBrowserCapabilities* объект, который соответствует определения текущего запроса с помощью следующего кода :

    [!code-csharp[Main](overview/samples/sample35.cs)]

    Код затем можно добавить или изменить функцию для этого браузера. Чтобы указать новые возможности браузера двумя способами.

    - Добавьте пару "ключ значение" в *IDictionary* объекта, представленного *возможности* свойство *HttpCapabilitiesBase* объекта. В предыдущем примере код добавляет возможность с именем мультисенсорный со значением *true*.
    - Задание свойств существующего *HttpCapabilitiesBase* объекта. В предыдущем примере, код задает *кадров* свойства *true*. Это свойство имеет метод доступа, для *IDictionary* объекта, представленного *возможности* свойство. 

        > [!NOTE]
        > Обратите внимание, эта модель применяется для любого свойства *HttpBrowserCapabilities*, включая адаптеров элементов управления.
2. Зарегистрируйте поставщик с приложением, как описано в предыдущей процедуре.

<a id="0.2__Toc224729036"></a><a id="0.2__Toc253429260"></a><a id="0.2__Toc243304634"></a>

### <a name="routing-in-aspnet-4"></a>Маршрутизация в ASP.NET 4

В ASP.NET 4 добавлена встроенная поддержка с помощью маршрутизации с помощью веб-форм. Маршрутизации позволяет настроить приложение для принятия запроса URL-адреса, которые не сопоставлены с физическими файлами. Вместо этого маршрутизации можно использовать для определения URL-адреса, были бы осмысленными для пользователей и возможность оптимизации поисковой системы (SEO) для вашего приложения. Например URL-адрес для страницы, которая отображает категории продуктов в существующее приложение может выглядеть как в следующем примере:

[!code-console[Main](overview/samples/sample36.cmd)]

С помощью маршрутизации, можно настроить приложение для приема следующий URL-адрес для отображения той же информации:

[!code-console[Main](overview/samples/sample37.cmd)]

Маршрут был доступен, начиная с ASP.NET 3.5 с пакетом обновления 1. (Пример использования маршрутизации в ASP.NET 3.5 SP1, см. в записи [с помощью маршрутизации с помощью веб-форм](http://haacked.com/archive/2008/03/11/using-routing-with-webforms.aspx "название данной записи.") в блоге Фила Хаака.) Тем не менее ASP.NET 4 содержит некоторые возможности, которые упрощают использование маршрутизации, включая следующие:

- *PageRouteHandler* класса, который является простой обработчик HTTP, который используется при определении маршрутов. Класс передает данные, запрос перенаправляется на страницу.
- Новые свойства *HttpRequest.RequestContext* и *Page.RouteData* (который является прокси для *HttpRequest.RequestContext.RouteData* объекта). Эти свойства упрощают для доступа к информации, которая передается из маршрута.
- Следующие новые построители выражений, которые определены в *System.Web.Compilation.RouteUrlExpressionBuilder* и *System.Web.Compilation.RouteValueExpressionBuilder*:
- *RouteUrl*, который предоставляет простой способ создать URL-адрес, соответствующий URL-адрес маршрута в серверном элементе управления ASP.NET.
- *RouteValue*, который предоставляет простой способ извлечения сведений из *RouteContext* объекта.
- *RouteParameter* класс, который облегчает процесс для передачи данных, содержащихся в *RouteContext* объекта на запрос для элемента управления источником данных (аналогично [ *FormParameter* ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.formparameter.aspx)).

#### <a name="routing-for-web-forms-pages"></a>Маршрут для страницы Web Forms

В следующем примере показано определение маршрута веб-форм с помощью нового *MapPageRoute* метод *маршрута* класса:

[!code-csharp[Main](overview/samples/sample38.cs)]

В ASP.NET 4 представлено *MapPageRoute* метод. Следующий пример эквивалентен определению SearchRoute, показанный в предыдущем примере, но использует *PageRouteHandler* класса.

[!code-csharp[Main](overview/samples/sample39.cs)]

Код в примере сопоставляет маршрут к физической страницы (в первый маршрут для `~/search.aspx`). Первое определение маршрута также указывает, что параметр с именем searchterm следует извлечь из URL-адрес и передается на страницу.

*MapPageRoute* метод поддерживает следующие перегрузки:

- *MapPageRoute (routeName строка, строка routeUrl, physicalFile строку, bool checkPhysicalUrlAccess)*
- *MapPageRoute (routeName строка, строка routeUrl, physicalFile строку, bool checkPhysicalUrlAccess, RouteValueDictionary значения по умолчанию)*
- *MapPageRoute (routeName строки, routeUrl строки, physicalFile строку, bool checkPhysicalUrlAccess, RouteValueDictionary значения по умолчанию, ограничения RouteValueDictionary)*

*CheckPhysicalUrlAccess* параметр указывает, нужно ли проверять права доступа для физической страницы, направляется маршрута (в данном случае search.aspx) и разрешения для входящего URL-адреса (в этом случае поиск / {searchterm}). Если значение *checkPhysicalUrlAccess* — *false*, будет проверен только разрешения входящего URL-адреса. Эти разрешения определяются в `Web.config` текстовый файл с помощью параметров примерно следующего вида:

[!code-xml[Main](overview/samples/sample40.xml)]

В примере конфигурации запрещен доступ к физической страницы `search.aspx` для всех пользователей, кроме тех, кто в роли администратора. При *checkPhysicalUrlAccess* параметра равным *true* (который является значением по умолчанию), только администраторы получают доступ к URL-адрес /search/ {searchterm}, так как search.aspx физической страницы только пользователям в этой роли. Если *checkPhysicalUrlAccess* равно *false* и узел настроен так, как показано в предыдущем примере, все прошедшие проверку подлинности пользователи получают доступ к URL-адрес /search/ {searchterm}.

#### <a name="reading-routing-information-in-a-web-forms-page"></a>Чтение информации о маршрутизации в страницу Web Forms

В коде веб-форм физической страницы, можно получить информацию, который маршрутизации извлечен из URL-адрес (или другую информацию, которая добавлена в другой объект *RouteData* объекта) с помощью два новых свойства:  *HttpRequest.RequestContext* и *Page.RouteData*. (*Page.RouteData* заключает в оболочку *HttpRequest.RequestContext.RouteData*.) В следующем примере показано, как использовать *Page.RouteData*.

[!code-csharp[Main](overview/samples/sample41.cs)]

Код извлекает значение, переданное для параметра searchterm, определенной в маршруте пример выше. Рассмотрим следующий URL-адрес запроса.

[!code-console[Main](overview/samples/sample42.cmd)]

Если этот запрос, слово «Скотт» будет проходить в `search.aspx` страницы.

#### <a name="accessing-routing-information-in-markup"></a>Доступ к сведения о маршрутизации в разметке

Метод, описанный в предыдущем разделе показано, как получить данные о маршруте в коде в страницу Web Forms. Можно также использовать выражения в разметке, которые обеспечивают доступ к тем же данным. Построители выражений — это мощная и элегантное способ работы с декларативный код. (Дополнительные сведения см. в записи [Express самостоятельно с помощью пользовательского построители выражений](http://haacked.com/archive/2006/11/29/Express_Yourself_With_Custom_Expression_Builders.aspx) в блоге Фила Хаака.)

В ASP.NET 4 включает две новые построители выражений для маршрутизации веб-форм. Следующий пример показывает способ их использования.

[!code-aspx[Main](overview/samples/sample43.aspx)]

В примере *RouteUrl* выражение используется для определения URL-адреса на основании параметра маршрута. Это избавляет от необходимости быть жестко полный URL-адрес в разметку и позволяет изменять структуру URL-адрес позднее без необходимости каких-либо изменениях эту ссылку.

На основе маршрута определенные ранее, эта разметка создает следующий URL-адрес:

[!code-console[Main](overview/samples/sample44.cmd)]

ASP.NET автоматически происходит правильный маршрут (то есть, он создает правильный URL-адрес) на основе входных параметров. Можно также включить имя маршрута в выражении, которое позволяет указать маршрута для использования.

В следующем примере показано, как использовать *RouteValue* выражение.

[!code-aspx[Main](overview/samples/sample45.aspx)]

При выполнении страницы, который содержит этот элемент управления значение «scott» отображается в метке.

*RouteValue* выражение позволяет легко использовать данные о маршруте в разметке и позволяет избежать необходимости работы с более сложные Page.RouteData["x"] синтаксис в разметке.

#### <a name="using-route-data-for-data-source-control-parameters"></a>Используя данные маршрута для параметров элемента управления источником данных

*RouteParameter* позволяет указать данные о маршруте в качестве значения параметра для запросов в элемент управления источником данных. Он [работает как](https://msdn.microsoft.com/library/system.web.ui.webcontrols.formparameter.aspx) класса, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample46.aspx)]

В этом случае будет использоваться значение searchterm параметр маршрута для @companyname параметр в <em>выберите</em> инструкции.

<a id="0.2__Toc224729037"></a><a id="0.2__Toc253429261"></a><a id="0.2__Toc243304635"></a>

### <a name="setting-client-ids"></a>Задания идентификаторов клиента

Новый *ClientIDMode* свойство предназначено для долгосрочных в ASP.NET, а именно как элементы управления создают *идентификатор* атрибутов для элементов, которые их отрисовки. Зная *идентификатор* атрибут отображаемых элементов важно, если приложение включает клиентский скрипт, который ссылается на эти элементы.

*Идентификатор* атрибута в формате HTML, отображаемый для серверных элементов управления создается на основе *ClientID* свойству элемента управления. До ASP.NET 4, алгоритм создания *идентификатор* атрибута из *ClientID* свойство было сцепляемых контейнера именования (если есть) с Идентификатором, а также в случае повторяющихся элементов управления (как в данные элементы управления), добавьте префикс и порядковый номер. Пока это всегда гарантирует, что идентификаторы элементов управления на странице, то алгоритм привела к управлять идентификаторы, которые не были прогнозируемого и поэтому было трудно ссылку из клиентского скрипта.

Новый *ClientIDMode* свойство позволяет указать более точно как идентификатор клиента создается для элементов управления. Можно задать *ClientIDMode* свойства для любого элемента управления, включая страницы. Ниже перечислены возможные значения.

- *AutoID* — это эквивалентно алгоритм создания *ClientID* значения свойств, используемых в более ранних версиях ASP.NET.
- *Статические* — указывает, что *ClientID* значение будет совпадать с Идентификатором без объединения идентификаторы родительских контейнеров именования. Это может быть полезно в пользовательских элементов управления. Поскольку веб-элемент управления пользователя могут быть расположены на разных страницах, а в другой контейнер элементов управления, может оказаться непростым клиентского скрипта для элементов управления, использующих *AutoID* алгоритма, так как невозможно предсказать, значения Идентификаторов, которые будут .
- *Прогнозируемый* — этот параметр используется главным образом для использования в элементах управления данными, использующие повторяющийся шаблоны. Он объединяет свойства ID элемента управления именования контейнеров, но созданный *ClientID* значения не содержат строки, такие как «ctlxxx». Этот параметр работает в сочетании с *ClientIDRowSuffix* свойству элемента управления. Задать *ClientIDRowSuffix* свойство имени поля данных и значение этого поля используется в качестве суффикса для создаваемого *ClientID* значение. Обычно следует использовать первичного ключа записи данных как *ClientIDRowSuffix* значение.
- *Наследовать* — этот параметр действует по умолчанию для элементов управления; он указывает, что создание идентификатора элемента управления таким же, как его родителя.

Можно задать *ClientIDMode* свойства на уровне страницы. Определяет значение по умолчанию *ClientIDMode* значение для всех элементов управления на текущей странице.

Значение по умолчанию *ClientIDMode* значение на уровне страницы — *AutoID*и значение по умолчанию *ClientIDMode* значение на уровне управления *наследовать*. В результате, если это свойство не задано в любом месте в коде, все элементы управления по умолчанию *AutoID* алгоритма.

Значение уровня страницы в *@ Page* директивы, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample47.aspx)]

Можно также задать *ClientIDMode* значение в файле конфигурации на уровне компьютера (по умолчанию) или на уровне приложения. Определяет значение по умолчанию *ClientIDMode* для всех элементов управления на всех страницах приложения. Если значение задано на уровне компьютера, он определяет значение по умолчанию *ClientIDMode* задание для всех веб-сайтов на этом компьютере. В следующем примере показан *ClientIDMode* в файле конфигурации:

[!code-xml[Main](overview/samples/sample48.xml)]

Как уже отмечалось ранее, значение *ClientID* свойство извлекается из контейнера именования для родительского элемента управления. В некоторых сценариях, например при использовании главные страницы элементы управления может оказаться идентификаторы как в следующем примере к просмотру HTML:

[!code-html[Main](overview/samples/sample49.html)]

Несмотря на то что *ввода* элемент, показанный в разметке (из *TextBox* управления) имеет только два контейнера именования глубокие на странице (вложенного *ContentPlaceholder* элементов управления), из-за способа обработки главные страницы конечным результатом является идентификатор элемента управления следующим образом:

[!code-console[Main](overview/samples/sample50.cmd)]

Этот идентификатор гарантированно будет уникальным в странице, но не излишне долго для большинства целей. Предположим, что требуется уменьшить длину идентификатора готовый для просмотра и иметь больший контроль над созданием идентификатор. (Например, вы хотите исключить префиксы «ctlxxx».) Является самым простым способом, чтобы добиться этого, задав *ClientIDMode* свойства, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample51.aspx)]

В этом образце *ClientIDMode* свойству *статических* для самой внешней *NamingPanel* элемент, а также установите для *прогнозируемый* для внутреннего *NamingControl* элемента. Эти параметры привести следующую разметку (остальная часть страницы и Главная страница считается таким же, как показано в предыдущем примере):

[!code-html[Main](overview/samples/sample52.html)]

*Статических* параметр действует как сброс иерархии имен для любых элементов управления внутри самой внешней *NamingPanel* элемент и исключения *ContentPlaceHolder* и *MasterPage* идентификаторы из созданного кода. ( *Имя* атрибут отображаемых элементов не влияет, поэтому функциональности ASP.NET сохраняется для события, состояние представления и т. д.) Сброс иерархии имен побочный эффект состоит в том даже при перемещении разметку для *NamingPanel* элементов на другой *ContentPlaceholder* идентификаторов клиента в готовом для просмотра, элементов управления остаются неизменными.

> [!NOTE]
> Обратите внимание, что вы можете задать уникальные идентификаторы Отрисованный элемент управления. Если это не так, это может нарушить работу никакой функциональности, требующей уникальные идентификаторы для отдельных элементов HTML, например, клиент *document.getElementById* функции.


#### <a name="creating-predictable-client-ids-in-data-bound-controls"></a>Создание предсказуемые клиентские идентификаторы в элементах управления с привязкой к данным

*ClientID* значения, которые создаются для элементов управления в элементе управления списком с привязкой к данным с помощью устаревшего алгоритма можно длинные и не действительно предсказуемо. *ClientIDMode* возможность позволяет иметь несколько управления создаются на том, как эти идентификаторы.

Разметка в следующем примере включает в себя *ListView* управления:

[!code-aspx[Main](overview/samples/sample53.aspx)]

В предыдущем примере *ClientIDMode* и *RowClientIDRowSuffix* задано в разметке. *ClientIDRowSuffix* свойство может использоваться только в элементах управления с привязкой к данным, а его поведение отличается в зависимости от того, какой элемент управления с помощью. Эти различия указаны следующие:

- *GridView* элемента управления, можно указать имя одного или нескольких столбцов в источнике данных, скомбинированные во время выполнения для создания идентификаторов клиента. Например, если задать *RowClientIDRowSuffix* для «ProductName, ProductId», идентификаторы элемента управления для отображаемых элементов будет иметь формат следующим образом:

- [!code-console[Main](overview/samples/sample54.cmd)]

- *ListView* элемента управления, можно указать один столбец в источнике данных, добавляемое к идентификатор клиента. Например, если задать *ClientIDRowSuffix* для «Марка», готовый для просмотра идентификаторы элемента управления будет иметь следующий формат:

- [!code-console[Main](overview/samples/sample55.cmd)]

- В этом случае конечные 1 является производным от идентификатора продукта элемента данных.

- *Повторителя* управления — это элемент управления не поддерживает *ClientIDRowSuffix* свойство. В *повторителя* используется элемент управления, индекс текущей строки. При использовании ClientIDMode = «Прогнозируемый» с *повторителя* управления формируется идентификатор клиента, который имеет следующий формат:

- [!code-console[Main](overview/samples/sample56.cmd)]

- Конечные 0 — это индекс текущей строки.

*FormView* и *DetailsView* элементы не имеют несколько строк, поэтому они не поддерживают *ClientIDRowSuffix* свойство.

<a id="0.2__Toc224729038"></a><a id="0.2__Toc253429262"></a><a id="0.2__Toc243304636"></a>

### <a name="persisting-row-selection-in-data-controls"></a>Сохранение выбора строки в элементах управления данными

*GridView* и *ListView* элементы управления можно дать возможность пользователю выбрать строку. В предыдущих версиях ASP.NET Выбор лица были на основе индекса строки на странице. Например если третий элемент на странице 1, затем переходит на страницу 2 третий элемент на этой странице выбирается.

Постоянного выбора ранее поддерживалась только в проектах динамических данных в .NET Framework 3.5 SP1. Если эта функция включена, выбранный элемент основан на ключ данных элемента. Это означает, что если вы выберите третью строку на странице 1 и переходит на страницу 2, ничего не выбрано на странице 2. При перемещении обратно на страницу 1 выбран третьей строки. Теперь поддерживается для постоянного выбора *GridView* и *ListView* элементов управления во всех проектах, с помощью *EnablePersistedSelection* свойства, как показано в Следующий пример:

[!code-aspx[Main](overview/samples/sample57.aspx)]

<a id="0.2__Toc253429263"></a><a id="0.2__Toc243304637"></a>

### <a name="aspnet-chart-control"></a>Элемент управления диаграммы для ASP.NET

ASP.NET *диаграммы* элемент управления расширяется предложений визуализации данных в платформе .NET Framework. С помощью *диаграммы* элемента управления, можно создавать страницы ASP.NET, имеет интуитивно понятными и приятно выглядящими диаграммами для сложного статистического или финансового анализа. ASP.NET *диаграммы* управления появилась как дополнительный компонент для выпуска платформы .NET Framework версии 3.5 с пакетом обновления 1 и входит в состав выпуска .NET Framework 4.

Элемент управления включает следующие компоненты:

- 35 различных типов диаграмм.
- Неограниченное количество областей диаграммы, заголовки, условные обозначения и заметки.
- Самые разнообразные параметры отображения для всех элементов диаграммы.
- Поддержка трехмерного для большинства типов диаграмм.
- Данные смарт-метки, которые автоматически помещается вокруг точки данных.
- Полосковые линии разрыва шкалы и логарифмической шкале.
- Более 50 финансовых и статистических формул для анализа данных и преобразования данных.
- Простая привязка и обработка данных диаграммы.
- Поддержка распространенных форматах данных, например дат, времени и валюты.
- Поддержка интерактивных и настройки, управляемые событиями, включая клиента щелкните событий с помощью Ajax.
- Управление состоянием.
- Двоичные потоки.

На следующих рисунках показаны примеры финансовых диаграмм, созданные с помощью элемента управления диаграммы для ASP.NET.

<a id="0.2_graphic17"></a>![](overview/_static/image1.png)

Рис. 2: Примеры элементов управления ASP.NET диаграммы

Дополнительные примеры использования элемента управления диаграммы ASP.NET, загрузив образец кода на [образцы среды для Microsoft Chart Controls](https://go.microsoft.com/fwlink/?LinkId=128300) страницу на веб-сайте MSDN. Дополнительные примеры сообщества можно найти содержимого в [форуме по элементу управления диаграммы](https://go.microsoft.com/fwlink/?LinkId=128713).

#### <a name="adding-the-chart-control-to-an-aspnet-page"></a>Добавление элемента управления диаграммы для страницы ASP.NET

Следующий пример демонстрирует добавление *диаграммы* управления для страницы ASP.NET с помощью разметки. В примере *диаграммы* управления создает гистограмму для статических данных точек.

[!code-aspx[Main](overview/samples/sample58.aspx)]

#### <a name="using-3-d-charts"></a>Использование трехмерных диаграмм

*Диаграммы* управления содержит *ChartAreas* коллекцию, которая может содержать *ChartArea* объектами, которые определяют характеристики областей диаграммы. Например, чтобы использовать трехмерные области диаграммы, используйте *Area3DStyle* свойства, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample59.aspx)]

На следующем рисунке показана объемной диаграммы с помощью четырех рядов *панель* тип диаграммы.

<a id="0.2_graphic18"></a>![](overview/_static/image2.png)

Рис. 3: Объемная линейчатая диаграмма

#### <a name="using-scale-breaks-and-logarithmic-scales"></a>С помощью разрывов шкалы и логарифмическую шкалу

Разрывы шкалы и логарифмическую шкалу являются два дополнительных способа добавления квалификации в диаграмму. Эти функции относятся к каждой оси в области диаграммы. Например, чтобы использовать эти возможности на основной оси Y области диаграммы, используйте *AxisY.IsLogarithmic* и *ScaleBreakStyle* свойства в *ChartArea* объекта. Следующий фрагмент кода показано, как использовать разрывы шкалы на основной оси Y.

[!code-aspx[Main](overview/samples/sample60.aspx)]

На рисунке ниже показано по оси Y с разрывами шкалы включена.

<a id="0.2_graphic19"></a>![](overview/_static/image3.png)

Рис. 4: Разрывы шкалы

<a id="0.2__QueryExtender"></a><a id="0.2__Toc224729041"></a><a id="0.2__Toc253429264"></a><a id="0.2__Toc243304638"></a>

### <a name="filtering-data-with-the-queryextender-control"></a>Фильтрация данных с помощью элемента управления QueryExtender

Очень часто выполняется для разработчиков, создающих веб-страницы на основе данных — для фильтрации данных. Это обычно выполнено путем построения *где* элементами управления источниками предложения в данных. Этот подход может быть сложной, а в некоторых случаях *где* синтаксис не позволяет воспользоваться преимуществами возможности основной базы данных.

Для упрощения фильтрации, новый *QueryExtender* управления был добавлен в ASP.NET 4. Можно добавить этот элемент управления *EntityDataSource* или *LinqDataSource* элементы управления для фильтрации данных, возвращаемых этими элементами управления. Поскольку *QueryExtender* , элемент управления использует LINQ, перед отправкой данных на страницу, которая приводит к очень эффективные операции на сервере базы данных применяется фильтр.

*QueryExtender* элемент управления поддерживает разнообразные параметры фильтра. В следующих разделах описываются эти возможности и примеры их использования.

#### <a name="search"></a>Поиск

Для параметра поиска *QueryExtender* элемент управления выполняет поиск в заданных полях. В следующем примере элемент управления использует текст, который вводится в элемент управления TextBoxSearch и ищет свое содержимое в `ProductName` и `Supplier.CompanyName` столбцы данных, возвращенный *LinqDataSource* элемент управления.

[!code-aspx[Main](overview/samples/sample61.aspx)]

#### <a name="range"></a>Диапазон

Параметр диапазона аналогична параметр поиска, но указывает пара значений, чтобы определить диапазон. В следующем примере *QueryExtender* управления выполняет `UnitPrice` столбец данных, возвращаемых из *LinqDataSource* элемента управления. Диапазон считывается из TextBoxFrom и TextBoxTo элементы управления на странице.

[!code-aspx[Main](overview/samples/sample62.aspx)]

#### <a name="propertyexpression"></a>PropertyExpression

Параметр выражения свойство позволяет определить сравнение со значением свойства. Если выражение, результатом которого является *true*, возвращаются искомые данные. В следующем примере *QueryExtender* управления фильтрацию данных путем сравнения данных в `Discontinued` столбца значение из элемента управления CheckBoxDiscontinued на странице.

[!code-aspx[Main](overview/samples/sample63.aspx)]

#### <a name="customexpression"></a>CustomExpression

Наконец, можно указать пользовательское выражение для использования с *QueryExtender* элемента управления. Этот параметр позволяет вызывать функцию на странице, определяющий логику пользовательского фильтра. В следующем примере показано, как декларативно задать пользовательское выражение в *QueryExtender* элемента управления.

[!code-aspx[Main](overview/samples/sample64.aspx)]

В следующем примере пользовательская функция, вызываемая *QueryExtender* элемента управления. В этом случае вместо запроса к базе данных, которая включает *где* предложение, код использует запрос LINQ для фильтрации данных.

[!code-csharp[Main](overview/samples/sample65.cs)]

Только одно выражение используется в этих примерах *QueryExtender* управления одновременно. Тем не менее, можно включить несколько выражений внутри *QueryExtender* элемента управления.

<a id="0.2__Toc253429265"></a><a id="0.2__Toc243304639"></a>

### <a name="html-encoded-code-expressions"></a>HTML-кодированную выражения кода

Некоторые сайты ASP.NET (особенно с ASP.NET MVC) сильно зависят от использования `<%` =  `expression %>` синтаксис (так называемого «фрагменты кода») для записи часть текста ответа. При использовании выражения кода можно легко забыть HTML-кодирование ввода текста, если текст поступил от пользователя, его можно оставить страницы открытым для атаки XSS (межсайтовых сценариев).

В ASP.NET 4 следующий новый синтаксис для выражения кода:

[!code-aspx[Main](overview/samples/sample66.aspx)]

Этот синтаксис используется кодировка HTML по умолчанию при записи в ответ. Новое выражение фактически переводит следующее:

[!code-aspx[Main](overview/samples/sample67.aspx)]

Например &lt;%: запрос [«UserInput»] %&gt; выполняет HTML-кодирования на значение *запрос [«UserInput»]*.

Эта функция предназначена для того, чтобы обеспечить возможность замены всех экземпляров старого синтаксиса с нового синтаксиса, чтобы не пришлось решить на каждом этапе один из них. Однако существуют случаи, в которых текст, выходные данные, должен быть HTML или уже закодирован в этом случае это может привести к двойной кодировкой.

В тех случаях, ASP.NET 4 появился новый интерфейс *IHtmlString*, вместе с конкретной реализацией *HtmlString*. Экземпляры этих типов позволяют указать, что возвращаемое значение уже правильно закодированы (или в противном случае исследовать) для отображения в виде HTML и, поэтому значение не должен быть HTML-кодированную еще раз. Например, следующие не должен (и не) в кодировке HTML:

[!code-aspx[Main](overview/samples/sample68.aspx)]

ASP.NET MVC 2 вспомогательные методы были обновленные для работы с этого нового синтаксиса, чтобы они не являются double в кодировке, но только во время выполнения ASP.NET 4. Этот новый синтаксис не работает при запуске приложения с помощью ASP.NET 3.5 SP1.

Имейте в виду, что это не обеспечивает защиту от атак с XSS. Например HTML, который использует значения атрибутов, которые не заключаются в кавычки может содержать данные, которые по-прежнему подвержены. Обратите внимание, вывод элементов управления ASP.NET и вспомогательных методов ASP.NET MVC всегда включает значения атрибутов в кавычки, который является рекомендуемым подходом.

Аналогичным образом этот синтаксис не выполняет кодирование JavaScript, например при создании строки JavaScript, на основе ввода пользователя.

<a id="0.2__Toc253429266"></a><a id="0.2__Toc243304640"></a>

### <a name="project-template-changes"></a>Изменения шаблонов проектов

В более ранних версиях ASP.NET при использовании Visual Studio для создания нового проекта веб-узла или проекта веб-приложения, полученный проекты содержат только странице Default.aspx, значение по умолчанию `Web.config` файла и `App_Data` папки, как показано в следующем примере на рисунке:

<a id="0.2_graphic1A"></a>![](overview/_static/image4.png)

Visual Studio также поддерживает тип проекта пустого веб-сайта, который не содержит файлов вообще, как показано на следующем рисунке:

<a id="0.2_graphic1B"></a>![](overview/_static/image5.png)

Результатом является то, что начинающий пользователь имеется очень мало рекомендация по созданию производственного веб-приложения. Таким образом ASP.NET 4 впервые представлены три новых шаблона, один для пустой проект веб-приложения и по одному для каждого проекта веб-приложения и веб-сайта.

#### <a name="empty-web-application-template"></a>Шаблон пустой веб-приложения

Как видно из имени, шаблон пустое веб-приложение будет урезанная проекта веб-приложения. Этот шаблон проекта выберите в диалоговом окне нового проекта Visual Studio, как показано на следующем рисунке:

[![](overview/_static/image7.png)](overview/_static/image6.png)

([Просмотр полноразмерное изображение](overview/_static/image8.png))

Когда вы создаете пустое веб-приложение ASP.NET, Visual Studio создает макет следующие папки:

<a id="0.2_graphic1D"></a>![](overview/_static/image9.png)

Это похоже на макет пустого веб-сайта из более ранних версиях ASP.NET, за одним исключением. В Visual Studio 2010 пустое веб-приложение и пустой веб-сайт проекты содержат следующие минимальные `Web.config` файл, содержащий сведения, используемые для определения платформы, на которой предназначен проект Visual Studio:

<a id="0.2_graphic1E"></a>![](overview/_static/image10.png)

Без этого *targetFramework* свойства, предназначенные для .NET Framework 2.0 для сохранения совместимости при открытии старых приложений по умолчанию Visual Studio.

#### <a name="web-application-and-web-site-project-templates"></a>Веб-приложений и шаблоны проектов веб-сайта

Другие два новых шаблонов проектов, поставляемых вместе с Visual Studio 2010 содержит значительные изменения. На следующем рисунке показана макет проекта, который создается при создании нового проекта веб-приложения. (Макет для проекта веб-сайта, практически не отличается.)

- <a id="0.2_graphic1F"></a>![](overview/_static/image11.png)

Проект содержит несколько файлов, которые не были созданы в более ранних версиях. Кроме того новый проект веб-приложения настроены базовые функции членства, которой можно быстро приступить к работе в защите доступа к нового приложения. Из-за это Включение `Web.config` -файле для нового проекта включает операции, которые используются для настройки членства, ролей и профилей. В следующем примере показан `Web.config` файла для нового проекта веб-приложения. (В этом случае *roleManager* отключена.)

[![](overview/_static/image13.png)](overview/_static/image12.png)

([Просмотр полноразмерное изображение](overview/_static/image14.png))

Проект также содержит второй `Web.config` файл `Account` каталог. Второй файл конфигурации предоставляет способ защиты доступа к странице ChangePassword.aspx для не-пользователи, выполнившие вход. В следующем примере показано содержимое второго `Web.config` файла.

![](overview/_static/image15.png)

По умолчанию в новых шаблонов проектов для создания страниц также содержать больше содержимого, в предыдущих версиях. Проект содержит главную страницу по умолчанию и CSS-файл, и страница по умолчанию (Default.aspx) должен содержать главную страницу по умолчанию. Результат является при запуске веб-приложения или веб-сайт в первый раз (home) страницы по умолчанию уже работы. На самом деле это похоже на страницу по умолчанию, отображаемые при запуске нового приложения MVC.

[![](overview/_static/image17.png)](overview/_static/image16.png)

([Просмотр полноразмерное изображение](overview/_static/image18.png))

Цель этих изменений в шаблоны проектов — предоставить рекомендации о том, как приступить к созданию нового веб-приложения. Семантически правильно, strict XHTML 1.0 соответствует разметки и макет, задается с помощью CSS страниц в шаблонах представляют рекомендации по созданию 4 веб-приложений ASP.NET. По умолчанию страницы также имеют макете два столбца, можно легко настроить.

Например предположим, что для нового веб-приложения вы хотите изменить некоторые цвета и вставьте эмблему компании, вместо логотипа Мое приложение ASP.NET. Чтобы сделать это, создайте новый каталог `Content` для сохранения изображения логотипа:

<a id="0.2_graphic23"></a>![](overview/_static/image19.png)

Чтобы добавить изображение к странице, затем откройте `Site.Master` файла, где определяется текст Мое приложение ASP.NET и замените ее на *изображения* элемент которого *src* атрибута задано значение нового логотипа изображение, как показано в следующем примере:

[![](overview/_static/image21.png)](overview/_static/image20.png)

([Просмотр полноразмерное изображение](overview/_static/image22.png))

Затем можно перейти в файле Site.css и изменять определения класса CSS, чтобы изменить цвет фона страницы, а также, заголовка.

Эти изменения образом, можно отобразить с минимальными усилиями настроенной домашней страницы:

[![](overview/_static/image24.png)](overview/_static/image23.png)

([Просмотр полноразмерное изображение](overview/_static/image25.png))

<a id="0.2__Toc253429267"></a><a id="0.2__Toc243304641"></a>

### <a name="css-improvements"></a>Усовершенствования CSS

Одно из основных областей работы в ASP.NET 4 было помогающие отрисовывать HTML, который соответствует стандартам последнюю HTML. Сюда относятся и изменения как серверные элементы управления ASP.NET использовать стили CSS.

#### <a name="compatibility-setting-for-rendering"></a>Параметр совместимости для подготовки к просмотру

По умолчанию, когда веб-приложение или веб-сайт предназначен для .NET Framework 4 *controlRenderingCompatibilityVersion* атрибут *страниц* элемента задано значение «4.0». Этот элемент определен в уровне компьютера `Web.config` файла и по умолчанию применяется ко всем приложениям ASP.NET 4:

[!code-xml[Main](overview/samples/sample69.xml)]

Значение для *controlRenderingCompatibility* представляет собой строку, позволяющую потенциальных новых версий определений в будущих выпусках. В текущем выпуске для этого свойства поддерживаются следующие значения:

- "3.5". Этот параметр указывает традиционной отрисовки и разметки. Разметка, элементы управления — обратной совместимости 100%, а параметр *xhtmlConformance* свойство учитывается.
- "4.0". Если этот параметр имеет свойство, серверные элементы управления ASP.NET выполните следующее:
- *XhtmlConformance* всегда считается «Strict». В результате элементы управления отображают XHTML 1.0 Strict разметку.
- Отключение элементов управления не связанной с входом больше не отображает недопустимых стилей.
- *div* элементы вокруг скрытые поля теперь со стилем, поэтому они не конфликтуют с пользовательским правил CSS.
- Элементы управления меню обрабатывать разметку, семантически правильное и соответствует рекомендациям по доступности.
- Проверяющие элементы управления не поддерживают встроенные стили.
- Элементы управления, ранее к просмотру границы = «0» (элементы управления, которые являются производными от ASP.NET *таблицы* управления и ASP.NET *изображения* управления) больше не отображают данный атрибут.

#### <a name="disabling-controls"></a>Отключение элементов управления

В ASP.NET 3.5 SP1 и более ранних версий, платформа отображает *отключена* атрибут в HTML-разметку для любой элемент управления *включено* свойство *false*. Однако, согласно спецификации HTML 4.01, только *ввода* элементы должны иметь этот атрибут.

В ASP.NET 4, можно задать *controlRenderingCompatabilityVersion* свойство «3.5», как показано в следующем примере:

[!code-xml[Main](overview/samples/sample70.xml)]

Можно создать разметку для *метка* управления следующим образом, который отключает элемент управления:

[!code-aspx[Main](overview/samples/sample71.aspx)]

*Метка* управления будет отображен следующий код HTML:

[!code-html[Main](overview/samples/sample72.html)]

В ASP.NET 4, можно задать *controlRenderingCompatabilityVersion* значение «4.0». Только элементы управления, отображаются в этом случае *входной* элементы будут отображаться *отключена* когда элемента управления *включено* свойству *false* . Элементы управления, которые не отображают HTML *ввода* вместо отображения элементов *класса* атрибут, который ссылается на класс CSS, который можно использовать для определения отключенный внешний вид элемента управления. Например *метка* показанный в предыдущем примере создал бы следующую разметку:

[!code-html[Main](overview/samples/sample73.html)]

Значение по умолчанию для класса, который указан для этого элемента управления — «aspNetDisabled». Тем не менее, это значение по умолчанию можно изменить путем задания статического *DisabledCssClass* статическим свойством *WebControl* класса. Для разработчиков элементов управления, поведение, используемое для конкретного элемента управления также могут быть определены с помощью *SupportsDisabledAttribute* свойство.

<a id="0.2__Toc253429268"></a><a id="0.2__Toc243304642"></a>

### <a name="hiding-div-elements-around-hidden-fields"></a>Скрытие div элементы вокруг скрытые поля

ASP.NET 2.0 и более поздних версиях отрисовка скрытых полей характерные для системы (например, *скрытые* элемент, используемый для сохранения информации состояния представления) внутри *div* элемент для соответствия стандарту XHTML. Тем не менее, это может вызвать проблему, если влияет правило CSS *div* элементов на странице. Например, это может привести к строке один пиксель, отображаемых на странице около скрытые *div* элементов. В ASP.NET 4 *div* элементы, заключите скрытые поля, созданной ASP.NET добавления ссылки класс CSS, как показано в следующем примере:

[!code-html[Main](overview/samples/sample74.html)]

Затем можно определить класс CSS, который применяется только к *скрытые* элементами, созданными с помощью ASP.NET, как показано в следующем примере:

[!code-css[Main](overview/samples/sample75.css)]

<a id="0.2__Toc253429269"></a><a id="0.2__Toc243304643"></a>

### <a name="rendering-an-outer-table-for-templated-controls"></a>Подготовка к просмотру внешней таблицы для элементах управления

По умолчанию следующие серверные элементы управления ASP.NET, поддерживающих шаблоны, автоматически переносятся в внешней таблицы, который используется для применения встроенных стилей:

- *FormView*
- *Имя входа*
- *PasswordRecovery*
- *ChangePassword*
- *Мастер*
- *CreateUserWizard*

Новое свойство с именем *свойство RenderOuterTable* был добавлен в эти элементы управления, которая позволяет внешней таблицы, удаляемый из разметки. Например, рассмотрим следующий пример *FormView* управления:

[!code-aspx[Main](overview/samples/sample76.aspx)]

Эта разметка отображает следующие выходные данные на страницу, содержащую таблицу HTML:

[!code-html[Main](overview/samples/sample77.html)]

Чтобы предотвратить в таблице, можно задать *FormView* элемента управления *свойство RenderOuterTable* свойства, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample78.aspx)]

Предыдущий пример отображает следующие выходные данные без *таблицы*, *tr*, и *td* элементов:

> Content


Это улучшение можно упростить его стиль содержимого элемента управления с помощью CSS, так как ни один из тегов Непредвиденная подготавливаются к просмотру с помощью элемента управления.

> [!NOTE]
> Это изменение отключает поддержку функции автоматического форматирования в конструкторе Visual Studio 2010, так как оно больше не *таблицы* элемент, который может содержать атрибутов стиля, которые создаются с помощью параметра автоматического форматирования.


<a id="0.2__Toc253429270"></a><a id="0.2__Toc243304644"></a>

### <a name="listview-control-enhancements"></a>Усовершенствования элемента управления ListView

*ListView* управления облегчается для использования в ASP.NET 4. Более ранней версии элемента управления требуется указывать шаблон макета, содержащий серверный элемент управления с известным идентификатором. В следующем примере показана типичный пример использования *ListView* элемента управления в ASP.NET 3.5.

[!code-aspx[Main](overview/samples/sample79.aspx)]

В ASP.NET 4 *ListView* управления шаблон макета не требуется. Разметка, показанная в предыдущем примере можно заменить на следующую разметку:

[!code-aspx[Main](overview/samples/sample80.aspx)]

<a id="0.2__Toc253429271"></a><a id="0.2__Toc243304645"></a>

### <a name="checkboxlist-and-radiobuttonlist-control-enhancements"></a>CheckBoxList и улучшения свободу

В ASP.NET 3.5, можно задать макет для *CheckBoxList* и *RadioButtonList* следующими двумя параметрами:

- *Поток*. Элемент управления отображает *span* элементы для хранения его содержимого.
- *Таблица*. Элемент управления отображает *таблицы* элемента для хранения его содержимого.

В следующем примере показана разметка для каждого из этих элементов управления.

[!code-aspx[Main](overview/samples/sample81.aspx)]

По умолчанию элементы управления обрабатывать HTML следующего вида:

[!code-html[Main](overview/samples/sample82.html)]

Так как эти элементы управления содержат списки элементов для отображения корректно с HTML, их следует отрисовки их содержимое с помощью списка HTML (*li*) элементов. Это упрощает для пользователей, чтение веб-страниц с помощью специальных возможностей и позволяет упростить стиля CSS с помощью элементов управления.

В ASP.NET 4 *CheckBoxList* и *RadioButtonList* элементы управления поддерживают новые значения для *RepeatLayout* свойство:

- *OrderedList* — содержимое отображается в виде *li* элементы внутри *ol* элемента.
- *UnorderedList* — содержимое отображается в виде *li* элементы внутри *ul* элемента.

В следующем примере показано, как использовать эти новые значения.

[!code-aspx[Main](overview/samples/sample83.aspx)]

Предыдущей разметки создает следующий код HTML:

[!code-html[Main](overview/samples/sample84.html)]

> [!NOTE]
> Обратите внимание, если установить *RepeatLayout* для *OrderedList* или *UnorderedList*, *RepeatDirection* свойство больше не может использоваться и будет исключение во время выполнения, если свойство было задано в разметке или коде. Свойство будет иметь значение не так, как определяются с помощью CSS, вместо этого визуальное расположение этих элементов управления.


<a id="0.2__Toc253429272"></a><a id="0.2__Toc243304646"></a>

### <a name="menu-control-improvements"></a>Усовершенствования управления меню

До ASP.NET 4 *меню* серии HTML-таблиц визуализации элемента управления. Это стало более сложным для применения стилей CSS за пределами задания свойств встроенной и не также соответствует стандартам специальных возможностей.

В ASP.NET 4 элемента управления теперь отображает HTML с использованием семантики разметку, которая содержит неупорядоченный список и элементами списка. В следующем примере показано разметки на странице ASP.NET для *меню* элемента управления.

[!code-aspx[Main](overview/samples/sample85.aspx)]

При отображении страницы, элемент управления создает следующий код HTML ( *onclick* код включен для ясности):

[!code-html[Main](overview/samples/sample86.html)]

Помимо улучшений отрисовки меню с помощью клавиатуры была улучшена с помощью управления фокус ввода. Когда *меню* элемент управления получает фокус, можно использовать клавиши со стрелками для перемещения элементов. *Меню* управления теперь также присоединяет доступны широкие возможности роли Интернет приложений (ARIA) и атрибутов ОП[ледующему](http://www.w3.org/TR/wai-aria-practices/#menu "меню ARIA рекомендации")для улучшения специальные возможности.

Стили для элемента управления меню выводятся в блок стиля в верхней части страницы, а не в готовом для просмотра HTML-элементов. Если требуется полный контроль над стили для элемента управления, можно установить новый *IncludeStyleBlock* свойства *false*, в этом случае блок стиля не создается. С помощью этого свойства можно использовать функцию автоматического форматирования в конструкторе Visual Studio, чтобы задать внешний вид меню. Затем можно запустить страницу, откройте исходный код страницы и скопируйте блок стиля в готовом для просмотра во внешнем файле CSS. В Visual Studio, отменить Стилизация и набор *IncludeStyleBlock* для *false*. Результатом является то, что вид меню определен с использованием стилей во внешней таблице стилей.

<a id="0.2__Toc253429273"></a><a id="0.2__Toc243304647"></a>

### <a name="wizard-and-createuserwizard-controls"></a>Мастера и элементы управления CreateUserWizard

ASP.NET *мастер* и *CreateUserWizard* элементы управления поддерживают шаблоны, которые позволяют определять их подготовки к просмотру HTML. (*CreateUserWizard* является производным от *мастер*.) В следующем примере показана разметка для полностью шаблонного *CreateUserWizard* управления:

[!code-aspx[Main](overview/samples/sample87.aspx)]

Элемент управления отображает HTML следующего вида:

[!code-html[Main](overview/samples/sample88.html)]

В ASP.NET 3.5 SP1, несмотря на то, что можно изменить содержимое шаблона вы по-прежнему полный контроль над выходные данные *мастер* элемента управления. В ASP.NET 4, можно создать *LayoutTemplate* шаблона и insert *заполнитель* управляет (с помощью зарезервированными именами), можно указать, каким образом *управления Wizard* для подготовки к просмотру. Это показано в следующем примере:

[!code-aspx[Main](overview/samples/sample89.aspx)]

Пример содержит следующие именованные заполнители в *LayoutTemplate* элемента:

- *headerPlaceholder* — во время выполнения, оно заменяется содержимое *HeaderTemplate* элемента.
- *sideBarPlaceholder* — во время выполнения, оно заменяется содержимое *SideBarTemplate* элемента.
- *wizardStepPlaceHolder* — во время выполнения, оно заменяется содержимое *WizardStepTemplate* элемента.
- *navigationPlaceholder* — во время выполнения это заменен шаблонами навигации, которые вы определили.

Разметка в пример, в котором используются заполнители отображает следующий код HTML (без содержимого, фактически определенных в шаблонах):

[!code-html[Main](overview/samples/sample90.html)]

— Только код HTML, который является сейчас не определяется пользователем *span* элемента. (Ожидается, то в будущих выпусках даже *span* элемент не будет отображаться.) Теперь предоставляет полный контроль над практически все содержимое, создаваемое *мастер* элемента управления.

<a id="0.2_dyndata"></a><a id="0.2__Toc253429274"></a><a id="0.2__Toc243304648"></a><a id="0.2__Toc224729042"></a>

## <a name="aspnet-mvc"></a>ASP.NET MVC

ASP.NET MVC была введена как платформу надстройку ASP.NET 3.5 с пакетом обновления 1 марта 2009. Visual Studio 2010 поддерживает ASP.NET MVC 2 включает новые функции и возможности.

<a id="0.2__Toc253429275"></a>

### <a name="areas-support"></a>Поддержка областей

Области позволяют группы контроллеры и представления в разделы большого приложения относительно изолированно от других разделов. Каждая область можно реализовать как отдельный проект ASP.NET MVC, можно ссылаться по основного приложения. Это помогает управлять сложности при построении крупных приложений и упрощает для нескольких команд для совместной работы над одним приложением.

<a id="0.2__Toc253429276"></a>

### <a name="data-annotation-attribute-validation-support"></a>Поддержка проверки атрибута заметки к данным

*DataAnnotations* атрибуты позволяют добавить логику проверки в модель с помощью атрибутов метаданных. *DataAnnotations* атрибуты были представлены в динамических данных ASP.NET в ASP.NET 3.5 SP1. Эти атрибуты были включены в связыватель модели по умолчанию и предоставляют средства на основе метаданных для проверки пользовательского ввода.

<a id="0.2__Toc253429277"></a>

### <a name="templated-helpers"></a>Шаблонизированные вспомогательные объекты

Шаблонизированные вспомогательные объекты позволяют автоматически связать редактирования и отобразить шаблоны с типами данных. Например, можно использовать вспомогательный класс шаблона для указания, что элемент выбора даты пользовательского интерфейса отображается автоматически для *System.DateTime* значение. Это аналогично шаблонов полей в динамических данных ASP.NET.

*Объект Html.EditorFor* и *Html.DisplayFor* вспомогательные методы имеют встроенную поддержку для визуализации данных стандартные типы объектов, а также сложные с несколькими свойствами. Они также настройки отображения, позволяя применять атрибуты заметки к данным как *DisplayName* и *ScaffoldColumn* для *ViewModel* объекта.

Часто необходимо настроить вывод дополнительные вспомогательные объекты пользовательского интерфейса и получить полный контроль над создаваемой. *Объект Html.EditorFor* и *Html.DisplayFor* вспомогательные методы поддерживают это с помощью механизма шаблонов, который позволяет определять внешние шаблоны, которые можно переопределить и элемента управления к просмотру выходные данные. Шаблоны для класса может осуществляться по отдельности.

<a id="0.2__Toc253429278"></a><a id="0.2__Toc243304649"></a>

## <a name="dynamic-data"></a>динамические данные

Платформа динамических данных была введена в версии .NET Framework 3.5 SP1 в середине 2008. Эта функция обеспечивает множество улучшений для создания управляемых данными приложений, включая следующие:

- Быстрая РАЗРАБОТКА приложений для быстрого создания веб-сайта на основе данных.
- Автоматическая проверка на основе ограничений, определенных в модели данных.
- Возможность легко изменить разметку, которая создается для полей в *GridView* и *DetailsView* элементов управления с помощью шаблонов полей, которые являются частью проекта платформы динамических данных.

> [!NOTE]
> Обратите внимание, для получения дополнительной информации см. в разделе [документации платформы динамических данных](https://msdn.microsoft.com/library/cc488545.aspx) в библиотеке MSDN.


Для ASP.NET 4 платформы динамических данных была расширена для предоставления разработчикам еще больше сократить для быстрого создания веб-сайтов на основе данных.

<a id="0.2__Toc253429279"></a><a id="0.2__Toc243304650"></a>

### <a name="enabling-dynamic-data-for-existing-projects"></a>Включение платформы динамических данных для существующих проектов

Динамические данные функции, доступные в .NET Framework 3.5 SP1 переведена в режим новые функции, например следующие:

- Шаблоны полей — они предоставляют данные типа на основе шаблонов для элементов управления с привязкой к данным. Шаблоны полей предоставляют простой способ настройки внешнего вида элементов управления данными, чем при использовании шаблона поля для каждого поля.
- Проверка динамических данных позволяет использовать атрибуты на классы данных для указания проверки для распространенных сценариев, таких как обязательные поля, проверка диапазона, проверка типов, сопоставление с использованием регулярных выражений шаблонов и пользовательской проверки. Проверка проводится элементами данных.

Тем не менее эти функции должны следующим требованиям:

- Уровень доступа к данным должен основываться на Entity Framework или LINQ to SQL.
- Элементы управления, поддерживаемых для этих функций источника только данные *EntityDataSource* или *LinqDataSource* элементов управления.
- Компоненты, необходимые веб-проекта, созданной с помощью платформы динамических данных или шаблонов сущностей динамических данных, чтобы все файлы, которые требовались для поддержки функции.

Поддержка платформы динамических данных в ASP.NET 4 основных предназначена для включения новых функциональных возможностей платформы динамических данных для любого приложения ASP.NET. В следующем примере показана разметка для элементов управления, которые могут использовать преимущества функций платформы динамических данных в существующую страницу.

[!code-aspx[Main](overview/samples/sample91.aspx)]

В коде для страницы Чтобы разрешить поддержку динамических данных для этих элементов управления необходимо добавить следующий код:

[!code-csharp[Main](overview/samples/sample92.cs)]

Когда *GridView* находится в режиме редактирования, платформа динамических данных автоматически проверяет, принадлежит ли данные, введенные в правильном формате. Если это не так, отображается сообщение об ошибке.

Эта функция также имеет и другие преимущества, например возможность задать по умолчанию значения для режима вставки. Без динамических данных для реализации по умолчанию для поля, необходимо присоединить к событию, найдите элемент управления (с помощью *FindControl*) и присвойте ему значение. В ASP.NET 4 *EnableDynamicData* вызов поддерживает второй параметр, который позволяет передавать значения по умолчанию для любого поля в объекте, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample93.cs)]

<a id="0.2__Toc224729043"></a><a id="0.2__Toc253429280"></a><a id="0.2__Toc243304651"></a>

### <a name="declarative-dynamicdatamanager-control-syntax"></a>Синтаксис декларативный элемент управления DynamicDataManager

*DynamicDataManager* управления была улучшена, чтобы его можно настроить декларативно, как и в большинстве элементов управления ASP.NET, а не только в коде. Разметка для *DynamicDataManager* управления выглядит как в следующем примере:

[!code-aspx[Main](overview/samples/sample94.aspx)]

Эта разметка включает поведение платформы динамических данных для элемента управления GridView1, упоминаемый в *DataControls* раздел *DynamicDataManager* управления.

<a id="0.2__Toc224729044"></a><a id="0.2__Toc253429281"></a><a id="0.2__Toc243304652"></a>

### <a name="entity-templates"></a>Шаблоны сущностей

Шаблоны сущностей предлагают новый способ настройки макета данных без необходимости создания пользовательской страницы. Используйте шаблоны *FormView* управления (вместо *DetailsView* контролировать, как использовать в шаблонах страницы в более ранних версиях платформы динамических данных) и *DynamicEntity* элемент управления для визуализации шаблонов сущностей. Это дает больше контроля над разметкой, отображаемой платформой динамических данных.

Ниже перечислены новые структура каталогов проекта, содержащий шаблоны сущностей.

[!code-console[Main](overview/samples/sample95.cmd)]

`EntityTemplate` Каталог содержит шаблоны для отображения объектов модели данных. По умолчанию объекты отображаются с помощью `Default.ascx` шаблона, который предоставляет разметку, которая выглядит так же, как разметка, созданные *DetailsView* элемент управления, используемый платформой динамических данных в ASP.NET 3.5 SP1. В следующем примере показана разметка для `Default.ascx` управления:

[!code-aspx[Main](overview/samples/sample96.aspx)]

Шаблоны по умолчанию можно изменить, чтобы изменить внешний вид и поведение для всего сайта. Существуют шаблоны для отображения, редактирования и операций вставки. Новые шаблоны могут быть добавлены на основе имени объекта данных для изменения внешнего вида только один тип объекта. Например можно добавить следующий шаблон:

[!code-console[Main](overview/samples/sample97.cmd)]

Шаблон может содержать следующую разметку:

[!code-aspx[Main](overview/samples/sample98.aspx)]

Новые шаблоны сущности отображаются на странице с помощью нового *DynamicEntity* управления. Этот элемент управления во время выполнения заменяется содержимое шаблона сущности. В следующем разметки показан *FormView* управления в `Detail.aspx` страницы шаблона, который использует шаблон сущности. Обратите внимание *DynamicEntity* элемент в разметке.

[!code-aspx[Main](overview/samples/sample99.aspx)]

<a id="0.2__Toc224729045"></a><a id="0.2__Toc253429282"></a><a id="0.2__Toc243304653"></a>

### <a name="new-field-templates-for-urls-and-email-addresses"></a>Новые шаблоны полей для URL-адреса и адреса электронной почты

В ASP.NET 4 представлено два новых шаблонов встроенное поле `EmailAddress.ascx` и `Url.ascx`. Эти шаблоны используются для полей, которые помечены как *EmailAddress* или *URL-адрес* с *DataType* атрибута. Для *EmailAddress* объектов, поле отображается в виде гиперссылки, которая создается с помощью *mailto:* протокола. Когда пользователь щелкает ссылку, он открывается клиент электронной почты пользователя и создается макет сообщения. Объекты, отмеченные как *URL-адрес* отображаются как обычные гиперссылки.

В следующем примере показано, как поля будут помечены.

[!code-csharp[Main](overview/samples/sample100.cs)]

<a id="0.2__Toc224729046"></a><a id="0.2__Toc253429283"></a><a id="0.2__Toc243304654"></a>

### <a name="creating-links-with-the-dynamichyperlink-control"></a>Создание связи с элементом управления DynamicHyperLink

Платформа динамических данных использует новую функцию маршрутизации, добавленный в .NET Framework 3.5 SP1 для управления URL-адреса, которые конечные пользователи видеть при доступе к веб-сайта. Новый *DynamicHyperLink* управления упрощает создание ссылок на страницах сайта динамических данных. В следующем примере показано, как использовать *DynamicHyperLink* управления:

[!code-aspx[Main](overview/samples/sample101.aspx)]

Эта разметка создает ссылку, которая указывает на страницу списка для `Products` таблицы на основе маршрутов, которые определены в `Global.asax` файла. Элемент управления автоматически использует имя таблицы по умолчанию на основе динамических данных страницы.

<a id="0.2__Toc224729047"></a><a id="0.2__Toc253429284"></a><a id="0.2__Toc243304655"></a>

### <a name="support-for-inheritance-in-the-data-model"></a>Поддержка наследования в модели данных

Entity Framework и LINQ to SQL поддерживает наследование в моделях данных. Примером этого может быть в базе данных имеются `InsurancePolicy` таблицы. Она может также содержать `CarPolicy` и `HousePolicy` таблицы, которые имеют те же поля, что `InsurancePolicy` и затем добавить дополнительные поля. Платформа динамических данных была изменена наследуемые объекты в модели данных и для поддержки формирования шаблонов для производных таблиц.

<a id="0.2__Toc224729048"></a><a id="0.2__Toc253429285"></a><a id="0.2__Toc243304656"></a>

### <a name="support-for-many-to-many-relationships-entity-framework-only"></a>Поддержка многие ко многим связи (только для Entity Framework)

Платформа Entity Framework поддерживает многие ко многим связей между таблицами, которые реализованы за счет предоставления связи в качестве коллекции на *сущности* объекта. Новый `ManyToMany.ascx` и `ManyToMany_Edit.ascx` шаблоны полей были добавлены для поддержки отображения и редактирования данных, которая участвует в связи, многие ко многим.

<a id="0.2__Toc224729049"></a><a id="0.2__Toc253429286"></a><a id="0.2__Toc243304657"></a>

### <a name="new-attributes-to-control-display-and-support-enumerations"></a>Новые атрибуты для управления отображением и поддержки перечислений

*DisplayAttribute* будет добавлен обеспечивают дополнительный контроль над способ отображения поля. *DisplayName* атрибута в более ранних версиях платформы динамических данных, можно изменить имя, используемое в качестве заголовка для поля. Новый *DisplayAttribute* позволяет указать дополнительные параметры для отображения поля, например порядок, в котором отображаются поля, а поле будет использоваться в качестве фильтра. Атрибут также позволяет независимо управлять имя, используемое для подписи в *GridView* управления имя, используемое в *DetailsView* управления текст справки для поля, а для водяной знак поля (если поле допускает ввод текста).

*EnumDataTypeAttribute* был добавлен класс для поддержки сопоставления полей для перечисления. При применении этого атрибута к полю, необходимо указать тип перечисления. Платформа динамических данных использует новую `Enumeration.ascx` шаблон поля для создания пользовательского интерфейса для отображения и редактирования значений перечисления. Шаблон сопоставляет значения из базы данных с именами в перечислении.

<a id="0.2__Toc224729050"></a><a id="0.2__Toc253429287"></a><a id="0.2__Toc243304658"></a>

### <a name="enhanced-support-for-filters"></a>Улучшенная поддержка фильтров

Платформа динамических данных 1.0, поставляемых с встроенные фильтры для столбцов внешнего ключа и логические столбцы. Фильтры не разрешают пользователям укажите их выводом на экран ли порядок отображения столбцов. Новый *DisplayAttribute* атрибут адреса обе эти проблемы, предоставляя контролировать отображение столбца в качестве фильтра, и в порядке, в котором он отображается.

Дополнительные улучшения — поддержка фильтрации не[с использованием нового](#0.2__QueryExtender "_QueryExtender") компонент веб-форм. Это позволяет создавать фильтры не имея сведений, фильтры, которые будут использоваться с элемента управления источника данных. Помимо этих расширений фильтров также была отключена в элементы управления шаблона, позволяет добавлять новые. Наконец *DisplayAttribute* класс, приведенные выше позволяет фильтр по умолчанию для переопределения, в том же, как *UIHint* позволяет шаблон полей по умолчанию для столбца должен быть переопределен.

<a id="0.2__Toc224729051"></a><a id="0.2__Toc253429288"></a><a id="0.2__Toc243304659"></a>

## <a name="visual-studio-2010-web-development-improvements"></a>Разработка Web усовершенствования для Visual Studio 2010

Улучшено веб-разработки в Visual Studio 2010 больше совместимости CSS, повышает эффективность через фрагментов разметки HTML и ASP.NET и новый динамический IntelliSense JavaScript.

<a id="0.2__Toc224729052"></a><a id="0.2__Toc253429289"></a><a id="0.2__Toc243304660"></a>

### <a name="improved-css-compatibility"></a>Усовершенствование совместимости CSS

Конструктор Visual Web Developer в Visual Studio 2010 был обновлен для улучшения соответствия стандартам CSS 2.1. Конструктор лучше сохраняет целостность исходный код HTML и надежнее, чем в предыдущих версиях Visual Studio. В механизме архитектурные усовершенствования также были внесены позволит лучше включить будущих улучшений в визуализации, макет и удобство обслуживания.

<a id="0.2__Toc224729053"></a><a id="0.2__Toc253429290"></a><a id="0.2__Toc243304661"></a>

### <a name="html-and-javascript-snippets"></a>HTML и JavaScript фрагменты кода

В редакторе HTML IntelliSense автоматически завершает имена тегов. Функция IntelliSense автоматически завершает все теги и многое другое. В Visual Studio 2010 фрагменты кода IntelliSense для JavaScript, наряду с C# и Visual Basic, которые поддерживались в более ранних версиях Visual Studio поддерживаются.

Visual Studio 2010 содержит более 200 фрагментов кода, помогающие Автозаполнение общих ASP.NET и HTML-теги, включая необходимые атрибуты (такие как runat = «server») и общие атрибуты, относящиеся к тегу (такие как *идентификатор*,  *DataSourceID*, *ControlToValidate*, и *текст*).

Можно загрузить дополнительные фрагменты кода, или можно написать свои собственные фрагменты, которые инкапсулируют блоков разметка, которую вы или ваша команда для выполнения типичных задач.

<a id="0.2__Toc224729054"></a><a id="0.2__Toc253429291"></a><a id="0.2__Toc243304662"></a>

### <a name="javascript-intellisense-enhancements"></a>Усовершенствования IntelliSense для JavaScript

В Visual 2010 IntelliSense для JavaScript был переработан для предоставления более широких возможностей редактирования. Теперь IntelliSense распознает объекты, динамически созданных методами, такими как *registerNamespace* и с помощью схожих технологий, используемых другими инфраструктурами JavaScript. Улучшена производительность для анализа больших библиотек скриптов и отображения IntelliSense с минимумом или совсем без задержки. Совместимость значительно увеличена для поддержки практически всех библиотек сторонних разработчиков и поддерживает разные стили программирования. Комментарии документации разбираются типом и немедленно передаются технологией IntelliSense.

<a id="0.2__Toc224729055"></a><a id="0.2__Toc253429292"></a><a id="0.2__Toc243304663"></a>

## <a name="web-application-deployment-with-visual-studio-2010"></a>Развертывание веб-приложений с помощью Visual Studio 2010

Когда разработчики ASP.NET развертывание веб-приложения, они часто найти точках, например, следующие проблемы:

- Для развертывания на сайте общего размещения требуется технологий, таких как FTP, которого может выполняться медленно. Кроме того необходимо выполнить действия, например запуск сценариев SQL для настройки базы данных вручную, и необходимо изменить параметры служб IIS, такие как настройка папку виртуального каталога, как приложение.
- В среде предприятия, помимо развертывания файлов веб-приложения администраторы должны часто изменять файлов конфигурации ASP.NET и параметры служб IIS. Администраторы базы данных необходимо выполнить ряд сценарии SQL для базы данных приложения. Такие установки трудоемким, часто занять часов, необходимо тщательно задокументированы.

Visual Studio 2010 включает технологии, решить эти проблемы и позволяют легко развертывать веб-приложения. Одна из этих технологий — средство веб-развертывания IIS (MsDeploy.exe).

Следующие основные возможности развертывания Web в Visual Studio 2010:

- Веб-пакетов
- Преобразования Web.config
- Развертывание базы данных
- Публикация одним щелчком для веб-приложений

Следующие разделы предоставляют подробные сведения об этих функциях.

<a id="0.2__Toc224729056"></a><a id="0.2__Toc253429293"></a><a id="0.2__Toc243304664"></a>

### <a name="web-packaging"></a>Веб-пакетов

Visual Studio 2010 использует средство MSDeploy для создания ZIP-файла для приложения, который называется *веб-пакета*. Пакетный файл содержит метаданные о приложении, а также следующее содержимое:

- Параметры служб IIS, которые включают параметры пула приложений, параметров страницы ошибки и т. д.
- Фактический веб-содержимое, включая веб-страниц, пользовательские элементы управления, статическое содержимое (изображения и HTML-файлы) и т. д.
- Схемы баз данных SQL Server и данные.
- Сертификаты безопасности, компоненты будут установлены в глобальный кэш СБОРОК, параметры реестра и т. д.

Веб-пакет можно скопировать на любой сервер и затем установить вручную с помощью диспетчера служб IIS. Кроме того для автоматического развертывания пакета можно установить с помощью командной строки или с помощью функции API развертывания.

Visual Studio 2010 предоставляет встроенные задачи MSBuild и целевых объектов для создания веб-пакетов. Дополнительные сведения см. в разделе [Обзор развертывания веб-приложения ASP.NET проектов](https://msdn.microsoft.com/library/dd394698%28VS.100%29.aspx) на сайте MSDN и [10 + 20 причин, почему следует создать веб-пакет](http://vishaljoshi.blogspot.com/2009/07/10-20-reasons-why-you-should-create-web.html) для работы.

<a id="0.2__Toc224729057"></a><a id="0.2__Toc253429294"></a><a id="0.2__Toc243304665"></a>

### <a name="webconfig-transformation"></a>Преобразования Web.config

Для развертывания веб-приложения, Visual Studio 2010 предоставляет [преобразования документов XML (XDT)](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html), функции, которая позволяет преобразовать `Web.config` файл из параметров разработки производственного параметры. Параметры преобразования указываются в файлы преобразования с именем `web.debug.config`, `web.release.config`, и т. д. (Имена файлов соответствуют конфигурации MSBuild). Файл преобразования включает изменения, которые необходимо внести на развернутой `Web.config` файла. Укажите изменения, используя простой синтаксис.

В следующем примере показано часть `web.release.config` файла, которое может быть произведено для развертывания конфигурации выпуска. Замените ключевое слово в примере указывает, что во время развертывания *connectionString* узел в `Web.config` файла будут заменены значениями, которые перечислены в примере.

[!code-xml[Main](overview/samples/sample102.xml)]

Дополнительные сведения см. в разделе [синтаксис преобразования файла Web.config для развертывания проекта веб-приложения](https://msdn.microsoft.com/library/dd465326%28VS.100%29.aspx) на MSDN <a id="0.2_a"> </a> веб-сайта и[веб-развертывания: преобразования Web.Config](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html)на работы.

<a id="0.2__Toc224729058"></a><a id="0.2__Toc253429295"></a><a id="0.2__Toc243304666"></a>

### <a name="database-deployment"></a>Развертывание базы данных

Пакет развертывания Visual Studio 2010 может включать зависимости, для баз данных SQL Server. Как часть определения пакета укажите строку подключения для базы данных-источника. При создании веб-пакета Visual Studio 2010 создает скрипты SQL для схемы базы данных и при необходимости для данных и затем добавляет их в пакет. Можно также предоставить пользовательские сценарии SQL и укажите последовательность, в котором их следует запустить на сервере. Во время развертывания укажите строку подключения, которая подходит для целевого сервера; процесс развертывания, затем использует эту строку подключения для выполнения скриптов, которые можно создать схему базы данных и добавить данные.

Кроме того, с помощью одного щелчка мыши публикации, можно настроить развертывание для публикации базы данных напрямую, при публикации приложения на удаленном узле общего размещения. Дополнительные сведения см. в разделе [как: развертывание базы данных с проектом веб-приложения](https://msdn.microsoft.com/library/dd465343%28VS.100%29.aspx) на сайте MSDN и [развертывания базы данных с VS 2010](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html) на работы.

<a id="0.2__Toc224729059"></a><a id="0.2__Toc253429296"></a><a id="0.2__Toc243304667"></a>

### <a name="one-click-publish-for-web-applications"></a>Публикация одним щелчком для веб-приложений

Visual Studio 2010 также позволяет использовать службу удаленного управления IIS для публикации веб-приложения на удаленном сервере. Можно создать профиль публикации, для учетной записи размещения или тестовых серверах и промежуточных серверов. Каждый профиль можно безопасно сохранить соответствующие учетные данные. Затем можно развернуть на любой целевой инструментов публикации серверов одним щелчком с помощью веб-одним щелчком. С помощью Visual Studio 2010 также можно опубликовать с помощью командной строки MSBuild. Это позволяет настроить среду командного построения, необходимо включить публикацию в модели непрерывной интеграции.

Дополнительные сведения см. в разделе [как: развертывание Web приложения проекта с использованием публикации одним щелчком и веб-развертывания](https://msdn.microsoft.com/library/dd465337%28VS.100%29.aspx) на сайте MSDN и [веб-публикация одним щелчком мыши с VS 2010](http://vishaljoshi.blogspot.com/2009/05/web-1-click-publish-with-vs-2010.html) на работы. Просмотреть видеопрезентации о развертывании веб-приложения в Visual Studio 2010 [VS 2010 для предварительных версий Web Developer](http://vishaljoshi.blogspot.com/2008/12/vs-2010-for-web-developer-previews.html) на работы.

<a id="0.2__Toc224729060"></a><a id="0.2__Toc253429297"></a><a id="0.2__Toc243304668"></a>

### <a name="resources"></a>Ресурсы

Следующие веб-сайты содержат дополнительные сведения об ASP.NET 4 и Visual Studio 2010.

- [В ASP.NET 4](https://msdn.microsoft.com/library/ee532866%28VS.100%29.aspx) — официальной документации для ASP.NET 4 на сайте MSDN.
- [https://www.asp.net/](https://www.asp.net/) — ASP.NET команды собственные веб-сайта.
- [https://www.asp.net/dynamicdata/](https://msdn.microsoft.com/library/cc488545.aspx) и [Динамическая схема содержимого ASP.NET данных](https://msdn.microsoft.com/library/cc488545%28VS.100%29.aspx) — ресурсы в сети на узле группы ASP.NET и в официальной документации платформы динамических данных ASP.NET.
- [https://www.asp.net/ajax/](../../ajax/index.md) — Основной веб-ресурс для разработки приложений ASP.NET Ajax.
- [https://blogs.msdn.com/webdevtools/](https://blogs.msdn.com/webdevtools/) — Блог команды разработчиков Visual Web, который включает сведения о функциях в Visual Studio 2010.
- [Интернет-стек любви ASP.NET](https://github.com/aspnet/AspNetWebStack) — основной веб-ресурс для предварительных выпусков ASP.NET.

<a id="0.2__Toc224729061"></a><a id="0.2__Toc253429298"></a><a id="0.2__Toc243304669"></a>

## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Сведения, содержащиеся в этом документе, отражают представление корпорации Майкрософт по описанным здесь вопросам на дату публикации. Поскольку корпорация Майкрософт должна реагировать на изменяющиеся рыночные условия, данный документ не должен интерпретироваться как обязательство со стороны Майкрософт, и корпорация Майкрософт не может гарантировать точность любой информации, представленной после даты публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска или передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без соблюдения ограничений авторских прав и письменного разрешения корпорации Майкрософт.

В настоящем документе могут упоминаться запатентованные или патентуемые технологии, товарные знаки, авторские права или другие права интеллектуальной собственности корпорации Майкрософт. Если иного явно не указано в письменном лицензионном соглашении корпорации Майкрософт, данный документ не предоставляет лицензии на эти патенты, товарные знаки, авторские права или другие права интеллектуальной собственности.

Если не указано иное, примеры компаний, организаций, продуктов, имена доменов, адреса электронной почты, эмблемы, люди, места и события названия являются вымышленными и возможное сходство с реально существующими предприятиями, организации, продукта, имя домена, по электронной почте адрес эмблемы, лица и события являются случайными и непреднамеренными.

© 2009 Microsoft Corporation. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
