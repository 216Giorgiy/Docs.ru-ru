---
uid: whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
title: "Новые возможности в ASP.NET 4.5 и Visual Studio 2012 | Документы Microsoft"
author: rick-anderson
description: "В этом документе описываются новые возможности и улучшения, появившиеся в ASP.NET 4.5. В нем также рассматриваются улучшения для разработки веб-приложений..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/29/2012
ms.topic: article
ms.assetid: ba1fabb4-31a3-4ebf-8327-41a6bbba6eaf
ms.technology: 
ms.prod: .net-framework
msc.legacyurl: /whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
msc.type: content
ms.openlocfilehash: 4487eb7436c0b6241505f41621a7f31b89c38b28
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
---
<a name="whats-new-in-aspnet-45-and-visual-studio-2012"></a>Новые возможности в ASP.NET 4.5 и Visual Studio 2012
====================
> В этом документе описываются новые возможности и улучшения, появившиеся в ASP.NET 4.5. Он также описывает усовершенствования, выполняемые для веб-разработки в Visual Studio 2012. Этот документ первоначально был опубликован 29 февраля 2012 г.


- [Среда выполнения ASP.NET Core и Framework](#_Toc318097372)

    - [Асинхронное чтение и запись запросов и ответов HTTP](#_Toc318097373)
    - [Усовершенствования обработки HttpRequest](#_Toc318097374)
    - [Асинхронно сбрасывать ответа](#_Toc318097375)
    - [Поддержка *await* и *задачи*-основе асинхронной модули и обработчики](#_Toc318097376)
    - [Асинхронный HTTP-модули](#_Toc318097377)
    - [Асинхронные обработчики HTTP](#_Toc318097378)
    - [Новые возможности проверки запроса ASP.NET](#_Toc318097379)
    - [Отложенная проверка запроса («ленивым»)](#_Toc318097380)
    - [Поддержка непроверенных запросов](#_Toc318097381)
    - [Библиотека AntiXSS](#_Toc318097382)
    - [Поддержка протокола WebSockets](#_Toc318097383)
    - [Объединение и минификация](#_Toc318097384)
    - [Улучшена производительность для размещения веб-сайтов](#_Toc_perf)

        - [Факторы производительности](#_Toc_perf_1)
        - [Требования для использования новых возможностей производительности](#_Toc_perf_2)
        - [Совместное использование общих сборок](#_Toc_perf_3)
        - [С помощью JIT-компиляции для многоядерных процессоров для более быстрый запуск](#_Toc_perf_4)
        - [Помощник по настройке сбора мусора для оптимизации памяти](#_Toc_perf_5)
        - [Предварительная выборка для веб-приложений](#_Toc_perf_6)
- [Веб-форм ASP.NET](#_Toc318097385)

    - [Строго типизированные элементы управления данными](#_Toc318097386)
    - [Привязка модели](#_Toc318097387)

        - [Выбор данных](#_Toc318097388)
        - [Поставщики значений](#_Toc318097389)
        - [Фильтрация на основе значений из элемента управления](#_Toc318097390)
    - [Выражения привязки данных в кодировке HTML](#_Toc318097391)
    - [Ненавязчивой проверки](#_Toc318097392)
    - [Обновления HTML5](#_Toc318097393)
- [ASP.NET MVC 4](#_Toc318097394)
- [Веб-страницы ASP.NET 2](#_Toc318097395)
- [Версия-кандидат Visual Studio 2012](#_Toc318097396)

    - [Проект, обмена данными между Visual Studio 2010 и Visual Studio 2012 Release Candidate (совместимость проекта)](#project-compatibility)
    - [Изменения конфигурации в шаблонах 4,5 веб-сайта ASP.NET](#Configuration_Changes_In_ASPNET45_Website_Templates)
    - [Собственная поддержка в службах IIS 7 для маршрутизации ASP.NET](#Native_Support_In_IIS7_For_ASPNET_Routine)
    - [Редактор HTML](#_Toc318097397)

        - [Смарт-тегов](#_Toc318097398)
        - [Поддержка WAI ARIA](#_Toc318097399)
        - [Новые фрагменты кода HTML5](#_Toc318097400)
        - [Извлечение в пользовательский элемент управления](#_Toc318097401)
        - [Технология IntelliSense для фрагменты кода в атрибутах](#_Toc318097402)
        - [Автоматическое переименование совпадающих тег при переименовании открывающий или закрывающий тег](#_Toc318097403)
        - [Генерация обработчика событий](#_Toc318097404)
        - [Автоматический отступ](#_Toc318097405)
        - [Уменьшить автоматическое завершение операторов](#_Toc318097406)
    - [Редактор JavaScript](#_Toc318097407)

        - [Структурирование кода](#_Toc318097408)
        - [Парные фигурные скобки](#_Toc318097409)
        - [Перейти к определению](#_Toc318097410)
        - [Поддержка ECMAScript5](#_Toc318097411)
        - [DOM IntelliSense](#_Toc318097412)
        - [Сигнатура перегрузки VSDOC](#_Toc318097413)
        - [Неявные ссылки](#_Toc318097414)
    - [Редактор CSS](#_Toc318097415)

        - [Уменьшить автоматическое завершение операторов](#_Toc318097416)
        - [Отступы.](#_Toc318097417)
        - [Поддержка взломает CSS](#_Toc318097418)
        - [Конкретные схемы поставщика (- moz-- webkit)](#_Toc318097419)
        - [Поддержка комментирования и идет раскомментирование](#_Toc318097420)
        - [Палитра цветов](#_Toc318097421)
        - [Фрагменты кода](#_Toc318097422)
        - [Настраиваемые области](#_Toc318097423)
    - [Инспектор страниц](#_Toc318097424)
    - [Публикация](#_Toc318097425)

        - [Профили публикации](#_Toc318097426)
        - [Предварительная компиляция ASP.NET и слияния](#_Toc318097427)
- [IIS Express](#_Toc318097428)
- [Disclaimer](#_Toc318097429)

<a id="_Toc318097372"></a>
## <a name="aspnet-core-runtime-and-framework"></a>Среда выполнения ASP.NET Core и Framework

<a id="_Toc318097373"></a>
### <a name="asynchronously-reading-and-writing-http-requests-and-responses"></a>Асинхронное чтение и запись запросов и ответов HTTP

ASP.NET 4 появилась возможность считывания сущности запроса HTTP в виде потока с помощью *HttpRequest.GetBufferlessInputStream* метод. Этот метод предоставляется потокового доступа к сущности запроса. Тем не менее она выполнена синхронно, который оказывает поток на время выполнения запроса.

ASP.NET 4.5 поддерживает возможность чтения потоков асинхронно на сущность запрос HTTP и возможность очистить асинхронно. ASP.NET 4.5 также предоставляет возможность объекта запроса HTTP, который обеспечивает простую интеграцию с подчиненным обработчиков HTTP, например .aspx страницы обработчиков и ASP.NET MVC контроллеры двойного буфера.

<a id="_Toc318097374"></a>
#### <a name="improvements-to-httprequest-handling"></a>Усовершенствования обработки HttpRequest

Ссылка поток, возвращенный ASP.NET 4.5 с *HttpRequest.GetBufferlessInputStream* поддерживает синхронные и асинхронные методы для чтения. *Поток* объект, возвращенный из *GetBufferlessInputStream* теперь реализует методы BeginRead и EndRead. Асинхронная *поток* методы позволяют асинхронное чтение объекта запроса в виде фрагментов, пока ASP.NET освобождает текущий поток между каждой итерации цикла асинхронного чтения.

ASP.NET 4.5 добавил вспомогательный метод для чтения объекта запроса буферизованный способом: *метод HttpRequest.GetBufferedInputStream*. Эта перегрузка новый работает как *GetBufferlessInputStream*, поддерживающий синхронные и асинхронные операции чтения. Тем не менее, как она считывает *GetBufferedInputStream* также копирует байты сущности в ASP.NET внутренние буферы, чтобы подчиненных модули и обработчики могут по-прежнему обращаться к сущности запроса. Например, если некоторые выше код в конвейере уже считано сущности запроса с помощью *GetBufferedInputStream*, по-прежнему можно использовать *HttpRequest.Form* или *HttpRequest.Files*. Это позволит вам выполнить асинхронную обработку в запросе (например, потоковая передача передачу большого файла в базе данных), но по-прежнему выполнения ASPX-страницы и MVC ASP.NET controllers впоследствии.

<a id="_Toc318097375"></a>
#### <a name="asynchronously-flushing-a-response"></a>Асинхронно сбрасывать ответа

Отправка ответов на HTTP-клиента может занять значительное время, когда клиент находится далеко или с низкой пропускной способностью. Обычно ASP.NET помещает в буфер байты ответа при их создании в приложении. ASP.NET выполняет одной операции отправки начисленная буферов в самом конце обработки запроса.

Если буфер от ответа большой (например, потоковая передача больших файлов на клиенте), необходимо периодически вызывать *HttpResponse.Flush* для отправки буферизации выходных данных клиента и поддерживать использование памяти в системе управления. Тем не менее поскольку *Flush* синхронный вызов, итеративного вызова *Flush* по-прежнему использует поток на время выполнения потенциально длительных запросов.

ASP.NET 4.5 добавляет поддержку для выполнения удалений в асинхронном режиме с помощью *BeginFlush* и *EndFlush* методы *HttpResponse* класса. С помощью этих методов, можно создать асинхронный модули и асинхронные обработчики, которые последовательно отправке данных клиенту без прерывания потоков операционной системы. Между *BeginFlush* и *EndFlush* вызовы ASP.NET освобождает текущего потока. Это значительно уменьшает общее число активных потоков, необходимых для поддержки загрузки HTTP длительное время.

<a id="_Toc318097376"></a>
### <a name="support-for-await-and-task---based-asynchronous-modules-and-handlers"></a>Поддержка *await* и *задачи* -основе асинхронной модули и обработчики

.NET Framework 4 появился асинхронного программирования концепция, называемая *задачи*. Задачи представляются *задачи* типа и связанных типов в *System.Threading.Tasks* пространства имен. .NET Framework 4.5 сборки на это с использованием компилятора усовершенствования, которые упрощают работу с *задачи* простой объектов. В .NET Framework 4.5, компиляторы поддерживают два новых ключевых слов: *await* и *async*. *Await* ключевое слово является синтаксических сокращением, указывающие, фрагмент кода асинхронно ожидать другой фрагмент кода. *Async* ключевое слово представляет Указание, которое можно использовать для пометки методов, как асинхронные методы на основе задач.

Сочетание *await*, *async*и *задачи* объекта он значительно упрощает написание асинхронного кода в .NET 4.5. ASP.NET 4.5 поддерживает эти упрощения с новые интерфейсы API, которые позволяют записывать асинхронной модули HTTP и асинхронные обработчики HTTP-данных, с помощью усовершенствования компилятора.

<a id="_Toc318097377"></a>
#### <a name="asynchronous-http-modules"></a>Асинхронный HTTP-модули

Предположим, что требуется выполнить асинхронную работу внутри метода, возвращающего *задачи* объекта. В следующем примере кода определяется асинхронного метода, который выполняет асинхронный вызов для загрузки Домашняя страница корпорации Microsoft. Обратите внимание на использование *async* ключевое слово в сигнатуре метода и *await* вызов *DownloadStringTaskAsync*.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample1.cs)]

Это все же придется создавать — .NET Framework автоматически будет обрабатывать очистить стек вызовов во время ожидания для завершения загрузки, а также автоматическое восстановление стека вызовов после завершения загрузки.

Теперь предположим, что вы хотите использовать этот асинхронный метод в асинхронный модуль ASP.NET HTTP. ASP.NET 4.5 содержит вспомогательный метод (*EventHandlerTaskAsyncHelper*) и новый тип делегата (*TaskEventHandler*), можно использовать для интеграции с помощью старых асинхронные методы на основе задач асинхронной модели программирования, предоставляемыми конвейер ASP.NET HTTP. В этом примере показано, как:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample2.cs)]

<a id="_Toc318097378"></a>
#### <a name="asynchronous-http-handlers"></a>Асинхронные обработчики HTTP

Традиционный подход к написанию асинхронные обработчики в ASP.NET является реализация *IHttpAsyncHandler* интерфейса. ASP.NET 4.5 появился *HttpTaskAsyncHandler* асинхронной базовый тип, который можно получить из, благодаря чему намного удобнее использовать асинхронные обработчики.

*HttpTaskAsyncHandler* тип является абстрактным, необходимо переопределить *ProcessRequestAsync* метод. Внутренне ASP.NET берет на себя интеграции возвращаемого подписи ( *задачи* объекта) из *ProcessRequestAsync* с более старых асинхронную модель программирования, используемую конвейера ASP.NET.

В следующем примере показано, как использовать *задачи* и *await* как часть реализации асинхронного обработчика HTTP:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample3.cs)]

<a id="_Toc318097379"></a>
### <a name="new-aspnet-request-validation-features"></a>Новые возможности проверки запроса ASP.NET

По умолчанию, ASP.NET выполняет проверку, он проверяет запросы для поиска разметки или сценария в поля, заголовков, файлы cookie и т. д. При обнаружении любого ASP.NET создает исключение. Это действует как первую линию обороны от потенциальных атак сценариев между сайтами.

ASP.NET 4.5 позволяет выборочно чтение данных непроверенных запросов. ASP.NET 4.5 интегрирует популярных AntiXSS библиотеки, которая раньше была внешней библиотеки.

Разработчики ответы на возможность выборочно отключить проверку запросов для своих приложений. Например если приложение является форум программного обеспечения, можно разрешить пользователям отправлять сообщения в формате HTML форумах и комментарии, но по-прежнему необходимо убедиться, что запрос проверки проверяет, все остальные.

ASP.NET 4.5 предоставляет две функции, с помощью которых проще выборочно работать с непроверенные входные данные: Отложенная проверка запроса («ленивым») и доступ к данным непроверенных запросов.

<a id="_Toc318097380"></a>
#### <a name="deferred-lazy-request-validation"></a>Отложенная проверка запроса («ленивым»)

В ASP.NET 4.5 по умолчанию все данные запроса регулируется проверки запроса. Тем не менее можно настроить приложение, чтобы отложить проверку запросов, до фактического доступа к данных запроса. (Это иногда называется проверку отложенной запросов, на основе условий как отложенную загрузку для некоторых сценариев данных.) Можно настроить приложение для использования отложенного проверки в файле Web.config, задав *requestValidationMode* атрибут 4.5 в *httpRUntime* элемента, как показано в следующем примере:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample4.xml)]

При режиме проверки запроса имеет значение 4.5, проверка запроса инициируется только для конкретного запроса значения, и только в том случае, если код обращается к этому значению. Например, если код возвращает значение Request.Form["forum\_блога"], проверка запроса вызывается только для этого элемента в коллекции форм. Ни один из других элементов в *формы* коллекции проверяются. В предыдущих версиях ASP.NET проверка запроса было запущено для всего запроса коллекции после обращения к любой элемент в коллекции. Новое поведение упрощает разные компоненты приложения рассмотрим различные части запроса данных, не активируя проверку запросов на другие элементы.

<a id="_Toc318097381"></a>
#### <a name="support-for-unvalidated-requests"></a>Поддержка непроверенных запросов

Проверка отложенного запроса сама по себе не решает проблемы выборочно обход проверки запроса. Вызов Request.Form["forum\_блога «] по-прежнему триггеры запрос проверки для этого запроса конкретного значения. Тем не менее может потребоваться доступ к этому полю, не активируя проверку, поскольку требуется разрешить разметку в этом поле.

Для этого ASP.NET 4.5 теперь поддерживает непроверенных доступ к данным запроса. ASP.NET 4.5 включает в себя новый *Unvalidated* свойство коллекции в *HttpRequest* класса. Эта коллекция предоставляет доступ ко всем значений общих данных запроса, как *формы*, *QueryString*, *файлы cookie*, и *URL-адрес*.

Используя пример форум, чтобы иметь возможность считывать данные непроверенных запросов, сначала необходимо настроить приложение для использования нового режима проверки запроса:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample5.xml)]

Затем можно использовать *HttpRequest.Unvalidated* свойство для чтения значения непроверенных форм:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample6.cs)]


> [!WARNING]
> Безопасность — *данных непроверенных запросов следует использовать с осторожностью.* ASP.NET 4.5 добавлена непроверенных запросов свойства и коллекции для упрощения доступа к данным Основательная непроверенных запросов. Однако по-прежнему необходимо выполнить пользовательскую проверку на основе данных необработанный запрос, чтобы убедиться, что опасный текст не отображается для пользователей.


<a id="_Toc318097382"></a>
### <a name="antixss-library"></a>Библиотека AntiXSS

Из-за популярности AntiXSS библиотеки Microsoft ASP.NET 4.5 теперь включает процедуры кодирования основной версии 4.0 этой библиотеки.

Процедуры кодирования реализуются *AntiXssEncoder* типа в новом *System.Web.Security.AntiXss* пространства имен. Можно использовать *AntiXssEncoder* тип непосредственно с помощью вызова любого из статических методов кодирования, реализованные в типе. Тем не менее, для использования нового подпрограммы anti-XSS проще настроить приложение ASP.NET для использования *AntiXssEncoder* класс по умолчанию. Чтобы сделать это, добавьте следующий атрибут в файл Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample7.xml)]

Когда *encoderType* атрибут настроена на использование *AntiXssEncoder* типа, весь вывод в ASP.NET кодировку автоматически использует новые процедуры кодирования.

Существуют следующие части внешней AntiXSS библиотеки, которые могут быть включены в ASP.NET 4.5:

- *HtmlEncode*, *HtmlFormUrlEncode*, и *HtmlAttributeEncode*
- *XmlAttributeEncode* и *XmlEncode*
- *Кодируют* и *UrlPathEncode* (новая)
- *CssEncode*

<a id="_Toc318097383"></a>
### <a name="support-for-websockets-protocol"></a>Поддержка протокола WebSockets

Протокол WebSocket является основанную на стандартах сетевой протокол, определяющий способ обмена данными двунаправленный безопасный, в режиме реального времени между клиентом и сервером по протоколу HTTP. Корпорация Майкрософт работает со W3C и IETF тел стандартам для определения протокола. Протокол WebSocket поддерживается любым клиентом (не только браузеры) с корпорацией Майкрософт, направив средства на приобретение значительное количество ресурсов, поддержка протокола WebSockets на клиент и операционные системы мобильных.

Протокол WebSocket делает гораздо проще создавать передачи данных долго выполняющихся между клиентом и сервером. Например запись приложения разговора гораздо проще, так как можно установить значение true, длительные соединение между клиентом и сервером. Необходимо использовать обходные пути, например периодический опрос или продолжительным опросом HTTP для моделирования поведения сокета.

ASP.NET 4.5 и IIS 8 поддерживает низкоуровневые WebSockets, позволяя разработчикам ASP.NET для использования управляемых интерфейсов API для асинхронного чтения и записи строки и двоичные данные в объекте WebSockets. Для ASP.NET 4.5 имеется новый *System.Web.WebSockets* пространство имен, которое содержит типы для работы с протоколом WebSockets.

Браузер клиент устанавливает соединение WebSockets путем создания DOM *WebSocket* объект, который указывает на URL-адрес в приложении ASP.NET, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample8.cs)]

Можно создать конечные точки WebSockets в ASP.NET с помощью любого вида модуль или обработчик. В предыдущем примере использовался данного файла, так как файлы .ashx быстрый способ создания обработчика.

Согласно протоколу WebSockets приложения ASP.NET принимает запрос соединения WebSocket клиента, указывая, что запрос должно быть обновлено с помощью запроса HTTP GET на запрос соединения WebSocket. Ниже приведен пример:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample9.cs)]

*AcceptWebSocketRequest* метод принимает делегат функции, так как ASP.NET освобождает текущего HTTP-запроса и затем передает управление делегат функции. Концептуально этот подход аналогичен использование *System.Threading.Thread*, где необходимо определить делегат начала потока, в которой фоновые выполняется работа.

После ASP.NET, так и клиента успешно завершена подтверждения соединения WebSocket, ASP.NET вызывает делегат и запуск приложения WebSockets. В следующем примере кода показан простой echo приложение, которое использует встроенную поддержку WebSockets в ASP.NET:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample10.cs)]

Поддержка в .NET 4.5 для *await* ключевое слово и асинхронные операции на основе задач очень удобна для написания приложений WebSockets. В примере кода показано, полностью асинхронно выполняет запрос соединения WebSocket в ASP.NET. Асинхронно ожидания приложением сообщения, отправляемые с клиента путем вызова *await сокета. ReceiveAsync*. Аналогичным образом, отправке асинхронное сообщение клиенту путем вызова *await сокета. SendAsync*.

В браузере, приложение получает сообщения WebSockets через *onmessage* функции. Чтобы отправить сообщение из браузера, вызовите *отправки* метод *WebSocket* типа DOM, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample11.cs)]

В будущем мы выпускает обновления для этих функциональных возможностей, что абстрактный отсутствовали некоторые низкоуровневые кодировки, то есть требуется в этом выпуске WebSockets приложений.

<a id="_Toc318097384"></a>
### <a name="bundling-and-minification"></a>Объединение и Минификация

Объединение позволяет объединить отдельные файлы JavaScript и CSS в пакет, который может рассматриваться как один файл. Иными сжимает файлы JavaScript и CSS, удаляя пробелы и другие символы, которые не являются обязательными. Эти возможности работы с веб-форм ASP.NET MVC и веб-страниц.

Пакеты создаются с помощью класса пакета или один из его дочерних классов ScriptBundle и StyleBundle. После настройки экземпляра пакета, пакета доступны на входящие запросы, просто добавьте его в глобальный экземпляр BundleCollection. По умолчанию в шаблонах конфигурации пакета выполняется в файле BundleConfig. Эта конфигурация по умолчанию создает пакеты для всех основных сценариев и css-файлы, используемые в шаблонах.

Пакеты ссылаются внутри представления с помощью одного из несколько возможных вспомогательные методы. Для поддержки визуализации различные разметки для пакета во время отладки и режиме выпуска, ScriptBundle и StyleBundle классы имеют вспомогательный метод визуализации. В режиме отладки, Render создает разметку для каждого ресурса в пакете. В режиме выпуска отрисовки создаст элемент одной разметки для всего пакета. Переключение между отладочной и окончательной режим можно, изменив атрибут debug элемента компиляции в файле web.config, как показано ниже:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample12.xml)]

Кроме того Включение и отключение оптимизации можно задать непосредственно через свойство BundleTable.EnableOptimizations.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample13.cs)]

Когда файлы объединены, они сначала упорядочены по алфавиту (способ их отображения в **обозревателе решений**). Затем организованы известно библиотек, и их пользовательские расширения (например, jQuery, MooTools и Dojo) гарантированно загружались первыми. Например будет конечного порядка для объединения папку «скрипты», как показано выше:

1. jquery-1.6.2.js
2. jquery-ui.js
3. jquery.tools.js
4. a.js

CSS-файлах также сортируются в алфавитном порядке и реорганизовать, так что reset.css и normalize.css предшествовать любым другим файлом. Конечный способ сортировки объединение указанной выше папки стили будет это:

1. reset.css
2. Content.CSS
3. Forms.CSS
4. Globals.CSS
5. Menu.CSS
6. Styles.CSS

<a id="_Toc_perf"></a>
### <a name="performance-improvements-for-web-hosting"></a>Улучшена производительность для размещения веб-сайтов

.NET Framework 4.5 и Windows 8 включать компоненты, может помочь достичь значительного увеличения производительности благодаря использованию для рабочих нагрузок с веб сервера. Это включает в себя сокращение (до 35%) в обоих время запуска и объем памяти для веб-сайтов, которые используют ASP.NET размещения.

<a id="_Toc_perf_1"></a>
#### <a name="key-performance-factors"></a>Факторы производительности

В идеальном случае всех веб-сайтов должен быть активным и в памяти для обеспечения быстрого ответа на следующий запрос каждый раз, когда они поступают. Следующие факторы, которые могут повлиять на скорость реагирования сайта.

- Время, необходимое для сайта перезагрузить пул приложений запускается повторно. Это время, необходимое для запуска процесса веб-сервера для сайта, когда сборки сайта больше не находятся в памяти. (Сборки платформы, остается в памяти, так как они используются для других сайтов.) Такой ситуации называется «холодные site, горячего framework запуска» или просто «холодного Автозагрузка сайта.»
- Объем памяти, занимаемый сайта. Условия для этого являются «потребление памяти для каждого сайта» или «без предоставления общего доступа рабочий набор.»

Новые улучшения производительности сосредоточиться на обоих этих факторов.

<a id="_Toc_perf_2"></a>
#### <a name="requirements-for-new-performance-features"></a>Требования для использования новых возможностей производительности

Требования для включения новых возможностей можно разделить на следующие категории:

- Усовершенствования, которые выполняются на платформе .NET Framework 4.
- Улучшения, которые требуется .NET Framework 4.5, но можно запустить в любой версии Windows.
- Улучшения, доступные только в .NET Framework 4.5 на Windows 8.

Производительность увеличивается с каждым уровнем улучшения, которому можно включить.

Некоторые усовершенствования .NET Framework 4.5 воспользоваться преимуществами более широкой функции производительности, которые применяются в других сценариях, а также.

<a id="_Toc_perf_3"></a>
#### <a name="sharing-common-assemblies"></a>Совместное использование общих сборок

**Требование**: .NET Framework 4 и Visual Studio 11 Developer Preview пакет SDK

Разные сайты, на сервере часто используют те же вспомогательные сборки (например, сборки из starter kit или образец приложения). Каждый узел имеет собственную копию этих сборок в каталоге Bin. Несмотря на то, что идентичен объектный код для сборки, они физически отдельных сборках, каждая сборка имеет для чтения во время запуска холодного сайта отдельно и хранится отдельно в памяти.

Новые функциональные возможности интернирования решает подобную неэффективность и уменьшает требования к оперативной памяти и загрузки времени. Изоляция позволяет Windows хранить одну копию каждой сборки в файловой системе и отдельные сборки в папке Bin сайта заменяются с символьными ссылками на единственную копию. Если отдельного узла должен distinct версию сборки, символьную ссылку заменяется новой версии сборки и влияет только с этого сайта.

Совместное использование сборок с помощью символические ссылки требуется новое средство, с именем aspnet\_intern.exe, который позволяет создавать и управлять хранилищем интернированные сборки. Он предоставляется в составе Visual Studio 11 Developer Preview SDK. (Тем не менее, он будет работать в системе, которая содержит только .NET Framework 4 установлена, при условии, что вы установили последнюю версию [обновление](https://support.microsoft.com/kb/2468871).)

Чтобы уже интернировано все подходящие сборки, запустите aspnet\_intern.exe периодически (например, раз в неделю по расписанию). Обычно используется следующим образом:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample14.cmd)]

Для просмотра всех параметров, запустите средство без аргументов.

<a id="_Toc_perf_4"></a>
#### <a name="using-multi-core-jit-compilation-for-faster-startup"></a>С помощью JIT-компиляции для многоядерных процессоров для более быстрый запуск

**Требование**: .NET Framework 4.5

Для запуска сайта холодного не только сделать сборки должны быть считаны с диска, но имя сайта должно быть JIT-компиляции. Для сложных сайта это можно добавить значительные задержки. Новый способ общего назначения в .NET Framework 4.5 уменьшает эти задержки, распределяя JIT-компиляции между доступных ядер процессора. Это делается столько и как можно раньше, используя сведения, собранные во время предыдущих запускает веб-узла. Эта функция реализуется [System.Runtime.ProfileOptimization.StartProfile](https://msdn.microsoft.com/library/system.runtime.profileoptimization.startprofile(VS.110).aspx) метод.

JIT-компиляции с использованием нескольких ядер включен по умолчанию в ASP.NET, поэтому не нужно ничего делать, чтобы воспользоваться этой функцией. Если вы хотите отключить эту функцию, сделайте следующий параметр в файле Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample15.xml)]

<a id="_Toc_perf_5"></a>
#### <a name="tuning-garbage-collection-to-optimize-for-memory"></a>Помощник по настройке сбора мусора для оптимизации памяти

**Требование**: .NET Framework 4.5

После запуска сайта его использование в куче сборщика мусора (GC) может быть значительную роль в используемой памяти. Как и любой сборщиком мусора сборщик Мусора .NET Framework делает компромисса между времени ЦП (частота и значимость коллекций), а также потребление памяти (дополнительное пространство, используемое для новых, освобожденные или может освободить объекты). Для предыдущих версий предоставлены рекомендации по настройке сборки Мусора для достижения баланс (например, в разделе [ASP.NET 2.0 и 3.5 настройки общего пользования размещение](https://www.iis.net/learn/web-hosting/web-server-for-shared-hosting/aspnet-20-35-shared-hosting-configuration)).

Для платформы .NET Framework 4.5, вместо нескольких параметров автономного, параметр конфигурации определяемых рабочей нагрузки доступна, позволяющий все ранее рекомендуемые параметры сборки Мусора а также новый помощник по настройке, обеспечивает дополнительную производительность для каждого сайта рабочее множество.

Чтобы включить помощник по настройке памяти GC, добавление в файл Windows\Microsoft.NET\Framework\v4.0.30319\aspnet.config следующий параметр:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample16.xml)]

(Если вы знакомы с предыдущей инструкции для изменения aspnet.config, обратите внимание, что этот параметр заменяет старые параметры — например, нет необходимости для задания gcServer, gcConcurrent и т. д. У вас удалить старые параметры.)

<a id="_Toc_perf_6"></a>
#### <a name="prefetching-for-web-applications"></a>Предварительная выборка для веб-приложений

**Требование**: .NET Framework 4.5 на Windows 8

Несколько выпусков Windows включила технология [ОС](http://en.wikipedia.org/wiki/Prefetcher) , снижает стоимость считывания с диска при запуске приложения. Поскольку холодного запуска ошибка преимущественно для клиентских приложений, эта технология не был включен в Windows Server, которая включает только те компоненты, которые необходимы для сервера. Предварительная выборка теперь доступна в последней версии Windows Server, где можно оптимизировать запуска отдельных веб-сайтов.

Для Windows Server ОС не включен по умолчанию. Включение и настройка ОС для размещения высокой плотности веб-сайтов, запустите следующий набор команд из командной строки:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample17.cmd)]

Чтобы интегрировать ОС с приложениями ASP.NET, добавьте следующее в файл Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample18.xml)]

<a id="_Toc318097385"></a>
## <a name="aspnet-web-forms"></a>Веб-формы ASP.NET

<a id="_Toc318097386"></a>
### <a name="strongly-typed-data-controls"></a>Строго типизированные данные элементы управления

В ASP.NET 4.5 веб-форм содержит ряд усовершенствований для работы с данными. Первый улучшения — управляет данные со строгой типизацией. Для элементов управления веб-форм в предыдущих версиях ASP.NET, отобразить значение с привязкой к данным с помощью *Eval* и выражение привязки данных:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample19.aspx)]

Для двусторонней привязки данных, используйте *привязки*:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample20.aspx)]

Во время выполнения этих вызовов использовать отражение для чтения значения заданного элемента и затем отображают результат в разметке. Этот подход упрощает для привязки данных для произвольного unshaped данных.

Тем не менее выражения привязки данных этого типа не поддерживают функции, такие как IntelliSense для имен членов, навигации (такие как перейти к определению) или проверка этих имен во время компиляции.

Чтобы устранить эту проблему, ASP.NET 4.5 добавлена возможность объявить тип данных, данных, к которому привязан элемент управления. Это делается с помощью нового *ItemType* свойство. Если это свойство задано, две новые типизированные переменные доступны в область выражения привязки данных: *элемент* и *BindItem*. Поскольку переменные являются строго типизированными, вы получаете все преимущества опыт разработки Visual Studio.


Выражения привязки данных, используйте *BindItem* переменной:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample21.aspx)]


Большинство элементов управления в структуре веб-форм ASP.NET, которые поддерживают привязку данных были обновлены для поддержки *ItemType* свойство.

<a id="_Toc318097387"></a>
### <a name="model-binding"></a>Привязка модели

Привязка модели расширяет возможности привязки данных в элементах управления веб-форм ASP.NET для работы с доступом к данным, ориентированный на код. Он включает в себя концепции из *ObjectDataSource* управления и из привязки модели в ASP.NET MVC.

<a id="_Toc318097388"></a>
#### <a name="selecting-data"></a>Выбор данных

Настройка элемента управления данных для использования привязки модели для выбора данных, задать для элемента управления *SelectMethod* на имя метода в коде страницы. Элемент управления данных вызывает метод в соответствующее время жизненного цикла страницы и автоматически связывает возвращаемых данных. Нет необходимости явно вызвать *DataBind* метод.

В следующем примере *GridView* элемент управления должен содержать метод с именем *GetCategories*:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample22.aspx)]

Вы создаете *GetCategories* метод в коде страницы. Для простой операции select не требуется задавать параметры метода и должен возвращать *IEnumerable* или *IQueryable* объекта. Если новый *ItemType* свойству (что обеспечивает строго типизированными выражения привязки данных, как описано в разделе [строго типизированные элементы управления данными](#_Toc318097386) ранее), универсальных версий этих интерфейсов должно быть возвращено — *IEnumerable&lt;T&gt;*  или *IQueryable&lt;T&gt;*, с *T* параметр, совпадающим с типом *ItemType* свойства (например, *IQueryable&lt;категории&gt;*).

В следующем примере показано код *GetCategories* метод. В этом примере используется модель Entity Framework Code First с образцом базы данных "Борей". Код гарантирует, что запрос возвращает подробные сведения о связанных продуктов для каждой категории посредством *Include* метод. (Это гарантирует, что *TemplateField* элемент в разметке отображает количество продуктов в каждой категории без необходимости [n + 1 Выделите](http://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem).)

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample23.cs)]

При запуске страницы, *GridView* управления вызовы *GetCategories* метод автоматически и отображает возвращаемые данные, используя настроенные поля:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.png)

Поскольку метод select возвращает *IQueryable* объекта, *GridView* управления можете расширить спектр операций запроса перед его выполнением. Например *GridView* управления можно добавить выражения запроса для сортировки и разбиения на страницы в возвращаемую *IQueryable* объекта перед его выполнением, чтобы эти операции выполняются с базовым Поставщик LINQ. В этом случае Entity Framework будет убедитесь, что эти операции выполняются в базе данных.

В следующем примере показан *GridView* управления изменена с целью разрешить сортировку и разбиение на страницы:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample24.aspx)]

Теперь при запуске страницы, элемент управления может убедитесь, что отображения текущей страницы данных и упорядочен по выбранному столбцу:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.png)

Для фильтрации возвращаемых данных, параметры должны добавляться к методу select. Эти параметры будет взят из привязки модели во время выполнения, и их можно использовать для изменения запроса до возвращения данных.

Например предположим, что вы хотите разрешить пользователям фильтрации продуктов по ключевому слову в строке запроса. Можно добавить параметр в метод и обновить код, чтобы использовать значение параметра по:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample25.cs)]

Этот код включает *где* выражение, если указано значение для *ключевое слово* и затем возвращает результаты запроса.

<a id="_Toc318097389"></a>
#### <a name="value-providers"></a>Поставщики значений

Предыдущий пример не указать, где значение *ключевое слово* небезопасного параметра. Чтобы указать эти сведения, можно использовать атрибут параметра. Например, можно использовать *QueryStringAttribute* класс в *System.Web.ModelBinding* пространство имен:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample26.cs)]

Это указывает, что привязка модели для привязки значение из строки запроса для *ключевое слово* параметра во время выполнения. (Это может вызвать выполнение преобразования типа, несмотря на то, что это не так, в этом случае.) Если тип не допускает значения NULL не может быть указано значение, создается исключение.

Источники значений для этих методов, рассматриваются как поставщики значений, а атрибуты параметра, которые указывают, какой поставщик значений для использования, рассматриваются как значения атрибутов поставщика. Веб-формы будет включать поставщиков значений и соответствующих атрибутов для всех обычные параметры вводимых пользователем данных в приложении Web Forms, такие как строка запроса, файлы cookie, значения формы, элементы управления, состояние представления, состояние сеанса и свойства профиля. Можно также написать поставщиках пользовательских значений.

По умолчанию имя параметра используется как ключ для поиска значения в коллекцию поставщиков значение. В примере, код будет выглядеть значение строки запроса с именем ключевого слова (например, ~ / default.aspx?keyword=chef). Можно указать пользовательский ключ, передавая его как аргумент для параметра атрибута. Например чтобы использовать значение переменной строки запроса с именем q, удалось это можно сделать:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample27.cs)]

Если этот метод в коде страницы, пользователи могут фильтровать результаты путем передачи строки запроса с помощью ключевого слова:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.png)

Привязка модели выполняет многие задачи, которые в противном случае пришлось бы кодировать вручную: считывания значения, проверка значение null, предпринимается попытка преобразовать его в соответствующий тип проверки, успешно ли выполнено преобразование и и, наконец, использование значения в запрос. Привязки результаты в гораздо меньше кода и возможность повторного использования функциональности во всем приложении модели.

<a id="_Toc318097390"></a>
#### <a name="filtering-by-values-from-a-control"></a>Фильтрация на основе значений из элемента управления

Предположим, что вы хотите расширить пример, чтобы позволить пользователю выбирать из раскрывающегося списка значение для фильтра. Добавьте следующие раскрывающегося списка в разметку и настройте его для получения данных из другой метод с помощью *SelectMethod* свойства:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample28.aspx)]

Обычно необходимо также добавить *EmptyDataTemplate* элемент *GridView* управления, чтобы элемент управления будет выведено сообщение, если нет соответствия продуктов не найдены:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample29.aspx)]

В коде страницы добавьте новый метод для раскрывающегося списка выберите:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample30.cs)]

Наконец, обновите *GetProducts* выберите метод, чтобы использовать новый параметр, содержащий идентификатор выбранной категории из раскрывающегося списка:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample31.cs)]

Теперь при запуске страницы, пользователи могут выбрать категорию в раскрывающемся списке и *GridView* управления автоматически повторно привязанные отображаются отфильтрованные данные. Это можно сделать, так как привязки модели отслеживает значения параметров для выбора методов и обнаруживает изменения все значения параметров после обратной передачи. В этом случае привязка модели заставляет элемент управления связанные данные повторно привязать к данным.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.png)

<a id="_Toc318097391"></a>
### <a name="html-encoded-data-binding-expressions"></a>Выражения привязки данных в кодировке HTML

Вы можете теперь HTML-кодирование результат выражения привязки данных. Добавьте двоеточие (:) в конец &lt;префикс % #, который помечает выражение привязки данных:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample32.aspx)]

<a id="_Toc318097392"></a>
### <a name="unobtrusive-validation"></a>Ненавязчивой проверки

Теперь можно настроить встроенные проверяющие элементы управления для использования ненавязчивого JavaScript для логики проверки на стороне клиента. Это значительно уменьшает объем кода JavaScript, встроенный в разметке страницы и сокращает общий размер страницы. Можно настроить ненавязчивого JavaScript для проверяющих элементов управления в любой из следующих способов:

- Глобально, добавив следующий параметр в  *&lt;appSettings&gt;*  в файле Web.config: 

    [!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample33.xml)]
- Глобально путем задания статического *System.Web.UI.ValidationSettings.UnobtrusiveValidationMode* свойства *UnobtrusiveValidationMode.WebForms* (обычно в *приложения \_Запустить* метод в файле Global.asax).
- По отдельности для страницы, задав новый *для режима UnobtrusiveValidationMode* свойство *страницы* класса *UnobtrusiveValidationMode.WebForms*.

<a id="_Toc318097393"></a>
### <a name="html5-updates"></a>Обновления HTML5

Некоторые были внесены усовершенствования для веб-форм серверные элементы управления, чтобы воспользоваться преимуществами новых функций HTML5:

- *TextMode* свойство *TextBox* управления был обновлен для поддержки новых типов входных HTML5 как *электронной почты*, *datetime*, и т. д.
- *FileUpload* управления теперь поддерживает загрузки нескольких файлов с помощью браузеров, поддерживающих эту функцию HTML5.
- Проверяющие элементы управления теперь поддержки проверки HTML5 входных элементов.
- Новые элементы HTML5 атрибутами, которые представляют URL-адрес теперь поддерживает runat = «server». В результате можно использовать ASP.NET соглашения в пути URL-адресов как ~ оператор для представления корня приложения (например, &lt;видео runat = «server» src="~/myVideo.wmv» /&gt;).
- *UpdatePanel* исправлена элемента управления для поддержки полей ввода учета HTML5.

<a id="_Toc318097394"></a>
## <a name="aspnet-mvc-4"></a>ASP.NET MVC 4

Бета-версия ASP.NET MVC 4 — теперь включены с помощью бета-версии Visual Studio 11. ASP.NET MVC — это платформа для разработки веб-приложений высокой тестирования и сопровождения, используя шаблон Model-View-Controller (MVC). ASP.NET MVC 4 позволяет легко создавать приложения для мобильных веб-технологий и включает веб-API ASP.NET, который помогает создавать службы HTTP могут связаться с любого устройства. Дополнительные сведения см. в разделе [заметки о выпуске ASP.NET MVC 4](mvc4-release-notes.md).

<a id="_Toc318097395"></a>
## <a name="aspnet-web-pages-2"></a>Веб-страницы ASP.NET 2

Новые возможности:

- Шаблоны новых и обновленных узлов.
- Добавление сервера и проверки на стороне клиента с помощью *проверки* вспомогательный.
- Возможность регистрировать скрипты с помощью диспетчера ресурсов.
- Включить имена входа из Facebook, а также других узлов, с помощью OAuth и OpenID.
- Добавление сопоставляется с помощью *сопоставляет* вспомогательный.
- Запуск веб-страниц приложений side-by-side.
- Подготовка к просмотру страницы для мобильных устройств.

Дополнительные сведения об этих функциях и примеры кода в полностраничном см. в разделе [верхней функции в бета-версии 2 веб-страницы](https://go.microsoft.com/fwlink/?LinkID=227824).

<a id="_Toc318097396"></a>
## <a name="visual-web-developer-11-beta"></a>Бета-версия Visual Web Developer 11

Этот раздел предоставляет сведения об улучшениях для веб-разработки в Visual Web Developer 11 Beta и версии-кандидата Visual Studio 2012.

<a id="project-compatibility"></a>
### <a name="project-sharing-between-visual-studio-2010-and-visual-studio-2012-release-candidate-project-compatibility"></a>Проект, обмена данными между Visual Studio 2010 и Visual Studio 2012 Release Candidate (совместимость проекта)

До Visual Studio 2012 Release Candidate Открытие существующего проекта в более новой версии Visual Studio запущен мастер преобразования. Это обновление содержимого проекта и решения (средства) принудительно новые форматы, которые не были совместимы. Таким образом после преобразования вы не удалось открыть проект более ранней версии Visual Studio.

Многие клиенты просили, это не правильного подхода. В Visual Studio 11 бета-версии мы теперь поддерживают совместное использование проектов и решений с помощью Visual Studio 2010 с пакетом обновления 1. Это означает, что при открытии 2010 project в Visual Studio 2012 Release Candidate по-прежнему можно открыть проект в Visual Studio 2010 с пакетом обновления 1.

> [!NOTE]
> Несколько типов проектов не может совместно использоваться Visual Studio 2010 с пакетом обновления 1 и версии-кандидата Visual Studio 2012. К ним относятся некоторые более старые проекты (таких как проекты ASP.NET MVC 2) или проекты для особых целей (например проекты установки).

При открытии проекта Visual Studio 2010 с пакетом обновления 1 Web в первый раз в бета-версии Visual Studio 11, в файл проекта будут добавлены следующие свойства:

- FileUpgradeFlags
- UpgradeBackupLocation
- OldToolsVersion
- VisualStudioVersion
- VSToolsPath

FileUpgradeFlags, UpgradeBackupLocation и OldToolsVersion используются процессом, который обновляет файл проекта. Они не оказывают влияния на работу с проектом в Visual Studio 2010.

VisualStudioVersion — это новое свойство, используемых MSBuild 4.5, который указывает версию Visual Studio для текущего проекта. Так как это свойство не существует в MSBuild 4.0 (версия MSBuild, который использует Visual Studio 2010 с пакетом обновления 1), мы вводят значение по умолчанию в файле проекта.

Свойство VSToolsPath используется для определения правильного TARGETS-файл для импорта из пути, представленного параметром MSBuildExtensionsPath32.

Существуют также некоторые изменения, связанные с элементами Import. Эти изменения не требуется для поддержки совместимости между обе версии Visual Studio.

> [!NOTE]
> Если проект общим для Visual Studio 2010 с пакетом обновления 1 и бета-версии Visual Studio 11 на двух различных компьютерах, и если проект включает локальную базу данных в приложении\_папке данных, убедитесь, что установлена версия SQL Server, используемые в базе данных установлены на обоих компьютерах.

<a id="Configuration_Changes_In_ASPNET45_Website_Templates"></a>
### <a name="configuration-changes-in-aspnet-45-website-templates"></a>Изменения конфигурации в шаблонах 4,5 веб-сайта ASP.NET

По умолчанию были внесены следующие изменения *Web.config* файл для сайта, созданные с помощью шаблонов веб-сайта в версии-кандидате Visual Studio 2012:

- В `<httpRuntime>` элемент, `encoderType` атрибут имеет значение по умолчанию теперь использование AntiXSS типы, которые были добавлены к ASP.NET. Дополнительные сведения см. в разделе [AntiXSS библиотеки](#_Toc318097382).
- Кроме того, в `<httpRuntime>` элемент, `requestValidationMode` атрибута задано значение «4.5». Это означает, что по умолчанию проверка запросов настроен на использование отложенной проверки («ленивым»). Дополнительные сведения см. в разделе [новые возможности проверки запроса ASP.NET](#_Toc318097379).
- `<modules>` Элемент `<system.webServer>` раздел не содержит `runAllManagedModulesForAllRequests` атрибута. (По умолчанию имеет значение false.) Это означает, что при использовании версии IIS 7, которая не была обновлена до SP1, может потребоваться проблем с маршрутизацией на новом узле. Дополнительные сведения см. в разделе [собственную поддержку в IIS 7 для маршрутизации ASP.NET](#Native_Support_In_IIS7_For_ASPNET_Routine).

Эти изменения не влияют на существующие приложения. Тем не менее они могут представлять различие в поведении между существующих веб-сайтов и новых веб-сайтов, которое создано для ASP.NET 4.5 с использованием новых шаблонов.

<a id="Native_Support_In_IIS7_For_ASPNET_Routine"></a>
### <a name="native-support-in-iis-7-for-aspnet-routing"></a>Собственная поддержка в службах IIS 7 для маршрутизации ASP.NET

Это не изменение ASP.NET таким образом, но изменения в шаблонах для новых проектов веб-сайта, которые могут повлиять на вас при работе версии IIS 7, который не был применен обновления SP1.

В ASP.NET можно добавить следующий параметр конфигурации для приложения для поддержки маршрутизации:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample34.xml?highlight=3)]

При **runAllManagedModulesForAllRequests** равно "true", "URL-адрес: `http://mysite/myapp/home` переходит к ASP.NET, даже при наличии не *.aspx*, *MVC было связано*, или же расширения для URL-АДРЕС.

Делает обновления, которые были выполнены для IIS 7 **runAllManagedModulesForAllRequests** Установка ненужных и поддерживает маршрутизацию в собственном коде ASP.NET. (Дополнительные сведения об обновлении см. в статье технической поддержки Майкрософт [обновление доступно, что позволяет определенным обработчикам служб IIS 7.0 или IIS 7.5 обрабатывать запросы, URL-адреса не заканчиваться точкой](https://support.microsoft.com/kb/980368).)

Если ваш веб-сайт работает в службах IIS 7, и если IIS был обновлен, не нужно задавать **runAllManagedModulesForAllRequests** значение true. На самом деле задание значения true не рекомендуется, поскольку он добавляет ненужных затрат на запрос. Если этот параметр имеет значение true, все запросы, в том числе для *.htm*, *.jpg*, и другие статические файлы также проходят через конвейер запросов ASP.NET.

При создании нового ASP.NET 4.5 веб-сайта с помощью шаблонов, предоставляемых в Visual Studio 2012 RC, конфигурация веб-сайта не включает **runAllManagedModulesForAllRequests** параметр. Это означает, что по умолчанию параметр имеет значение false.

Если вы запустите веб-сайт в Windows 7 без пакета обновления 1 установлен, службы IIS 7 не будет содержать необходимые обновления. Как следствие маршрутизация не будет работать, и вы увидите ошибок. Если имеются неполадки, где маршрутизации не работает, можно сделать либо следующее:

- Обновите Windows 7 с пакетом обновления 1, который будет добавлять обновления в IIS 7.
- Установите обновление, описанное в статье технической поддержки Майкрософт, перечисленные ранее.
- Задать **runAllManagedModulesForAllRequests** значение true в файле Web.config этого веб-сайта. Обратите внимание, что это добавит некоторые накладные расходы на запросы.

<a id="_Toc318097397"></a>
### <a name="html-editor"></a>Редактор HTML

<a id="_Toc318097398"></a>
#### <a name="smart-tasks"></a>Смарт-тегов

В режиме конструктора сложных свойств серверных элементов управления, часто связаны диалоговые окна и мастеры, которые позволяют легко установить их. Например, можно использовать специальное диалоговое окно для добавления источника данных в *повторителя* управления или добавление столбцов в *GridView* элемента управления.

Тем не менее этот тип Справка по пользовательскому Интерфейсу для сложных свойств не был доступен в режиме исходного кода. Таким образом Visual Studio 11 появился смарт-тегов для представления источников. Смарт-задачи — это контекстно зависимые ярлыки для часто используемых функций в редакторах C# и Visual Basic.

Для элементов управления веб-форм ASP.NET смарт-тегов отображаются теги сервера как небольшой глиф когда курсор находится внутри элемента:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.png)

При щелкните глиф или нажмите клавиши CTRL + расширяется смарт-задач. (точка), как в редакторах кода. Затем отображается сочетания клавиш, которые похожи на смарт-тегов в представлении конструктора.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image7.png)

Например одноименное на предыдущем рисунке показаны параметры задачи GridView. Если изменить столбцы, отображается следующее диалоговое окно:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image8.png)

Заполнение наборов поле диалогового окна те же свойства можно задать в конструкторе. При нажатии кнопки "ОК", разметки для элемента управления обновляется с учетом новых параметров:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image9.png)

<a id="_Toc318097399"></a>
#### <a name="wai-aria-support"></a>Поддержка WAI ARIA

Создание доступных веб-сайтов становится все более важной. [WAI ARIA расширенного доступа](http://www.w3.org/WAI/intro/aria) определяет, как разработчики должны создавать доступны веб-сайтов. Этот стандарт теперь полностью поддерживается в Visual Studio.

Например *роли* атрибута теперь имеет полную:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image10.png)

Стандарт WAI ARIA также представляет атрибуты, которые начинаются с префикса *aria -* , которые позволяют добавить в документ HTML5 семантику. Visual Studio также полностью поддерживает эти *aria -* атрибуты:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image11.png) ![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image12.png)

<a id="_Toc318097400"></a>
#### <a name="new-html5-snippets"></a>Новые фрагменты кода HTML5

Чтобы сделать его быстрее и легче написать часто используемые разметку HTML5, Visual Studio включает несколько фрагментов кода. Например, фрагмент видео:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image13.png)

Чтобы вызвать фрагмент, нажмите клавишу Tab дважды в том случае, если элемент выбран в IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image14.png)

Это позволяет создать фрагмент, который можно настроить.

<a id="_Toc318097401"></a>
#### <a name="extract-to-user-control"></a>Извлечение в пользовательский элемент управления

В больших веб-страницах возможность ее смысл Перемещение отдельных фрагментов в пользовательские элементы управления. Эта форма рефакторинга может помочь повысить удобство чтения страницы и можно упростить структуру страницы.

Чтобы облегчить эту задачу, при редактировании страницы веб-форм в режиме исходного кода, теперь выделите текст на странице, щелкните его правой кнопкой мыши и выберите извлечение в пользовательский элемент управления:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.jpg)

<a id="_Toc318097402"></a>
#### <a name="intellisense-for-code-nuggets-in-attributes"></a>Технология IntelliSense для фрагменты кода в атрибутах

Visual Studio всегда предоставила IntelliSense фрагменты кода на стороне сервера в любой страницы или элемента управления. Теперь Visual Studio включает IntelliSense для фрагменты кода в также атрибуты HTML.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image15.png)

Это упрощает создание выражения привязки данных:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image16.png)

<a id="_Toc318097403"></a>
#### <a name="automatic-renaming-of-matching-tag-when-you-rename-an-opening-or-closing-tag"></a>Автоматическое переименование совпадающих тег при переименовании открывающий или закрывающий тег

При переименовании элемента HTML (например, можно изменить *div* тег, чтобы быть *заголовок* тега), соответствующий Открытие или закрытие тега также изменяется в режиме реального времени.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image17.png)

Это позволяет избежать ошибок, где вы забыли измените закрывающий тег или не тот.

<a id="_Toc318097404"></a>
#### <a name="event-handler-generation"></a>Генерация обработчика событий

Visual Studio теперь включает компоненты в представлении исходного кода для создания обработчиков событий и связать их вручную. Если вы изменяете имя события в представлении исходного кода, IntelliSense отображает &lt;создать новое событие&gt;, которой будет создан обработчик событий в код страницы, имеет правильной сигнатуры:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.jpg)

По умолчанию обработчик события будет использовать идентификатор элемента управления для имени метода обработки событий:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.jpg)

Полученный обработчик событий будет выглядеть следующим образом (в этом случае в C#):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image18.png)

<a id="_Toc318097405"></a>
#### <a name="smart-indent"></a>Автоматический отступ

При нажатии клавиши ВВОД внутри пустой элемент HTML, редактор будет поместить курсор в нужном месте:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image19.png)

При нажатии клавиши ВВОД в этом расположении, закрывающий тег перемещен вниз и отступ соответствует открывающему тегу. Также будет перемещена курсора:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image20.png)

<a id="_Toc318097406"></a>
#### <a name="auto-reduce-statement-completion"></a>Уменьшить автоматическое завершение операторов

Список IntelliSense в Visual Studio теперь фильтры, основанные на тип, который будет только соответствующие параметры:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image21.png)

IntelliSense также фильтры, основанные на отдельные слова в списке IntelliSense регистр заголовка. Например если ввести «список рассылки» списка рассылки и asp: DataList отображается:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image22.png)

Эта функция упрощает быстрее для получения завершение операторов для известных элементов.

<a id="_Toc318097407"></a>
### <a name="javascript-editor"></a>редактор JavaScript

Редактор JavaScript в Visual Studio 2012 Release Candidate является абсолютно новым и повышающая опыт в работе с использованием JavaScript в Visual Studio.

<a id="_Toc318097408"></a>
#### <a name="code-outlining"></a>Структура кода

Теперь областей структуры автоматически создаются для всех функций, что позволяет сворачивать части файла, которые не относятся к текущей фокус ввода.

<a id="_Toc318097409"></a>
#### <a name="brace-matching"></a>Парные фигурные скобки

Когда вы устанавливаете точку вставки на открывающую или закрывающую скобку, редактор выделяет один сопоставления.

<a id="_Toc318097410"></a>
#### <a name="go-to-definition"></a>Перейти к определению

Перейти к определению-команда, можно перейти к источнику для функции или переменной.

<a id="_Toc318097411"></a>
#### <a name="ecmascript5-support"></a>Поддержка ECMAScript5

Редактор поддерживает новый синтаксис и API-интерфейсы в ECMAScript5 последней версии standard, который описывает на языке JavaScript.

<a id="_Toc318097412"></a>
#### <a name="dom-intellisense"></a>DOM IntelliSense

Улучшенная IntelliSense для API-интерфейсов DOM, с поддержкой для многих новых интерфейсов API HTML5 в том числе *querySelector*, хранилище DOM, обмен сообщениями, между документами и *холсте*. DOM IntelliSense теперь событиями один простой файл JavaScript, а не при определении собственного типа библиотеки. Это позволяет легко расширить или заменить.

<a id="_Toc318097413"></a>
#### <a name="vsdoc-signature-overloads"></a>Сигнатура перегрузки VSDOC

Подробные комментарии IntelliSense теперь могут быть объявлены для отдельных перегрузок функций JavaScript с помощью нового  *&lt;подписи&gt;*  элемента, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample35.cs)]

<a id="_Toc318097414"></a>
#### <a name="implicit-references"></a>Неявные ссылки

Файлы JavaScript теперь можно добавить в список центра, неявно включается в список файлов, заданной JavaScript файл или блок ссылки, то есть вы получаете IntelliSense для его содержимое. Например, можно добавить файлы jQuery центра список файлов, и вы сможете получить IntelliSense для функций jQuery в любой файл, блок JavaScript ли ссылки на явным образом (с помощью / / / &lt;ссылка /&gt;) или нет.

<a id="_Toc318097415"></a>
### <a name="css-editor"></a>редактор CSS

<a id="_Toc318097416"></a>
#### <a name="auto-reduce-statement-completion"></a>Уменьшить автоматическое завершение операторов

Список IntelliSense CSS теперь фильтры на основе свойств CSS и значений, поддерживаемых выбранной схеме.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image23.png)

IntelliSense также поддерживает поиск вариантов заголовка:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image24.png)

<a id="_Toc318097417"></a>
#### <a name="hierarchical-indentation"></a>Иерархические отступы

Редактора CSS использует отступ для отображения иерархических правила дающую Общие сведения о том, как логически организованы каскадные правила. В следующем примере #list селектора каскадных дочерний элемент элементов списка и поэтому с отступом.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image25.png)

Ниже приведен пример более сложные наследования.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image26.png)

Отступы правила определяется правилами своего родительского. Отступы включена по умолчанию, но его можно отключить в диалоговом окне Параметры (Сервис, параметры в строке меню):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image27.png)

<a id="_Toc318097418"></a>
#### <a name="css-hacks-support"></a>Поддержка взломает CSS

Анализ сотен файлов CSS реальных показывает взлома CSS очень часто, что теперь поддерживает наиболее широко используемых в Visual Studio. Эта поддержка включает IntelliSense и проверка звезды (\*) и символ подчеркивания (\_) свойство злонамеренных действий:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image28.png)

Полезные советы для типичных селектор также поддерживаются для обеспечения отступы даже в том случае, если они применяются. Является взлома селектор обычно используется для цели Internet Explorer 7 для вставки в начале селектор с  *\*: первый дочерний + html*. С помощью этого правила будет поддерживать отступы.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image29.png)

<a id="_Toc318097419"></a>
#### <a name="vendor-specific-schemas--moz---webkit"></a>Конкретные схемы поставщика (- moz-- webkit)

CSS3 предоставляет множество свойств, которые были реализованы в разных браузерах по-разному. Это ранее принудительно разработчикам кода для конкретного обозревателя с помощью синтаксиса конкретного поставщика. Эти свойства, зависящие от браузера теперь включены в IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image30.png)

<a id="_Toc318097420"></a>
#### <a name="commenting-and-uncommenting-support"></a>Поддержка комментирования и идет раскомментирование

Теперь можно добавить комментарии и раскомментируйте правила CSS, с помощью того же сочетания клавиш, используемые в редакторе кода (Ctrl + K, C, чтобы комментарий и Ctrl + K, возможность раскомментируйте).

<a id="_Toc318097421"></a>
#### <a name="color-picker"></a>Палитра цветов

В предыдущих версиях Visual Studio IntelliSense для атрибутов, связанных с цветовой включал раскрывающемся списке значений именованный цвет. Палитра полнофункциональный будет заменен этим списком.

При вводе значения цвета, палитра цветов автоматически отображается и выводит список ранее использованных цветов, следуют палитра цветов по умолчанию. Можно выбрать цвет с помощью клавиатуры или мыши.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image31.png)

Список можно развернуть в полный палитра. Средство выбора позволяет управлять альфа-канал путем автоматического преобразования любого цвета в формате RGBA при перемещении ползунка непрозрачности:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image32.png)

<a id="_Toc318097422"></a>
#### <a name="snippets"></a>Фрагменты кода

Фрагменты кода в редакторе CSS позволяют упростить и ускорить создание стилей браузерах. Многие свойства CSS3, требующих параметры браузера теперь были отменены в фрагменты кода.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image33.png)

Фрагменты кода CSS поддержки сложных сценариев (например, медиа-запросами CSS3), введя в символ (@), который показывает список IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image34.png)

При выборе @media значение и нажмите клавишу Tab, редактор CSS вставляет следующий фрагмент кода:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.jpg)

С помощью фрагментов кода, можно создать свои собственные фрагменты CSS.

<a id="_Toc318097423"></a>
#### <a name="custom-regions"></a>Настраиваемые области

С именем области кода, которые уже доступны в редакторе кода, теперь доступны для редактирования CSS. Это позволяет легко группировать стиля, связанных с блоками.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image35.png)

Когда область свернута, она отображает имя области:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image36.png)

<a id="_Toc318097424"></a>
### <a name="page-inspector"></a>Инспектор страниц

Инспектор страниц — это средство, отображает веб-страницы (HTML, Web Forms, ASP.NET MVC или веб-страницы) в Интегрированной среде разработки Visual Studio и позволяет изучить исходный код и полученный результат. Для страниц ASP.NET инспектор страниц позволяет определить, какие серверный код созданных разметки HTML, который отображается в браузере.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image37.png)

Дополнительные сведения о инспектор страниц см. в разделе следующие учебники:

- С помощью инспектора страниц в [ASP.NET MVC](../mvc/overview/views/using-page-inspector-in-aspnet-mvc.md)
- С помощью инспектора страниц в [веб-форм ASP.NET](../web-forms/overview/getting-started/using-page-inspector-in-a-visual-studio-11-beta-web-forms-project.md)

<a id="_Toc318097425"></a>
### <a name="publishing"></a>Публикация

<a id="_Toc318097426"></a>
#### <a name="publish-profiles"></a>Профили публикации

В Visual Studio 2010 сведения о публикации проектов веб-приложений не хранится в системе управления версиями и не предназначен для совместного использования с другими разделами. В Visual Studio 2012 Release Candidate был изменен формат профиль публикации. Он был сделан артефакта team и теперь можно легко использовать из сборок, исходя из MSBuild. Сведения о конфигурации построения, находится в диалоговом окне «Публикация» можно легко переключить конфигурации построения перед публикацией.

Публикация профили хранятся в папке PublishProfiles. Расположение папки зависит от используемого языка программирования:

- C#: Properties\PublishProfiles
- Visual Basic: Мои Project\PublishProfiles

Каждый профиль представляет собой файл MSBuild. Во время публикации, этот файл импортируется в файл проекта MSBuild. В Visual Studio 2010, если вы хотите внести изменения в процесс публикации или пакета, необходимо поместить внесенные изменения в файл с именем **ProjectName**. wpp.targets. Это по-прежнему поддерживается, но теперь можно поместить настройки профиля публикации. Таким образом, настройки будут использоваться только для этого профиля.

Теперь можно также используют опубликовать профили из MSBuild. Чтобы сделать это, используйте следующую команду, при построении проекта:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample36.cmd)]

Значение project.csproj — путь к проекту и Имя_профиля — имя профиля для публикации. Кроме того, вместо того чтобы передавать имя профиля для *PublishProfile* свойства, можно передать в полный путь профиля публикации.

<a id="_Toc318097427"></a>
#### <a name="aspnet-precompilation-and-merge"></a>Предварительная компиляция ASP.NET и слияния

Для проектов веб-приложений Visual Studio 2012 Release Candidate добавляет параметр на странице свойств Пакет/Публикация веб-сайта, позволяющий выполнить предварительную компиляцию и слияния содержимого веб-узла при публикации или пакета проекта. Чтобы просмотреть эти параметры, щелкните правой кнопкой мыши проект в обозревателе решений, выберите пункт Свойства и выберите упаковка и публикация веб-страницы свойств. На следующем рисунке Precompile этого приложения перед публикацией параметр.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.jpg)

Если выбран этот параметр, Visual Studio выполняет компиляцию приложения, при публикации или пакета веб-приложения. Если вы хотите управлять как предкомпилированные сайта или как слияние сборок, нажмите кнопку "Дополнительно" для настройки этих параметров.

<a id="_Toc318097428"></a>
### <a name="iis-express"></a>IIS Express

По умолчанию веб-сервер для тестирования веб-проектов в Visual Studio теперь — IIS Express. Visual Studio Development Server по-прежнему является параметром для локальный веб-сервер во время разработки, но IIS Express теперь рекомендуемые сервера. Опыт использования IIS Express в бета-версии Visual Studio 11 очень похожа на использование его в Visual Studio 2010 с пакетом обновления 1.

<a id="_Toc318097429"></a>
## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Сведения, содержащиеся в этом документе, отражают представление корпорации Майкрософт по описанным здесь вопросам на дату публикации. Поскольку корпорация Майкрософт должна реагировать на изменяющиеся рыночные условия, данный документ не должен интерпретироваться как обязательство со стороны Майкрософт, и корпорация Майкрософт не может гарантировать точность любой информации, представленной после даты публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска или передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без соблюдения ограничений авторских прав и письменного разрешения корпорации Майкрософт.

В настоящем документе могут упоминаться запатентованные или патентуемые технологии, товарные знаки, авторские права или другие права интеллектуальной собственности корпорации Майкрософт. Если иного явно не указано в письменном лицензионном соглашении корпорации Майкрософт, данный документ не предоставляет лицензии на эти патенты, товарные знаки, авторские права или другие права интеллектуальной собственности.

За исключением специально отмеченных случаев, описанные здесь компании, организации, товары, имена доменов, адреса электронной почты, эмблемы, люди, места и события являются вымышленными; любые совпадения с какими-либо реальными компаниями, организациями, товарами, именами доменов, адресами электронной почты, эмблемами, лицами, местами и событиями являются случайными.

© Корпорация Майкрософт (Microsoft Corporation), 2012. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
